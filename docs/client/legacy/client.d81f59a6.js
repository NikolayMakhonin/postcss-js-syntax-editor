import { a as _typeof } from './chunk.b0ae64c3.js';
import { a as assign, b as protoDev, c as init, d as createElement, e as createText, f as claimElement, g as children, h as claimText, i as detachNode, j as addLoc, k as insert, l as append, m as getSpreadUpdate, n as flush, o as createComment, p as setData } from './chunk.42d23e7c.js';

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

var arrayWithHoles = _arrayWithHoles;

function _iterableToArrayLimit(arr, i) {
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

var iterableToArrayLimit = _iterableToArrayLimit;

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}

var nonIterableRest = _nonIterableRest;

function _slicedToArray(arr, i) {
  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || nonIterableRest();
}

var slicedToArray = _slicedToArray;

/* src\components\Nav.html generated by Svelte v2.16.1 */
var file = "src\\components\\Nav.html";

function create_main_fragment(component, ctx) {
  var nav, ul, li0, a0, text0, a0_class_value, li1, h1, a1, text1;
  return {
    c: function create() {
      nav = createElement("nav");
      ul = createElement("ul");
      li0 = createElement("li");
      a0 = createElement("a");
      text0 = createText("home");
      li1 = createElement("li");
      h1 = createElement("h1");
      a1 = createElement("a");
      text1 = createText("Postcss-Js-Syntax to CSS converter");
      this.h();
    },
    l: function claim(nodes) {
      nav = claimElement(nodes, "NAV", {
        class: true
      }, false);
      var nav_nodes = children(nav);
      ul = claimElement(nav_nodes, "UL", {
        class: true
      }, false);
      var ul_nodes = children(ul);
      li0 = claimElement(ul_nodes, "LI", {
        class: true
      }, false);
      var li0_nodes = children(li0);
      a0 = claimElement(li0_nodes, "A", {
        class: true,
        href: true
      }, false);
      var a0_nodes = children(a0);
      text0 = claimText(a0_nodes, "home");
      a0_nodes.forEach(detachNode);
      li0_nodes.forEach(detachNode);
      li1 = claimElement(ul_nodes, "LI", {
        class: true
      }, false);
      var li1_nodes = children(li1);
      h1 = claimElement(li1_nodes, "H1", {
        class: true
      }, false);
      var h1_nodes = children(h1);
      a1 = claimElement(h1_nodes, "A", {
        href: true,
        class: true
      }, false);
      var a1_nodes = children(a1);
      text1 = claimText(a1_nodes, "Postcss-Js-Syntax to CSS converter");
      a1_nodes.forEach(detachNode);
      h1_nodes.forEach(detachNode);
      li1_nodes.forEach(detachNode);
      ul_nodes.forEach(detachNode);
      nav_nodes.forEach(detachNode);
      this.h();
    },
    h: function hydrate() {
      a0.className = a0_class_value = "" + (ctx.segment === ctx.undefined ? 'selected' : '') + " svelte-18n1fgv";
      a0.href = ".";
      addLoc(a0, file, 0, 13, 13);
      li0.className = "svelte-18n1fgv";
      addLoc(li0, file, 0, 9, 9);
      a1.href = "https://github.com/NikolayMakhonin/postcss-js-syntax";
      a1.className = "svelte-18n1fgv";
      addLoc(a1, file, 0, 96, 96);
      h1.className = "svelte-18n1fgv";
      addLoc(h1, file, 0, 92, 92);
      li1.className = "svelte-18n1fgv";
      addLoc(li1, file, 0, 88, 88);
      ul.className = "svelte-18n1fgv";
      addLoc(ul, file, 0, 5, 5);
      nav.className = "svelte-18n1fgv";
      addLoc(nav, file, 0, 0, 0);
    },
    m: function mount(target, anchor) {
      insert(target, nav, anchor);
      append(nav, ul);
      append(ul, li0);
      append(li0, a0);
      append(a0, text0);
      append(ul, li1);
      append(li1, h1);
      append(h1, a1);
      append(a1, text1);
    },
    p: function update(changed, ctx) {
      if ((changed.segment || changed.undefined) && a0_class_value !== (a0_class_value = "" + (ctx.segment === ctx.undefined ? 'selected' : '') + " svelte-18n1fgv")) {
        a0.className = a0_class_value;
      }
    },
    d: function destroy(detach) {
      if (detach) {
        detachNode(nav);
      }
    }
  };
}

function Nav(options) {
  this._debugName = '<Nav>';

  if (!options || !options.target && !options.root) {
    throw new Error("'target' is a required option");
  }

  init(this, options);
  this._state = assign({
    undefined: undefined
  }, options.data);
  if (!('segment' in this._state)) console.warn("<Nav> was created without expected data property 'segment'");
  this._intro = true;
  this._fragment = create_main_fragment(this, this._state);

  if (options.target) {
    var nodes = children(options.target);
    options.hydrate ? this._fragment.l(nodes) : this._fragment.c();
    nodes.forEach(detachNode);

    this._mount(options.target, options.anchor);
  }
}

assign(Nav.prototype, protoDev);

Nav.prototype._checkReadOnly = function _checkReadOnly(newState) {};

/* src\routes\_layout.html generated by Svelte v2.16.1 */
var file$1 = "src\\routes\\_layout.html";

function create_main_fragment$1(component, ctx) {
  var text, main;
  var nav_initial_data = {
    segment: ctx.child.segment
  };
  var nav = new Nav({
    root: component.root,
    store: component.store,
    data: nav_initial_data
  });
  var switch_instance_spread_levels = [ctx.child.props];
  var switch_value = ctx.child.component;

  function switch_props(ctx) {
    var switch_instance_initial_data = {};

    for (var i = 0; i < switch_instance_spread_levels.length; i += 1) {
      switch_instance_initial_data = assign(switch_instance_initial_data, switch_instance_spread_levels[i]);
    }

    return {
      root: component.root,
      store: component.store,
      data: switch_instance_initial_data
    };
  }

  if (switch_value) {
    var switch_instance = new switch_value(switch_props(ctx));
  }

  return {
    c: function create() {
      nav._fragment.c();

      text = createText("\n\n");
      main = createElement("main");
      if (switch_instance) switch_instance._fragment.c();
      this.h();
    },
    l: function claim(nodes) {
      nav._fragment.l(nodes);

      text = claimText(nodes, "\n\n");
      main = claimElement(nodes, "MAIN", {
        class: true
      }, false);
      var main_nodes = children(main);
      if (switch_instance) switch_instance._fragment.l(main_nodes);
      main_nodes.forEach(detachNode);
      this.h();
    },
    h: function hydrate() {
      main.className = "svelte-vxf4f5";
      addLoc(main, file$1, 2, 0, 32);
    },
    m: function mount(target, anchor) {
      nav._mount(target, anchor);

      insert(target, text, anchor);
      insert(target, main, anchor);

      if (switch_instance) {
        switch_instance._mount(main, null);
      }
    },
    p: function update(changed, ctx) {
      var nav_changes = {};
      if (changed.child) nav_changes.segment = ctx.child.segment;

      nav._set(nav_changes);

      var switch_instance_changes = changed.child ? getSpreadUpdate(switch_instance_spread_levels, [ctx.child.props]) : {};

      if (switch_value !== (switch_value = ctx.child.component)) {
        if (switch_instance) {
          switch_instance.destroy();
        }

        if (switch_value) {
          switch_instance = new switch_value(switch_props(ctx));

          switch_instance._fragment.c();

          switch_instance._mount(main, null);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance._set(switch_instance_changes);
      }
    },
    d: function destroy(detach) {
      nav.destroy(detach);

      if (detach) {
        detachNode(text);
        detachNode(main);
      }

      if (switch_instance) switch_instance.destroy();
    }
  };
}

function Layout(options) {
  this._debugName = '<Layout>';

  if (!options || !options.target && !options.root) {
    throw new Error("'target' is a required option");
  }

  init(this, options);
  this._state = assign({}, options.data);
  if (!('child' in this._state)) console.warn("<Layout> was created without expected data property 'child'");
  this._intro = true;
  this._fragment = create_main_fragment$1(this, this._state);

  if (options.target) {
    var nodes = children(options.target);
    options.hydrate ? this._fragment.l(nodes) : this._fragment.c();
    nodes.forEach(detachNode);

    this._mount(options.target, options.anchor);

    flush(this);
  }
}

assign(Layout.prototype, protoDev);

Layout.prototype._checkReadOnly = function _checkReadOnly(newState) {};

/* src\routes\_error.html generated by Svelte v2.16.1 */
var file$2 = "src\\routes\\_error.html";

function create_main_fragment$2(component, ctx) {
  var title_value,
      text0,
      h1,
      text1,
      text2,
      p,
      text3_value = ctx.error.message,
      text3,
      text4,
      if_block_anchor;
  document.title = title_value = ctx.status;
  var if_block = ctx.error.stack && create_if_block(component, ctx);
  return {
    c: function create() {
      text0 = createText("\n\n");
      h1 = createElement("h1");
      text1 = createText(ctx.status);
      text2 = createText("\n\n");
      p = createElement("p");
      text3 = createText(text3_value);
      text4 = createText("\n\n");
      if (if_block) if_block.c();
      if_block_anchor = createComment();
      this.h();
    },
    l: function claim(nodes) {
      text0 = claimText(nodes, "\n\n");
      h1 = claimElement(nodes, "H1", {
        class: true
      }, false);
      var h1_nodes = children(h1);
      text1 = claimText(h1_nodes, ctx.status);
      h1_nodes.forEach(detachNode);
      text2 = claimText(nodes, "\n\n");
      p = claimElement(nodes, "P", {
        class: true
      }, false);
      var p_nodes = children(p);
      text3 = claimText(p_nodes, text3_value);
      p_nodes.forEach(detachNode);
      text4 = claimText(nodes, "\n\n");
      if (if_block) if_block.l(nodes);
      if_block_anchor = createComment();
      this.h();
    },
    h: function hydrate() {
      h1.className = "svelte-zwt8wo";
      addLoc(h1, file$2, 4, 0, 55);
      p.className = "svelte-zwt8wo";
      addLoc(p, file$2, 6, 0, 74);
    },
    m: function mount(target, anchor) {
      insert(target, text0, anchor);
      insert(target, h1, anchor);
      append(h1, text1);
      insert(target, text2, anchor);
      insert(target, p, anchor);
      append(p, text3);
      insert(target, text4, anchor);
      if (if_block) if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p: function update(changed, ctx) {
      if (changed.status && title_value !== (title_value = ctx.status)) {
        document.title = title_value;
      }

      if (changed.status) {
        setData(text1, ctx.status);
      }

      if (changed.error && text3_value !== (text3_value = ctx.error.message)) {
        setData(text3, text3_value);
      }

      if (ctx.error.stack) {
        if (if_block) {
          if_block.p(changed, ctx);
        } else {
          if_block = create_if_block(component, ctx);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d: function destroy(detach) {
      if (detach) {
        detachNode(text0);
        detachNode(h1);
        detachNode(text2);
        detachNode(p);
        detachNode(text4);
      }

      if (if_block) if_block.d(detach);

      if (detach) {
        detachNode(if_block_anchor);
      }
    }
  };
} // (9:0) {#if dev && error.stack}


function create_if_block(component, ctx) {
  var pre,
      text_value = ctx.error.stack,
      text;
  return {
    c: function create() {
      pre = createElement("pre");
      text = createText(text_value);
      this.h();
    },
    l: function claim(nodes) {
      pre = claimElement(nodes, "PRE", {}, false);
      var pre_nodes = children(pre);
      text = claimText(pre_nodes, text_value);
      pre_nodes.forEach(detachNode);
      this.h();
    },
    h: function hydrate() {
      addLoc(pre, file$2, 9, 1, 124);
    },
    m: function mount(target, anchor) {
      insert(target, pre, anchor);
      append(pre, text);
    },
    p: function update(changed, ctx) {
      if (changed.error && text_value !== (text_value = ctx.error.stack)) {
        setData(text, text_value);
      }
    },
    d: function destroy(detach) {
      if (detach) {
        detachNode(pre);
      }
    }
  };
}

function Error$1(options) {
  this._debugName = '<Error>';

  if (!options || !options.target && !options.root) {
    throw new Error$1("'target' is a required option");
  }

  init(this, options);
  this._state = assign({}, options.data);
  if (!('status' in this._state)) console.warn("<Error> was created without expected data property 'status'");
  if (!('error' in this._state)) console.warn("<Error> was created without expected data property 'error'");
  this._intro = true;
  this._fragment = create_main_fragment$2(this, this._state);

  if (options.target) {
    var nodes = children(options.target);
    options.hydrate ? this._fragment.l(nodes) : this._fragment.c();
    nodes.forEach(detachNode);

    this._mount(options.target, options.anchor);
  }
}

assign(Error$1.prototype, protoDev);

Error$1.prototype._checkReadOnly = function _checkReadOnly(newState) {};

function goto(href) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
    replaceState: false
  };
  var target$$1 = select_route(new URL(href, document.baseURI));

  if (target$$1) {
    _history[opts.replaceState ? 'replaceState' : 'pushState']({
      id: cid
    }, '', href);

    return navigate(target$$1, null).then(function () {});
  }

  location.href = href;
  return new Promise(function (f) {}); // never resolves
}

var ignore = [/^\/blog.json$/, /^\/blog\/([^\/]+?).json$/];
var components = [{
  js: function js() {
    return import('./chunk.578c1fec.js');
  },
  css: ["chunk.578c1fec.css"]
}, {
  js: function js() {
    return import('./chunk.6cb2acd8.js');
  },
  css: []
}, {
  js: function js() {
    return import('./chunk.fdadb65b.js');
  },
  css: ["chunk.fdadb65b.css"]
}, {
  js: function js() {
    return import('./chunk.0037cdcb.js');
  },
  css: ["chunk.0037cdcb.css"]
}];

var pages = function (d) {
  return [{
    // index.html
    pattern: /^\/?$/,
    parts: [{
      i: 0
    }]
  }, {
    // about.html
    pattern: /^\/about\/?$/,
    parts: [{
      i: 1
    }]
  }, {
    // blog/index.html
    pattern: /^\/blog\/?$/,
    parts: [null, {
      i: 2
    }]
  }, {
    // blog/[slug].html
    pattern: /^\/blog\/([^\/]+?)\/?$/,
    parts: [null, {
      i: 3,
      params: function params(match) {
        return {
          slug: d(match[1])
        };
      }
    }]
  }];
}(decodeURIComponent);

var ready = false;
var root_component;
var segments = [];
var current_token;
var root_preload;
var root_data;
var root_props = {
  path: null,
  params: null,
  query: null,
  child: {
    segment: null,
    component: null,
    props: {}
  }
};
var prefetching = null;

function set_prefetching(href, promise) {
  prefetching = {
    href: href,
    promise: promise
  };
}

var store;

function set_store(fn) {
  store = fn(initial_data.store);
}

var target;

function set_target(element) {
  target = element;
}

var uid = 1;

function set_uid(n) {
  uid = n;
}

var cid;

function set_cid(n) {
  cid = n;
}

var initial_data = typeof __SAPPER__ !== 'undefined' && __SAPPER__;

var _history = typeof history !== 'undefined' ? history : {
  pushState: function pushState(state, title, href) {},
  replaceState: function replaceState(state, title, href) {},
  scrollRestoration: ''
};

var scroll_history = {};

function select_route(url) {
  if (url.origin !== location.origin) return null;
  if (!url.pathname.startsWith(initial_data.baseUrl)) return null;
  var path = url.pathname.slice(initial_data.baseUrl.length); // avoid accidental clashes between server routes and pages

  if (ignore.some(function (pattern) {
    return pattern.test(path);
  })) return;

  for (var i = 0; i < pages.length; i += 1) {
    var page = pages[i];
    var match = page.pattern.exec(path);

    if (match) {
      var _ret = function () {
        var query = Object.create(null);

        if (url.search.length > 0) {
          url.search.slice(1).split('&').forEach(function (searchParam) {
            var _$exec = /([^=]*)(?:=(.*))?/.exec(decodeURIComponent(searchParam)),
                _$exec2 = slicedToArray(_$exec, 3),
                key = _$exec2[1],
                value = _$exec2[2];

            value = (value || '').replace(/\+/g, ' ');
            if (typeof query[key] === 'string') query[key] = [query[key]];
            if (_typeof(query[key]) === 'object') query[key].push(value);else query[key] = value;
          });
        }

        return {
          v: {
            url: url,
            path: path,
            page: page,
            match: match,
            query: query
          }
        };
      }();

      if (_typeof(_ret) === "object") return _ret.v;
    }
  }
}

function scroll_state() {
  return {
    x: pageXOffset,
    y: pageYOffset
  };
}

function navigate(target, id, noscroll, hash) {
  if (id) {
    // popstate or initial navigation
    cid = id;
  } else {
    var current_scroll = scroll_state(); // clicked on a link. preserve scroll state

    scroll_history[cid] = current_scroll;
    id = cid = ++uid;
    scroll_history[cid] = noscroll ? current_scroll : {
      x: 0,
      y: 0
    };
  }

  cid = id;

  if (root_component) {
    root_component.set({
      preloading: true
    });
  }

  var loaded = prefetching && prefetching.href === target.url.href ? prefetching.promise : prepare_page(target);
  prefetching = null;
  var token = current_token = {};
  return loaded.then(function (_ref) {
    var redirect = _ref.redirect,
        data = _ref.data,
        nullable_depth = _ref.nullable_depth,
        new_segments = _ref.new_segments;

    if (redirect) {
      return goto(redirect.location, {
        replaceState: true
      });
    }

    if (new_segments) {
      segments = new_segments;
    }

    render(data, nullable_depth, scroll_history[id], noscroll, hash, token);
    if (document.activeElement) document.activeElement.blur();
  });
}

function render(data, nullable_depth, scroll, noscroll, hash, token) {
  if (current_token !== token) return;

  if (root_component) {
    // first, clear out highest-level root component
    var level = data.child;

    for (var i = 0; i < nullable_depth; i += 1) {
      if (i === nullable_depth) break;
      level = level.props.child;
    }

    var _level = level,
        component = _level.component;
    level.component = null;
    root_component.set({
      child: data.child
    }); // then render new stuff

    level.component = component;
    root_component.set(data);
  } else {
    // first load — remove SSR'd <head> contents
    var _start = document.querySelector('#sapper-head-start');

    var end = document.querySelector('#sapper-head-end');

    if (_start && end) {
      while (_start.nextSibling !== end) {
        detach(_start.nextSibling);
      }

      detach(_start);
      detach(end);
    }

    Object.assign(data, root_data);
    root_component = new Layout({
      target: target,
      data: data,
      store: store,
      hydrate: true
    });
  }

  if (!noscroll) {
    if (hash) {
      // scroll is an element id (from a hash), we need to compute y.
      var deep_linked = document.querySelector(hash);

      if (deep_linked) {
        scroll = {
          x: 0,
          y: deep_linked.getBoundingClientRect().top
        };
      }
    }

    scroll_history[cid] = scroll;
    if (scroll) scrollTo(scroll.x, scroll.y);
  }

  Object.assign(root_props, data);
  ready = true;
}

function prepare_page(target) {
  var page = target.page,
      path = target.path,
      query = target.query;
  var new_segments = path.split('/').filter(Boolean);
  var changed_from = 0;

  while (segments[changed_from] && new_segments[changed_from] && segments[changed_from] === new_segments[changed_from]) {
    changed_from += 1;
  }

  if (changed_from === new_segments.length) {
    changed_from -= 1;
  }

  var _redirect = null;
  var _error = null;
  var preload_context = {
    store: store,
    fetch: function (_fetch) {
      function fetch(_x, _x2) {
        return _fetch.apply(this, arguments);
      }

      fetch.toString = function () {
        return _fetch.toString();
      };

      return fetch;
    }(function (url, opts) {
      return fetch(url, opts);
    }),
    redirect: function redirect(statusCode, location) {
      if (_redirect && (_redirect.statusCode !== statusCode || _redirect.location !== location)) {
        throw new Error("Conflicting redirects");
      }

      _redirect = {
        statusCode: statusCode,
        location: location
      };
    },
    error: function error(statusCode, message) {
      _error = {
        statusCode: statusCode,
        message: message
      };
    }
  };

  if (!root_preload) {
    root_preload = Layout.preload ? initial_data.preloaded[0] || Layout.preload.call(preload_context, {
      path: path,
      query: query,
      params: {}
    }) : {};
  }

  return Promise.all(page.parts.map(function (part, i) {
    if (i < changed_from) return null;
    if (!part) return null;
    return load_component(components[part.i]).then(function (Component) {
      var req = {
        path: path,
        query: query,
        params: part.params ? part.params(target.match) : {}
      };
      var preloaded;

      if (ready || !initial_data.preloaded[i + 1]) {
        preloaded = Component.preload ? Component.preload.call(preload_context, req) : {};
      } else {
        preloaded = initial_data.preloaded[i + 1];
      }

      return Promise.resolve(preloaded).then(function (preloaded) {
        return {
          Component: Component,
          preloaded: preloaded
        };
      });
    });
  })).catch(function (err) {
    _error = {
      statusCode: 500,
      message: err
    };
    return [];
  }).then(function (results) {
    if (root_data) {
      return results;
    } else {
      return Promise.resolve(root_preload).then(function (value) {
        root_data = value;
        return results;
      });
    }
  }).then(function (results) {
    if (_redirect) {
      return {
        redirect: _redirect,
        new_segments: new_segments
      };
    }

    var get_params = page.parts[page.parts.length - 1].params || function () {
      return {};
    };

    var params = get_params(target.match);

    if (_error) {
      var _props = {
        path: path,
        query: query,
        params: params,
        error: typeof _error.message === 'string' ? new Error(_error.message) : _error.message,
        status: _error.statusCode
      };
      return {
        new_segments: new_segments,
        data: Object.assign({}, _props, {
          preloading: false,
          child: {
            component: Error$1,
            props: _props
          }
        })
      };
    }

    var props = {
      path: path,
      query: query,
      error: null,
      status: null
    };
    var data = {
      path: path,
      preloading: false,
      child: Object.assign({}, root_props.child, {
        segment: new_segments[0]
      })
    };
    if (changed(query, root_props.query)) data.query = query;
    if (changed(params, root_props.params)) data.params = params;
    var level = data.child;
    var nullable_depth = 0;

    for (var i = 0; i < page.parts.length; i += 1) {
      var part = page.parts[i];
      if (!part) continue;

      var _get_params = part.params || function () {
        return {};
      };

      if (i < changed_from) {
        level.props.path = path;
        level.props.query = query;
        level.props.child = Object.assign({}, level.props.child);
        nullable_depth += 1;
      } else {
        level.component = results[i].Component;
        level.props = Object.assign({}, level.props, props, {
          params: _get_params(target.match)
        }, results[i].preloaded);
        level.props.child = {};
      }

      level = level.props.child;
      level.segment = new_segments[i + 1];
    }

    return {
      data: data,
      nullable_depth: nullable_depth,
      new_segments: new_segments
    };
  });
}

function load_css(chunk) {
  var href = "client/".concat(chunk);
  if (document.querySelector("link[href=\"".concat(href, "\"]"))) return;
  return new Promise(function (fulfil, reject) {
    var link = document.createElement('link');
    link.rel = 'stylesheet';
    link.href = href;

    link.onload = function () {
      return fulfil();
    };

    link.onerror = reject;
    document.head.appendChild(link);
  });
}

function load_component(component) {
  // TODO this is temporary — once placeholders are
  // always rewritten, scratch the ternary
  var promises = typeof component.css === 'string' ? [] : component.css.map(load_css);
  promises.unshift(component.js());
  return Promise.all(promises).then(function (values) {
    return values[0].default;
  });
}

function detach(node) {
  node.parentNode.removeChild(node);
}

function changed(a, b) {
  return JSON.stringify(a) !== JSON.stringify(b);
}

function prefetch(href) {
  var target$$1 = select_route(new URL(href, document.baseURI));

  if (target$$1) {
    if (!prefetching || href !== prefetching.href) {
      set_prefetching(href, prepare_page(target$$1));
    }

    return prefetching.promise;
  }
}

function start(opts) {
  if ('scrollRestoration' in _history) {
    _history.scrollRestoration = 'manual';
  }

  set_target(opts.target);
  if (opts.store) set_store(opts.store);
  addEventListener('click', handle_click);
  addEventListener('popstate', handle_popstate); // prefetch

  addEventListener('touchstart', trigger_prefetch);
  addEventListener('mousemove', handle_mousemove);
  return Promise.resolve().then(function () {
    var _location = location,
        hash = _location.hash,
        href = _location.href;

    _history.replaceState({
      id: uid
    }, '', href);

    if (!initial_data.error) {
      var target$$1 = select_route(new URL(location.href));
      if (target$$1) return navigate(target$$1, uid, false, hash);
    }
  });
}

var mousemove_timeout;

function handle_mousemove(event) {
  clearTimeout(mousemove_timeout);
  mousemove_timeout = setTimeout(function () {
    trigger_prefetch(event);
  }, 20);
}

function trigger_prefetch(event) {
  var a = find_anchor(event.target);
  if (!a || a.rel !== 'prefetch') return;
  prefetch(a.href);
}

function handle_click(event) {
  // Adapted from https://github.com/visionmedia/page.js
  // MIT license https://github.com/visionmedia/page.js#license
  if (which(event) !== 1) return;
  if (event.metaKey || event.ctrlKey || event.shiftKey) return;
  if (event.defaultPrevented) return;
  var a = find_anchor(event.target);
  if (!a) return;
  if (!a.href) return; // check if link is inside an svg
  // in this case, both href and target are always inside an object

  var svg = _typeof(a.href) === 'object' && a.href.constructor.name === 'SVGAnimatedString';
  var href = String(svg ? a.href.baseVal : a.href);

  if (href === location.href) {
    if (!location.hash) event.preventDefault();
    return;
  } // Ignore if tag has
  // 1. 'download' attribute
  // 2. rel='external' attribute


  if (a.hasAttribute('download') || a.getAttribute('rel') === 'external') return; // Ignore if <a> has a target

  if (svg ? a.target.baseVal : a.target) return;
  var url = new URL(href); // Don't handle hash changes

  if (url.pathname === location.pathname && url.search === location.search) return;
  var target$$1 = select_route(url);

  if (target$$1) {
    var noscroll = a.hasAttribute('sapper-noscroll');
    navigate(target$$1, null, noscroll, url.hash);
    event.preventDefault();

    _history.pushState({
      id: cid
    }, '', url.href);
  }
}

function which(event) {
  return event.which === null ? event.button : event.which;
}

function find_anchor(node) {
  while (node && node.nodeName.toUpperCase() !== 'A') {
    node = node.parentNode;
  } // SVG <a> elements have a lowercase name


  return node;
}

function handle_popstate(event) {
  scroll_history[cid] = scroll_state();

  if (event.state) {
    var url = new URL(location.href);
    var target$$1 = select_route(url);

    if (target$$1) {
      navigate(target$$1, event.state.id);
    } else {
      location.href = location.href;
    }
  } else {
    // hashchange
    set_uid(uid + 1);
    set_cid(uid);

    _history.replaceState({
      id: cid
    }, '', location.href);
  }
}

start({
  target: document.querySelector('#sapper')
});
//# sourceMappingURL=client.d81f59a6.js.map
