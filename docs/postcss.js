(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
const postcss = require('postcss')
const postcssJsSyntax = require('postcss-js-syntax').default
const postcssNested = require('postcss-nested')
const postcssNano = require('cssnano')
const postcssBeautify = require('perfectionist')

if (typeof window !== 'undefined') {
	window.postcss = postcss
	postcss.syntaxes = {
		js: postcssJsSyntax
	}
	postcss.plugins = {
		nested  : postcssNested,
		nano    : postcssNano,
		beautify: postcssBeautify
	}
}

},{"cssnano":672,"perfectionist":810,"postcss":1074,"postcss-js-syntax":872,"postcss-nested":963}],2:[function(require,module,exports){
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

module.exports = _interopRequireDefault;
},{}],3:[function(require,module,exports){
var zero = '0'.charCodeAt(0);
var plus = '+'.charCodeAt(0);
var minus = '-'.charCodeAt(0);

function isWhitespace(code) {
	return code <= 32;
}

function isDigit(code) {
	return 48 <= code && code <= 57;
}

function isSign(code) {
	return code === minus || code === plus;
}

module.exports = function (opts, a, b) {
	var checkSign = opts.sign;
	var ia = 0;
	var ib = 0;
	var ma = a.length;
	var mb = b.length;
	var ca, cb; // character code
	var za, zb; // leading zero count
	var na, nb; // number length
	var sa, sb; // number sign
	var ta, tb; // temporary
	var bias;

	while (ia < ma && ib < mb) {
		ca = a.charCodeAt(ia);
		cb = b.charCodeAt(ib);
		za = zb = 0;
		na = nb = 0;
		sa = sb = true;
		bias = 0;

		// skip over leading spaces
		while (isWhitespace(ca)) {
			ia += 1;
			ca = a.charCodeAt(ia);
		}
		while (isWhitespace(cb)) {
			ib += 1;
			cb = b.charCodeAt(ib);
		}

		// skip and save sign
		if (checkSign) {
			ta = a.charCodeAt(ia + 1);
			if (isSign(ca) && isDigit(ta)) {
				if (ca === minus) {
					sa = false;
				}
				ia += 1;
				ca = ta;
			}
			tb = b.charCodeAt(ib + 1);
			if (isSign(cb) && isDigit(tb)) {
				if (cb === minus) {
					sb = false;
				}
				ib += 1;
				cb = tb;
			}
		}

		// compare digits with other symbols
		if (isDigit(ca) && !isDigit(cb)) {
			return -1;
		}
		if (!isDigit(ca) && isDigit(cb)) {
			return 1;
		}

		// compare negative and positive
		if (!sa && sb) {
			return -1;
		}
		if (sa && !sb) {
			return 1;
		}

		// count leading zeros
		while (ca === zero) {
			za += 1;
			ia += 1;
			ca = a.charCodeAt(ia);
		}
		while (cb === zero) {
			zb += 1;
			ib += 1;
			cb = b.charCodeAt(ib);
		}

		// count numbers
		while (isDigit(ca) || isDigit(cb)) {
			if (isDigit(ca) && isDigit(cb) && bias === 0) {
				if (sa) {
					if (ca < cb) {
						bias = -1;
					} else if (ca > cb) {
						bias = 1;
					}
				} else {
					if (ca > cb) {
						bias = -1;
					} else if (ca < cb) {
						bias = 1;
					}
				}
			}
			if (isDigit(ca)) {
				ia += 1;
				na += 1;
				ca = a.charCodeAt(ia);
			}
			if (isDigit(cb)) {
				ib += 1;
				nb += 1;
				cb = b.charCodeAt(ib);
			}
		}

		// compare number length
		if (sa) {
			if (na < nb) {
				return -1;
			}
			if (na > nb) {
				return 1;
			}
		} else {
			if (na > nb) {
				return -1;
			}
			if (na < nb) {
				return 1;
			}
		}

		// compare numbers
		if (bias) {
			return bias;
		}

		// compare leading zeros
		if (sa) {
			if (za > zb) {
				return -1;
			}
			if (za < zb) {
				return 1;
			}
		} else {
			if (za < zb) {
				return -1;
			}
			if (za > zb) {
				return 1;
			}
		}

		// compare ascii codes
		if (ca < cb) {
			return -1;
		}
		if (ca > cb) {
			return 1;
		}

		ia += 1;
		ib += 1;
	}

	// compare length
	if (ma < mb) {
		return -1;
	}
	if (ma > mb) {
		return 1;
	}
};

},{}],4:[function(require,module,exports){
var compare = require('./compare');

function mediator(a, b) {
	return compare(this, a.converted, b.converted);
}

module.exports = function (array, opts) {
	if (!Array.isArray(array) || array.length < 2) {
		return array;
	}
	if (typeof opts !== 'object') {
		opts = {};
	}
	opts.sign = !!opts.sign;
	var insensitive = !!opts.insensitive;
	var result = Array(array.length);
	var i, max, value;

	for (i = 0, max = array.length; i < max; i += 1) {
		value = String(array[i]);
		result[i] = {
			value: array[i],
			converted: insensitive ? value.toLowerCase() : value
		};
	}

	result.sort(mediator.bind(opts));

	for (i = result.length - 1; ~i; i -= 1) {
		result[i] = result[i].value;
	}

	return result;
};

},{"./compare":3}],5:[function(require,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  for (var i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(
      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
    ))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],6:[function(require,module,exports){
module.exports = {
	trueFunc: function trueFunc(){
		return true;
	},
	falseFunc: function falseFunc(){
		return false;
	}
};
},{}],7:[function(require,module,exports){

},{}],8:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"dup":7}],9:[function(require,module,exports){
(function (global){
/*! https://mths.be/punycode v1.4.1 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports = typeof exports == 'object' && exports &&
		!exports.nodeType && exports;
	var freeModule = typeof module == 'object' && module &&
		!module.nodeType && module;
	var freeGlobal = typeof global == 'object' && global;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw new RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * https://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.4.1',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
		define('punycode', function() {
			return punycode;
		});
	} else if (freeExports && freeModule) {
		if (module.exports == freeExports) {
			// in Node.js, io.js, or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else {
			// in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else {
		// in Rhino or a web browser
		root.punycode = punycode;
	}

}(this));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],10:[function(require,module,exports){
var BrowserslistError = require('./error')

function noop () { }

module.exports = {
  loadQueries: function loadQueries () {
    throw new BrowserslistError(
      'Sharable configs are not supported in client-side build of Browserslist')
  },

  getStat: function getStat (opts) {
    return opts.stats
  },

  loadConfig: function loadConfig (opts) {
    if (opts.config) {
      throw new BrowserslistError(
        'Browserslist config are not supported in client-side build')
    }
  },

  loadCountry: function loadCountry () {
    throw new BrowserslistError(
      'Country statistics is not supported ' +
      'in client-side build of Browserslist')
  },

  currentNode: function currentNode (resolve, context) {
    return resolve(['maintained node versions'], context)[0]
  },

  parseConfig: noop,

  readConfig: noop,

  findConfig: noop,

  clearCaches: noop,

  oldDataWarning: noop
}

},{"./error":11}],11:[function(require,module,exports){
function BrowserslistError (message) {
  this.name = 'BrowserslistError'
  this.message = message
  this.browserslist = true
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, BrowserslistError)
  }
}

BrowserslistError.prototype = Error.prototype

module.exports = BrowserslistError

},{}],12:[function(require,module,exports){
var jsReleases = require('node-releases/data/processed/envs.json')
var agents = require('caniuse-lite/dist/unpacker/agents').agents
var jsEOL = require('node-releases/data/release-schedule/release-schedule.json')
var path = require('path')
var e2c = require('electron-to-chromium/versions')

var BrowserslistError = require('./error')
var env = require('./node') // Will load browser.js in webpack

var FLOAT_RANGE = /^\d+(\.\d+)?(-\d+(\.\d+)?)*$/
var YEAR = 365.259641 * 24 * 60 * 60 * 1000

// Enum values MUST be powers of 2, so combination are safe
/** @constant {number} */
var QUERY_OR = 1
/** @constant {number} */
var QUERY_AND = 2

function isVersionsMatch (versionA, versionB) {
  return (versionA + '.').indexOf(versionB + '.') === 0
}

function isEolReleased (name) {
  var version = name.slice(1)
  return jsReleases.some(function (i) {
    return isVersionsMatch(i.version, version)
  })
}

function normalize (versions) {
  return versions.filter(function (version) {
    return typeof version === 'string'
  })
}

function nameMapper (name) {
  return function mapName (version) {
    return name + ' ' + version
  }
}

function getMajor (version) {
  return parseInt(version.split('.')[0])
}

function getMajorVersions (released, number) {
  if (released.length === 0) return []
  var minimum = getMajor(released[released.length - 1]) - parseInt(number) + 1
  var selected = []
  for (var i = released.length - 1; i >= 0; i--) {
    if (minimum > getMajor(released[i])) break
    selected.unshift(released[i])
  }
  return selected
}

function uniq (array) {
  var filtered = []
  for (var i = 0; i < array.length; i++) {
    if (filtered.indexOf(array[i]) === -1) filtered.push(array[i])
  }
  return filtered
}

// Helpers

function fillUsage (result, name, data) {
  for (var i in data) {
    result[name + ' ' + i] = data[i]
  }
}

function generateFilter (sign, version) {
  version = parseFloat(version)
  if (sign === '>') {
    return function (v) {
      return parseFloat(v) > version
    }
  } else if (sign === '>=') {
    return function (v) {
      return parseFloat(v) >= version
    }
  } else if (sign === '<') {
    return function (v) {
      return parseFloat(v) < version
    }
  } else {
    return function (v) {
      return parseFloat(v) <= version
    }
  }
}

function compareStrings (a, b) {
  if (a < b) return -1
  if (a > b) return +1
  return 0
}

function normalizeVersion (data, version) {
  if (data.versions.indexOf(version) !== -1) {
    return version
  } else if (browserslist.versionAliases[data.name][version]) {
    return browserslist.versionAliases[data.name][version]
  } else if (data.versions.length === 1) {
    return data.versions[0]
  } else {
    return false
  }
}

function filterByYear (since) {
  since = since / 1000
  return Object.keys(agents).reduce(function (selected, name) {
    var data = byName(name)
    if (!data) return selected
    var versions = Object.keys(data.releaseDate).filter(function (v) {
      return data.releaseDate[v] >= since
    })
    return selected.concat(versions.map(nameMapper(data.name)))
  }, [])
}

function byName (name) {
  name = name.toLowerCase()
  name = browserslist.aliases[name] || name
  return browserslist.data[name]
}

function checkName (name) {
  var data = byName(name)
  if (!data) throw new BrowserslistError('Unknown browser ' + name)
  return data
}

function unknownQuery (query) {
  return new BrowserslistError(
    'Unknown browser query `' + query + '`. ' +
    'Maybe you are using old Browserslist or made typo in query.'
  )
}

/**
 * Resolves queries into a browser list.
 * @param {string|string[]} queries Queries to combine.
 * Either an array of queries or a long string of queries.
 * @param {object} [context] Optional arguments to
 * the select function in `queries`.
 * @returns {string[]} A list of browsers
 */
function resolve (queries, context) {
  if (Array.isArray(queries)) {
    queries = flatten(queries.map(parse))
  } else {
    queries = parse(queries)
  }

  return queries.reduce(function (result, query, index) {
    var selection = query.queryString

    var isExclude = selection.indexOf('not ') === 0
    if (isExclude) {
      if (index === 0) {
        throw new BrowserslistError(
          'Write any browsers query (for instance, `defaults`) ' +
          'before `' + selection + '`')
      }
      selection = selection.slice(4)
    }

    for (var i = 0; i < QUERIES.length; i++) {
      var type = QUERIES[i]
      var match = selection.match(type.regexp)
      if (match) {
        var args = [context].concat(match.slice(1))
        var array = type.select.apply(browserslist, args).map(function (j) {
          var parts = j.split(' ')
          if (parts[1] === '0') {
            return parts[0] + ' ' + byName(parts[0]).versions[0]
          } else {
            return j
          }
        })

        switch (query.type) {
          case QUERY_AND:
            if (isExclude) {
              return result.filter(function (j) {
                // remove result items that are in array
                // (the relative complement of array in result)
                return array.indexOf(j) === -1
              })
            } else {
              return result.filter(function (j) {
                // remove result items not in array
                // (intersect of result and array)
                return array.indexOf(j) !== -1
              })
            }
          case QUERY_OR:
          default:
            if (isExclude) {
              var filter = { }
              array.forEach(function (j) {
                filter[j] = true
              })
              return result.filter(function (j) {
                return !filter[j]
              })
            }
            // union of result and array
            return result.concat(array)
        }
      }
    }

    throw unknownQuery(selection)
  }, [])
}

/**
 * Return array of browsers by selection queries.
 *
 * @param {(string|string[])} [queries=browserslist.defaults] Browser queries.
 * @param {object} [opts] Options.
 * @param {string} [opts.path="."] Path to processed file.
 *                                 It will be used to find config files.
 * @param {string} [opts.env="production"] Processing environment.
 *                                         It will be used to take right
 *                                         queries from config file.
 * @param {string} [opts.config] Path to config file with queries.
 * @param {object} [opts.stats] Custom browser usage statistics
 *                              for "> 1% in my stats" query.
 * @param {boolean} [opts.ignoreUnknownVersions=false] Do not throw on unknown
 *                                                     version in direct query.
 * @param {boolean} [opts.dangerousExtend] Disable security checks
 *                                         for extend query.
 * @returns {string[]} Array with browser names in Can I Use.
 *
 * @example
 * browserslist('IE >= 10, IE 8') //=> ['ie 11', 'ie 10', 'ie 8']
 */
function browserslist (queries, opts) {
  if (typeof opts === 'undefined') opts = { }

  if (typeof opts.path === 'undefined') {
    opts.path = path.resolve ? path.resolve('.') : '.'
  }

  if (typeof queries === 'undefined' || queries === null) {
    var config = browserslist.loadConfig(opts)
    if (config) {
      queries = config
    } else {
      queries = browserslist.defaults
    }
  }

  if (!(typeof queries === 'string' || Array.isArray(queries))) {
    throw new BrowserslistError(
      'Browser queries must be an array or string. Got ' + typeof queries + '.')
  }

  var context = {
    ignoreUnknownVersions: opts.ignoreUnknownVersions,
    dangerousExtend: opts.dangerousExtend
  }

  env.oldDataWarning(browserslist.data)
  var stats = env.getStat(opts, browserslist.data)
  if (stats) {
    context.customUsage = { }
    for (var browser in stats) {
      fillUsage(context.customUsage, browser, stats[browser])
    }
  }

  var result = resolve(queries, context).sort(function (name1, name2) {
    name1 = name1.split(' ')
    name2 = name2.split(' ')
    if (name1[0] === name2[0]) {
      if (FLOAT_RANGE.test(name1[1]) && FLOAT_RANGE.test(name2[1])) {
        return parseFloat(name2[1]) - parseFloat(name1[1])
      } else {
        return compareStrings(name2[1], name1[1])
      }
    } else {
      return compareStrings(name1[0], name2[0])
    }
  })

  return uniq(result)
}

/**
 * @typedef {object} BrowserslistQuery
 * @property {number} type A type constant like QUERY_OR @see QUERY_OR.
 * @property {string} queryString A query like "not ie < 11".
 */

/**
 * Parse a browserslist string query
 * @param {string} queries One or more queries as a string
 * @returns {BrowserslistQuery[]} An array of BrowserslistQuery
 */
function parse (queries) {
  var qs = []

  do {
    queries = doMatch(queries, qs)
  } while (queries)

  return qs
}

/**
 * Find query matches in a string. This function is meant to be called
 * repeatedly with the returned query string until there is no more matches.
 * @param {string} string A string with one or more queries.
 * @param {BrowserslistQuery[]} qs Out parameter,
 * will be filled with `BrowserslistQuery`.
 * @returns {string} The rest of the query string minus the matched part.
 */
function doMatch (string, qs) {
  var or = /^(?:,\s*|\s+OR\s+)(.*)/i
  var and = /^\s+AND\s+(.*)/i

  return find(
    string,
    function (parsed, n, max) {
      if (and.test(parsed)) {
        qs.unshift({ type: QUERY_AND, queryString: parsed.match(and)[1] })
        return true
      } else if (or.test(parsed)) {
        qs.unshift({ type: QUERY_OR, queryString: parsed.match(or)[1] })
        return true
      } else if (n === max) {
        qs.unshift({ type: QUERY_OR, queryString: parsed.trim() })
        return true
      }
      return false
    }
  )
}

function find (string, predicate) {
  for (var n = 1, max = string.length; n <= max; n++) {
    var parsed = string.substr(-n, n)
    if (predicate(parsed, n, max)) {
      return string.replace(parsed, '')
    }
  }
  return ''
}

function flatten (array) {
  if (!Array.isArray(array)) return [array]
  return array.reduce(function (a, b) {
    return a.concat(flatten(b))
  }, [])
}

// Will be filled by Can I Use data below
browserslist.data = { }
browserslist.usage = {
  global: { },
  custom: null
}

// Default browsers query
browserslist.defaults = [
  '> 0.5%',
  'last 2 versions',
  'Firefox ESR',
  'not dead'
]

// Browser names aliases
browserslist.aliases = {
  fx: 'firefox',
  ff: 'firefox',
  ios: 'ios_saf',
  explorer: 'ie',
  blackberry: 'bb',
  explorermobile: 'ie_mob',
  operamini: 'op_mini',
  operamobile: 'op_mob',
  chromeandroid: 'and_chr',
  firefoxandroid: 'and_ff',
  ucandroid: 'and_uc',
  qqandroid: 'and_qq'
}

// Aliases to work with joined versions like `ios_saf 7.0-7.1`
browserslist.versionAliases = { }

browserslist.clearCaches = env.clearCaches
browserslist.parseConfig = env.parseConfig
browserslist.readConfig = env.readConfig
browserslist.findConfig = env.findConfig
browserslist.loadConfig = env.loadConfig

/**
 * Return browsers market coverage.
 *
 * @param {string[]} browsers Browsers names in Can I Use.
 * @param {string|object} [stats="global"] Which statistics should be used.
 *                                         Country code or custom statistics.
 *                                         Pass `"my stats"` to load statistics
 *                                         from Browserslist files.
 *
 * @return {number} Total market coverage for all selected browsers.
 *
 * @example
 * browserslist.coverage(browserslist('> 1% in US'), 'US') //=> 83.1
 */
browserslist.coverage = function (browsers, stats) {
  var data
  if (typeof stats === 'undefined') {
    data = browserslist.usage.global
  } else if (stats === 'my stats') {
    var opts = {}
    opts.path = path.resolve ? path.resolve('.') : '.'
    var customStats = env.getStat(opts)
    if (!customStats) {
      throw new BrowserslistError('Custom usage statistics was not provided')
    }
    data = {}
    for (var browser in customStats) {
      fillUsage(data, browser, customStats[browser])
    }
  } else if (typeof stats === 'string') {
    if (stats.length > 2) {
      stats = stats.toLowerCase()
    } else {
      stats = stats.toUpperCase()
    }
    env.loadCountry(browserslist.usage, stats)
    data = browserslist.usage[stats]
  } else {
    if ('dataByBrowser' in stats) {
      stats = stats.dataByBrowser
    }
    data = { }
    for (var name in stats) {
      for (var version in stats[name]) {
        data[name + ' ' + version] = stats[name][version]
      }
    }
  }

  return browsers.reduce(function (all, i) {
    var usage = data[i]
    if (usage === undefined) {
      usage = data[i.replace(/ \S+$/, ' 0')]
    }
    return all + (usage || 0)
  }, 0)
}

var QUERIES = [
  {
    regexp: /^last\s+(\d+)\s+major versions?$/i,
    select: function (context, versions) {
      return Object.keys(agents).reduce(function (selected, name) {
        var data = byName(name)
        if (!data) return selected
        var array = getMajorVersions(data.released, versions)

        array = array.map(nameMapper(data.name))
        return selected.concat(array)
      }, [])
    }
  },
  {
    regexp: /^last\s+(\d+)\s+versions?$/i,
    select: function (context, versions) {
      return Object.keys(agents).reduce(function (selected, name) {
        var data = byName(name)
        if (!data) return selected
        var array = data.released.slice(-versions)

        array = array.map(nameMapper(data.name))
        return selected.concat(array)
      }, [])
    }
  },
  {
    regexp: /^last\s+(\d+)\s+electron\s+major versions?$/i,
    select: function (context, versions) {
      var validVersions = getMajorVersions(Object.keys(e2c).reverse(), versions)
      return validVersions.map(function (i) {
        return 'chrome ' + e2c[i]
      })
    }
  },
  {
    regexp: /^last\s+(\d+)\s+(\w+)\s+major versions?$/i,
    select: function (context, versions, name) {
      var data = checkName(name)
      var validVersions = getMajorVersions(data.released, versions)
      return validVersions.map(nameMapper(data.name))
    }
  },
  {
    regexp: /^last\s+(\d+)\s+electron\s+versions?$/i,
    select: function (context, versions) {
      return Object.keys(e2c).reverse().slice(-versions).map(function (i) {
        return 'chrome ' + e2c[i]
      })
    }
  },
  {
    regexp: /^last\s+(\d+)\s+(\w+)\s+versions?$/i,
    select: function (context, versions, name) {
      var data = checkName(name)
      return data.released.slice(-versions).map(nameMapper(data.name))
    }
  },
  {
    regexp: /^unreleased\s+versions$/i,
    select: function () {
      return Object.keys(agents).reduce(function (selected, name) {
        var data = byName(name)
        if (!data) return selected
        var array = data.versions.filter(function (v) {
          return data.released.indexOf(v) === -1
        })

        array = array.map(nameMapper(data.name))
        return selected.concat(array)
      }, [])
    }
  },
  {
    regexp: /^unreleased\s+electron\s+versions?$/i,
    select: function () {
      return []
    }
  },
  {
    regexp: /^unreleased\s+(\w+)\s+versions?$/i,
    select: function (context, name) {
      var data = checkName(name)
      return data.versions.filter(function (v) {
        return data.released.indexOf(v) === -1
      }).map(nameMapper(data.name))
    }
  },
  {
    regexp: /^last\s+(\d*.?\d+)\s+years?$/i,
    select: function (context, years) {
      return filterByYear(Date.now() - YEAR * years)
    }
  },
  {
    regexp: /^since (\d+)(?:-(\d+))?(?:-(\d+))?$/i,
    select: function (context, year, month, date) {
      year = parseInt(year)
      month = parseInt(month || '01') - 1
      date = parseInt(date || '01')
      return filterByYear(Date.UTC(year, month, date, 0, 0, 0))
    }
  },
  {
    regexp: /^(>=?|<=?)\s*(\d*\.?\d+)%$/,
    select: function (context, sign, popularity) {
      popularity = parseFloat(popularity)
      var usage = browserslist.usage.global

      return Object.keys(usage).reduce(function (result, version) {
        if (sign === '>') {
          if (usage[version] > popularity) {
            result.push(version)
          }
        } else if (sign === '<') {
          if (usage[version] < popularity) {
            result.push(version)
          }
        } else if (sign === '<=') {
          if (usage[version] <= popularity) {
            result.push(version)
          }
        } else if (usage[version] >= popularity) {
          result.push(version)
        }
        return result
      }, [])
    }
  },
  {
    regexp: /^(>=?|<=?)\s*(\d*\.?\d+)%\s+in\s+my\s+stats$/,
    select: function (context, sign, popularity) {
      popularity = parseFloat(popularity)

      if (!context.customUsage) {
        throw new BrowserslistError('Custom usage statistics was not provided')
      }

      var usage = context.customUsage

      return Object.keys(usage).reduce(function (result, version) {
        if (sign === '>') {
          if (usage[version] > popularity) {
            result.push(version)
          }
        } else if (sign === '<') {
          if (usage[version] < popularity) {
            result.push(version)
          }
        } else if (sign === '<=') {
          if (usage[version] <= popularity) {
            result.push(version)
          }
        } else if (usage[version] >= popularity) {
          result.push(version)
        }
        return result
      }, [])
    }
  },
  {
    regexp: /^(>=?|<=?)\s*(\d*\.?\d+)%\s+in\s+((alt-)?\w\w)$/,
    select: function (context, sign, popularity, place) {
      popularity = parseFloat(popularity)

      if (place.length === 2) {
        place = place.toUpperCase()
      } else {
        place = place.toLowerCase()
      }

      env.loadCountry(browserslist.usage, place)
      var usage = browserslist.usage[place]

      return Object.keys(usage).reduce(function (result, version) {
        if (sign === '>') {
          if (usage[version] > popularity) {
            result.push(version)
          }
        } else if (sign === '<') {
          if (usage[version] < popularity) {
            result.push(version)
          }
        } else if (sign === '<=') {
          if (usage[version] <= popularity) {
            result.push(version)
          }
        } else if (usage[version] >= popularity) {
          result.push(version)
        }
        return result
      }, [])
    }
  },
  {
    regexp: /^cover\s+(\d*\.?\d+)%(\s+in\s+(my\s+stats|(alt-)?\w\w))?$/,
    select: function (context, coverage, statMode) {
      coverage = parseFloat(coverage)

      var usage = browserslist.usage.global
      if (statMode) {
        if (statMode.match(/^\s+in\s+my\s+stats$/)) {
          if (!context.customUsage) {
            throw new BrowserslistError(
              'Custom usage statistics was not provided'
            )
          }
          usage = context.customUsage
        } else {
          var match = statMode.match(/\s+in\s+((alt-)?\w\w)/)
          var place = match[1]
          if (place.length === 2) {
            place = place.toUpperCase()
          } else {
            place = place.toLowerCase()
          }
          env.loadCountry(browserslist.usage, place)
          usage = browserslist.usage[place]
        }
      }

      var versions = Object.keys(usage).sort(function (a, b) {
        return usage[b] - usage[a]
      })

      var coveraged = 0
      var result = []
      var version
      for (var i = 0; i <= versions.length; i++) {
        version = versions[i]
        if (usage[version] === 0) break

        coveraged += usage[version]
        result.push(version)
        if (coveraged >= coverage) break
      }

      return result
    }
  },
  {
    regexp: /^electron\s+([\d.]+)\s*-\s*([\d.]+)$/i,
    select: function (context, from, to) {
      if (!e2c[from]) {
        throw new BrowserslistError('Unknown version ' + from + ' of electron')
      }
      if (!e2c[to]) {
        throw new BrowserslistError('Unknown version ' + to + ' of electron')
      }

      from = parseFloat(from)
      to = parseFloat(to)

      return Object.keys(e2c).filter(function (i) {
        var parsed = parseFloat(i)
        return parsed >= from && parsed <= to
      }).map(function (i) {
        return 'chrome ' + e2c[i]
      })
    }
  },
  {
    regexp: /^(\w+)\s+([\d.]+)\s*-\s*([\d.]+)$/i,
    select: function (context, name, from, to) {
      var data = checkName(name)
      from = parseFloat(normalizeVersion(data, from) || from)
      to = parseFloat(normalizeVersion(data, to) || to)

      function filter (v) {
        var parsed = parseFloat(v)
        return parsed >= from && parsed <= to
      }

      return data.released.filter(filter).map(nameMapper(data.name))
    }
  },
  {
    regexp: /^electron\s*(>=?|<=?)\s*([\d.]+)$/i,
    select: function (context, sign, version) {
      return Object.keys(e2c)
        .filter(generateFilter(sign, version))
        .map(function (i) {
          return 'chrome ' + e2c[i]
        })
    }
  },
  {
    regexp: /^(\w+)\s*(>=?|<=?)\s*([\d.]+)$/,
    select: function (context, name, sign, version) {
      var data = checkName(name)
      var alias = browserslist.versionAliases[data.name][version]
      if (alias) {
        version = alias
      }
      return data.released
        .filter(generateFilter(sign, version))
        .map(function (v) {
          return data.name + ' ' + v
        })
    }
  },
  {
    regexp: /^(firefox|ff|fx)\s+esr$/i,
    select: function () {
      return ['firefox 60']
    }
  },
  {
    regexp: /(operamini|op_mini)\s+all/i,
    select: function () {
      return ['op_mini all']
    }
  },
  {
    regexp: /^electron\s+([\d.]+)$/i,
    select: function (context, version) {
      var chrome = e2c[version]
      if (!chrome) {
        throw new BrowserslistError(
          'Unknown version ' + version + ' of electron')
      }
      return ['chrome ' + chrome]
    }
  },
  {
    regexp: /^node\s+(\d+(\.\d+)?(\.\d+)?)$/i,
    select: function (context, version) {
      var nodeReleases = jsReleases.filter(function (i) {
        return i.name === 'nodejs'
      })
      var matched = nodeReleases.filter(function (i) {
        return isVersionsMatch(i.version, version)
      })
      if (matched.length === 0) {
        if (context.ignoreUnknownVersions) {
          return []
        } else {
          throw new BrowserslistError(
            'Unknown version ' + version + ' of Node.js')
        }
      }
      return ['node ' + matched[matched.length - 1].version]
    }
  },
  {
    regexp: /^current\s+node$/i,
    select: function (context) {
      return [env.currentNode(resolve, context)]
    }
  },
  {
    regexp: /^maintained\s+node\s+versions$/i,
    select: function (context) {
      var now = Date.now()
      var queries = Object.keys(jsEOL).filter(function (key) {
        return now < Date.parse(jsEOL[key].end) &&
          now > Date.parse(jsEOL[key].start) &&
          isEolReleased(key)
      }).map(function (key) {
        return 'node ' + key.slice(1)
      })
      return resolve(queries, context)
    }
  },
  {
    regexp: /^(\w+)\s+(tp|[\d.]+)$/i,
    select: function (context, name, version) {
      if (/^tp$/i.test(version)) version = 'TP'
      var data = checkName(name)
      var alias = normalizeVersion(data, version)
      if (alias) {
        version = alias
      } else {
        if (version.indexOf('.') === -1) {
          alias = version + '.0'
        } else {
          alias = version.replace(/\.0$/, '')
        }
        alias = normalizeVersion(data, alias)
        if (alias) {
          version = alias
        } else if (context.ignoreUnknownVersions) {
          return []
        } else {
          throw new BrowserslistError(
            'Unknown version ' + version + ' of ' + name)
        }
      }
      return [data.name + ' ' + version]
    }
  },
  {
    regexp: /^extends (.+)$/i,
    select: function (context, name) {
      return resolve(env.loadQueries(context, name), context)
    }
  },
  {
    regexp: /^defaults$/i,
    select: function () {
      return browserslist(browserslist.defaults)
    }
  },
  {
    regexp: /^dead$/i,
    select: function (context) {
      var dead = ['ie <= 10', 'ie_mob <= 10', 'bb <= 10', 'op_mob <= 12.1']
      return resolve(dead, context)
    }
  },
  {
    regexp: /^(\w+)$/i,
    select: function (context, name) {
      if (byName(name)) {
        throw new BrowserslistError(
          'Specify versions in Browserslist query for browser ' + name)
      } else {
        throw unknownQuery(name)
      }
    }
  }
];

// Get and convert Can I Use data

(function () {
  for (var name in agents) {
    var browser = agents[name]
    browserslist.data[name] = {
      name: name,
      versions: normalize(agents[name].versions),
      released: normalize(agents[name].versions.slice(0, -3)),
      releaseDate: agents[name].release_date
    }
    fillUsage(browserslist.usage.global, name, browser.usage_global)

    browserslist.versionAliases[name] = { }
    for (var i = 0; i < browser.versions.length; i++) {
      var full = browser.versions[i]
      if (!full) continue

      if (full.indexOf('-') !== -1) {
        var interval = full.split('-')
        for (var j = 0; j < interval.length; j++) {
          browserslist.versionAliases[name][interval[j]] = full
        }
      }
    }
  }
}())

module.exports = browserslist

},{"./error":11,"./node":10,"caniuse-lite/dist/unpacker/agents":529,"electron-to-chromium/versions":686,"node-releases/data/processed/envs.json":787,"node-releases/data/release-schedule/release-schedule.json":788,"path":7}],13:[function(require,module,exports){
(function (Buffer){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function () { return 42 } }
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  buf.__proto__ = Buffer.prototype
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
if (typeof Symbol !== 'undefined' && Symbol.species != null &&
    Buffer[Symbol.species] === Buffer) {
  Object.defineProperty(Buffer, Symbol.species, {
    value: null,
    configurable: true,
    enumerable: false,
    writable: false
  })
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayLike(value)
  }

  if (value == null) {
    throw TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  var valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  var b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(
      value[Symbol.toPrimitive]('string'), encodingOrOffset, length
    )
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Buffer.prototype.__proto__ = Uint8Array.prototype
Buffer.__proto__ = Uint8Array

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  buf.__proto__ = Buffer.prototype
  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      buf = Buffer.from(buf)
    }
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  var len = string.length
  var mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  var strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
        : (firstByte > 0xBF) ? 2
          : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  newBuf.__proto__ = Buffer.prototype
  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (var i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding)
    var len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

}).call(this,require("buffer").Buffer)
},{"base64-js":5,"buffer":13,"ieee754":725}],14:[function(require,module,exports){
'use strict';
const callsites = require('callsites');

module.exports = () => {
	const c = callsites();
	let caller;

	for (let i = 0; i < c.length; i++) {
		const hasReceiver = c[i].getTypeName() !== null;

		if (hasReceiver) {
			caller = i;
			break;
		}
	}

	return c[caller];
};

},{"callsites":16}],15:[function(require,module,exports){
'use strict';
const callerCallsite = require('caller-callsite');

module.exports = () => callerCallsite().getFileName();

},{"caller-callsite":14}],16:[function(require,module,exports){
'use strict';
module.exports = () => {
	const _ = Error.prepareStackTrace;
	Error.prepareStackTrace = (_, stack) => stack;
	const stack = new Error().stack.slice(1);
	Error.prepareStackTrace = _;
	return stack;
};

},{}],17:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getBrowserScope = exports.setBrowserScope = exports.getLatestStableBrowsers = exports.find = exports.isSupported = exports.getSupport = exports.features = undefined;

var _lodash = require("lodash.memoize");

var _lodash2 = _interopRequireDefault(_lodash);

var _browserslist = require("browserslist");

var _browserslist2 = _interopRequireDefault(_browserslist);

var _caniuseLite = require("caniuse-lite");

var _utils = require("./utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var featuresList = Object.keys(_caniuseLite.features);

var browsers = void 0;
function setBrowserScope(browserList) {
  browsers = (0, _utils.cleanBrowsersList)(browserList);
}

function getBrowserScope() {
  return browsers;
}

var parse = (0, _lodash2.default)(_utils.parseCaniuseData, function (feat, browsers) {
  return feat.title + browsers;
});

function getSupport(query) {
  var feature = void 0;
  try {
    feature = (0, _caniuseLite.feature)(_caniuseLite.features[query]);
  } catch (e) {
    var res = find(query);
    if (res.length === 1) return getSupport(res[0]);
    throw new ReferenceError("Please provide a proper feature name. Cannot find " + query);
  }
  return parse(feature, browsers);
}

function isSupported(feature, browsers) {
  var data = void 0;
  try {
    data = (0, _caniuseLite.feature)(_caniuseLite.features[feature]);
  } catch (e) {
    var res = find(feature);
    if (res.length === 1) {
      data = _caniuseLite.features[res[0]];
    } else {
      throw new ReferenceError("Please provide a proper feature name. Cannot find " + feature);
    }
  }

  return (0, _browserslist2.default)(browsers, { ignoreUnknownVersions: true }).map(function (browser) {
    return browser.split(" ");
  }).every(function (browser) {
    return data.stats[browser[0]] && data.stats[browser[0]][browser[1]] === "y";
  });
}

function find(query) {
  if (typeof query !== "string") {
    throw new TypeError("The `query` parameter should be a string.");
  }

  if (~featuresList.indexOf(query)) {
    // exact match
    return query;
  }

  return featuresList.filter(function (file) {
    return (0, _utils.contains)(file, query);
  });
}

function getLatestStableBrowsers() {
  return (0, _browserslist2.default)("last 1 version");
}

setBrowserScope();

exports.features = featuresList;
exports.getSupport = getSupport;
exports.isSupported = isSupported;
exports.find = find;
exports.getLatestStableBrowsers = getLatestStableBrowsers;
exports.setBrowserScope = setBrowserScope;
exports.getBrowserScope = getBrowserScope;
},{"./utils":18,"browserslist":12,"caniuse-lite":534,"lodash.memoize":785}],18:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.contains = contains;
exports.parseCaniuseData = parseCaniuseData;
exports.cleanBrowsersList = cleanBrowsersList;

var _lodash = require("lodash.uniq");

var _lodash2 = _interopRequireDefault(_lodash);

var _browserslist = require("browserslist");

var _browserslist2 = _interopRequireDefault(_browserslist);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function contains(str, substr) {
  return !!~str.indexOf(substr);
}

function parseCaniuseData(feature, browsers) {
  var support = {};
  var letters;
  var letter;

  browsers.forEach(function (browser) {
    support[browser] = {};
    for (var info in feature.stats[browser]) {
      letters = feature.stats[browser][info].replace(/#\d+/, "").trim().split(" ");
      info = parseFloat(info.split("-")[0]); //if info is a range, take the left
      if (isNaN(info)) continue;
      for (var i = 0; i < letters.length; i++) {
        letter = letters[i];
        if (letter === "d") {
          // skip this letter, we don't support it yet
          continue;
        } else if (letter === "y") {
          // min support asked, need to find the min value
          if (typeof support[browser][letter] === "undefined" || info < support[browser][letter]) {
            support[browser][letter] = info;
          }
        } else {
          // any other support, need to find the max value
          if (typeof support[browser][letter] === "undefined" || info > support[browser][letter]) {
            support[browser][letter] = info;
          }
        }
      }
    }
  });

  return support;
}

function cleanBrowsersList(browserList) {
  return (0, _lodash2.default)((0, _browserslist2.default)(browserList).map(function (browser) {
    return browser.split(" ")[0];
  }));
}
},{"browserslist":12,"lodash.uniq":786}],19:[function(require,module,exports){
module.exports={A:{A:{K:0.0100156,D:0.0100156,G:0.13521,E:0.195304,A:0.0600934,B:2.26352,gB:0.009298},B:"ms",C:["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","gB","K","D","G","E","A","B","","",""],E:"IE",F:{gB:962323200,K:998870400,D:1161129600,G:1237420800,E:1300060800,A:1346716800,B:1381968000}},B:{A:{"2":0.019308,C:0.014481,d:0.043443,J:0.062751,M:0.120675,H:1.5205,I:0},B:"ms",C:["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","C","2","d","J","M","H","I","","",""],E:"Edge",F:{"2":1447286400,C:1438128000,d:1470096000,J:1491868800,M:1508198400,H:1525046400,I:1542067200}},C:{A:{"0":0.033789,"1":0.024135,"2":0.004486,"3":0.511662,"4":0,"6":0.004707,"7":0.168945,"9":0.028962,dB:0.004827,BB:0.004707,F:0.009654,N:0.004879,K:0.020136,D:0.005725,G:0.004725,E:0.00533,A:0.004283,B:0.004317,C:0.004471,d:0.00453,J:0.004827,M:0.004417,H:0.004827,I:0.004393,O:0.004443,P:0.004283,Q:0.008652,R:0.004393,S:0.004827,T:0.008786,U:0.004326,V:0.004317,W:0.004393,X:0.004418,Y:0.008834,Z:0.004725,a:0.009654,b:0.004471,c:0.004725,e:0.009654,f:0.004417,g:0.004783,h:0.014481,i:0.004783,j:0.004827,k:0.004827,l:0.004707,m:0.019308,n:0.009654,o:0.014481,L:0.004783,q:0.062751,r:0.053097,s:0.009654,t:0.014481,u:0.009654,v:0.207561,w:0.009654,x:0.024135,y:0.014481,z:0.043443,GB:0.024135,FB:0.033789,AB:0.04827,CB:2.58727,DB:0.082059,XB:0.008786,WB:0.009414},B:"moz",C:["","","","dB","BB","XB","WB","F","N","K","D","G","E","A","B","C","2","d","J","M","H","I","O","P","Q","R","S","T","U","V","W","X","Y","Z","a","b","c","6","e","f","g","h","i","j","k","l","m","n","o","L","q","r","s","t","u","v","w","x","y","z","0","1","GB","7","FB","9","AB","3","CB","DB","4",""],E:"Firefox",F:{"0":1510617600,"1":1516665600,"2":1335225600,"3":1544486400,"4":null,"6":1417392000,"7":1525824000,"9":1536105600,dB:1161648000,BB:1213660800,XB:1246320000,WB:1264032000,F:1300752000,N:1308614400,K:1313452800,D:1317081600,G:1317081600,E:1320710400,A:1324339200,B:1327968000,C:1331596800,d:1338854400,J:1342483200,M:1346112000,H:1349740800,I:1353628800,O:1357603200,P:1361232000,Q:1364860800,R:1368489600,S:1372118400,T:1375747200,U:1379376000,V:1386633600,W:1391472000,X:1395100800,Y:1398729600,Z:1402358400,a:1405987200,b:1409616000,c:1413244800,e:1421107200,f:1424736000,g:1428278400,h:1431475200,i:1435881600,j:1439251200,k:1442880000,l:1446508800,m:1450137600,n:1453852800,o:1457395200,L:1461628800,q:1465257600,r:1470096000,s:1474329600,t:1479168000,u:1485216000,v:1488844800,w:1492560000,x:1497312000,y:1502150400,z:1506556800,GB:1520985600,FB:1529971200,AB:1540252800,CB:1548720000,DB:null}},D:{A:{"0":0.057924,"1":0.077232,"2":0.004879,"3":0.086886,"4":0.217215,"6":0.014481,"7":0.038616,"9":0.082059,F:0.004706,N:0.004879,K:0.004879,D:0.005591,G:0.005591,E:0.005591,A:0.004534,B:0.009654,C:0.010424,d:0.004706,J:0.014481,M:0.004393,H:0.004393,I:0.008652,O:0.004418,P:0.004393,Q:0.004317,R:0.019308,S:0.008786,T:0.014481,U:0.004827,V:0.009654,W:0.004326,X:0.004725,Y:0.101367,Z:0.009654,a:0.024135,b:0.004827,c:0.019308,e:0.014481,f:0.009654,g:0.004827,h:0.033789,i:0.009654,j:0.028962,k:0.009654,l:0.004827,m:0.033789,n:0.004827,o:0.009654,L:0.009654,q:0.014481,r:0.04827,s:0.492354,t:0.009654,u:0.019308,v:0.009654,w:0.024135,x:0.038616,y:0.053097,z:0.057924,GB:0.033789,FB:0.362025,AB:0.371679,CB:0.154464,DB:0.09654,QB:0.183426,iB:0.222042,KB:0.381333,IB:11.6717,LB:15.0023,MB:0.053097,NB:0.024135,OB:0},B:"webkit",C:["F","N","K","D","G","E","A","B","C","2","d","J","M","H","I","O","P","Q","R","S","T","U","V","W","X","Y","Z","a","b","c","6","e","f","g","h","i","j","k","l","m","n","o","L","q","r","s","t","u","v","w","x","y","z","0","1","GB","7","FB","9","AB","3","CB","DB","4","QB","iB","KB","IB","LB","MB","NB","OB"],E:"Chrome",F:{"0":1489017600,"1":1492560000,"2":1312243200,"3":1516752000,"4":1527552000,"6":1397001600,"7":1500940800,"9":1508198400,F:1264377600,N:1274745600,K:1283385600,D:1287619200,G:1291248000,E:1296777600,A:1299542400,B:1303862400,C:1307404800,d:1316131200,J:1316131200,M:1319500800,H:1323734400,I:1328659200,O:1332892800,P:1337040000,Q:1340668800,R:1343692800,S:1348531200,T:1352246400,U:1357862400,V:1361404800,W:1364428800,X:1369094400,Y:1374105600,Z:1376956800,a:1384214400,b:1389657600,c:1392940800,e:1400544000,f:1405468800,g:1409011200,h:1412640000,i:1416268800,j:1421798400,k:1425513600,l:1429401600,m:1432080000,n:1437523200,o:1441152000,L:1444780800,q:1449014400,r:1453248000,s:1456963200,t:1460592000,u:1464134400,v:1469059200,w:1472601600,x:1476230400,y:1480550400,z:1485302400,GB:1496707200,FB:1504569600,AB:1512518400,CB:1520294400,DB:1523923200,QB:1532390400,iB:1536019200,KB:1539648000,IB:1543968000,LB:1548720000,MB:null,NB:null,OB:null}},E:{A:{"5":0.009654,F:0,N:0.004827,K:0.004349,D:0.009654,G:0.04827,E:0.053097,A:0.033789,B:0.086886,C:1.81012,PB:0,HB:0.008692,RB:0.120675,SB:0.014481,TB:0.004283,UB:0.062751,VB:0.168945,p:0.328236,YB:0},B:"webkit",C:["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","PB","HB","F","N","RB","K","SB","D","TB","G","E","UB","A","VB","B","p","C","5","YB",""],E:"Safari",F:{"5":null,PB:1205798400,HB:1226534400,F:1244419200,N:1275868800,RB:1311120000,K:1343174400,SB:1382400000,D:1382400000,TB:1410998400,G:1413417600,E:1443657600,UB:1458518400,A:1474329600,VB:1490572800,B:1505779200,p:1522281600,C:1537142400,YB:null}},F:{A:{"0":0.468219,"1":0.506835,"5":0.014481,"6":0.009758,"8":0.004879,E:0.0082,B:0.016581,C:0.004317,J:0.00685,M:0.00685,H:0.00685,I:0.005014,O:0.006015,P:0.004879,Q:0.006597,R:0.006597,S:0.013434,T:0.006702,U:0.006015,V:0.005595,W:0.004393,X:0.008652,Y:0.004879,Z:0.004879,a:0.004827,b:0.005152,c:0.005014,e:0.004879,f:0.019308,g:0.004283,h:0.004367,i:0.004534,j:0.004367,k:0.004227,l:0.004418,m:0.024135,n:0.004227,o:0.004725,L:0.004417,q:0.008942,r:0.004707,s:0.004827,t:0.004707,u:0.004707,v:0.004326,w:0.004783,x:0.014349,y:0.004725,z:0.014481,ZB:0.00685,aB:0,bB:0.008392,cB:0.004706,p:0.006229,eB:0.008786},B:"webkit",C:["","","","","","","","","","","","","","","E","ZB","aB","bB","cB","B","p","8","eB","C","5","J","M","H","I","O","P","Q","R","S","T","U","V","W","X","Y","Z","a","b","c","6","e","f","g","h","i","j","k","l","m","n","o","L","q","r","s","t","u","v","w","x","y","z","0","1","","",""],E:"Opera",F:{"0":1543363200,"1":1548201600,"5":1352073600,"6":1449100800,"8":1309219200,E:1150761600,ZB:1223424000,aB:1251763200,bB:1267488000,cB:1277942400,B:1292457600,p:1302566400,eB:1323129600,C:1323129600,J:1372723200,M:1377561600,H:1381104000,I:1386288000,O:1390867200,P:1393891200,Q:1399334400,R:1401753600,S:1405987200,T:1409616000,U:1413331200,V:1417132800,W:1422316800,X:1425945600,Y:1430179200,Z:1433808000,a:1438646400,b:1442448000,c:1445904000,e:1454371200,f:1457308800,g:1462320000,h:1465344000,i:1470096000,j:1474329600,k:1477267200,l:1481587200,m:1486425600,n:1490054400,o:1494374400,L:1498003200,q:1502236800,r:1506470400,s:1510099200,t:1515024000,u:1517961600,v:1521676800,w:1525910400,x:1530144000,y:1534982400,z:1537833600},D:{"5":"o","8":"o",E:"o",B:"o",C:"o",ZB:"o",aB:"o",bB:"o",cB:"o",p:"o",eB:"o"}},G:{A:{G:0.309691,HB:0.00440841,fB:0.00330631,EB:0.00330631,hB:0.0121231,JB:0.00771472,jB:0.0253484,kB:0.0606157,lB:0.031961,mB:0.23585,nB:0.147682,oB:0.306385,pB:0.400063,qB:0.95883,rB:8.46525,sB:0.0407778},B:"webkit",C:["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","HB","fB","EB","hB","JB","jB","G","kB","lB","mB","nB","oB","pB","qB","rB","sB","",""],E:"iOS Safari",F:{HB:1270252800,fB:1283904000,EB:1299628800,hB:1331078400,JB:1359331200,jB:1394409600,G:1410912000,kB:1413763200,lB:1442361600,mB:1458518400,nB:1473724800,oB:1490572800,pB:1505779200,qB:1522281600,rB:1537142400,sB:null}},H:{A:{tB:1.7288},B:"o",C:["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","tB","","",""],E:"Opera Mini",F:{tB:1426464000}},I:{A:{"4":0,BB:0.000880511,F:0.117108,uB:0,vB:0,wB:0.0193712,xB:0.0334594,EB:0.176983,yB:0,zB:0.39711},B:"webkit",C:["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","uB","vB","wB","BB","F","xB","EB","yB","zB","4","","",""],E:"Android Browser",F:{"4":1494115200,uB:1256515200,vB:1274313600,wB:1291593600,BB:1298332800,F:1318896000,xB:1341792000,EB:1374624000,yB:1386547200,zB:1401667200}},J:{A:{D:0.0041384,A:0.0165536},B:"webkit",C:["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","D","A","","",""],E:"Blackberry Browser",F:{D:1325376000,A:1359504000}},K:{A:{"5":0,"8":0,A:0,B:0,C:0,L:0.0111391,p:0},B:"o",C:["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","A","B","p","8","C","5","L","","",""],E:"Opera Mobile",F:{"5":1349740800,"8":1318291200,A:1287100800,B:1300752000,p:1314835200,C:1330300800,L:1474588800},D:{L:"webkit"}},L:{A:{IB:33.4594},B:"webkit",C:["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","IB","","",""],E:"Chrome for Android",F:{IB:1543881600}},M:{A:{"3":0.181055},B:"moz",C:["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","3","","",""],E:"Firefox for Android",F:{"3":1544745600}},N:{A:{A:0.0115934,B:0.108633},B:"ms",C:["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","A","B","","",""],E:"IE Mobile",F:{A:1340150400,B:1353456000}},O:{A:{"0B":3.76594},B:"webkit",C:["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","0B","","",""],E:"UC Browser for Android",F:{"0B":1471392000},D:{"0B":"webkit"}},P:{A:{F:0.610326,"1B":0.0526143,"2B":0.0947057,"3B":0,"4B":0},B:"webkit",C:["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","F","1B","2B","3B","4B","","",""],E:"Samsung Internet",F:{F:1461024000,"1B":1481846400,"2B":1509408000,"3B":1528329600,"4B":1546128000}},Q:{A:{"5B":0},B:"webkit",C:["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","5B","","",""],E:"QQ Browser",F:{"5B":1483228800}},R:{A:{"6B":0},B:"webkit",C:["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","6B","","",""],E:"Baidu Browser",F:{"6B":1491004800}}};

},{}],20:[function(require,module,exports){
module.exports={"0":"57","1":"58","2":"13","3":"64","4":"67","5":"12.1","6":"34","7":"60","8":"11.5","9":"62",A:"10",B:"11",C:"12",D:"7",E:"9",F:"4",G:"8",H:"17",I:"18",J:"15",K:"6",L:"46",M:"16",N:"5",O:"19",P:"20",Q:"21",R:"22",S:"23",T:"24",U:"25",V:"26",W:"27",X:"28",Y:"29",Z:"30",a:"31",b:"32",c:"33",d:"14",e:"35",f:"36",g:"37",h:"38",i:"39",j:"40",k:"41",l:"42",m:"43",n:"44",o:"45",p:"11.1",q:"47",r:"48",s:"49",t:"50",u:"51",v:"52",w:"53",x:"54",y:"55",z:"56",AB:"63",BB:"3",CB:"65",DB:"66",EB:"4.2-4.3",FB:"61",GB:"59",HB:"3.2",IB:"71",JB:"6.0-6.1",KB:"70",LB:"72",MB:"73",NB:"74",OB:"75",PB:"3.1",QB:"68",RB:"5.1",SB:"6.1",TB:"7.1",UB:"9.1",VB:"10.1",WB:"3.6",XB:"3.5",YB:"TP",ZB:"9.5-9.6",aB:"10.0-10.1",bB:"10.5",cB:"10.6",dB:"2",eB:"11.6",fB:"4.0-4.1",gB:"5.5",hB:"5.0-5.1",iB:"69",jB:"7.0-7.1",kB:"8.1-8.4",lB:"9.0-9.2",mB:"9.3",nB:"10.0-10.2",oB:"10.3",pB:"11.0-11.2",qB:"11.3-11.4",rB:"12.0-12.1",sB:"12.2",tB:"all",uB:"2.1",vB:"2.2",wB:"2.3",xB:"4.1",yB:"4.4",zB:"4.4.3-4.4.4","0B":"11.8","1B":"5.0-5.4","2B":"6.2-6.4","3B":"7.2-7.4","4B":"8.2","5B":"1.2","6B":"7.12"};

},{}],21:[function(require,module,exports){
module.exports={A:"ie",B:"edge",C:"firefox",D:"chrome",E:"safari",F:"opera",G:"ios_saf",H:"op_mini",I:"android",J:"bb",K:"op_mob",L:"and_chr",M:"and_ff",N:"ie_mob",O:"and_uc",P:"samsung",Q:"and_qq",R:"baidu"};

},{}],22:[function(require,module,exports){
module.exports={"aac":require("./features/aac"),"abortcontroller":require("./features/abortcontroller"),"ac3-ec3":require("./features/ac3-ec3"),"accelerometer":require("./features/accelerometer"),"addeventlistener":require("./features/addeventlistener"),"alternate-stylesheet":require("./features/alternate-stylesheet"),"ambient-light":require("./features/ambient-light"),"apng":require("./features/apng"),"array-find-index":require("./features/array-find-index"),"array-find":require("./features/array-find"),"array-flat":require("./features/array-flat"),"array-includes":require("./features/array-includes"),"arrow-functions":require("./features/arrow-functions"),"asmjs":require("./features/asmjs"),"async-clipboard":require("./features/async-clipboard"),"async-functions":require("./features/async-functions"),"async-iterations-and-generators":require("./features/async-iterations-and-generators"),"atob-btoa":require("./features/atob-btoa"),"audio-api":require("./features/audio-api"),"audio":require("./features/audio"),"audiotracks":require("./features/audiotracks"),"autofocus":require("./features/autofocus"),"auxclick":require("./features/auxclick"),"av1":require("./features/av1"),"background-attachment":require("./features/background-attachment"),"background-clip-text":require("./features/background-clip-text"),"background-img-opts":require("./features/background-img-opts"),"background-position-x-y":require("./features/background-position-x-y"),"background-repeat-round-space":require("./features/background-repeat-round-space"),"background-sync":require("./features/background-sync"),"battery-status":require("./features/battery-status"),"beacon":require("./features/beacon"),"beforeafterprint":require("./features/beforeafterprint"),"bigint":require("./features/bigint"),"blobbuilder":require("./features/blobbuilder"),"bloburls":require("./features/bloburls"),"border-image":require("./features/border-image"),"border-radius":require("./features/border-radius"),"broadcastchannel":require("./features/broadcastchannel"),"brotli":require("./features/brotli"),"calc":require("./features/calc"),"canvas-blending":require("./features/canvas-blending"),"canvas-text":require("./features/canvas-text"),"canvas":require("./features/canvas"),"ch-unit":require("./features/ch-unit"),"chacha20-poly1305":require("./features/chacha20-poly1305"),"channel-messaging":require("./features/channel-messaging"),"childnode-remove":require("./features/childnode-remove"),"classlist":require("./features/classlist"),"clear-site-data-header":require("./features/clear-site-data-header"),"client-hints-dpr-width-viewport":require("./features/client-hints-dpr-width-viewport"),"clipboard":require("./features/clipboard"),"comparedocumentposition":require("./features/comparedocumentposition"),"console-basic":require("./features/console-basic"),"console-time":require("./features/console-time"),"const":require("./features/const"),"constraint-validation":require("./features/constraint-validation"),"contenteditable":require("./features/contenteditable"),"contentsecuritypolicy":require("./features/contentsecuritypolicy"),"contentsecuritypolicy2":require("./features/contentsecuritypolicy2"),"cors":require("./features/cors"),"createimagebitmap":require("./features/createimagebitmap"),"credential-management":require("./features/credential-management"),"cryptography":require("./features/cryptography"),"css-all":require("./features/css-all"),"css-animation":require("./features/css-animation"),"css-any-link":require("./features/css-any-link"),"css-appearance":require("./features/css-appearance"),"css-apply-rule":require("./features/css-apply-rule"),"css-at-counter-style":require("./features/css-at-counter-style"),"css-backdrop-filter":require("./features/css-backdrop-filter"),"css-background-offsets":require("./features/css-background-offsets"),"css-backgroundblendmode":require("./features/css-backgroundblendmode"),"css-boxdecorationbreak":require("./features/css-boxdecorationbreak"),"css-boxshadow":require("./features/css-boxshadow"),"css-canvas":require("./features/css-canvas"),"css-caret-color":require("./features/css-caret-color"),"css-case-insensitive":require("./features/css-case-insensitive"),"css-clip-path":require("./features/css-clip-path"),"css-color-adjust":require("./features/css-color-adjust"),"css-conic-gradients":require("./features/css-conic-gradients"),"css-containment":require("./features/css-containment"),"css-counters":require("./features/css-counters"),"css-crisp-edges":require("./features/css-crisp-edges"),"css-cross-fade":require("./features/css-cross-fade"),"css-default-pseudo":require("./features/css-default-pseudo"),"css-descendant-gtgt":require("./features/css-descendant-gtgt"),"css-deviceadaptation":require("./features/css-deviceadaptation"),"css-dir-pseudo":require("./features/css-dir-pseudo"),"css-display-contents":require("./features/css-display-contents"),"css-element-function":require("./features/css-element-function"),"css-env-function":require("./features/css-env-function"),"css-exclusions":require("./features/css-exclusions"),"css-featurequeries":require("./features/css-featurequeries"),"css-filter-function":require("./features/css-filter-function"),"css-filters":require("./features/css-filters"),"css-first-letter":require("./features/css-first-letter"),"css-first-line":require("./features/css-first-line"),"css-fixed":require("./features/css-fixed"),"css-focus-visible":require("./features/css-focus-visible"),"css-focus-within":require("./features/css-focus-within"),"css-font-rendering-controls":require("./features/css-font-rendering-controls"),"css-font-stretch":require("./features/css-font-stretch"),"css-gencontent":require("./features/css-gencontent"),"css-gradients":require("./features/css-gradients"),"css-grid":require("./features/css-grid"),"css-hanging-punctuation":require("./features/css-hanging-punctuation"),"css-has":require("./features/css-has"),"css-hyphenate":require("./features/css-hyphenate"),"css-hyphens":require("./features/css-hyphens"),"css-image-orientation":require("./features/css-image-orientation"),"css-image-set":require("./features/css-image-set"),"css-in-out-of-range":require("./features/css-in-out-of-range"),"css-indeterminate-pseudo":require("./features/css-indeterminate-pseudo"),"css-initial-letter":require("./features/css-initial-letter"),"css-initial-value":require("./features/css-initial-value"),"css-letter-spacing":require("./features/css-letter-spacing"),"css-line-clamp":require("./features/css-line-clamp"),"css-logical-props":require("./features/css-logical-props"),"css-marker-pseudo":require("./features/css-marker-pseudo"),"css-masks":require("./features/css-masks"),"css-matches-pseudo":require("./features/css-matches-pseudo"),"css-math-functions":require("./features/css-math-functions"),"css-media-interaction":require("./features/css-media-interaction"),"css-media-resolution":require("./features/css-media-resolution"),"css-media-scripting":require("./features/css-media-scripting"),"css-mediaqueries":require("./features/css-mediaqueries"),"css-mixblendmode":require("./features/css-mixblendmode"),"css-motion-paths":require("./features/css-motion-paths"),"css-namespaces":require("./features/css-namespaces"),"css-not-sel-list":require("./features/css-not-sel-list"),"css-nth-child-of":require("./features/css-nth-child-of"),"css-opacity":require("./features/css-opacity"),"css-optional-pseudo":require("./features/css-optional-pseudo"),"css-overflow-anchor":require("./features/css-overflow-anchor"),"css-overflow":require("./features/css-overflow"),"css-overscroll-behavior":require("./features/css-overscroll-behavior"),"css-page-break":require("./features/css-page-break"),"css-paged-media":require("./features/css-paged-media"),"css-paint-api":require("./features/css-paint-api"),"css-placeholder-shown":require("./features/css-placeholder-shown"),"css-placeholder":require("./features/css-placeholder"),"css-read-only-write":require("./features/css-read-only-write"),"css-rebeccapurple":require("./features/css-rebeccapurple"),"css-reflections":require("./features/css-reflections"),"css-regions":require("./features/css-regions"),"css-repeating-gradients":require("./features/css-repeating-gradients"),"css-resize":require("./features/css-resize"),"css-revert-value":require("./features/css-revert-value"),"css-rrggbbaa":require("./features/css-rrggbbaa"),"css-scroll-behavior":require("./features/css-scroll-behavior"),"css-scrollbar":require("./features/css-scrollbar"),"css-sel2":require("./features/css-sel2"),"css-sel3":require("./features/css-sel3"),"css-selection":require("./features/css-selection"),"css-shapes":require("./features/css-shapes"),"css-snappoints":require("./features/css-snappoints"),"css-sticky":require("./features/css-sticky"),"css-supports-api":require("./features/css-supports-api"),"css-table":require("./features/css-table"),"css-text-align-last":require("./features/css-text-align-last"),"css-text-indent":require("./features/css-text-indent"),"css-text-justify":require("./features/css-text-justify"),"css-text-orientation":require("./features/css-text-orientation"),"css-text-spacing":require("./features/css-text-spacing"),"css-textshadow":require("./features/css-textshadow"),"css-touch-action-2":require("./features/css-touch-action-2"),"css-touch-action":require("./features/css-touch-action"),"css-transitions":require("./features/css-transitions"),"css-unicode-bidi":require("./features/css-unicode-bidi"),"css-unset-value":require("./features/css-unset-value"),"css-variables":require("./features/css-variables"),"css-widows-orphans":require("./features/css-widows-orphans"),"css-writing-mode":require("./features/css-writing-mode"),"css-zoom":require("./features/css-zoom"),"css3-attr":require("./features/css3-attr"),"css3-boxsizing":require("./features/css3-boxsizing"),"css3-colors":require("./features/css3-colors"),"css3-cursors-grab":require("./features/css3-cursors-grab"),"css3-cursors-newer":require("./features/css3-cursors-newer"),"css3-cursors":require("./features/css3-cursors"),"css3-tabsize":require("./features/css3-tabsize"),"currentcolor":require("./features/currentcolor"),"custom-elements":require("./features/custom-elements"),"custom-elementsv1":require("./features/custom-elementsv1"),"customevent":require("./features/customevent"),"datalist":require("./features/datalist"),"dataset":require("./features/dataset"),"datauri":require("./features/datauri"),"details":require("./features/details"),"deviceorientation":require("./features/deviceorientation"),"devicepixelratio":require("./features/devicepixelratio"),"dialog":require("./features/dialog"),"dispatchevent":require("./features/dispatchevent"),"do-not-track":require("./features/do-not-track"),"document-currentscript":require("./features/document-currentscript"),"document-evaluate-xpath":require("./features/document-evaluate-xpath"),"document-execcommand":require("./features/document-execcommand"),"document-scrollingelement":require("./features/document-scrollingelement"),"documenthead":require("./features/documenthead"),"dom-manip-convenience":require("./features/dom-manip-convenience"),"dom-range":require("./features/dom-range"),"domcontentloaded":require("./features/domcontentloaded"),"domfocusin-domfocusout-events":require("./features/domfocusin-domfocusout-events"),"dommatrix":require("./features/dommatrix"),"download":require("./features/download"),"dragndrop":require("./features/dragndrop"),"element-closest":require("./features/element-closest"),"element-from-point":require("./features/element-from-point"),"eme":require("./features/eme"),"eot":require("./features/eot"),"es5":require("./features/es5"),"es6-class":require("./features/es6-class"),"es6-generators":require("./features/es6-generators"),"es6-module-dynamic-import":require("./features/es6-module-dynamic-import"),"es6-module":require("./features/es6-module"),"es6-number":require("./features/es6-number"),"es6-string-includes":require("./features/es6-string-includes"),"eventsource":require("./features/eventsource"),"feature-policy":require("./features/feature-policy"),"fetch":require("./features/fetch"),"fieldset-disabled":require("./features/fieldset-disabled"),"fileapi":require("./features/fileapi"),"filereader":require("./features/filereader"),"filereadersync":require("./features/filereadersync"),"filesystem":require("./features/filesystem"),"flac":require("./features/flac"),"flexbox":require("./features/flexbox"),"flow-root":require("./features/flow-root"),"focusin-focusout-events":require("./features/focusin-focusout-events"),"focusoptions-preventscroll":require("./features/focusoptions-preventscroll"),"font-family-system-ui":require("./features/font-family-system-ui"),"font-feature":require("./features/font-feature"),"font-kerning":require("./features/font-kerning"),"font-loading":require("./features/font-loading"),"font-size-adjust":require("./features/font-size-adjust"),"font-smooth":require("./features/font-smooth"),"font-unicode-range":require("./features/font-unicode-range"),"font-variant-alternates":require("./features/font-variant-alternates"),"font-variant-east-asian":require("./features/font-variant-east-asian"),"fontface":require("./features/fontface"),"form-attribute":require("./features/form-attribute"),"form-submit-attributes":require("./features/form-submit-attributes"),"form-validation":require("./features/form-validation"),"forms":require("./features/forms"),"fullscreen":require("./features/fullscreen"),"gamepad":require("./features/gamepad"),"geolocation":require("./features/geolocation"),"getboundingclientrect":require("./features/getboundingclientrect"),"getcomputedstyle":require("./features/getcomputedstyle"),"getelementsbyclassname":require("./features/getelementsbyclassname"),"getrandomvalues":require("./features/getrandomvalues"),"gyroscope":require("./features/gyroscope"),"hardwareconcurrency":require("./features/hardwareconcurrency"),"hashchange":require("./features/hashchange"),"heif":require("./features/heif"),"hevc":require("./features/hevc"),"hidden":require("./features/hidden"),"high-resolution-time":require("./features/high-resolution-time"),"history":require("./features/history"),"html-media-capture":require("./features/html-media-capture"),"html5semantic":require("./features/html5semantic"),"http-live-streaming":require("./features/http-live-streaming"),"http2":require("./features/http2"),"iframe-sandbox":require("./features/iframe-sandbox"),"iframe-seamless":require("./features/iframe-seamless"),"iframe-srcdoc":require("./features/iframe-srcdoc"),"imagecapture":require("./features/imagecapture"),"ime":require("./features/ime"),"img-naturalwidth-naturalheight":require("./features/img-naturalwidth-naturalheight"),"imports":require("./features/imports"),"indeterminate-checkbox":require("./features/indeterminate-checkbox"),"indexeddb":require("./features/indexeddb"),"indexeddb2":require("./features/indexeddb2"),"inline-block":require("./features/inline-block"),"innertext":require("./features/innertext"),"input-autocomplete-onoff":require("./features/input-autocomplete-onoff"),"input-color":require("./features/input-color"),"input-datetime":require("./features/input-datetime"),"input-email-tel-url":require("./features/input-email-tel-url"),"input-event":require("./features/input-event"),"input-file-accept":require("./features/input-file-accept"),"input-file-directory":require("./features/input-file-directory"),"input-file-multiple":require("./features/input-file-multiple"),"input-inputmode":require("./features/input-inputmode"),"input-minlength":require("./features/input-minlength"),"input-number":require("./features/input-number"),"input-pattern":require("./features/input-pattern"),"input-placeholder":require("./features/input-placeholder"),"input-range":require("./features/input-range"),"input-search":require("./features/input-search"),"input-selection":require("./features/input-selection"),"insert-adjacent":require("./features/insert-adjacent"),"insertadjacenthtml":require("./features/insertadjacenthtml"),"internationalization-plural-rul":require("./features/internationalization-plural-rul"),"internationalization":require("./features/internationalization"),"intersectionobserver":require("./features/intersectionobserver"),"intrinsic-width":require("./features/intrinsic-width"),"jpeg2000":require("./features/jpeg2000"),"jpegxr":require("./features/jpegxr"),"json":require("./features/json"),"justify-content-space-evenly":require("./features/justify-content-space-evenly"),"kerning-pairs-ligatures":require("./features/kerning-pairs-ligatures"),"keyboardevent-charcode":require("./features/keyboardevent-charcode"),"keyboardevent-code":require("./features/keyboardevent-code"),"keyboardevent-getmodifierstate":require("./features/keyboardevent-getmodifierstate"),"keyboardevent-key":require("./features/keyboardevent-key"),"keyboardevent-location":require("./features/keyboardevent-location"),"keyboardevent-which":require("./features/keyboardevent-which"),"lazyload":require("./features/lazyload"),"let":require("./features/let"),"link-icon-png":require("./features/link-icon-png"),"link-icon-svg":require("./features/link-icon-svg"),"link-rel-dns-prefetch":require("./features/link-rel-dns-prefetch"),"link-rel-preconnect":require("./features/link-rel-preconnect"),"link-rel-prefetch":require("./features/link-rel-prefetch"),"link-rel-preload":require("./features/link-rel-preload"),"link-rel-prerender":require("./features/link-rel-prerender"),"localecompare":require("./features/localecompare"),"magnetometer":require("./features/magnetometer"),"matchesselector":require("./features/matchesselector"),"matchmedia":require("./features/matchmedia"),"mathml":require("./features/mathml"),"maxlength":require("./features/maxlength"),"media-attribute":require("./features/media-attribute"),"media-fragments":require("./features/media-fragments"),"media-session-api":require("./features/media-session-api"),"mediacapture-fromelement":require("./features/mediacapture-fromelement"),"mediarecorder":require("./features/mediarecorder"),"mediasource":require("./features/mediasource"),"menu":require("./features/menu"),"meta-theme-color":require("./features/meta-theme-color"),"meter":require("./features/meter"),"midi":require("./features/midi"),"minmaxwh":require("./features/minmaxwh"),"mp3":require("./features/mp3"),"mpeg-dash":require("./features/mpeg-dash"),"mpeg4":require("./features/mpeg4"),"multibackgrounds":require("./features/multibackgrounds"),"multicolumn":require("./features/multicolumn"),"mutation-events":require("./features/mutation-events"),"mutationobserver":require("./features/mutationobserver"),"namevalue-storage":require("./features/namevalue-storage"),"nav-timing":require("./features/nav-timing"),"navigator-language":require("./features/navigator-language"),"netinfo":require("./features/netinfo"),"node-contains":require("./features/node-contains"),"node-parentelement":require("./features/node-parentelement"),"notifications":require("./features/notifications"),"object-fit":require("./features/object-fit"),"object-observe":require("./features/object-observe"),"object-values":require("./features/object-values"),"objectrtc":require("./features/objectrtc"),"offline-apps":require("./features/offline-apps"),"offscreencanvas":require("./features/offscreencanvas"),"ogg-vorbis":require("./features/ogg-vorbis"),"ogv":require("./features/ogv"),"ol-reversed":require("./features/ol-reversed"),"once-event-listener":require("./features/once-event-listener"),"online-status":require("./features/online-status"),"opus":require("./features/opus"),"orientation-sensor":require("./features/orientation-sensor"),"outline":require("./features/outline"),"pad-start-end":require("./features/pad-start-end"),"page-transition-events":require("./features/page-transition-events"),"pagevisibility":require("./features/pagevisibility"),"passive-event-listener":require("./features/passive-event-listener"),"passwordrules":require("./features/passwordrules"),"path2d":require("./features/path2d"),"payment-request":require("./features/payment-request"),"permissions-api":require("./features/permissions-api"),"picture-in-picture":require("./features/picture-in-picture"),"picture":require("./features/picture"),"ping":require("./features/ping"),"png-alpha":require("./features/png-alpha"),"pointer-events":require("./features/pointer-events"),"pointer":require("./features/pointer"),"pointerlock":require("./features/pointerlock"),"prefers-color-scheme":require("./features/prefers-color-scheme"),"prefers-reduced-motion":require("./features/prefers-reduced-motion"),"progress":require("./features/progress"),"promise-finally":require("./features/promise-finally"),"promises":require("./features/promises"),"proximity":require("./features/proximity"),"proxy":require("./features/proxy"),"publickeypinning":require("./features/publickeypinning"),"push-api":require("./features/push-api"),"queryselector":require("./features/queryselector"),"readonly-attr":require("./features/readonly-attr"),"referrer-policy":require("./features/referrer-policy"),"registerprotocolhandler":require("./features/registerprotocolhandler"),"rel-noopener":require("./features/rel-noopener"),"rel-noreferrer":require("./features/rel-noreferrer"),"rellist":require("./features/rellist"),"rem":require("./features/rem"),"requestanimationframe":require("./features/requestanimationframe"),"requestidlecallback":require("./features/requestidlecallback"),"resizeobserver":require("./features/resizeobserver"),"resource-timing":require("./features/resource-timing"),"rest-parameters":require("./features/rest-parameters"),"rtcpeerconnection":require("./features/rtcpeerconnection"),"ruby":require("./features/ruby"),"run-in":require("./features/run-in"),"same-site-cookie-attribute":require("./features/same-site-cookie-attribute"),"screen-orientation":require("./features/screen-orientation"),"script-async":require("./features/script-async"),"script-defer":require("./features/script-defer"),"scrollintoview":require("./features/scrollintoview"),"scrollintoviewifneeded":require("./features/scrollintoviewifneeded"),"sdch":require("./features/sdch"),"selection-api":require("./features/selection-api"),"server-timing":require("./features/server-timing"),"serviceworkers":require("./features/serviceworkers"),"setimmediate":require("./features/setimmediate"),"sha-2":require("./features/sha-2"),"shadowdom":require("./features/shadowdom"),"shadowdomv1":require("./features/shadowdomv1"),"sharedarraybuffer":require("./features/sharedarraybuffer"),"sharedworkers":require("./features/sharedworkers"),"sni":require("./features/sni"),"spdy":require("./features/spdy"),"speech-recognition":require("./features/speech-recognition"),"speech-synthesis":require("./features/speech-synthesis"),"spellcheck-attribute":require("./features/spellcheck-attribute"),"sql-storage":require("./features/sql-storage"),"srcset":require("./features/srcset"),"stopimmediatepropagation":require("./features/stopimmediatepropagation"),"stream":require("./features/stream"),"streams":require("./features/streams"),"stricttransportsecurity":require("./features/stricttransportsecurity"),"style-scoped":require("./features/style-scoped"),"subresource-integrity":require("./features/subresource-integrity"),"svg-css":require("./features/svg-css"),"svg-filters":require("./features/svg-filters"),"svg-fonts":require("./features/svg-fonts"),"svg-fragment":require("./features/svg-fragment"),"svg-html":require("./features/svg-html"),"svg-html5":require("./features/svg-html5"),"svg-img":require("./features/svg-img"),"svg-smil":require("./features/svg-smil"),"svg":require("./features/svg"),"symbols":require("./features/symbols"),"tabindex-attr":require("./features/tabindex-attr"),"template-literals":require("./features/template-literals"),"template":require("./features/template"),"testfeat":require("./features/testfeat"),"text-decoration":require("./features/text-decoration"),"text-emphasis":require("./features/text-emphasis"),"text-overflow":require("./features/text-overflow"),"text-size-adjust":require("./features/text-size-adjust"),"text-stroke":require("./features/text-stroke"),"textcontent":require("./features/textcontent"),"textencoder":require("./features/textencoder"),"tls1-1":require("./features/tls1-1"),"tls1-2":require("./features/tls1-2"),"tls1-3":require("./features/tls1-3"),"token-binding":require("./features/token-binding"),"touch":require("./features/touch"),"transforms2d":require("./features/transforms2d"),"transforms3d":require("./features/transforms3d"),"ttf":require("./features/ttf"),"typedarrays":require("./features/typedarrays"),"u2f":require("./features/u2f"),"unhandledrejection":require("./features/unhandledrejection"),"upgradeinsecurerequests":require("./features/upgradeinsecurerequests"),"url":require("./features/url"),"urlsearchparams":require("./features/urlsearchparams"),"use-strict":require("./features/use-strict"),"user-select-none":require("./features/user-select-none"),"user-timing":require("./features/user-timing"),"variable-fonts":require("./features/variable-fonts"),"vibration":require("./features/vibration"),"video":require("./features/video"),"videotracks":require("./features/videotracks"),"viewport-units":require("./features/viewport-units"),"wai-aria":require("./features/wai-aria"),"wasm":require("./features/wasm"),"wav":require("./features/wav"),"wbr-element":require("./features/wbr-element"),"web-animation":require("./features/web-animation"),"web-app-manifest":require("./features/web-app-manifest"),"web-bluetooth":require("./features/web-bluetooth"),"web-share":require("./features/web-share"),"webauthn":require("./features/webauthn"),"webgl":require("./features/webgl"),"webgl2":require("./features/webgl2"),"webm":require("./features/webm"),"webp":require("./features/webp"),"websockets":require("./features/websockets"),"webusb":require("./features/webusb"),"webvr":require("./features/webvr"),"webvtt":require("./features/webvtt"),"webworkers":require("./features/webworkers"),"will-change":require("./features/will-change"),"woff":require("./features/woff"),"woff2":require("./features/woff2"),"word-break":require("./features/word-break"),"wordwrap":require("./features/wordwrap"),"x-doc-messaging":require("./features/x-doc-messaging"),"x-frame-options":require("./features/x-frame-options"),"xhr2":require("./features/xhr2"),"xhtml":require("./features/xhtml"),"xhtmlsmil":require("./features/xhtmlsmil"),"xml-serializer":require("./features/xml-serializer")};

},{"./features/aac":23,"./features/abortcontroller":24,"./features/ac3-ec3":25,"./features/accelerometer":26,"./features/addeventlistener":27,"./features/alternate-stylesheet":28,"./features/ambient-light":29,"./features/apng":30,"./features/array-find":32,"./features/array-find-index":31,"./features/array-flat":33,"./features/array-includes":34,"./features/arrow-functions":35,"./features/asmjs":36,"./features/async-clipboard":37,"./features/async-functions":38,"./features/async-iterations-and-generators":39,"./features/atob-btoa":40,"./features/audio":42,"./features/audio-api":41,"./features/audiotracks":43,"./features/autofocus":44,"./features/auxclick":45,"./features/av1":46,"./features/background-attachment":47,"./features/background-clip-text":48,"./features/background-img-opts":49,"./features/background-position-x-y":50,"./features/background-repeat-round-space":51,"./features/background-sync":52,"./features/battery-status":53,"./features/beacon":54,"./features/beforeafterprint":55,"./features/bigint":56,"./features/blobbuilder":57,"./features/bloburls":58,"./features/border-image":59,"./features/border-radius":60,"./features/broadcastchannel":61,"./features/brotli":62,"./features/calc":63,"./features/canvas":66,"./features/canvas-blending":64,"./features/canvas-text":65,"./features/ch-unit":67,"./features/chacha20-poly1305":68,"./features/channel-messaging":69,"./features/childnode-remove":70,"./features/classlist":71,"./features/clear-site-data-header":72,"./features/client-hints-dpr-width-viewport":73,"./features/clipboard":74,"./features/comparedocumentposition":75,"./features/console-basic":76,"./features/console-time":77,"./features/const":78,"./features/constraint-validation":79,"./features/contenteditable":80,"./features/contentsecuritypolicy":81,"./features/contentsecuritypolicy2":82,"./features/cors":83,"./features/createimagebitmap":84,"./features/credential-management":85,"./features/cryptography":86,"./features/css-all":87,"./features/css-animation":88,"./features/css-any-link":89,"./features/css-appearance":90,"./features/css-apply-rule":91,"./features/css-at-counter-style":92,"./features/css-backdrop-filter":93,"./features/css-background-offsets":94,"./features/css-backgroundblendmode":95,"./features/css-boxdecorationbreak":96,"./features/css-boxshadow":97,"./features/css-canvas":98,"./features/css-caret-color":99,"./features/css-case-insensitive":100,"./features/css-clip-path":101,"./features/css-color-adjust":102,"./features/css-conic-gradients":103,"./features/css-containment":104,"./features/css-counters":105,"./features/css-crisp-edges":106,"./features/css-cross-fade":107,"./features/css-default-pseudo":108,"./features/css-descendant-gtgt":109,"./features/css-deviceadaptation":110,"./features/css-dir-pseudo":111,"./features/css-display-contents":112,"./features/css-element-function":113,"./features/css-env-function":114,"./features/css-exclusions":115,"./features/css-featurequeries":116,"./features/css-filter-function":117,"./features/css-filters":118,"./features/css-first-letter":119,"./features/css-first-line":120,"./features/css-fixed":121,"./features/css-focus-visible":122,"./features/css-focus-within":123,"./features/css-font-rendering-controls":124,"./features/css-font-stretch":125,"./features/css-gencontent":126,"./features/css-gradients":127,"./features/css-grid":128,"./features/css-hanging-punctuation":129,"./features/css-has":130,"./features/css-hyphenate":131,"./features/css-hyphens":132,"./features/css-image-orientation":133,"./features/css-image-set":134,"./features/css-in-out-of-range":135,"./features/css-indeterminate-pseudo":136,"./features/css-initial-letter":137,"./features/css-initial-value":138,"./features/css-letter-spacing":139,"./features/css-line-clamp":140,"./features/css-logical-props":141,"./features/css-marker-pseudo":142,"./features/css-masks":143,"./features/css-matches-pseudo":144,"./features/css-math-functions":145,"./features/css-media-interaction":146,"./features/css-media-resolution":147,"./features/css-media-scripting":148,"./features/css-mediaqueries":149,"./features/css-mixblendmode":150,"./features/css-motion-paths":151,"./features/css-namespaces":152,"./features/css-not-sel-list":153,"./features/css-nth-child-of":154,"./features/css-opacity":155,"./features/css-optional-pseudo":156,"./features/css-overflow":158,"./features/css-overflow-anchor":157,"./features/css-overscroll-behavior":159,"./features/css-page-break":160,"./features/css-paged-media":161,"./features/css-paint-api":162,"./features/css-placeholder":164,"./features/css-placeholder-shown":163,"./features/css-read-only-write":165,"./features/css-rebeccapurple":166,"./features/css-reflections":167,"./features/css-regions":168,"./features/css-repeating-gradients":169,"./features/css-resize":170,"./features/css-revert-value":171,"./features/css-rrggbbaa":172,"./features/css-scroll-behavior":173,"./features/css-scrollbar":174,"./features/css-sel2":175,"./features/css-sel3":176,"./features/css-selection":177,"./features/css-shapes":178,"./features/css-snappoints":179,"./features/css-sticky":180,"./features/css-supports-api":181,"./features/css-table":182,"./features/css-text-align-last":183,"./features/css-text-indent":184,"./features/css-text-justify":185,"./features/css-text-orientation":186,"./features/css-text-spacing":187,"./features/css-textshadow":188,"./features/css-touch-action":190,"./features/css-touch-action-2":189,"./features/css-transitions":191,"./features/css-unicode-bidi":192,"./features/css-unset-value":193,"./features/css-variables":194,"./features/css-widows-orphans":195,"./features/css-writing-mode":196,"./features/css-zoom":197,"./features/css3-attr":198,"./features/css3-boxsizing":199,"./features/css3-colors":200,"./features/css3-cursors":203,"./features/css3-cursors-grab":201,"./features/css3-cursors-newer":202,"./features/css3-tabsize":204,"./features/currentcolor":205,"./features/custom-elements":206,"./features/custom-elementsv1":207,"./features/customevent":208,"./features/datalist":209,"./features/dataset":210,"./features/datauri":211,"./features/details":212,"./features/deviceorientation":213,"./features/devicepixelratio":214,"./features/dialog":215,"./features/dispatchevent":216,"./features/do-not-track":217,"./features/document-currentscript":218,"./features/document-evaluate-xpath":219,"./features/document-execcommand":220,"./features/document-scrollingelement":221,"./features/documenthead":222,"./features/dom-manip-convenience":223,"./features/dom-range":224,"./features/domcontentloaded":225,"./features/domfocusin-domfocusout-events":226,"./features/dommatrix":227,"./features/download":228,"./features/dragndrop":229,"./features/element-closest":230,"./features/element-from-point":231,"./features/eme":232,"./features/eot":233,"./features/es5":234,"./features/es6-class":235,"./features/es6-generators":236,"./features/es6-module":238,"./features/es6-module-dynamic-import":237,"./features/es6-number":239,"./features/es6-string-includes":240,"./features/eventsource":241,"./features/feature-policy":242,"./features/fetch":243,"./features/fieldset-disabled":244,"./features/fileapi":245,"./features/filereader":246,"./features/filereadersync":247,"./features/filesystem":248,"./features/flac":249,"./features/flexbox":250,"./features/flow-root":251,"./features/focusin-focusout-events":252,"./features/focusoptions-preventscroll":253,"./features/font-family-system-ui":254,"./features/font-feature":255,"./features/font-kerning":256,"./features/font-loading":257,"./features/font-size-adjust":258,"./features/font-smooth":259,"./features/font-unicode-range":260,"./features/font-variant-alternates":261,"./features/font-variant-east-asian":262,"./features/fontface":263,"./features/form-attribute":264,"./features/form-submit-attributes":265,"./features/form-validation":266,"./features/forms":267,"./features/fullscreen":268,"./features/gamepad":269,"./features/geolocation":270,"./features/getboundingclientrect":271,"./features/getcomputedstyle":272,"./features/getelementsbyclassname":273,"./features/getrandomvalues":274,"./features/gyroscope":275,"./features/hardwareconcurrency":276,"./features/hashchange":277,"./features/heif":278,"./features/hevc":279,"./features/hidden":280,"./features/high-resolution-time":281,"./features/history":282,"./features/html-media-capture":283,"./features/html5semantic":284,"./features/http-live-streaming":285,"./features/http2":286,"./features/iframe-sandbox":287,"./features/iframe-seamless":288,"./features/iframe-srcdoc":289,"./features/imagecapture":290,"./features/ime":291,"./features/img-naturalwidth-naturalheight":292,"./features/imports":293,"./features/indeterminate-checkbox":294,"./features/indexeddb":295,"./features/indexeddb2":296,"./features/inline-block":297,"./features/innertext":298,"./features/input-autocomplete-onoff":299,"./features/input-color":300,"./features/input-datetime":301,"./features/input-email-tel-url":302,"./features/input-event":303,"./features/input-file-accept":304,"./features/input-file-directory":305,"./features/input-file-multiple":306,"./features/input-inputmode":307,"./features/input-minlength":308,"./features/input-number":309,"./features/input-pattern":310,"./features/input-placeholder":311,"./features/input-range":312,"./features/input-search":313,"./features/input-selection":314,"./features/insert-adjacent":315,"./features/insertadjacenthtml":316,"./features/internationalization":318,"./features/internationalization-plural-rul":317,"./features/intersectionobserver":319,"./features/intrinsic-width":320,"./features/jpeg2000":321,"./features/jpegxr":322,"./features/json":323,"./features/justify-content-space-evenly":324,"./features/kerning-pairs-ligatures":325,"./features/keyboardevent-charcode":326,"./features/keyboardevent-code":327,"./features/keyboardevent-getmodifierstate":328,"./features/keyboardevent-key":329,"./features/keyboardevent-location":330,"./features/keyboardevent-which":331,"./features/lazyload":332,"./features/let":333,"./features/link-icon-png":334,"./features/link-icon-svg":335,"./features/link-rel-dns-prefetch":336,"./features/link-rel-preconnect":337,"./features/link-rel-prefetch":338,"./features/link-rel-preload":339,"./features/link-rel-prerender":340,"./features/localecompare":341,"./features/magnetometer":342,"./features/matchesselector":343,"./features/matchmedia":344,"./features/mathml":345,"./features/maxlength":346,"./features/media-attribute":347,"./features/media-fragments":348,"./features/media-session-api":349,"./features/mediacapture-fromelement":350,"./features/mediarecorder":351,"./features/mediasource":352,"./features/menu":353,"./features/meta-theme-color":354,"./features/meter":355,"./features/midi":356,"./features/minmaxwh":357,"./features/mp3":358,"./features/mpeg-dash":359,"./features/mpeg4":360,"./features/multibackgrounds":361,"./features/multicolumn":362,"./features/mutation-events":363,"./features/mutationobserver":364,"./features/namevalue-storage":365,"./features/nav-timing":366,"./features/navigator-language":367,"./features/netinfo":368,"./features/node-contains":369,"./features/node-parentelement":370,"./features/notifications":371,"./features/object-fit":372,"./features/object-observe":373,"./features/object-values":374,"./features/objectrtc":375,"./features/offline-apps":376,"./features/offscreencanvas":377,"./features/ogg-vorbis":378,"./features/ogv":379,"./features/ol-reversed":380,"./features/once-event-listener":381,"./features/online-status":382,"./features/opus":383,"./features/orientation-sensor":384,"./features/outline":385,"./features/pad-start-end":386,"./features/page-transition-events":387,"./features/pagevisibility":388,"./features/passive-event-listener":389,"./features/passwordrules":390,"./features/path2d":391,"./features/payment-request":392,"./features/permissions-api":393,"./features/picture":395,"./features/picture-in-picture":394,"./features/ping":396,"./features/png-alpha":397,"./features/pointer":399,"./features/pointer-events":398,"./features/pointerlock":400,"./features/prefers-color-scheme":401,"./features/prefers-reduced-motion":402,"./features/progress":403,"./features/promise-finally":404,"./features/promises":405,"./features/proximity":406,"./features/proxy":407,"./features/publickeypinning":408,"./features/push-api":409,"./features/queryselector":410,"./features/readonly-attr":411,"./features/referrer-policy":412,"./features/registerprotocolhandler":413,"./features/rel-noopener":414,"./features/rel-noreferrer":415,"./features/rellist":416,"./features/rem":417,"./features/requestanimationframe":418,"./features/requestidlecallback":419,"./features/resizeobserver":420,"./features/resource-timing":421,"./features/rest-parameters":422,"./features/rtcpeerconnection":423,"./features/ruby":424,"./features/run-in":425,"./features/same-site-cookie-attribute":426,"./features/screen-orientation":427,"./features/script-async":428,"./features/script-defer":429,"./features/scrollintoview":430,"./features/scrollintoviewifneeded":431,"./features/sdch":432,"./features/selection-api":433,"./features/server-timing":434,"./features/serviceworkers":435,"./features/setimmediate":436,"./features/sha-2":437,"./features/shadowdom":438,"./features/shadowdomv1":439,"./features/sharedarraybuffer":440,"./features/sharedworkers":441,"./features/sni":442,"./features/spdy":443,"./features/speech-recognition":444,"./features/speech-synthesis":445,"./features/spellcheck-attribute":446,"./features/sql-storage":447,"./features/srcset":448,"./features/stopimmediatepropagation":449,"./features/stream":450,"./features/streams":451,"./features/stricttransportsecurity":452,"./features/style-scoped":453,"./features/subresource-integrity":454,"./features/svg":463,"./features/svg-css":455,"./features/svg-filters":456,"./features/svg-fonts":457,"./features/svg-fragment":458,"./features/svg-html":459,"./features/svg-html5":460,"./features/svg-img":461,"./features/svg-smil":462,"./features/symbols":464,"./features/tabindex-attr":465,"./features/template":467,"./features/template-literals":466,"./features/testfeat":468,"./features/text-decoration":469,"./features/text-emphasis":470,"./features/text-overflow":471,"./features/text-size-adjust":472,"./features/text-stroke":473,"./features/textcontent":474,"./features/textencoder":475,"./features/tls1-1":476,"./features/tls1-2":477,"./features/tls1-3":478,"./features/token-binding":479,"./features/touch":480,"./features/transforms2d":481,"./features/transforms3d":482,"./features/ttf":483,"./features/typedarrays":484,"./features/u2f":485,"./features/unhandledrejection":486,"./features/upgradeinsecurerequests":487,"./features/url":488,"./features/urlsearchparams":489,"./features/use-strict":490,"./features/user-select-none":491,"./features/user-timing":492,"./features/variable-fonts":493,"./features/vibration":494,"./features/video":495,"./features/videotracks":496,"./features/viewport-units":497,"./features/wai-aria":498,"./features/wasm":499,"./features/wav":500,"./features/wbr-element":501,"./features/web-animation":502,"./features/web-app-manifest":503,"./features/web-bluetooth":504,"./features/web-share":505,"./features/webauthn":506,"./features/webgl":507,"./features/webgl2":508,"./features/webm":509,"./features/webp":510,"./features/websockets":511,"./features/webusb":512,"./features/webvr":513,"./features/webvtt":514,"./features/webworkers":515,"./features/will-change":516,"./features/woff":517,"./features/woff2":518,"./features/word-break":519,"./features/wordwrap":520,"./features/x-doc-messaging":521,"./features/x-frame-options":522,"./features/xhr2":523,"./features/xhtml":524,"./features/xhtmlsmil":525,"./features/xml-serializer":526}],23:[function(require,module,exports){
module.exports={A:{A:{"1":"E A B","2":"K D G gB"},B:{"1":"2 C d J M H I"},C:{"2":"2 dB BB F N K D G E A B C d J M H I O P Q XB WB","132":"0 1 3 4 6 7 9 R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB"},D:{"1":"0 1 2 3 4 6 7 9 C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"F N K D G E","16":"A B"},E:{"1":"5 F N K D G E A B C RB SB TB UB VB p YB","2":"PB HB"},F:{"1":"0 1 6 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"5 8 E B C ZB aB bB cB p eB"},G:{"1":"G fB EB hB JB jB kB lB mB nB oB pB qB rB sB","16":"HB"},H:{"2":"tB"},I:{"1":"4 BB F xB EB yB zB","2":"uB vB wB"},J:{"1":"A","2":"D"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"132":"3"},N:{"1":"A","2":"B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:6,C:"AAC audio file format"};

},{}],24:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"1":"M H I","2":"2 C d J"},C:{"1":"0 1 3 4 7 9 GB FB AB CB DB","2":"2 6 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z XB WB"},D:{"1":"4 DB QB iB KB IB LB MB NB OB","2":"0 1 2 3 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB"},E:{"1":"5 YB","2":"F N K D G E A B PB HB RB SB TB UB VB","130":"C p"},F:{"1":"0 1 w x y z","2":"5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v ZB aB bB cB p eB"},G:{"1":"qB rB sB","2":"G HB fB EB hB JB jB kB lB mB nB oB pB"},H:{"2":"tB"},I:{"1":"4","2":"BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"2":"5 8 A B C L p"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"2":"0B"},P:{"2":"F 1B 2B 3B 4B"},Q:{"2":"5B"},R:{"2":"6B"}},B:1,C:"AbortController & AbortSignal"};

},{}],25:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"1":"2 C d J M H I"},C:{"2":"0 1 2 3 4 6 7 9 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB"},D:{"2":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"2":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"2":"0 1 5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z ZB aB bB cB p eB"},G:{"2":"G HB fB EB hB JB jB kB","132":"lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"2":"4 BB F uB vB wB xB EB yB zB"},J:{"2":"D","132":"A"},K:{"2":"8 A B C L p","132":"5"},L:{"2":"IB"},M:{"2":"3"},N:{"2":"A B"},O:{"132":"0B"},P:{"2":"F 1B 2B 3B 4B"},Q:{"2":"5B"},R:{"2":"6B"}},B:6,C:"AC-3 (Dolby Digital) and EC-3 (Dolby Digital Plus) codecs"};

},{}],26:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"2":"0 1 2 3 4 6 7 9 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB"},D:{"1":"4 QB iB KB IB LB MB NB OB","2":"0 2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","194":"1 3 7 9 GB FB AB CB DB"},E:{"2":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"1":"0 1 x y z","2":"5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w ZB aB bB cB p eB"},G:{"2":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"1":"4","2":"BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"2":"5 8 A B C L p"},L:{"1":"IB"},M:{"2":"3"},N:{"2":"A B"},O:{"2":"0B"},P:{"2":"F 1B 2B 3B 4B"},Q:{"2":"5B"},R:{"2":"6B"}},B:4,C:"Accelerometer"};

},{}],27:[function(require,module,exports){
module.exports={A:{A:{"1":"E A B","130":"K D G gB"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 2 3 4 6 7 9 D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","257":"dB BB F N K XB WB"},D:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"1":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"1":"0 1 5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z ZB aB bB cB p eB"},G:{"1":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"1":"tB"},I:{"1":"4 BB F uB vB wB xB EB yB zB"},J:{"1":"D A"},K:{"1":"5 8 A B C L p"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:1,C:"EventTarget.addEventListener()"};

},{}],28:[function(require,module,exports){
module.exports={A:{A:{"1":"G E A B","2":"K D gB"},B:{"2":"2 C d J M H I"},C:{"1":"0 1 2 3 4 6 7 9 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB"},D:{"2":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"2":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"1":"5 8 E B C ZB aB bB cB p eB","16":"0 1 6 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z"},G:{"2":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"16":"tB"},I:{"2":"4 BB F uB vB wB xB EB yB zB"},J:{"16":"D A"},K:{"16":"5 8 A B C L p"},L:{"16":"IB"},M:{"16":"3"},N:{"16":"A B"},O:{"16":"0B"},P:{"16":"F 1B 2B 3B 4B"},Q:{"2":"5B"},R:{"16":"6B"}},B:1,C:"Alternate stylesheet"};

},{}],29:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C","132":"d J M H I"},C:{"2":"2 dB BB F N K D G E A B C d J M H I O P Q XB WB","132":"0 1 6 R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB","194":"3 4 7 9 FB AB CB DB"},D:{"2":"0 2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","322":"1 3 4 7 9 GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"2":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"2":"0 1 5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z ZB aB bB cB p eB"},G:{"2":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"2":"4 BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"2":"5 8 A B C L p"},L:{"2":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"2":"0B"},P:{"2":"F 1B 2B 3B 4B"},Q:{"2":"5B"},R:{"2":"6B"}},B:4,C:"Ambient Light Sensor"};

},{}],30:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"1":"0 1 2 3 4 6 7 9 BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB","2":"dB"},D:{"1":"3 4 7 9 GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"0 1 2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z"},E:{"1":"5 G E A B C UB VB p YB","2":"F N K D PB HB RB SB TB"},F:{"1":"0 1 5 8 B C L q r s t u v w x y z ZB aB bB cB p eB","2":"6 E J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o"},G:{"1":"G kB lB mB nB oB pB qB rB sB","2":"HB fB EB hB JB jB"},H:{"2":"tB"},I:{"2":"4 BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"1":"5 8 A B C L p"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"2":"0B"},P:{"1":"3B 4B","2":"F 1B 2B"},Q:{"2":"5B"},R:{"2":"6B"}},B:7,C:"Animated PNG (APNG)"};

},{}],31:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"1":"J M H I","16":"2 C d"},C:{"1":"0 1 3 4 6 7 9 U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"2 dB BB F N K D G E A B C d J M H I O P Q R S T XB WB"},D:{"1":"0 1 3 4 7 9 o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n"},E:{"1":"5 G E A B C TB UB VB p YB","2":"F N K D PB HB RB SB"},F:{"1":"0 1 6 b c e f g h i j k l m n o L q r s t u v w x y z","2":"5 8 E B C J M H I O P Q R S T U V W X Y Z a ZB aB bB cB p eB"},G:{"1":"G kB lB mB nB oB pB qB rB sB","2":"HB fB EB hB JB jB"},H:{"2":"tB"},I:{"1":"4","2":"BB F uB vB wB xB EB yB zB"},J:{"2":"D","16":"A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"1":"0B"},P:{"1":"1B 2B 3B 4B","2":"F"},Q:{"1":"5B"},R:{"1":"6B"}},B:6,C:"Array.prototype.findIndex"};

},{}],32:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"1":"J M H I","16":"2 C d"},C:{"1":"0 1 3 4 6 7 9 U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"2 dB BB F N K D G E A B C d J M H I O P Q R S T XB WB"},D:{"1":"0 1 3 4 7 9 o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n"},E:{"1":"5 G E A B C TB UB VB p YB","2":"F N K D PB HB RB SB"},F:{"1":"0 1 6 b c e f g h i j k l m n o L q r s t u v w x y z","2":"5 8 E B C J M H I O P Q R S T U V W X Y Z a ZB aB bB cB p eB"},G:{"1":"G kB lB mB nB oB pB qB rB sB","2":"HB fB EB hB JB jB"},H:{"2":"tB"},I:{"1":"4","2":"BB F uB vB wB xB EB yB zB"},J:{"2":"D","16":"A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"1":"0B"},P:{"1":"1B 2B 3B 4B","2":"F"},Q:{"1":"5B"},R:{"1":"6B"}},B:6,C:"Array.prototype.find"};

},{}],33:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"1":"3 4 9 AB CB DB","2":"0 1 2 6 7 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB XB WB"},D:{"1":"iB KB IB LB MB NB OB","2":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB"},E:{"1":"5 C YB","2":"F N K D G E A B PB HB RB SB TB UB VB p"},F:{"1":"0 1 z","2":"5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y ZB aB bB cB p eB"},G:{"1":"rB sB","2":"G HB fB EB hB JB jB kB lB mB nB oB pB qB"},H:{"2":"tB"},I:{"2":"4 BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"2":"0B"},P:{"2":"F 1B 2B 3B 4B"},Q:{"2":"5B"},R:{"2":"6B"}},B:7,C:"flat & flatMap array methods"};

},{}],34:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"1":"d J M H I","2":"2 C"},C:{"1":"0 1 3 4 7 9 m n o L q r s t u v w x y z GB FB AB CB DB","2":"2 6 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l XB WB"},D:{"1":"0 1 3 4 7 9 q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L"},E:{"1":"5 E A B C UB VB p YB","2":"F N K D G PB HB RB SB TB"},F:{"1":"0 1 6 e f g h i j k l m n o L q r s t u v w x y z","2":"5 8 E B C J M H I O P Q R S T U V W X Y Z a b c ZB aB bB cB p eB"},G:{"1":"lB mB nB oB pB qB rB sB","2":"G HB fB EB hB JB jB kB"},H:{"2":"tB"},I:{"1":"4","2":"BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"1":"0B"},P:{"1":"1B 2B 3B 4B","2":"F"},Q:{"1":"5B"},R:{"1":"6B"}},B:6,C:"Array.prototype.includes"};

},{}],35:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 3 4 6 7 9 R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"2 dB BB F N K D G E A B C d J M H I O P Q XB WB"},D:{"1":"0 1 3 4 7 9 o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n"},E:{"1":"5 A B C VB p YB","2":"F N K D G E PB HB RB SB TB UB"},F:{"1":"0 1 6 b c e f g h i j k l m n o L q r s t u v w x y z","2":"5 8 E B C J M H I O P Q R S T U V W X Y Z a ZB aB bB cB p eB"},G:{"1":"nB oB pB qB rB sB","2":"G HB fB EB hB JB jB kB lB mB"},H:{"2":"tB"},I:{"1":"4","2":"BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"1":"0B"},P:{"1":"1B 2B 3B 4B","2":"F"},Q:{"2":"5B"},R:{"1":"6B"}},B:6,C:"Arrow functions"};

},{}],36:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"1":"2 d J M H I","322":"C"},C:{"1":"0 1 3 4 6 7 9 R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"2 dB BB F N K D G E A B C d J M H I O P Q XB WB"},D:{"2":"2 F N K D G E A B C d J M H I O P Q R S T U V W","132":"0 1 3 4 6 7 9 X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"2":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"2":"5 8 E B C ZB aB bB cB p eB","132":"0 1 6 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z"},G:{"2":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"2":"BB F uB vB wB xB EB yB zB","132":"4"},J:{"2":"D A"},K:{"2":"5 8 A B C p","132":"L"},L:{"132":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"2":"0B"},P:{"2":"F","132":"1B 2B 3B 4B"},Q:{"132":"5B"},R:{"132":"6B"}},B:6,C:"asm.js"};

},{}],37:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"2":"0 1 2 3 4 6 7 9 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB"},D:{"1":"3 4 9 AB CB DB QB iB KB IB LB MB NB OB","2":"0 2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","66":"1 7 GB FB"},E:{"2":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"2":"5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q ZB aB bB cB p eB","16":"0 1 r s t u v w x y z"},G:{"2":"G fB EB hB JB jB kB lB mB nB oB pB qB rB sB","16":"HB"},H:{"2":"tB"},I:{"2":"4 BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"2":"5 8 A B C L p"},L:{"2":"IB"},M:{"2":"3"},N:{"2":"A B"},O:{"2":"0B"},P:{"2":"F 1B 2B 3B 4B"},Q:{"2":"5B"},R:{"2":"6B"}},B:5,C:"Asynchronous Clipboard API"};

},{}],38:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"1":"J M H I","2":"2 C","194":"d"},C:{"1":"0 1 3 4 7 9 v w x y z GB FB AB CB DB","2":"2 6 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u XB WB"},D:{"1":"0 1 3 4 7 9 y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x"},E:{"1":"5 B C VB p YB","2":"F N K D G E A PB HB RB SB TB UB"},F:{"1":"0 1 l m n o L q r s t u v w x y z","2":"5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k ZB aB bB cB p eB"},G:{"1":"oB pB qB rB sB","2":"G HB fB EB hB JB jB kB lB mB nB"},H:{"2":"tB"},I:{"1":"4","2":"BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"1":"0B"},P:{"1":"2B 3B 4B","2":"F 1B"},Q:{"2":"5B"},R:{"2":"6B"}},B:6,C:"Async functions"};

},{}],39:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"1":"0 1 3 4 7 9 GB FB AB CB DB","2":"2 6 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z XB WB"},D:{"1":"3 4 AB CB DB QB iB KB IB LB MB NB OB","2":"0 1 2 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB"},E:{"1":"5 C YB","2":"F N K D G E A B PB HB RB SB TB UB VB p"},F:{"1":"0 1 t u v w x y z","2":"5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s ZB aB bB cB p eB"},G:{"2":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"2":"4 BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"2":"5 8 A B C L p"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"2":"0B"},P:{"2":"F 1B 2B 3B 4B"},Q:{"2":"5B"},R:{"2":"6B"}},B:6,C:"Async iterators and generators"};

},{}],40:[function(require,module,exports){
module.exports={A:{A:{"1":"A B","2":"K D G E gB"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 2 3 4 6 7 9 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB"},D:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"1":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"1":"0 1 5 6 8 B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z cB p eB","2":"E ZB aB","16":"bB"},G:{"1":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"1":"tB"},I:{"1":"4 BB F uB vB wB xB EB yB zB"},J:{"1":"D A"},K:{"1":"5 8 B C L p","16":"A"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:1,C:"Base64 encoding and decoding"};

},{}],41:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 3 4 6 7 9 U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"2 dB BB F N K D G E A B C d J M H I O P Q R S T XB WB"},D:{"1":"0 1 3 4 6 7 9 e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"F N K D G E","33":"2 A B C d J M H I O P Q R S T U V W X Y Z a b c"},E:{"2":"F N PB HB RB","33":"5 K D G E A B C SB TB UB VB p YB"},F:{"1":"0 1 6 R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"5 8 E B C ZB aB bB cB p eB","33":"J M H I O P Q"},G:{"2":"HB fB EB hB","33":"G JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"1":"4","2":"BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:5,C:"Web Audio API"};

},{}],42:[function(require,module,exports){
module.exports={A:{A:{"1":"E A B","2":"K D G gB"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 3 4 6 7 9 P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"dB BB","132":"2 F N K D G E A B C d J M H I O XB WB"},D:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"1":"5 F N K D G E A B C RB SB TB UB VB p YB","2":"PB HB"},F:{"1":"0 1 5 6 8 B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z bB cB p eB","2":"E","4":"ZB aB"},G:{"1":"G fB EB hB JB jB kB lB mB nB oB pB qB rB sB","2":"HB"},H:{"2":"tB"},I:{"1":"4 BB F wB xB EB yB zB","2":"uB vB"},J:{"1":"D A"},K:{"1":"5 8 B C L p","2":"A"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:1,C:"Audio element"};

},{}],43:[function(require,module,exports){
module.exports={A:{A:{"1":"A B","2":"K D G E gB"},B:{"1":"2 C d J M H I"},C:{"2":"2 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b XB WB","194":"0 1 3 4 6 7 9 c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB"},D:{"2":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n","322":"0 1 3 4 7 9 o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"1":"5 D G E A B C SB TB UB VB p YB","2":"F N K PB HB RB"},F:{"2":"5 8 E B C J M H I O P Q R S T U V W X Y Z a ZB aB bB cB p eB","322":"0 1 6 b c e f g h i j k l m n o L q r s t u v w x y z"},G:{"1":"G jB kB lB mB nB oB pB qB rB sB","2":"HB fB EB hB JB"},H:{"2":"tB"},I:{"2":"4 BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"2":"5 8 A B C p","322":"L"},L:{"322":"IB"},M:{"2":"3"},N:{"1":"A B"},O:{"2":"0B"},P:{"2":"F 1B 2B 3B 4B"},Q:{"2":"5B"},R:{"2":"6B"}},B:1,C:"Audio Tracks"};

},{}],44:[function(require,module,exports){
module.exports={A:{A:{"1":"A B","2":"K D G E gB"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"dB BB XB WB"},D:{"1":"0 1 2 3 4 6 7 9 N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"F"},E:{"1":"5 N K D G E A B C RB SB TB UB VB p YB","2":"F PB HB"},F:{"1":"0 1 5 6 8 B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z ZB aB bB cB p eB","2":"E"},G:{"2":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"1":"4 BB F xB EB yB zB","2":"uB vB wB"},J:{"1":"D A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"A B"},O:{"2":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:1,C:"Autofocus attribute"};

},{}],45:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"2":"2 6 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v XB WB","129":"0 1 3 4 7 9 w x y z GB FB AB CB DB"},D:{"1":"0 1 3 4 7 9 y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x"},E:{"2":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"1":"0 1 l m n o L q r s t u v w x y z","2":"5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k ZB aB bB cB p eB"},G:{"2":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"1":"4","2":"BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"2":"5 8 A B C p","16":"L"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"1":"0B"},P:{"1":"1B 2B 3B 4B","2":"F"},Q:{"1":"5B"},R:{"1":"6B"}},B:5,C:"Auxclick"};

},{}],46:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H","194":"I"},C:{"2":"2 6 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x XB WB","578":"3 AB","772":"4 CB DB","1090":"0 1 7 y z GB","1602":"9 FB"},D:{"1":"KB IB LB MB NB OB","2":"0 1 2 3 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2114":"4 QB iB"},E:{"2":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"1":"0 1","2":"5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z ZB aB bB cB p eB"},G:{"2":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"2":"4 BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"2":"5 8 A B C L p"},L:{"2":"IB"},M:{"578":"3"},N:{"2":"A B"},O:{"2":"0B"},P:{"2":"F 1B 2B 3B 4B"},Q:{"2":"5B"},R:{"2":"6B"}},B:6,C:"AV1 video format"};

},{}],47:[function(require,module,exports){
module.exports={A:{A:{"1":"E A B","132":"K D G gB"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 3 4 6 7 9 U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","132":"2 dB BB F N K D G E A B C d J M H I O P Q R S T XB WB"},D:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"1":"5 N K D G E A B C RB SB TB UB VB p YB","132":"F PB HB"},F:{"1":"0 1 5 6 8 B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z bB cB p eB","132":"E ZB aB"},G:{"2":"HB fB EB","772":"G hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"2":"4 BB F uB vB wB yB zB","132":"xB EB"},J:{"260":"D A"},K:{"1":"5 8 B C L p","132":"A"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"A B"},O:{"1":"0B"},P:{"2":"F","1028":"1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1028":"6B"}},B:4,C:"CSS background-attachment"};

},{}],48:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"257":"J M H I","548":"2 C d"},C:{"1":"0 1 3 4 7 9 s t u v w x y z GB FB AB CB DB","16":"2 6 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q XB WB","130":"r"},D:{"36":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"16":"PB HB","36":"5 F N K D G E A B C RB SB TB UB VB p YB"},F:{"16":"0 1 5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z ZB aB bB cB p eB"},G:{"16":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"16":"tB"},I:{"16":"4 BB F uB vB wB xB EB yB zB"},J:{"16":"D A"},K:{"16":"5 8 A B C L p"},L:{"16":"IB"},M:{"16":"3"},N:{"16":"A B"},O:{"16":"0B"},P:{"16":"F 1B 2B 3B 4B"},Q:{"16":"5B"},R:{"16":"6B"}},B:1,C:"CSS3 Background-clip: text"};

},{}],49:[function(require,module,exports){
module.exports={A:{A:{"1":"E A B","2":"K D G gB"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"dB BB XB","36":"WB"},D:{"1":"0 1 3 4 6 7 9 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","516":"2 F N K D G E A B C d"},E:{"1":"5 D G E A B C TB UB VB p YB","772":"F N K PB HB RB SB"},F:{"1":"0 1 5 6 8 B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z bB cB p eB","2":"E ZB","36":"aB"},G:{"1":"G jB kB lB mB nB oB pB qB rB sB","4":"HB fB EB JB","516":"hB"},H:{"132":"tB"},I:{"1":"4 yB zB","36":"uB","516":"BB F xB EB","548":"vB wB"},J:{"1":"D A"},K:{"1":"5 8 A B C L p"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:4,C:"CSS3 Background-image options"};

},{}],50:[function(require,module,exports){
module.exports={A:{A:{"1":"K D G E A B gB"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 3 4 7 9 s t u v w x y z GB FB AB CB DB","2":"2 6 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r XB WB"},D:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"1":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"1":"0 1 6 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"5 8 E B C ZB aB bB cB p eB"},G:{"1":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"1":"4 BB F uB vB wB xB EB yB zB"},J:{"1":"D A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:7,C:"background-position-x & background-position-y"};

},{}],51:[function(require,module,exports){
module.exports={A:{A:{"1":"A B","2":"K D G gB","132":"E"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 3 4 7 9 s t u v w x y z GB FB AB CB DB","2":"2 6 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r XB WB"},D:{"1":"0 1 3 4 6 7 9 b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a"},E:{"1":"5 D G E A B C TB UB VB p YB","2":"F N K PB HB RB SB"},F:{"1":"0 1 5 6 8 B C O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z bB cB p eB","2":"E J M H I ZB aB"},G:{"1":"G jB kB lB mB nB oB pB qB rB sB","2":"HB fB EB hB JB"},H:{"1":"tB"},I:{"1":"4 yB zB","2":"BB F uB vB wB xB EB"},J:{"1":"A","2":"D"},K:{"1":"5 8 B C L p","2":"A"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:4,C:"CSS background-repeat round and space"};

},{}],52:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"2":"0 1 2 3 6 7 9 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB XB WB","16":"4 DB"},D:{"1":"0 1 3 4 7 9 s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r"},E:{"2":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"1":"0 1 f g h i j k l m n o L q r s t u v w x y z","2":"5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e ZB aB bB cB p eB"},G:{"2":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"2":"4 BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"2":"3"},N:{"2":"A B"},O:{"1":"0B"},P:{"1":"1B 2B 3B 4B","2":"F"},Q:{"1":"5B"},R:{"2":"6B"}},B:7,C:"Background Sync API"};

},{}],53:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"1":"m n o L q r s t u","2":"0 1 3 4 7 9 dB BB F N K D G E v w x y z GB FB AB CB DB XB WB","132":"6 M H I O P Q R S T U V W X Y Z a b c e f g h i j k l","164":"2 A B C d J"},D:{"1":"0 1 3 4 7 9 h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f","66":"g"},E:{"2":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"1":"0 1 6 U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"5 8 E B C J M H I O P Q R S T ZB aB bB cB p eB"},G:{"2":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"1":"4","2":"BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"2":"5B"},R:{"1":"6B"}},B:4,C:"Battery Status API"};

},{}],54:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"1":"d J M H I","2":"2 C"},C:{"1":"0 1 3 4 6 7 9 a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"2 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z XB WB"},D:{"1":"0 1 3 4 7 9 i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h"},E:{"1":"5 C p YB","2":"F N K D G E A B PB HB RB SB TB UB VB"},F:{"1":"0 1 6 V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"5 8 E B C J M H I O P Q R S T U ZB aB bB cB p eB"},G:{"1":"qB rB sB","2":"G HB fB EB hB JB jB kB lB mB nB oB pB"},H:{"2":"tB"},I:{"1":"4","2":"BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:5,C:"Beacon API"};

},{}],55:[function(require,module,exports){
module.exports={A:{A:{"1":"K D G E A B","16":"gB"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 2 3 4 6 7 9 K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"dB BB F N XB WB"},D:{"1":"3 4 AB CB DB QB iB KB IB LB MB NB OB","2":"0 1 2 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB"},E:{"2":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"1":"0 1 t u v w x y z","2":"5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s ZB aB bB cB p eB"},G:{"2":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"2":"4 BB F uB vB wB xB EB yB zB"},J:{"16":"D A"},K:{"2":"5 8 A B C L p"},L:{"1":"IB"},M:{"1":"3"},N:{"16":"A B"},O:{"16":"0B"},P:{"2":"1B 2B 3B 4B","16":"F"},Q:{"2":"5B"},R:{"2":"6B"}},B:2,C:"Printing Events"};

},{}],56:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"2":"0 1 2 3 6 7 9 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB XB WB","194":"4 CB DB"},D:{"1":"4 QB iB KB IB LB MB NB OB","2":"0 1 2 3 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB"},E:{"2":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"1":"0 1 x y z","2":"5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w ZB aB bB cB p eB"},G:{"2":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"2":"4 BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"2":"5 8 A B C L p"},L:{"1":"IB"},M:{"2":"3"},N:{"2":"A B"},O:{"2":"0B"},P:{"2":"F 1B 2B 3B 4B"},Q:{"2":"5B"},R:{"2":"6B"}},B:3,C:"BigInt"};

},{}],57:[function(require,module,exports){
module.exports={A:{A:{"1":"A B","2":"K D G E gB"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 2 3 4 6 7 9 d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"dB BB F N XB WB","36":"K D G E A B C"},D:{"1":"0 1 3 4 6 7 9 P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"F N K D","36":"2 G E A B C d J M H I O"},E:{"1":"5 K D G E A B C SB TB UB VB p YB","2":"F N PB HB RB"},F:{"1":"0 1 5 6 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"8 E B C ZB aB bB cB p eB"},G:{"1":"G JB jB kB lB mB nB oB pB qB rB sB","2":"HB fB EB hB"},H:{"2":"tB"},I:{"1":"4","2":"uB vB wB","36":"BB F xB EB yB zB"},J:{"1":"A","2":"D"},K:{"1":"5 L","2":"8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:5,C:"Blob constructing"};

},{}],58:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E gB","129":"A B"},B:{"1":"J M H I","129":"2 C d"},C:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"dB BB XB WB"},D:{"1":"0 1 3 4 6 7 9 S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"F N K D","33":"2 G E A B C d J M H I O P Q R"},E:{"1":"5 D G E A B C SB TB UB VB p YB","2":"F N PB HB RB","33":"K"},F:{"1":"0 1 6 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"5 8 E B C ZB aB bB cB p eB"},G:{"1":"G jB kB lB mB nB oB pB qB rB sB","2":"HB fB EB hB","33":"JB"},H:{"2":"tB"},I:{"1":"4 yB zB","2":"BB uB vB wB","33":"F xB EB"},J:{"1":"A","2":"D"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"B","2":"A"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:5,C:"Blob URLs"};

},{}],59:[function(require,module,exports){
module.exports={A:{A:{"1":"B","2":"K D G E A gB"},B:{"1":"d J M H I","129":"2 C"},C:{"1":"0 1 3 4 7 9 t u v w x y z GB FB AB CB DB","2":"dB BB","260":"6 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s","804":"2 F N K D G E A B C d XB WB"},D:{"1":"0 1 3 4 7 9 z GB FB AB CB DB QB iB KB IB LB MB NB OB","260":"u v w x y","388":"6 Z a b c e f g h i j k l m n o L q r s t","1412":"J M H I O P Q R S T U V W X Y","1956":"2 F N K D G E A B C d"},E:{"129":"5 A B C UB VB p YB","1412":"K D G E SB TB","1956":"F N PB HB RB"},F:{"1":"0 1 m n o L q r s t u v w x y z","2":"E ZB aB","260":"h i j k l","388":"6 J M H I O P Q R S T U V W X Y Z a b c e f g","1796":"bB cB","1828":"5 8 B C p eB"},G:{"129":"mB nB oB pB qB rB sB","1412":"G JB jB kB lB","1956":"HB fB EB hB"},H:{"1828":"tB"},I:{"388":"4 yB zB","1956":"BB F uB vB wB xB EB"},J:{"1412":"A","1924":"D"},K:{"2":"A","388":"L","1828":"5 8 B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"B","2":"A"},O:{"388":"0B"},P:{"1":"3B 4B","260":"1B 2B","388":"F"},Q:{"260":"5B"},R:{"260":"6B"}},B:4,C:"CSS3 Border images"};

},{}],60:[function(require,module,exports){
module.exports={A:{A:{"1":"E A B","2":"K D G gB"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 3 4 7 9 t u v w x y z GB FB AB CB DB","257":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s","289":"BB XB WB","292":"dB"},D:{"1":"0 1 2 3 4 6 7 9 N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","33":"F"},E:{"1":"5 N D G E A B C TB UB VB p YB","33":"F PB HB","129":"K RB SB"},F:{"1":"0 1 5 6 8 B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z bB cB p eB","2":"E ZB aB"},G:{"1":"G fB EB hB JB jB kB lB mB nB oB pB qB rB sB","33":"HB"},H:{"2":"tB"},I:{"1":"4 BB F vB wB xB EB yB zB","33":"uB"},J:{"1":"D A"},K:{"1":"5 8 B C L p","2":"A"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:4,C:"CSS3 Border-radius (rounded corners)"};

},{}],61:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"1":"0 1 3 4 7 9 h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"2 6 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g XB WB"},D:{"1":"0 1 3 4 7 9 x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w"},E:{"2":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"1":"0 1 k l m n o L q r s t u v w x y z","2":"5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j ZB aB bB cB p eB"},G:{"2":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"1":"4","2":"BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"1":"0B"},P:{"1":"3B 4B","2":"F 1B 2B"},Q:{"2":"5B"},R:{"2":"6B"}},B:1,C:"BroadcastChannel"};

},{}],62:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"1":"J M H I","2":"2 C d"},C:{"1":"0 1 3 4 7 9 n o L q r s t u v w x y z GB FB AB CB DB","2":"2 6 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m XB WB"},D:{"1":"0 1 3 4 7 9 u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r","194":"s","257":"t"},E:{"2":"F N K D G E A PB HB RB SB TB UB VB","513":"5 B C p YB"},F:{"1":"0 1 h i j k l m n o L q r s t u v w x y z","2":"5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e ZB aB bB cB p eB","194":"f g"},G:{"1":"pB qB rB sB","2":"G HB fB EB hB JB jB kB lB mB nB oB"},H:{"2":"tB"},I:{"2":"BB F uB vB wB xB EB yB zB","257":"4"},J:{"2":"D A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"1":"0B"},P:{"1":"1B 2B 3B 4B","2":"F"},Q:{"1":"5B"},R:{"2":"6B"}},B:6,C:"Brotli Accept-Encoding/Content-Encoding"};

},{}],63:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G gB","260":"E","516":"A B"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 3 4 6 7 9 M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"dB BB XB WB","33":"2 F N K D G E A B C d J"},D:{"1":"0 1 3 4 6 7 9 V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 F N K D G E A B C d J M H I","33":"O P Q R S T U"},E:{"1":"5 D G E A B C SB TB UB VB p YB","2":"F N PB HB RB","33":"K"},F:{"1":"0 1 6 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"5 8 E B C ZB aB bB cB p eB"},G:{"1":"G jB kB lB mB nB oB pB qB rB sB","2":"HB fB EB hB","33":"JB"},H:{"2":"tB"},I:{"1":"4","2":"BB F uB vB wB xB EB","132":"yB zB"},J:{"1":"A","2":"D"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:4,C:"calc() as CSS unit value"};

},{}],64:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"1":"2 d J M H I","2":"C"},C:{"1":"0 1 3 4 6 7 9 P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"2 dB BB F N K D G E A B C d J M H I O XB WB"},D:{"1":"0 1 3 4 6 7 9 Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 F N K D G E A B C d J M H I O P Q R S T U V W X Y"},E:{"1":"5 D G E A B C SB TB UB VB p YB","2":"F N K PB HB RB"},F:{"1":"0 1 6 H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"5 8 E B C J M ZB aB bB cB p eB"},G:{"1":"G jB kB lB mB nB oB pB qB rB sB","2":"HB fB EB hB JB"},H:{"2":"tB"},I:{"1":"4 yB zB","2":"BB F uB vB wB xB EB"},J:{"2":"D A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:4,C:"Canvas blend modes"};

},{}],65:[function(require,module,exports){
module.exports={A:{A:{"1":"E A B","2":"gB","8":"K D G"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB","8":"dB BB"},D:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"1":"5 F N K D G E A B C RB SB TB UB VB p YB","8":"PB HB"},F:{"1":"0 1 5 6 8 B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z bB cB p eB","8":"E ZB aB"},G:{"1":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"1":"4 BB F uB vB wB xB EB yB zB"},J:{"1":"D A"},K:{"1":"5 8 B C L p","8":"A"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:1,C:"Text API for Canvas"};

},{}],66:[function(require,module,exports){
module.exports={A:{A:{"1":"E A B","2":"gB","8":"K D G"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB WB","132":"dB BB XB"},D:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"1":"5 F N K D G E A B C RB SB TB UB VB p YB","132":"PB HB"},F:{"1":"0 1 5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z ZB aB bB cB p eB"},G:{"1":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"260":"tB"},I:{"1":"4 BB F xB EB yB zB","132":"uB vB wB"},J:{"1":"D A"},K:{"1":"5 8 A B C L p"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:1,C:"Canvas (basic support)"};

},{}],67:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G gB","132":"E A B"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 2 3 4 6 7 9 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB"},D:{"1":"0 1 3 4 6 7 9 W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 F N K D G E A B C d J M H I O P Q R S T U V"},E:{"1":"5 D G E A B C TB UB VB p YB","2":"F N K PB HB RB SB"},F:{"1":"0 1 6 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"5 8 E B C ZB aB bB cB p eB"},G:{"1":"G jB kB lB mB nB oB pB qB rB sB","2":"HB fB EB hB JB"},H:{"2":"tB"},I:{"1":"4 yB zB","2":"BB F uB vB wB xB EB"},J:{"1":"A","2":"D"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:4,C:"ch (character) unit"};

},{}],68:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"1":"0 1 3 4 7 9 q r s t u v w x y z GB FB AB CB DB","2":"2 6 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L XB WB"},D:{"1":"0 1 3 4 7 9 s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b","129":"6 c e f g h i j k l m n o L q r"},E:{"2":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"1":"0 1 f g h i j k l m n o L q r s t u v w x y z","2":"5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e ZB aB bB cB p eB"},G:{"1":"pB qB rB sB","2":"G HB fB EB hB JB jB kB lB mB nB oB"},H:{"2":"tB"},I:{"1":"4","2":"BB F uB vB wB xB EB yB","16":"zB"},J:{"2":"D A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"2":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:6,C:"ChaCha20-Poly1305 cipher suites for TLS"};

},{}],69:[function(require,module,exports){
module.exports={A:{A:{"1":"A B","2":"K D G E gB"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 3 4 7 9 k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"2 dB BB F N K D G E A B C d J M H I O P Q R S T U XB WB","194":"6 V W X Y Z a b c e f g h i j"},D:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"1":"5 N K D G E A B C RB SB TB UB VB p YB","2":"F PB HB"},F:{"1":"0 1 5 6 8 B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z cB p eB","2":"E ZB aB","16":"bB"},G:{"1":"G hB JB jB kB lB mB nB oB pB qB rB sB","2":"HB fB EB"},H:{"2":"tB"},I:{"1":"4 yB zB","2":"BB F uB vB wB xB EB"},J:{"1":"D A"},K:{"1":"5 8 B C L p","2":"A"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:1,C:"Channel messaging"};

},{}],70:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"1":"2 d J M H I","16":"C"},C:{"1":"0 1 3 4 6 7 9 S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"2 dB BB F N K D G E A B C d J M H I O P Q R XB WB"},D:{"1":"0 1 3 4 6 7 9 T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 F N K D G E A B C d J M H I O P Q R S"},E:{"1":"5 D G E A B C SB TB UB VB p YB","2":"F N PB HB RB","16":"K"},F:{"1":"0 1 6 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"5 8 E B C ZB aB bB cB p eB"},G:{"1":"G jB kB lB mB nB oB pB qB rB sB","2":"HB fB EB hB JB"},H:{"2":"tB"},I:{"1":"4 yB zB","2":"BB F uB vB wB xB EB"},J:{"1":"A","2":"D"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:1,C:"ChildNode.remove()"};

},{}],71:[function(require,module,exports){
module.exports={A:{A:{"8":"K D G E gB","1924":"A B"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 3 4 6 7 9 V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","8":"dB BB XB","516":"T U","772":"2 F N K D G E A B C d J M H I O P Q R S WB"},D:{"1":"0 1 3 4 6 7 9 X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","8":"F N K D","516":"T U V W","772":"S","900":"2 G E A B C d J M H I O P Q R"},E:{"1":"5 D G E A B C TB UB VB p YB","8":"F N PB HB","900":"K RB SB"},F:{"1":"0 1 6 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","8":"E B ZB aB bB cB p","900":"5 8 C eB"},G:{"1":"G jB kB lB mB nB oB pB qB rB sB","8":"HB fB EB","900":"hB JB"},H:{"900":"tB"},I:{"1":"4 yB zB","8":"uB vB wB","900":"BB F xB EB"},J:{"1":"A","900":"D"},K:{"1":"L","8":"A B","900":"5 8 C p"},L:{"1":"IB"},M:{"1":"3"},N:{"900":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:1,C:"classList (DOMTokenList)"};

},{}],72:[function(require,module,exports){
module.exports={A:{A:{"16":"K D G E A B gB"},B:{"16":"2 C d J M H I"},C:{"1":"3 4 AB CB DB","16":"0 1 2 6 7 9 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB XB WB"},D:{"1":"3 4 9 FB AB CB DB QB iB KB IB LB MB NB OB","16":"0 1 2 6 7 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB"},E:{"16":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"1":"0 1 r s t u v w x y z","16":"5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q ZB aB bB cB p eB"},G:{"16":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"16":"tB"},I:{"1":"4","16":"BB F uB vB wB xB EB yB zB"},J:{"16":"D A"},K:{"16":"5 8 A B C L p"},L:{"1":"IB"},M:{"1":"3"},N:{"16":"A B"},O:{"16":"0B"},P:{"16":"F 1B 2B 3B 4B"},Q:{"16":"5B"},R:{"16":"6B"}},B:5,C:"Clear-Site-Data Header"};

},{}],73:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"2":"0 1 2 3 4 6 7 9 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB"},D:{"1":"0 1 3 4 7 9 L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o"},E:{"2":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"1":"0 1 6 c e f g h i j k l m n o L q r s t u v w x y z","2":"5 8 E B C J M H I O P Q R S T U V W X Y Z a b ZB aB bB cB p eB"},G:{"2":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"1":"4","2":"BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"2":"3"},N:{"2":"A B"},O:{"1":"0B"},P:{"1":"1B 2B 3B 4B","2":"F"},Q:{"2":"5B"},R:{"1":"6B"}},B:6,C:"Client Hints: DPR, Width, Viewport-Width"};

},{}],74:[function(require,module,exports){
module.exports={A:{A:{"2436":"K D G E A B gB"},B:{"260":"H I","2436":"2 C d J M"},C:{"2":"2 dB BB F N K D G E A B C d J M H I O P Q XB WB","772":"6 R S T U V W X Y Z a b c e f g h i j","4100":"0 1 3 4 7 9 k l m n o L q r s t u v w x y z GB FB AB CB DB"},D:{"2":"F N K D G E A B C","2564":"2 6 d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l","10244":"0 1 3 4 7 9 m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"1":"5 C YB","16":"PB HB","2308":"A B VB p","2820":"F N K D G E RB SB TB UB"},F:{"2":"8 E B ZB aB bB cB p eB","16":"C","516":"5","2564":"J M H I O P Q R S T U V W X Y","10244":"0 1 6 Z a b c e f g h i j k l m n o L q r s t u v w x y z"},G:{"1":"rB sB","2":"HB fB EB","2820":"G hB JB jB kB lB mB nB oB pB qB"},H:{"2":"tB"},I:{"2":"BB F uB vB wB xB EB","2308":"4 yB zB"},J:{"2":"D","2308":"A"},K:{"2":"8 A B C p","16":"5","3076":"L"},L:{"2052":"IB"},M:{"1028":"3"},N:{"2":"A B"},O:{"2":"0B"},P:{"2052":"1B 2B 3B 4B","2308":"F"},Q:{"10244":"5B"},R:{"2052":"6B"}},B:5,C:"Synchronous Clipboard API"};

},{}],75:[function(require,module,exports){
module.exports={A:{A:{"1":"E A B","2":"K D G gB"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","16":"dB BB XB WB"},D:{"1":"0 1 3 4 6 7 9 Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","16":"2 F N K D G E A B C d","132":"J M H I O P Q R S T U V W X Y"},E:{"1":"5 A B C VB p YB","16":"F N K PB HB","132":"D G E SB TB UB","260":"RB"},F:{"1":"0 1 5 6 C H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z eB","16":"8 E B ZB aB bB cB p","132":"J M"},G:{"1":"nB oB pB qB rB sB","16":"HB","132":"G fB EB hB JB jB kB lB mB"},H:{"1":"tB"},I:{"1":"4 yB zB","16":"uB vB","132":"BB F wB xB EB"},J:{"132":"D A"},K:{"1":"5 C L","16":"8 A B p"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:1,C:"Node.compareDocumentPosition()"};

},{}],76:[function(require,module,exports){
module.exports={A:{A:{"1":"A B","2":"K D gB","132":"G E"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"dB BB XB WB"},D:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"1":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"1":"0 1 5 6 8 B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z p eB","2":"E ZB aB bB cB"},G:{"1":"HB fB EB hB","513":"G JB jB kB lB mB nB oB pB qB rB sB"},H:{"4097":"tB"},I:{"1025":"4 BB F uB vB wB xB EB yB zB"},J:{"258":"D A"},K:{"2":"A","258":"5 8 B C L p"},L:{"1025":"IB"},M:{"2049":"3"},N:{"258":"A B"},O:{"258":"0B"},P:{"1025":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1025":"6B"}},B:1,C:"Basic console logging functions"};

},{}],77:[function(require,module,exports){
module.exports={A:{A:{"1":"B","2":"K D G E A gB"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 2 3 4 6 7 9 A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"dB BB F N K D G E XB WB"},D:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"1":"5 F N K D G E A B C RB SB TB UB VB p YB","2":"PB HB"},F:{"1":"0 1 5 6 8 C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z p eB","2":"E ZB aB bB cB","16":"B"},G:{"1":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"1":"tB"},I:{"1":"4 BB F uB vB wB xB EB yB zB"},J:{"1":"D A"},K:{"1":"L","16":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"B","2":"A"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:1,C:"console.time and console.timeEnd"};

},{}],78:[function(require,module,exports){
module.exports={A:{A:{"1":"B","2":"K D G E A gB"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 3 4 7 9 f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","132":"dB BB F N K D G E A B C XB WB","260":"2 6 d J M H I O P Q R S T U V W X Y Z a b c e"},D:{"1":"0 1 3 4 7 9 s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","260":"2 F N K D G E A B C d J M H I O P","772":"6 Q R S T U V W X Y Z a b c e f g h i j","1028":"k l m n o L q r"},E:{"1":"5 A B C VB p YB","260":"F N PB HB","772":"K D G E RB SB TB UB"},F:{"1":"0 1 f g h i j k l m n o L q r s t u v w x y z","2":"E ZB","132":"8 B aB bB cB p","644":"5 C eB","772":"J M H I O P Q R S T U V W","1028":"6 X Y Z a b c e"},G:{"1":"nB oB pB qB rB sB","260":"HB fB EB","772":"G hB JB jB kB lB mB"},H:{"644":"tB"},I:{"1":"4","16":"uB vB","260":"wB","772":"BB F xB EB yB zB"},J:{"772":"D A"},K:{"1":"L","132":"8 A B p","644":"5 C"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"B","2":"A"},O:{"1":"0B"},P:{"1":"1B 2B 3B 4B","1028":"F"},Q:{"772":"5B"},R:{"1028":"6B"}},B:6,C:"const"};

},{}],79:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E gB","900":"A B"},B:{"1":"H I","388":"d J M","900":"2 C"},C:{"1":"0 1 3 4 7 9 u v w x y z GB FB AB CB DB","2":"dB BB XB WB","260":"s t","388":"6 Y Z a b c e f g h i j k l m n o L q r","900":"2 F N K D G E A B C d J M H I O P Q R S T U V W X"},D:{"1":"0 1 3 4 7 9 j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","16":"2 F N K D G E A B C d","388":"6 U V W X Y Z a b c e f g h i","900":"J M H I O P Q R S T"},E:{"1":"5 A B C VB p YB","16":"F N PB HB","388":"G E TB UB","900":"K D RB SB"},F:{"1":"0 1 6 W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","16":"8 E B ZB aB bB cB p","388":"J M H I O P Q R S T U V","900":"5 C eB"},G:{"1":"nB oB pB qB rB sB","16":"HB fB EB","388":"G jB kB lB mB","900":"hB JB"},H:{"2":"tB"},I:{"1":"4","16":"BB uB vB wB","388":"yB zB","900":"F xB EB"},J:{"16":"D","388":"A"},K:{"1":"L","16":"8 A B p","900":"5 C"},L:{"1":"IB"},M:{"1":"3"},N:{"900":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"388":"5B"},R:{"1":"6B"}},B:1,C:"Constraint Validation API"};

},{}],80:[function(require,module,exports){
module.exports={A:{A:{"1":"K D G E A B gB"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB","2":"dB","4":"BB"},D:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"1":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"1":"0 1 5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z ZB aB bB cB p eB"},G:{"1":"G hB JB jB kB lB mB nB oB pB qB rB sB","2":"HB fB EB"},H:{"2":"tB"},I:{"1":"4 BB F xB EB yB zB","2":"uB vB wB"},J:{"1":"D A"},K:{"1":"5 L","2":"8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:1,C:"contenteditable attribute (basic support)"};

},{}],81:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E gB","132":"A B"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 3 4 6 7 9 S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"dB BB XB WB","129":"2 F N K D G E A B C d J M H I O P Q R"},D:{"1":"0 1 3 4 6 7 9 U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 F N K D G E A B C","257":"d J M H I O P Q R S T"},E:{"1":"5 D G E A B C TB UB VB p YB","2":"F N PB HB","257":"K SB","260":"RB"},F:{"1":"0 1 6 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"5 8 E B C ZB aB bB cB p eB"},G:{"1":"G jB kB lB mB nB oB pB qB rB sB","2":"HB fB EB","257":"JB","260":"hB"},H:{"2":"tB"},I:{"1":"4 yB zB","2":"BB F uB vB wB xB EB"},J:{"2":"D","257":"A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"132":"A B"},O:{"257":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:4,C:"Content Security Policy 1.0"};

},{}],82:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d","32772":"J M H I"},C:{"2":"2 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z XB WB","132":"6 a b c","260":"e","516":"f g h i j k l m n","8196":"0 1 3 4 7 9 o L q r s t u v w x y z GB FB AB CB DB"},D:{"1":"0 1 3 4 7 9 j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e","1028":"f g h","2052":"i"},E:{"1":"5 A B C VB p YB","2":"F N K D G E PB HB RB SB TB UB"},F:{"1":"0 1 6 W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"5 8 E B C J M H I O P Q R ZB aB bB cB p eB","1028":"S T U","2052":"V"},G:{"1":"nB oB pB qB rB sB","2":"G HB fB EB hB JB jB kB lB mB"},H:{"2":"tB"},I:{"1":"4","2":"BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"4100":"3"},N:{"2":"A B"},O:{"2":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:4,C:"Content Security Policy Level 2"};

},{}],83:[function(require,module,exports){
module.exports={A:{A:{"1":"B","2":"K D gB","132":"A","260":"G E"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 2 6 7 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB XB WB","2":"dB BB","1025":"3 4 9 FB AB CB DB"},D:{"1":"0 1 2 3 4 6 7 9 d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","132":"F N K D G E A B C"},E:{"2":"PB HB","513":"5 K D G E A B C SB TB UB VB p YB","644":"F N RB"},F:{"1":"0 1 5 6 C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"8 E B ZB aB bB cB p eB"},G:{"513":"G JB jB kB lB mB nB oB pB qB rB sB","644":"HB fB EB hB"},H:{"2":"tB"},I:{"1":"4 yB zB","132":"BB F uB vB wB xB EB"},J:{"1":"A","132":"D"},K:{"1":"5 C L","2":"8 A B p"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"B","132":"A"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:1,C:"Cross-Origin Resource Sharing"};

},{}],84:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"2":"2 6 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k XB WB","3076":"0 1 3 4 7 9 l m n o L q r s t u v w x y z GB FB AB CB DB"},D:{"1":"3 4 7 9 GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s","132":"t u","260":"v w","516":"0 1 x y z"},E:{"2":"F N K D G E A B C PB HB RB SB TB UB VB p","16":"5 YB"},F:{"1":"0 1 L q r s t u v w x y z","2":"5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f ZB aB bB cB p eB","132":"g h","260":"i j","516":"k l m n o"},G:{"2":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"1":"4","2":"BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"3076":"3"},N:{"2":"A B"},O:{"1":"0B"},P:{"1":"2B 3B 4B","16":"F 1B"},Q:{"1":"5B"},R:{"2":"6B"}},B:1,C:"createImageBitmap"};

},{}],85:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"2":"0 1 2 3 4 6 7 9 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB"},D:{"1":"0 1 3 4 7 9 GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q","66":"r s t","129":"u v w x y z"},E:{"2":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"1":"0 1 o L q r s t u v w x y z","2":"5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n ZB aB bB cB p eB"},G:{"2":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"1":"4","2":"BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"2":"3"},N:{"2":"A B"},O:{"1":"0B"},P:{"1":"3B 4B","2":"F 1B 2B"},Q:{"2":"5B"},R:{"2":"6B"}},B:5,C:"Credential Management API"};

},{}],86:[function(require,module,exports){
module.exports={A:{A:{"2":"gB","8":"K D G E A","164":"B"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 3 4 6 7 9 e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","8":"2 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a XB WB","322":"b c"},D:{"1":"0 1 3 4 7 9 g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","8":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f"},E:{"1":"5 B C p YB","8":"F N K D PB HB RB SB","545":"G E A TB UB VB"},F:{"1":"0 1 6 T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","8":"5 8 E B C J M H I O P Q R S ZB aB bB cB p eB"},G:{"1":"pB qB rB sB","8":"HB fB EB hB JB jB","545":"G kB lB mB nB oB"},H:{"2":"tB"},I:{"1":"4","8":"BB F uB vB wB xB EB yB zB"},J:{"8":"D A"},K:{"1":"L","8":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"8":"A","164":"B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:4,C:"Web Cryptography"};

},{}],87:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"1":"0 1 3 4 6 7 9 W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"2 dB BB F N K D G E A B C d J M H I O P Q R S T U V XB WB"},D:{"1":"0 1 3 4 7 9 g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f"},E:{"1":"5 A B C UB VB p YB","2":"F N K D G E PB HB RB SB TB"},F:{"1":"0 1 6 T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"5 8 E B C J M H I O P Q R S ZB aB bB cB p eB"},G:{"1":"mB nB oB pB qB rB sB","2":"G HB fB EB hB JB jB kB lB"},H:{"2":"tB"},I:{"1":"4 zB","2":"BB F uB vB wB xB EB yB"},J:{"2":"D A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:4,C:"CSS all property"};

},{}],88:[function(require,module,exports){
module.exports={A:{A:{"1":"A B","2":"K D G E gB"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 3 4 6 7 9 M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"dB BB F XB WB","33":"2 N K D G E A B C d J"},D:{"1":"0 1 3 4 7 9 m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","33":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l"},E:{"1":"5 E A B C UB VB p YB","2":"PB HB","33":"K D G RB SB TB","292":"F N"},F:{"1":"0 1 5 6 Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"8 E B ZB aB bB cB p eB","33":"C J M H I O P Q R S T U V W X Y"},G:{"1":"lB mB nB oB pB qB rB sB","33":"G JB jB kB","164":"HB fB EB hB"},H:{"2":"tB"},I:{"1":"4","33":"F xB EB yB zB","164":"BB uB vB wB"},J:{"33":"D A"},K:{"1":"5 L","2":"8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"33":"5B"},R:{"1":"6B"}},B:5,C:"CSS Animation"};

},{}],89:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"1":"0 1 3 4 7 9 t u v w x y z GB FB AB CB DB","16":"2 dB BB F N K D G E A B C d J M H I O P XB WB","33":"6 Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s"},D:{"16":"2 F N K D G E A B C d J M H I O P Q R S","33":"0 1 3 4 6 7 9 T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"16":"F N K PB HB RB","33":"5 D G E A B C SB TB UB VB p YB"},F:{"2":"5 8 E B C ZB aB bB cB p eB","33":"0 1 6 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z"},G:{"16":"HB fB EB hB","33":"G JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"16":"BB F uB vB wB xB EB yB zB","33":"4"},J:{"16":"D A"},K:{"2":"5 8 A B C p","33":"L"},L:{"33":"IB"},M:{"33":"3"},N:{"2":"A B"},O:{"16":"0B"},P:{"16":"F","33":"1B 2B 3B 4B"},Q:{"33":"5B"},R:{"33":"6B"}},B:5,C:"CSS :any-link selector"};

},{}],90:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"388":"2 C d J M H I"},C:{"164":"0 1 3 4 7 9 e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","676":"2 6 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c XB WB"},D:{"164":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"164":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"2":"5 8 E B C ZB aB bB cB p eB","164":"0 1 6 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z"},G:{"164":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"164":"4 BB F uB vB wB xB EB yB zB"},J:{"164":"D A"},K:{"2":"5 8 A B C p","164":"L"},L:{"164":"IB"},M:{"164":"3"},N:{"2":"A","388":"B"},O:{"164":"0B"},P:{"164":"F 1B 2B 3B 4B"},Q:{"164":"5B"},R:{"164":"6B"}},B:5,C:"CSS Appearance"};

},{}],91:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"2":"0 1 2 3 4 6 7 9 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB"},D:{"2":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t","194":"0 1 3 4 7 9 u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"2":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"2":"5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g ZB aB bB cB p eB","194":"0 1 h i j k l m n o L q r s t u v w x y z"},G:{"2":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"2":"4 BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"2":"5 8 A B C p","194":"L"},L:{"194":"IB"},M:{"2":"3"},N:{"2":"A B"},O:{"2":"0B"},P:{"2":"F","194":"1B 2B 3B 4B"},Q:{"2":"5B"},R:{"194":"6B"}},B:7,C:"CSS @apply rule"};

},{}],92:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"2":"2 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b XB WB","132":"0 1 3 4 6 7 9 c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB"},D:{"2":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"2":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"2":"0 1 5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z ZB aB bB cB p eB"},G:{"2":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"2":"4 BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"2":"5 8 A B C L p"},L:{"2":"IB"},M:{"132":"3"},N:{"2":"A B"},O:{"2":"0B"},P:{"2":"F 1B 2B 3B 4B"},Q:{"2":"5B"},R:{"2":"6B"}},B:4,C:"CSS Counter Styles"};

},{}],93:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M","257":"H I"},C:{"2":"0 1 2 3 4 6 7 9 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB"},D:{"2":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L","194":"0 1 3 4 7 9 q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"2":"F N K D G PB HB RB SB TB","33":"5 E A B C UB VB p YB"},F:{"2":"5 8 E B C J M H I O P Q R S T U V W X Y Z a b c ZB aB bB cB p eB","194":"0 1 6 e f g h i j k l m n o L q r s t u v w x y z"},G:{"2":"G HB fB EB hB JB jB kB","33":"lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"2":"4 BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"2":"5 8 A B C p","194":"L"},L:{"194":"IB"},M:{"2":"3"},N:{"2":"A B"},O:{"2":"0B"},P:{"2":"F","194":"1B 2B 3B 4B"},Q:{"194":"5B"},R:{"194":"6B"}},B:7,C:"CSS Backdrop Filter"};

},{}],94:[function(require,module,exports){
module.exports={A:{A:{"1":"E A B","2":"K D G gB"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 2 3 4 6 7 9 d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"dB BB F N K D G E A B C XB WB"},D:{"1":"0 1 3 4 6 7 9 U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 F N K D G E A B C d J M H I O P Q R S T"},E:{"1":"5 D G E A B C TB UB VB p YB","2":"F N K PB HB RB SB"},F:{"1":"0 1 5 6 8 B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z bB cB p eB","2":"E ZB aB"},G:{"1":"G jB kB lB mB nB oB pB qB rB sB","2":"HB fB EB hB JB"},H:{"1":"tB"},I:{"1":"4 yB zB","2":"BB F uB vB wB xB EB"},J:{"1":"A","2":"D"},K:{"1":"5 8 B C L p","2":"A"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:4,C:"CSS background-position edge offsets"};

},{}],95:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"1":"0 1 3 4 6 7 9 Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"2 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y XB WB"},D:{"1":"0 1 3 4 7 9 e f g h i j k l m n o q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c","260":"L"},E:{"1":"5 B C VB p YB","2":"F N K D PB HB RB SB","132":"G E A TB UB"},F:{"1":"0 1 6 R S T U V W X Y Z a b e f g h i j k l m n o L q r s t u v w x y z","2":"5 8 E B C J M H I O P Q ZB aB bB cB p eB","260":"c"},G:{"1":"oB pB qB rB sB","2":"HB fB EB hB JB jB","132":"G kB lB mB nB"},H:{"2":"tB"},I:{"1":"4","2":"BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"2":"5 8 A B C p","260":"L"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:4,C:"CSS background-blend-mode"};

},{}],96:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"1":"0 1 3 4 6 7 9 b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"2 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a XB WB"},D:{"2":"2 F N K D G E A B C d J M H I O P Q","164":"0 1 3 4 6 7 9 R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"2":"F N K PB HB RB","164":"5 D G E A B C SB TB UB VB p YB"},F:{"2":"E ZB aB bB cB","129":"5 8 B C p eB","164":"0 1 6 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z"},G:{"2":"HB fB EB hB JB","164":"G jB kB lB mB nB oB pB qB rB sB"},H:{"132":"tB"},I:{"2":"BB F uB vB wB xB EB","164":"4 yB zB"},J:{"2":"D","164":"A"},K:{"2":"A","129":"5 8 B C p","164":"L"},L:{"164":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"1":"0B"},P:{"164":"F 1B 2B 3B 4B"},Q:{"164":"5B"},R:{"164":"6B"}},B:5,C:"CSS box-decoration-break"};

},{}],97:[function(require,module,exports){
module.exports={A:{A:{"1":"E A B","2":"K D G gB"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"dB BB","33":"XB WB"},D:{"1":"0 1 2 3 4 6 7 9 A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","33":"F N K D G E"},E:{"1":"5 K D G E A B C RB SB TB UB VB p YB","33":"N","164":"F PB HB"},F:{"1":"0 1 5 6 8 B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z bB cB p eB","2":"E ZB aB"},G:{"1":"G hB JB jB kB lB mB nB oB pB qB rB sB","33":"fB EB","164":"HB"},H:{"2":"tB"},I:{"1":"4 F xB EB yB zB","164":"BB uB vB wB"},J:{"1":"A","33":"D"},K:{"1":"5 8 B C L p","2":"A"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:4,C:"CSS3 Box-shadow"};

},{}],98:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"2":"2 6 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u XB WB","16":"0 1 3 4 7 9 v w x y z GB FB AB CB DB"},D:{"2":"0 1 3 4 7 9 r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","33":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q"},E:{"2":"PB HB","33":"5 F N K D G E A B C RB SB TB UB VB p YB"},F:{"2":"0 1 5 8 E B C e f g h i j k l m n o L q r s t u v w x y z ZB aB bB cB p eB","33":"6 J M H I O P Q R S T U V W X Y Z a b c"},G:{"33":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"2":"4","33":"BB F uB vB wB xB EB yB zB"},J:{"33":"D A"},K:{"2":"5 8 A B C L p"},L:{"2":"IB"},M:{"2":"3"},N:{"2":"A B"},O:{"2":"0B"},P:{"2":"1B 2B 3B 4B","33":"F"},Q:{"33":"5B"},R:{"2":"6B"}},B:7,C:"CSS Canvas Drawings"};

},{}],99:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"1":"0 1 3 4 7 9 w x y z GB FB AB CB DB","2":"2 6 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v XB WB"},D:{"1":"0 1 3 4 7 9 GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z"},E:{"1":"5 C p YB","2":"F N K D G E A B PB HB RB SB TB UB VB"},F:{"1":"0 1 n o L q r s t u v w x y z","2":"5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m ZB aB bB cB p eB"},G:{"1":"qB rB sB","2":"G HB fB EB hB JB jB kB lB mB nB oB pB"},H:{"2":"tB"},I:{"1":"4","2":"BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"1":"0B"},P:{"1":"3B 4B","2":"F 1B 2B"},Q:{"2":"5B"},R:{"2":"6B"}},B:4,C:"CSS caret-color"};

},{}],100:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"1":"0 1 3 4 7 9 q r s t u v w x y z GB FB AB CB DB","2":"2 6 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L XB WB"},D:{"1":"0 1 3 4 7 9 s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r"},E:{"1":"5 E A B C UB VB p YB","2":"F N K D G PB HB RB SB TB"},F:{"1":"0 1 f g h i j k l m n o L q r s t u v w x y z","2":"5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e ZB aB bB cB p eB"},G:{"1":"lB mB nB oB pB qB rB sB","2":"G HB fB EB hB JB jB kB"},H:{"2":"tB"},I:{"2":"4 BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"1":"0B"},P:{"1":"1B 2B 3B 4B","2":"F"},Q:{"2":"5B"},R:{"2":"6B"}},B:5,C:"Case-insensitive CSS attribute selectors"};

},{}],101:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H","3138":"I"},C:{"1":"0 1 3 4 7 9 x y z GB FB AB CB DB","2":"dB BB","132":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L XB WB","644":"q r s t u v w"},D:{"2":"2 F N K D G E A B C d J M H I O P Q R S","260":"0 1 3 4 7 9 y z GB FB AB CB DB QB iB KB IB LB MB NB OB","292":"6 T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x"},E:{"2":"F N K PB HB RB SB","292":"5 D G E A B C TB UB VB p YB"},F:{"2":"5 8 E B C ZB aB bB cB p eB","260":"0 1 l m n o L q r s t u v w x y z","292":"6 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k"},G:{"2":"HB fB EB hB JB","292":"G jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"2":"BB F uB vB wB xB EB","260":"4","292":"yB zB"},J:{"2":"D A"},K:{"2":"5 8 A B C p","292":"L"},L:{"260":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"292":"0B"},P:{"292":"F 1B 2B 3B 4B"},Q:{"292":"5B"},R:{"260":"6B"}},B:4,C:"CSS clip-path property (for HTML)"};

},{}],102:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"1":"0 1 3 4 7 9 r s t u v w x y z GB FB AB CB DB","2":"2 6 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q XB WB"},D:{"16":"2 F N K D G E A B C d J M H I","33":"0 1 3 4 6 7 9 O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"2":"F N PB HB RB","33":"5 K D G E A B C SB TB UB VB p YB"},F:{"2":"5 8 E B C ZB aB bB cB p eB","33":"0 1 6 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z"},G:{"16":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"16":"4 BB F uB vB wB xB EB yB zB"},J:{"16":"D A"},K:{"2":"5 8 A B C L p"},L:{"16":"IB"},M:{"1":"3"},N:{"16":"A B"},O:{"16":"0B"},P:{"16":"F 1B 2B 3B 4B"},Q:{"16":"5B"},R:{"16":"6B"}},B:7,C:"CSS color-adjust"};

},{}],103:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"2":"0 1 2 3 4 6 7 9 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB"},D:{"1":"iB KB IB LB MB NB OB","2":"0 1 2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","194":"3 4 7 9 GB FB AB CB DB QB"},E:{"1":"5 YB","2":"F N K D G E A B C PB HB RB SB TB UB VB p"},F:{"2":"5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o ZB aB bB cB p eB","194":"0 1 L q r s t u v w x y z"},G:{"1":"sB","2":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB"},H:{"2":"tB"},I:{"1":"4","2":"BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"2":"5 8 A B C L p"},L:{"1":"IB"},M:{"2":"3"},N:{"2":"A B"},O:{"2":"0B"},P:{"2":"F 1B 2B 3B 4B"},Q:{"2":"5B"},R:{"2":"6B"}},B:5,C:"CSS Conical Gradients"};

},{}],104:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"2":"2 6 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j XB WB","322":"k l m n o L q r s t u","336":"0 1 3 4 7 9 v w x y z GB FB AB CB DB"},D:{"1":"0 1 3 4 7 9 v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t","194":"u"},E:{"2":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"1":"0 1 j k l m n o L q r s t u v w x y z","2":"5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g ZB aB bB cB p eB","194":"h i"},G:{"2":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"1":"4","2":"BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"322":"3"},N:{"2":"A B"},O:{"1":"0B"},P:{"1":"2B 3B 4B","2":"F 1B"},Q:{"2":"5B"},R:{"2":"6B"}},B:4,C:"CSS Containment"};

},{}],105:[function(require,module,exports){
module.exports={A:{A:{"1":"G E A B","2":"K D gB"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 2 3 4 6 7 9 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB"},D:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"1":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"1":"0 1 5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z ZB aB bB cB p eB"},G:{"1":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"1":"tB"},I:{"1":"4 BB F uB vB wB xB EB yB zB"},J:{"1":"D A"},K:{"1":"5 8 A B C L p"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:2,C:"CSS Counters"};

},{}],106:[function(require,module,exports){
module.exports={A:{A:{"2":"K gB","2340":"D G E A B"},B:{"2":"2 C d J M H I"},C:{"2":"dB BB XB","513":"4 CB DB","545":"0 1 2 3 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB WB"},D:{"2":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j","1025":"0 1 3 4 7 9 k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"1":"5 A B C VB p YB","2":"F N PB HB RB","164":"K","4644":"D G E SB TB UB"},F:{"2":"8 E B J M H I O P Q R S T U V W ZB aB bB cB p","545":"5 C eB","1025":"0 1 6 X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z"},G:{"1":"nB oB pB qB rB sB","2":"HB fB EB","4260":"hB JB","4644":"G jB kB lB mB"},H:{"2":"tB"},I:{"2":"BB F uB vB wB xB EB yB zB","1025":"4"},J:{"2":"D","4260":"A"},K:{"2":"8 A B p","545":"5 C","1025":"L"},L:{"1025":"IB"},M:{"545":"3"},N:{"2340":"A B"},O:{"1":"0B"},P:{"1025":"F 1B 2B 3B 4B"},Q:{"2":"5B"},R:{"1025":"6B"}},B:7,C:"Crisp edges/pixelated images"};

},{}],107:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"2":"0 1 2 3 4 6 7 9 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB"},D:{"2":"2 F N K D G E A B C d J M","33":"0 1 3 4 6 7 9 H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"1":"5 A B C VB p YB","2":"F N PB HB","33":"K D G E RB SB TB UB"},F:{"2":"5 8 E B C ZB aB bB cB p eB","33":"0 1 6 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z"},G:{"1":"nB oB pB qB rB sB","2":"HB fB EB","33":"G hB JB jB kB lB mB"},H:{"2":"tB"},I:{"2":"BB F uB vB wB xB EB","33":"4 yB zB"},J:{"2":"D A"},K:{"2":"5 8 A B C p","33":"L"},L:{"33":"IB"},M:{"2":"3"},N:{"2":"A B"},O:{"33":"0B"},P:{"33":"F 1B 2B 3B 4B"},Q:{"33":"5B"},R:{"33":"6B"}},B:7,C:"CSS Cross-Fade Function"};

},{}],108:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","16":"dB BB XB WB"},D:{"1":"0 1 3 4 7 9 u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","16":"2 F N K D G E A B C d","132":"6 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t"},E:{"1":"5 B C VB p YB","16":"F N PB HB","132":"K D G E A RB SB TB UB"},F:{"1":"0 1 h i j k l m n o L q r s t u v w x y z","16":"8 E B ZB aB bB cB p","132":"6 J M H I O P Q R S T U V W X Y Z a b c e f g","260":"5 C eB"},G:{"1":"oB pB qB rB sB","16":"HB fB EB hB JB","132":"G jB kB lB mB nB"},H:{"260":"tB"},I:{"1":"4","16":"BB uB vB wB","132":"F xB EB yB zB"},J:{"16":"D","132":"A"},K:{"1":"L","16":"8 A B C p","260":"5"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"132":"0B"},P:{"1":"1B 2B 3B 4B","132":"F"},Q:{"1":"5B"},R:{"2":"6B"}},B:7,C:":default CSS pseudo-class"};

},{}],109:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"2":"0 1 2 3 4 6 7 9 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB"},D:{"2":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB","16":"MB NB OB"},E:{"1":"B","2":"5 F N K D G E A C PB HB RB SB TB UB VB p YB"},F:{"2":"0 1 5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z ZB aB bB cB p eB"},G:{"2":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"2":"4 BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"2":"5 8 A B C L p"},L:{"2":"IB"},M:{"2":"3"},N:{"2":"A B"},O:{"2":"0B"},P:{"2":"F 1B 2B 3B 4B"},Q:{"2":"5B"},R:{"2":"6B"}},B:7,C:"Explicit descendant combinator >>"};

},{}],110:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E gB","164":"A B"},B:{"164":"2 C d J M H I"},C:{"2":"0 1 2 3 4 6 7 9 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB"},D:{"2":"2 F N K D G E A B C d J M H I O P Q R S T U V W X","66":"0 1 3 4 6 7 9 Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"2":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"2":"5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i ZB aB bB cB p eB","66":"0 1 j k l m n o L q r s t u v w x y z"},G:{"2":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"292":"tB"},I:{"2":"4 BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"2":"A L","292":"5 8 B C p"},L:{"2":"IB"},M:{"2":"3"},N:{"164":"A B"},O:{"2":"0B"},P:{"2":"F 1B 2B 3B 4B"},Q:{"66":"5B"},R:{"2":"6B"}},B:5,C:"CSS Device Adaptation"};

},{}],111:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"1":"0 1 3 4 7 9 s t u v w x y z GB FB AB CB DB","2":"2 dB BB F N K D G E A B C d J M XB WB","33":"6 H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r"},D:{"2":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"2":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"2":"0 1 5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z ZB aB bB cB p eB"},G:{"2":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"2":"4 BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"2":"5 8 A B C L p"},L:{"2":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"2":"0B"},P:{"2":"F 1B 2B 3B 4B"},Q:{"2":"5B"},R:{"2":"6B"}},B:5,C:":dir() CSS pseudo-class"};

},{}],112:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"1":"3 4 9 AB CB DB","2":"2 6 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f XB WB","260":"0 1 7 g h i j k l m n o L q r s t u v w x y z GB FB"},D:{"2":"0 2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","194":"1 3 7 9 GB FB AB","260":"4 CB DB QB iB KB IB LB MB NB OB"},E:{"2":"F N K D G E A B PB HB RB SB TB UB VB","772":"5 C p YB"},F:{"2":"5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u ZB aB bB cB p eB","260":"0 1 v w x y z"},G:{"2":"G HB fB EB hB JB jB kB lB mB nB oB pB","260":"qB rB sB"},H:{"2":"tB"},I:{"2":"BB F uB vB wB xB EB yB zB","260":"4"},J:{"2":"D A"},K:{"2":"5 8 A B C L p"},L:{"260":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"2":"0B"},P:{"2":"F 1B 2B 3B 4B"},Q:{"2":"5B"},R:{"2":"6B"}},B:5,C:"CSS display: contents"};

},{}],113:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"33":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","164":"dB BB XB WB"},D:{"2":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"2":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"2":"0 1 5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z ZB aB bB cB p eB"},G:{"2":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"2":"4 BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"2":"5 8 A B C L p"},L:{"2":"IB"},M:{"33":"3"},N:{"2":"A B"},O:{"2":"0B"},P:{"2":"F 1B 2B 3B 4B"},Q:{"2":"5B"},R:{"2":"6B"}},B:5,C:"CSS element() function"};

},{}],114:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"1":"4 CB DB","2":"0 1 2 3 6 7 9 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB XB WB"},D:{"1":"iB KB IB LB MB NB OB","2":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB"},E:{"1":"5 C p YB","2":"F N K D G E A PB HB RB SB TB UB VB","132":"B"},F:{"1":"0 1 z","2":"5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y ZB aB bB cB p eB"},G:{"1":"qB rB sB","2":"G HB fB EB hB JB jB kB lB mB nB oB","132":"pB"},H:{"2":"tB"},I:{"2":"4 BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"2":"5 8 A B C L p"},L:{"1":"IB"},M:{"2":"3"},N:{"2":"A B"},O:{"2":"0B"},P:{"2":"F 1B 2B 3B 4B"},Q:{"2":"5B"},R:{"2":"6B"}},B:7,C:"CSS Environment Variables env()"};

},{}],115:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E gB","33":"A B"},B:{"33":"2 C d J M H I"},C:{"2":"0 1 2 3 4 6 7 9 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB"},D:{"2":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"2":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"2":"0 1 5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z ZB aB bB cB p eB"},G:{"2":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"2":"4 BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"2":"5 8 A B C L p"},L:{"2":"IB"},M:{"2":"3"},N:{"33":"A B"},O:{"2":"0B"},P:{"2":"F 1B 2B 3B 4B"},Q:{"2":"5B"},R:{"2":"6B"}},B:5,C:"CSS Exclusions Level 1"};

},{}],116:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 3 4 6 7 9 R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"2 dB BB F N K D G E A B C d J M H I O P Q XB WB"},D:{"1":"0 1 3 4 6 7 9 X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 F N K D G E A B C d J M H I O P Q R S T U V W"},E:{"1":"5 E A B C UB VB p YB","2":"F N K D G PB HB RB SB TB"},F:{"1":"0 1 5 6 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"8 E B C ZB aB bB cB p eB"},G:{"1":"lB mB nB oB pB qB rB sB","2":"G HB fB EB hB JB jB kB"},H:{"1":"tB"},I:{"1":"4 yB zB","2":"BB F uB vB wB xB EB"},J:{"2":"D A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:4,C:"CSS Feature Queries"};

},{}],117:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"2":"0 1 2 3 4 6 7 9 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB"},D:{"2":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"1":"5 A B C UB VB p YB","2":"F N K D G PB HB RB SB TB","33":"E"},F:{"2":"0 1 5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z ZB aB bB cB p eB"},G:{"1":"nB oB pB qB rB sB","2":"G HB fB EB hB JB jB kB","33":"lB mB"},H:{"2":"tB"},I:{"2":"4 BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"2":"5 8 A B C L p"},L:{"2":"IB"},M:{"2":"3"},N:{"2":"A B"},O:{"2":"0B"},P:{"2":"F 1B 2B 3B 4B"},Q:{"2":"5B"},R:{"2":"6B"}},B:5,C:"CSS filter() function"};

},{}],118:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"1028":"2 d J M H I","1346":"C"},C:{"1":"0 1 3 4 7 9 e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"dB BB XB","196":"6","516":"2 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c WB"},D:{"1":"0 1 3 4 7 9 w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 F N K D G E A B C d J M H","33":"6 I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v"},E:{"1":"5 A B C UB VB p YB","2":"F N PB HB RB","33":"K D G E SB TB"},F:{"1":"0 1 j k l m n o L q r s t u v w x y z","2":"5 8 E B C ZB aB bB cB p eB","33":"6 J M H I O P Q R S T U V W X Y Z a b c e f g h i"},G:{"1":"mB nB oB pB qB rB sB","2":"HB fB EB hB","33":"G JB jB kB lB"},H:{"2":"tB"},I:{"1":"4","2":"BB F uB vB wB xB EB","33":"yB zB"},J:{"2":"D","33":"A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"1":"0B"},P:{"1":"3B 4B","33":"F 1B 2B"},Q:{"33":"5B"},R:{"33":"6B"}},B:5,C:"CSS Filter Effects"};

},{}],119:[function(require,module,exports){
module.exports={A:{A:{"1":"E A B","16":"gB","516":"G","1540":"K D"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB","132":"BB","260":"dB"},D:{"1":"0 1 2 3 4 6 7 9 E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","16":"N K D G","132":"F"},E:{"1":"5 K D G E A B C RB SB TB UB VB p YB","16":"N PB","132":"F HB"},F:{"1":"0 1 5 6 C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z eB","16":"E ZB","260":"8 B aB bB cB p"},G:{"1":"G hB JB jB kB lB mB nB oB pB qB rB sB","16":"HB fB EB"},H:{"1":"tB"},I:{"1":"4 BB F xB EB yB zB","16":"uB vB","132":"wB"},J:{"1":"D A"},K:{"1":"5 C L","260":"8 A B p"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:2,C:"::first-letter CSS pseudo-element selector"};

},{}],120:[function(require,module,exports){
module.exports={A:{A:{"1":"E A B","132":"K D G gB"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 2 3 4 6 7 9 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB"},D:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"1":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"1":"0 1 5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z ZB aB bB cB p eB"},G:{"1":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"1":"tB"},I:{"1":"4 BB F uB vB wB xB EB yB zB"},J:{"1":"D A"},K:{"1":"5 8 A B C L p"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:2,C:"CSS first-line pseudo-element"};

},{}],121:[function(require,module,exports){
module.exports={A:{A:{"1":"D G E A B","2":"gB","8":"K"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 2 3 4 6 7 9 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB"},D:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"1":"5 F N K D G E A B C PB HB RB SB TB VB p YB","1025":"UB"},F:{"1":"0 1 5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z ZB aB bB cB p eB"},G:{"1":"G kB lB mB nB oB pB qB rB sB","2":"HB fB EB","132":"hB JB jB"},H:{"2":"tB"},I:{"1":"4 BB yB zB","260":"uB vB wB","513":"F xB EB"},J:{"1":"D A"},K:{"1":"5 8 A B C L p"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:2,C:"CSS position:fixed"};

},{}],122:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"2":"dB BB XB WB","161":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB"},D:{"2":"0 1 2 3 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","328":"4 QB iB KB IB LB MB NB OB"},E:{"2":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"2":"0 1 5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z ZB aB bB cB p eB"},G:{"2":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"2":"4 BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"2":"5 8 A B C L p"},L:{"328":"IB"},M:{"161":"3"},N:{"2":"A B"},O:{"2":"0B"},P:{"2":"F 1B 2B 3B 4B"},Q:{"2":"5B"},R:{"2":"6B"}},B:7,C:":focus-visible CSS pseudo-class"};

},{}],123:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"1":"0 1 3 4 7 9 v w x y z GB FB AB CB DB","2":"2 6 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u XB WB"},D:{"1":"3 4 7 9 FB AB CB DB QB iB KB IB LB MB NB OB","2":"0 1 2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","194":"GB"},E:{"1":"5 B C VB p YB","2":"F N K D G E A PB HB RB SB TB UB"},F:{"1":"0 1 q r s t u v w x y z","2":"5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o ZB aB bB cB p eB","194":"L"},G:{"1":"oB pB qB rB sB","2":"G HB fB EB hB JB jB kB lB mB nB"},H:{"2":"tB"},I:{"2":"4 BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"2":"5 8 A B C L p"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"2":"0B"},P:{"2":"F 1B 2B 3B 4B"},Q:{"2":"5B"},R:{"2":"6B"}},B:7,C:":focus-within CSS pseudo-class"};

},{}],124:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"1":"1 3 4 7 9 GB FB AB CB DB","2":"2 6 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o XB WB","322":"0 L q r s t u v w x y z"},D:{"1":"3 4 7 9 FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r","194":"0 1 s t u v w x y z GB"},E:{"1":"5 C p YB","2":"F N K D G E A B PB HB RB SB TB UB VB"},F:{"1":"0 1 q r s t u v w x y z","2":"5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e ZB aB bB cB p eB","194":"f g h i j k l m n o L"},G:{"1":"qB rB sB","2":"G HB fB EB hB JB jB kB lB mB nB oB pB"},H:{"2":"tB"},I:{"2":"4 BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"2":"5 8 A B C p","194":"L"},L:{"1":"IB"},M:{"2":"3"},N:{"2":"A B"},O:{"2":"0B"},P:{"1":"4B","2":"F","194":"1B 2B 3B"},Q:{"194":"5B"},R:{"2":"6B"}},B:5,C:"CSS font-rendering controls"};

},{}],125:[function(require,module,exports){
module.exports={A:{A:{"1":"E A B","2":"K D G gB"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 2 3 4 6 7 9 E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"dB BB F N K D G XB WB"},D:{"1":"0 1 3 4 7 9 r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q"},E:{"1":"5 B C p YB","2":"F N K D G E A PB HB RB SB TB UB VB"},F:{"1":"0 1 e f g h i j k l m n o L q r s t u v w x y z","2":"5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c ZB aB bB cB p eB"},G:{"2":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"1":"4","2":"BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"A B"},O:{"1":"0B"},P:{"1":"1B 2B 3B 4B","2":"F"},Q:{"2":"5B"},R:{"1":"6B"}},B:4,C:"CSS font-stretch"};

},{}],126:[function(require,module,exports){
module.exports={A:{A:{"1":"E A B","2":"K D gB","132":"G"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 2 3 4 6 7 9 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB"},D:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"1":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"1":"0 1 5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z ZB aB bB cB p eB"},G:{"1":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"1":"tB"},I:{"1":"4 BB F uB vB wB xB EB yB zB"},J:{"1":"D A"},K:{"1":"5 8 A B C L p"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:2,C:"CSS Generated content for pseudo-elements"};

},{}],127:[function(require,module,exports){
module.exports={A:{A:{"1":"A B","2":"K D G E gB"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 3 4 7 9 f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"dB BB XB","260":"6 M H I O P Q R S T U V W X Y Z a b c e","292":"2 F N K D G E A B C d J WB"},D:{"1":"0 1 3 4 6 7 9 V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","33":"2 A B C d J M H I O P Q R S T U","548":"F N K D G E"},E:{"2":"PB HB","260":"5 D G E A B C SB TB UB VB p YB","292":"K RB","804":"F N"},F:{"1":"0 1 5 6 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"E B ZB aB bB cB","33":"C eB","164":"8 p"},G:{"260":"G jB kB lB mB nB oB pB qB rB sB","292":"hB JB","804":"HB fB EB"},H:{"2":"tB"},I:{"1":"4 yB zB","33":"F xB EB","548":"BB uB vB wB"},J:{"1":"A","548":"D"},K:{"1":"5 L","2":"A B","33":"C","164":"8 p"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:4,C:"CSS Gradients"};

},{}],128:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G gB","8":"E","292":"A B"},B:{"1":"M H I","292":"2 C d J"},C:{"1":"0 1 3 4 7 9 x y z GB FB AB CB DB","2":"2 dB BB F N K D G E A B C d J M H I XB WB","8":"6 O P Q R S T U V W X Y Z a b c e f g h i","584":"j k l m n o L q r s t u","1025":"v w"},D:{"1":"1 3 4 7 9 GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 F N K D G E A B C d J M H I O P Q R S T","8":"U V W X","200":"6 Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","1025":"0"},E:{"1":"5 B C VB p YB","2":"F N PB HB RB","8":"K D G E A SB TB UB"},F:{"1":"0 1 n o L q r s t u v w x y z","2":"5 8 E B C J M H I O P Q R S T U V W ZB aB bB cB p eB","200":"6 X Y Z a b c e f g h i j k l m"},G:{"1":"oB pB qB rB sB","2":"HB fB EB hB","8":"G JB jB kB lB mB nB"},H:{"2":"tB"},I:{"1":"4","2":"BB F uB vB wB xB","8":"EB yB zB"},J:{"2":"D A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"292":"A B"},O:{"1":"0B"},P:{"1":"2B 3B 4B","2":"1B","8":"F"},Q:{"200":"5B"},R:{"2":"6B"}},B:4,C:"CSS Grid Layout"};

},{}],129:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"2":"0 1 2 3 4 6 7 9 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB"},D:{"2":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"1":"5 A B C VB p YB","2":"F N K D G E PB HB RB SB TB UB"},F:{"2":"0 1 5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z ZB aB bB cB p eB"},G:{"1":"nB oB pB qB rB sB","2":"G HB fB EB hB JB jB kB lB mB"},H:{"2":"tB"},I:{"2":"4 BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"2":"5 8 A B C L p"},L:{"2":"IB"},M:{"2":"3"},N:{"2":"A B"},O:{"2":"0B"},P:{"2":"F 1B 2B 3B 4B"},Q:{"2":"5B"},R:{"2":"6B"}},B:5,C:"CSS hanging-punctuation"};

},{}],130:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"2":"0 1 2 3 4 6 7 9 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB"},D:{"2":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"2":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"2":"0 1 5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z ZB aB bB cB p eB"},G:{"2":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"2":"4 BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"2":"5 8 A B C L p"},L:{"2":"IB"},M:{"2":"3"},N:{"2":"A B"},O:{"2":"0B"},P:{"2":"F 1B 2B 3B 4B"},Q:{"2":"5B"},R:{"2":"6B"}},B:5,C:":has() CSS relational pseudo-class"};

},{}],131:[function(require,module,exports){
module.exports={A:{A:{"16":"K D G E A B gB"},B:{"16":"2 C d J M H I"},C:{"16":"0 1 2 3 4 6 7 9 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB"},D:{"1":"0 1 3 4 7 9 y z GB FB AB CB DB QB iB KB IB LB MB NB OB","16":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x"},E:{"16":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"16":"0 1 5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z ZB aB bB cB p eB"},G:{"16":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"16":"tB"},I:{"16":"4 BB F uB vB wB xB EB yB zB"},J:{"16":"D A"},K:{"16":"5 8 A B C L p"},L:{"16":"IB"},M:{"16":"3"},N:{"16":"A B"},O:{"16":"0B"},P:{"16":"F 1B 2B 3B 4B"},Q:{"16":"5B"},R:{"16":"6B"}},B:5,C:"CSS4 Hyphenation"};

},{}],132:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E gB","33":"A B"},B:{"33":"2 C d J M H I"},C:{"1":"0 1 3 4 7 9 m n o L q r s t u v w x y z GB FB AB CB DB","2":"dB BB F N XB WB","33":"2 6 K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l"},D:{"2":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x","132":"0 1 3 4 7 9 y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"2":"F N PB HB","33":"5 K D G E A B C RB SB TB UB VB p YB"},F:{"2":"5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k ZB aB bB cB p eB","132":"0 1 l m n o L q r s t u v w x y z"},G:{"2":"HB fB","33":"G EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"2":"BB F uB vB wB xB EB yB zB","132":"4"},J:{"2":"D A"},K:{"2":"5 8 A B C L p"},L:{"132":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"4":"0B"},P:{"1":"2B 3B 4B","2":"F","132":"1B"},Q:{"2":"5B"},R:{"132":"6B"}},B:5,C:"CSS Hyphenation"};

},{}],133:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"1":"0 1 3 4 6 7 9 V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"2 dB BB F N K D G E A B C d J M H I O P Q R S T U XB WB"},D:{"2":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"2":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"2":"0 1 5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z ZB aB bB cB p eB"},G:{"132":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"2":"4 BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"2":"5 8 A B C L p"},L:{"2":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"2":"0B"},P:{"2":"F 1B 2B 3B 4B"},Q:{"2":"5B"},R:{"2":"6B"}},B:4,C:"CSS3 image-orientation"};

},{}],134:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"2":"0 1 2 3 4 6 7 9 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB"},D:{"2":"2 F N K D G E A B C d J M H I O P","33":"0 1 3 4 6 7 9 Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"2":"F N PB HB RB","33":"K D G E SB TB UB","129":"5 A B C VB p YB"},F:{"2":"5 8 E B C ZB aB bB cB p eB","33":"0 1 6 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z"},G:{"2":"HB fB EB hB","33":"G JB jB kB lB mB","129":"nB oB pB qB rB sB"},H:{"2":"tB"},I:{"2":"BB F uB vB wB xB EB","33":"4 yB zB"},J:{"2":"D","33":"A"},K:{"2":"5 8 A B C p","33":"L"},L:{"33":"IB"},M:{"2":"3"},N:{"2":"A B"},O:{"33":"0B"},P:{"33":"F 1B 2B 3B 4B"},Q:{"33":"5B"},R:{"33":"6B"}},B:5,C:"CSS image-set"};

},{}],135:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"C","260":"2 d J M H I"},C:{"1":"0 1 3 4 7 9 t u v w x y z GB FB AB CB DB","2":"2 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X XB WB","516":"6 Y Z a b c e f g h i j k l m n o L q r s"},D:{"1":"0 1 3 4 7 9 w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"F","16":"2 N K D G E A B C d","260":"v","772":"6 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u"},E:{"1":"5 B C VB p YB","2":"F PB HB","16":"N","772":"K D G E A RB SB TB UB"},F:{"1":"0 1 j k l m n o L q r s t u v w x y z","16":"E ZB","260":"5 8 B C i aB bB cB p eB","772":"6 J M H I O P Q R S T U V W X Y Z a b c e f g h"},G:{"1":"oB pB qB rB sB","2":"HB fB EB","772":"G hB JB jB kB lB mB nB"},H:{"132":"tB"},I:{"1":"4","2":"BB uB vB wB","260":"F xB EB yB zB"},J:{"2":"D","260":"A"},K:{"1":"L","260":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"1":"0B"},P:{"1":"1B 2B 3B 4B","260":"F"},Q:{"1":"5B"},R:{"1":"6B"}},B:5,C:":in-range and :out-of-range CSS pseudo-classes"};

},{}],136:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G gB","132":"A B","388":"E"},B:{"132":"2 C d J M H I"},C:{"1":"0 1 3 4 7 9 u v w x y z GB FB AB CB DB","16":"dB BB XB WB","132":"2 6 K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t","388":"F N"},D:{"1":"0 1 3 4 7 9 i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","16":"2 F N K D G E A B C d","132":"6 J M H I O P Q R S T U V W X Y Z a b c e f g h"},E:{"1":"5 B C VB p YB","16":"F N K PB HB","132":"D G E A SB TB UB","388":"RB"},F:{"1":"0 1 6 V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","16":"8 E B ZB aB bB cB p","132":"J M H I O P Q R S T U","516":"5 C eB"},G:{"1":"oB pB qB rB sB","16":"HB fB EB hB JB","132":"G jB kB lB mB nB"},H:{"516":"tB"},I:{"1":"4","16":"BB uB vB wB zB","132":"yB","388":"F xB EB"},J:{"16":"D","132":"A"},K:{"1":"L","16":"8 A B C p","516":"5"},L:{"1":"IB"},M:{"132":"3"},N:{"132":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:7,C:":indeterminate CSS pseudo-class"};

},{}],137:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"2":"0 1 2 3 4 6 7 9 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB"},D:{"2":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"2":"F N K D G PB HB RB SB TB","4":"E","164":"5 A B C UB VB p YB"},F:{"2":"0 1 5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z ZB aB bB cB p eB"},G:{"2":"G HB fB EB hB JB jB kB","164":"lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"2":"4 BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"2":"5 8 A B C L p"},L:{"2":"IB"},M:{"2":"3"},N:{"2":"A B"},O:{"2":"0B"},P:{"2":"F 1B 2B 3B 4B"},Q:{"2":"5B"},R:{"2":"6B"}},B:5,C:"CSS Initial Letter"};

},{}],138:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 3 4 6 7 9 O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","33":"2 F N K D G E A B C d J M H I XB WB","164":"dB BB"},D:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"1":"5 F N K D G E A B C HB RB SB TB UB VB p YB","16":"PB"},F:{"1":"0 1 6 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"5 8 E B C ZB aB bB cB p eB"},G:{"1":"G fB EB hB JB jB kB lB mB nB oB pB qB rB sB","16":"HB"},H:{"2":"tB"},I:{"1":"4 BB F wB xB EB yB zB","16":"uB vB"},J:{"1":"D A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:4,C:"CSS initial value"};

},{}],139:[function(require,module,exports){
module.exports={A:{A:{"1":"E A B","16":"gB","132":"K D G"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 2 3 4 6 7 9 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB"},D:{"1":"0 1 3 4 6 7 9 Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","132":"2 F N K D G E A B C d J M H I O P Q R S T U V W X Y"},E:{"1":"5 D G E A B C SB TB UB VB p YB","16":"PB","132":"F N K HB RB"},F:{"1":"0 1 6 H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","16":"E ZB","132":"5 8 B C J M aB bB cB p eB"},G:{"1":"G fB EB hB JB jB kB lB mB nB oB pB qB rB sB","16":"HB"},H:{"2":"tB"},I:{"1":"4 yB zB","16":"uB vB","132":"BB F wB xB EB"},J:{"132":"D A"},K:{"1":"L","132":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:2,C:"letter-spacing CSS property"};

},{}],140:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M","129":"H I"},C:{"2":"0 1 2 3 4 6 7 9 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB"},D:{"16":"2 F N K D G E A B C","33":"0 1 3 4 6 7 9 d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"2":"F PB HB","33":"5 N K D G E A B C RB SB TB UB VB p YB"},F:{"2":"5 8 E B C ZB aB bB cB p eB","33":"0 1 6 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z"},G:{"2":"HB fB EB","33":"G hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"16":"uB vB","33":"4 BB F wB xB EB yB zB"},J:{"33":"D A"},K:{"2":"5 8 A B C p","33":"L"},L:{"33":"IB"},M:{"2":"3"},N:{"2":"A B"},O:{"33":"0B"},P:{"33":"F 1B 2B 3B 4B"},Q:{"33":"5B"},R:{"33":"6B"}},B:7,C:"CSS line-clamp"};

},{}],141:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"1":"0 1 3 4 7 9 k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"dB","164":"2 6 BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j XB WB"},D:{"1":"iB KB IB LB MB NB OB","292":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB"},E:{"1":"5 YB","292":"F N K D G E A B C PB HB RB SB TB UB VB p"},F:{"2":"5 8 E B C ZB aB bB cB p eB","292":"0 1 6 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z"},G:{"1":"sB","292":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB"},H:{"2":"tB"},I:{"1":"4","292":"BB F uB vB wB xB EB yB zB"},J:{"292":"D A"},K:{"2":"5 8 A B C p","292":"L"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"292":"0B"},P:{"292":"F 1B 2B 3B 4B"},Q:{"292":"5B"},R:{"292":"6B"}},B:5,C:"CSS Logical Properties"};

},{}],142:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"2":"0 1 2 3 4 6 7 9 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB"},D:{"2":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"2":"F N K D G E A B PB HB RB SB TB UB VB","129":"5 C p YB"},F:{"2":"0 1 5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z ZB aB bB cB p eB"},G:{"1":"qB rB sB","2":"G HB fB EB hB JB jB kB lB mB nB oB pB"},H:{"2":"tB"},I:{"2":"4 BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"2":"5 8 A B C L p"},L:{"2":"IB"},M:{"2":"3"},N:{"2":"A B"},O:{"2":"0B"},P:{"2":"F 1B 2B 3B 4B"},Q:{"2":"5B"},R:{"2":"6B"}},B:5,C:"CSS ::marker pseudo-element"};

},{}],143:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M","3138":"H","12292":"I"},C:{"1":"0 1 3 4 7 9 w x y z GB FB AB CB DB","2":"dB BB","260":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v XB WB"},D:{"164":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"2":"PB HB","164":"5 F N K D G E A B C RB SB TB UB VB p YB"},F:{"2":"5 8 E B C ZB aB bB cB p eB","164":"0 1 6 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z"},G:{"164":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"164":"4 yB zB","676":"BB F uB vB wB xB EB"},J:{"164":"D A"},K:{"2":"5 8 A B C p","164":"L"},L:{"164":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"164":"0B"},P:{"164":"F 1B 2B 3B 4B"},Q:{"164":"5B"},R:{"164":"6B"}},B:4,C:"CSS Masks"};

},{}],144:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"16":"dB BB XB WB","548":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB"},D:{"16":"2 F N K D G E A B C d","164":"0 1 3 6 7 9 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB","1348":"4 CB DB QB iB KB IB LB MB NB OB"},E:{"2":"F PB HB","16":"N","164":"K D G RB SB TB","257":"5 E A B C UB VB p YB"},F:{"2":"5 8 E B C ZB aB bB cB p eB","164":"6 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u","1220":"0 1 v w x y z"},G:{"16":"HB fB EB hB JB","164":"G jB kB","257":"lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"16":"BB uB vB wB","164":"4 F xB EB yB zB"},J:{"16":"D","164":"A"},K:{"2":"5 8 A B C p","164":"L"},L:{"1220":"IB"},M:{"548":"3"},N:{"2":"A B"},O:{"164":"0B"},P:{"164":"F 1B 2B 3B 4B"},Q:{"164":"5B"},R:{"164":"6B"}},B:5,C:":matches() CSS pseudo-class"};

},{}],145:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"2":"0 1 2 3 6 7 9 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB XB WB","16":"4 DB"},D:{"2":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"2":"F N K D G E A B PB HB RB SB TB UB VB","132":"5 C p YB"},F:{"2":"0 1 5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z ZB aB bB cB p eB"},G:{"2":"G HB fB EB hB JB jB kB lB mB nB oB pB","132":"qB rB sB"},H:{"2":"tB"},I:{"2":"4 BB F uB vB wB xB EB yB zB"},J:{"16":"D A"},K:{"2":"5 8 A B C L p"},L:{"2":"IB"},M:{"2":"3"},N:{"2":"A B"},O:{"2":"0B"},P:{"2":"F 1B 2B 3B 4B"},Q:{"16":"5B"},R:{"16":"6B"}},B:5,C:"CSS math functions min(), max() and clamp()"};

},{}],146:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"1":"2 C d J M H I"},C:{"1":"3 4 CB DB","2":"0 1 2 6 7 9 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB XB WB"},D:{"1":"0 1 3 4 7 9 k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j"},E:{"1":"5 E A B C UB VB p YB","2":"F N K D G PB HB RB SB TB"},F:{"1":"0 1 6 X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"5 8 E B C J M H I O P Q R S T U V W ZB aB bB cB p eB"},G:{"1":"lB mB nB oB pB qB rB sB","2":"G HB fB EB hB JB jB kB"},H:{"2":"tB"},I:{"1":"4","2":"BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"1":"0B"},P:{"1":"1B 2B 3B 4B","2":"F"},Q:{"2":"5B"},R:{"1":"6B"}},B:5,C:"Media Queries: interaction media features"};

},{}],147:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G gB","132":"E A B"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 3 4 6 7 9 M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"dB BB","260":"2 F N K D G E A B C d J XB WB"},D:{"1":"0 1 3 4 6 7 9 Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","548":"2 F N K D G E A B C d J M H I O P Q R S T U V W X"},E:{"2":"PB HB","548":"5 F N K D G E A B C RB SB TB UB VB p YB"},F:{"1":"0 1 5 6 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"E","548":"8 B C ZB aB bB cB p eB"},G:{"16":"HB","548":"G fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"132":"tB"},I:{"1":"4 yB zB","16":"uB vB","548":"BB F wB xB EB"},J:{"548":"D A"},K:{"1":"5 L","548":"8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"132":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:2,C:"Media Queries: resolution feature"};

},{}],148:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"16":"2 C d J M H I"},C:{"2":"2 6 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u XB WB","16":"0 1 3 4 7 9 v w x y z GB FB AB CB DB"},D:{"2":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB","16":"MB NB OB"},E:{"2":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"2":"0 1 5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z ZB aB bB cB p eB"},G:{"2":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"2":"4 BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"2":"5 8 A B C L p"},L:{"2":"IB"},M:{"2":"3"},N:{"2":"A B"},O:{"2":"0B"},P:{"2":"F 1B 2B 3B 4B"},Q:{"2":"5B"},R:{"2":"6B"}},B:5,C:"Media Queries: scripting media feature"};

},{}],149:[function(require,module,exports){
module.exports={A:{A:{"8":"K D G gB","129":"E A B"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB","2":"dB BB"},D:{"1":"0 1 3 4 6 7 9 V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","129":"2 F N K D G E A B C d J M H I O P Q R S T U"},E:{"1":"5 D G E A B C SB TB UB VB p YB","129":"F N K RB","388":"PB HB"},F:{"1":"0 1 5 6 8 B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z ZB aB bB cB p eB","2":"E"},G:{"1":"G jB kB lB mB nB oB pB qB rB sB","129":"HB fB EB hB JB"},H:{"1":"tB"},I:{"1":"4 yB zB","129":"BB F uB vB wB xB EB"},J:{"1":"D A"},K:{"1":"5 8 A B C L p"},L:{"1":"IB"},M:{"1":"3"},N:{"129":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:2,C:"CSS3 Media Queries"};

},{}],150:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"1":"0 1 3 4 6 7 9 b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"2 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a XB WB"},D:{"1":"0 1 3 4 7 9 k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 F N K D G E A B C d J M H I O P Q R S T U V W X","194":"6 Y Z a b c e f g h i j"},E:{"2":"F N K D PB HB RB SB","260":"5 G E A B C TB UB VB p YB"},F:{"1":"0 1 6 Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"5 8 E B C J M H I O P Q R S T U V W X ZB aB bB cB p eB"},G:{"2":"HB fB EB hB JB jB","260":"G kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"1":"4","2":"BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"1":"0B"},P:{"1":"1B 2B 3B 4B","2":"F"},Q:{"1":"5B"},R:{"1":"6B"}},B:4,C:"Blending of HTML/SVG elements"};

},{}],151:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"2":"0 1 2 3 4 6 7 9 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB"},D:{"1":"0 1 3 4 7 9 L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l","194":"m n o"},E:{"2":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"1":"0 1 6 c e f g h i j k l m n o L q r s t u v w x y z","2":"5 8 E B C J M H I O P Q R S T U V W X Y ZB aB bB cB p eB","194":"Z a b"},G:{"2":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"1":"4","2":"BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"2":"3"},N:{"2":"A B"},O:{"1":"0B"},P:{"1":"1B 2B 3B 4B","2":"F"},Q:{"2":"5B"},R:{"1":"6B"}},B:5,C:"CSS Motion Path"};

},{}],152:[function(require,module,exports){
module.exports={A:{A:{"1":"E A B","2":"K D G gB"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 2 3 4 6 7 9 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB"},D:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"1":"5 F N K D G E A B C RB SB TB UB VB p YB","16":"PB HB"},F:{"1":"0 1 5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z ZB aB bB cB p eB"},G:{"1":"G EB hB JB jB kB lB mB nB oB pB qB rB sB","16":"HB fB"},H:{"1":"tB"},I:{"1":"4 BB F uB vB wB xB EB yB zB"},J:{"1":"D A"},K:{"1":"5 8 A B C L p"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:2,C:"CSS namespaces"};

},{}],153:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"2":"0 1 2 3 6 7 9 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB XB WB","16":"4 DB"},D:{"2":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB","16":"MB NB OB"},E:{"1":"5 E A B C UB VB p YB","2":"F N K D G PB HB RB SB TB"},F:{"2":"0 1 5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z ZB aB bB cB p eB"},G:{"1":"lB mB nB oB pB qB rB sB","2":"G HB fB EB hB JB jB kB"},H:{"2":"tB"},I:{"2":"4 BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"2":"5 8 A B C L p"},L:{"2":"IB"},M:{"2":"3"},N:{"2":"A B"},O:{"2":"0B"},P:{"2":"F 1B 2B 3B 4B"},Q:{"2":"5B"},R:{"2":"6B"}},B:5,C:"selector list argument of :not()"};

},{}],154:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"2":"0 1 2 3 4 6 7 9 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB"},D:{"2":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"1":"5 E A B C UB VB p YB","2":"F N K D G PB HB RB SB TB"},F:{"2":"0 1 5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z ZB aB bB cB p eB"},G:{"1":"lB mB nB oB pB qB rB sB","2":"G HB fB EB hB JB jB kB"},H:{"2":"tB"},I:{"2":"4 BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"2":"5 8 A B C L p"},L:{"2":"IB"},M:{"2":"3"},N:{"2":"A B"},O:{"2":"0B"},P:{"2":"F 1B 2B 3B 4B"},Q:{"2":"5B"},R:{"2":"6B"}},B:7,C:"selector list argument of :nth-child and :nth-last-child CSS pseudo-classes"};

},{}],155:[function(require,module,exports){
module.exports={A:{A:{"1":"E A B","4":"K D G gB"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 2 3 4 6 7 9 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB"},D:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"1":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"1":"0 1 5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z ZB aB bB cB p eB"},G:{"1":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"1":"tB"},I:{"1":"4 BB F uB vB wB xB EB yB zB"},J:{"1":"D A"},K:{"1":"5 8 A B C L p"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:2,C:"CSS3 Opacity"};

},{}],156:[function(require,module,exports){
module.exports={A:{A:{"1":"A B","2":"K D G E gB"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"dB BB XB WB"},D:{"1":"0 1 3 4 6 7 9 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","16":"2 F N K D G E A B C d"},E:{"1":"5 N K D G E A B C RB SB TB UB VB p YB","2":"F PB HB"},F:{"1":"0 1 6 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","16":"E ZB","132":"5 8 B C aB bB cB p eB"},G:{"1":"G hB JB jB kB lB mB nB oB pB qB rB sB","2":"HB fB EB"},H:{"132":"tB"},I:{"1":"4 BB F wB xB EB yB zB","16":"uB vB"},J:{"1":"D A"},K:{"1":"L","132":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:7,C:":optional CSS pseudo-class"};

},{}],157:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"2":"0 1 2 3 4 6 7 9 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB"},D:{"1":"0 1 3 4 7 9 z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y"},E:{"2":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"1":"0 1 m n o L q r s t u v w x y z","2":"5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l ZB aB bB cB p eB"},G:{"2":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"1":"4","2":"BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"2":"3"},N:{"2":"A B"},O:{"2":"0B"},P:{"1":"1B 2B 3B 4B","2":"F"},Q:{"2":"5B"},R:{"1":"6B"}},B:5,C:"CSS overflow-anchor (Scroll Anchoring)"};

},{}],158:[function(require,module,exports){
module.exports={A:{A:{"388":"K D G E A B gB"},B:{"388":"2 C d J M H I"},C:{"260":"3 4 9 FB AB CB DB","388":"0 1 2 6 7 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB XB WB"},D:{"260":"QB iB KB IB LB MB NB OB","388":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB"},E:{"388":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"260":"0 1 y z","388":"5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x ZB aB bB cB p eB"},G:{"388":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"388":"tB"},I:{"388":"4 BB F uB vB wB xB EB yB zB"},J:{"388":"D A"},K:{"388":"5 8 A B C L p"},L:{"260":"IB"},M:{"260":"3"},N:{"388":"A B"},O:{"388":"0B"},P:{"388":"F 1B 2B 3B 4B"},Q:{"388":"5B"},R:{"388":"6B"}},B:5,C:"CSS overflow property"};

},{}],159:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E gB","132":"A B"},B:{"132":"2 C d J M H","516":"I"},C:{"1":"3 4 7 9 GB FB AB CB DB","2":"0 1 2 6 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z XB WB"},D:{"1":"4 CB DB QB iB KB IB LB MB NB OB","2":"0 1 2 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB","260":"3 AB"},E:{"2":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"1":"0 1 v w x y z","2":"5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s ZB aB bB cB p eB","260":"t u"},G:{"2":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"1":"4","2":"BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"2":"5 8 A B C L p"},L:{"1":"IB"},M:{"2":"3"},N:{"132":"A B"},O:{"2":"0B"},P:{"1":"4B","2":"F 1B 2B 3B"},Q:{"2":"5B"},R:{"2":"6B"}},B:7,C:"CSS overscroll-behavior"};

},{}],160:[function(require,module,exports){
module.exports={A:{A:{"388":"A B","900":"K D G E gB"},B:{"388":"2 C d J M H I"},C:{"772":"4 CB DB","900":"0 1 2 3 6 7 9 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB XB WB"},D:{"900":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"772":"A","900":"5 F N K D G E B C PB HB RB SB TB UB VB p YB"},F:{"16":"E ZB","129":"5 8 B C aB bB cB p eB","900":"0 1 6 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z"},G:{"900":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"129":"tB"},I:{"900":"4 BB F uB vB wB xB EB yB zB"},J:{"900":"D A"},K:{"129":"5 8 A B C p","900":"L"},L:{"900":"IB"},M:{"900":"3"},N:{"388":"A B"},O:{"900":"0B"},P:{"900":"F 1B 2B 3B 4B"},Q:{"900":"5B"},R:{"900":"6B"}},B:2,C:"CSS page-break properties"};

},{}],161:[function(require,module,exports){
module.exports={A:{A:{"2":"K D gB","132":"G E A B"},B:{"132":"2 C d J M H I"},C:{"2":"2 dB BB F N K D G E A B C d J M H I XB WB","132":"0 1 3 4 6 7 9 O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB"},D:{"1":"0 1 3 4 6 7 9 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","16":"2 F N K D G E A B C d"},E:{"2":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"1":"0 1 6 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","132":"5 8 E B C ZB aB bB cB p eB"},G:{"2":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"16":"tB"},I:{"16":"4 BB F uB vB wB xB EB yB zB"},J:{"16":"D A"},K:{"16":"5 8 A B C p","258":"L"},L:{"1":"IB"},M:{"132":"3"},N:{"258":"A B"},O:{"258":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:5,C:"CSS Paged Media (@page)"};

},{}],162:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"2":"0 1 2 3 4 6 7 9 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB"},D:{"1":"4 CB DB QB iB KB IB LB MB NB OB","2":"0 1 2 3 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB"},E:{"2":"F N K D G E A B C PB HB RB SB TB UB VB p","194":"5 YB"},F:{"1":"0 1 v w x y z","2":"5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u ZB aB bB cB p eB"},G:{"2":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"1":"4","2":"BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"2":"5 8 A B C L p"},L:{"1":"IB"},M:{"2":"3"},N:{"2":"A B"},O:{"2":"0B"},P:{"2":"F 1B 2B 3B 4B"},Q:{"2":"5B"},R:{"2":"6B"}},B:5,C:"CSS Paint API"};

},{}],163:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E gB","292":"A B"},B:{"2":"2 C d J M H I"},C:{"1":"0 1 3 4 7 9 u v w x y z GB FB AB CB DB","2":"dB BB XB WB","164":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t"},D:{"1":"0 1 3 4 7 9 q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L"},E:{"1":"5 E A B C UB VB p YB","2":"F N K D G PB HB RB SB TB"},F:{"1":"0 1 6 e f g h i j k l m n o L q r s t u v w x y z","2":"5 8 E B C J M H I O P Q R S T U V W X Y Z a b c ZB aB bB cB p eB"},G:{"1":"lB mB nB oB pB qB rB sB","2":"G HB fB EB hB JB jB kB"},H:{"2":"tB"},I:{"1":"4","2":"BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"2":"5 8 A B C L p"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"1":"0B"},P:{"1":"1B 2B 3B 4B","2":"F"},Q:{"1":"5B"},R:{"1":"6B"}},B:5,C:":placeholder-shown CSS pseudo-class"};

},{}],164:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"36":"2 C d J M H I"},C:{"1":"0 1 3 4 7 9 u v w x y z GB FB AB CB DB","2":"2 dB BB F N K D G E A B C d J M H I XB WB","33":"6 O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t"},D:{"1":"0 1 3 4 7 9 GB FB AB CB DB QB iB KB IB LB MB NB OB","36":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z"},E:{"1":"5 B C VB p YB","2":"F PB HB","36":"N K D G E A RB SB TB UB"},F:{"1":"0 1 n o L q r s t u v w x y z","2":"5 8 E B C ZB aB bB cB p eB","36":"6 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m"},G:{"1":"oB pB qB rB sB","2":"HB fB","36":"G EB hB JB jB kB lB mB nB"},H:{"2":"tB"},I:{"1":"4","36":"BB F uB vB wB xB EB yB zB"},J:{"36":"D A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"36":"A B"},O:{"1":"0B"},P:{"1":"3B 4B","36":"F 1B 2B"},Q:{"36":"5B"},R:{"1":"6B"}},B:5,C:"::placeholder CSS pseudo-element"};

},{}],165:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"1":"2 d J M H I","2":"C"},C:{"16":"dB","33":"0 1 2 3 4 6 7 9 BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB"},D:{"1":"0 1 3 4 7 9 f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","16":"2 F N K D G E A B C d","132":"6 J M H I O P Q R S T U V W X Y Z a b c e"},E:{"1":"5 E A B C UB VB p YB","16":"PB HB","132":"F N K D G RB SB TB"},F:{"1":"0 1 6 S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","16":"E B ZB aB bB cB p","132":"5 8 C J M H I O P Q R eB"},G:{"1":"lB mB nB oB pB qB rB sB","16":"HB fB","132":"G EB hB JB jB kB"},H:{"2":"tB"},I:{"1":"4","16":"uB vB","132":"BB F wB xB EB yB zB"},J:{"1":"A","132":"D"},K:{"1":"L","2":"A B p","132":"5 8 C"},L:{"1":"IB"},M:{"33":"3"},N:{"2":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:1,C:"CSS :read-only and :read-write selectors"};

},{}],166:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A gB","132":"B"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 3 4 6 7 9 c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"2 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b XB WB"},D:{"1":"0 1 3 4 7 9 h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g"},E:{"1":"5 D G E A B C TB UB VB p YB","2":"F N K PB HB RB","16":"SB"},F:{"1":"0 1 6 U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"5 8 E B C J M H I O P Q R S T ZB aB bB cB p eB"},G:{"1":"G kB lB mB nB oB pB qB rB sB","2":"HB fB EB hB JB jB"},H:{"2":"tB"},I:{"1":"4 yB zB","2":"BB F uB vB wB xB EB"},J:{"2":"D A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"2":"5B"},R:{"1":"6B"}},B:5,C:"Rebeccapurple color"};

},{}],167:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"2":"0 1 2 3 4 6 7 9 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB"},D:{"33":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"2":"PB HB","33":"5 F N K D G E A B C RB SB TB UB VB p YB"},F:{"2":"5 8 E B C ZB aB bB cB p eB","33":"0 1 6 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z"},G:{"33":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"33":"4 BB F uB vB wB xB EB yB zB"},J:{"33":"D A"},K:{"2":"5 8 A B C p","33":"L"},L:{"33":"IB"},M:{"2":"3"},N:{"2":"A B"},O:{"2":"0B"},P:{"33":"F 1B 2B 3B 4B"},Q:{"33":"5B"},R:{"33":"6B"}},B:7,C:"CSS Reflections"};

},{}],168:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E gB","420":"A B"},B:{"420":"2 C d J M H I"},C:{"2":"0 1 2 3 4 6 7 9 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB"},D:{"2":"0 1 2 3 4 7 9 F N K D G E A B C d e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","36":"J M H I","66":"6 O P Q R S T U V W X Y Z a b c"},E:{"2":"5 F N K C PB HB RB p YB","33":"D G E A B SB TB UB VB"},F:{"2":"0 1 5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z ZB aB bB cB p eB"},G:{"2":"HB fB EB hB JB qB rB sB","33":"G jB kB lB mB nB oB pB"},H:{"2":"tB"},I:{"2":"4 BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"2":"5 8 A B C L p"},L:{"2":"IB"},M:{"2":"3"},N:{"420":"A B"},O:{"2":"0B"},P:{"2":"F 1B 2B 3B 4B"},Q:{"2":"5B"},R:{"2":"6B"}},B:5,C:"CSS Regions"};

},{}],169:[function(require,module,exports){
module.exports={A:{A:{"1":"A B","2":"K D G E gB"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 3 4 6 7 9 M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"dB BB XB","33":"2 F N K D G E A B C d J WB"},D:{"1":"0 1 3 4 6 7 9 V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"F N K D G E","33":"2 A B C d J M H I O P Q R S T U"},E:{"1":"5 D G E A B C SB TB UB VB p YB","2":"F N PB HB","33":"K RB"},F:{"1":"0 1 5 6 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"E B ZB aB bB cB","33":"C eB","36":"8 p"},G:{"1":"G jB kB lB mB nB oB pB qB rB sB","2":"HB fB EB","33":"hB JB"},H:{"2":"tB"},I:{"1":"4 yB zB","2":"BB uB vB wB","33":"F xB EB"},J:{"1":"A","2":"D"},K:{"1":"5 L","2":"A B","33":"C","36":"8 p"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:4,C:"CSS Repeating Gradients"};

},{}],170:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"1":"0 1 2 3 4 6 7 9 N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"dB BB XB WB","33":"F"},D:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"1":"5 F N K D G E A B C RB SB TB UB VB p YB","2":"PB HB"},F:{"1":"0 1 6 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"8 E B C ZB aB bB cB p eB","132":"5"},G:{"2":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"1":"4","2":"BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"1":"0B"},P:{"1":"1B 2B 3B 4B","2":"F"},Q:{"1":"5B"},R:{"1":"6B"}},B:4,C:"CSS resize property"};

},{}],171:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"2":"0 1 2 3 4 6 7 9 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB"},D:{"2":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"1":"5 A B C UB VB p YB","2":"F N K D G E PB HB RB SB TB"},F:{"2":"0 1 5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z ZB aB bB cB p eB"},G:{"1":"mB nB oB pB qB rB sB","2":"G HB fB EB hB JB jB kB lB"},H:{"2":"tB"},I:{"2":"4 BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"2":"5 8 A B C L p"},L:{"2":"IB"},M:{"2":"3"},N:{"2":"A B"},O:{"2":"0B"},P:{"2":"F 1B 2B 3B 4B"},Q:{"2":"5B"},R:{"2":"6B"}},B:5,C:"CSS revert value"};

},{}],172:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"1":"0 1 3 4 7 9 s t u v w x y z GB FB AB CB DB","2":"2 6 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r XB WB"},D:{"1":"3 4 9 AB CB DB QB iB KB IB LB MB NB OB","2":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u","194":"0 1 7 v w x y z GB FB"},E:{"1":"5 A B C VB p YB","2":"F N K D G E PB HB RB SB TB UB"},F:{"1":"0 1 v w x y z","2":"5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h ZB aB bB cB p eB","194":"i j k l m n o L q r s t u"},G:{"1":"nB oB pB qB rB sB","2":"G HB fB EB hB JB jB kB lB mB"},H:{"2":"tB"},I:{"1":"4","2":"BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"2":"5 8 A B C L p"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"2":"0B"},P:{"1":"4B","2":"F","194":"1B 2B 3B"},Q:{"194":"5B"},R:{"194":"6B"}},B:7,C:"#rrggbbaa hex color notation"};

},{}],173:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"1":"0 1 3 4 7 9 f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"2 6 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e XB WB"},D:{"2":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j","129":"3 4 9 FB AB CB DB QB iB KB IB LB MB NB OB","450":"0 1 7 k l m n o L q r s t u v w x y z GB"},E:{"2":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"2":"5 8 E B C J M H I O P Q R S T U V W ZB aB bB cB p eB","129":"0 1 r s t u v w x y z","450":"6 X Y Z a b c e f g h i j k l m n o L q"},G:{"2":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"1":"4","2":"BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"2":"5 8 A B C L p"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"2":"0B"},P:{"1":"4B","2":"F 1B 2B 3B"},Q:{"450":"5B"},R:{"2":"6B"}},B:5,C:"CSSOM Scroll-behavior"};

},{}],174:[function(require,module,exports){
module.exports={A:{A:{"132":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"2":"0 1 2 6 7 9 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB XB WB","3074":"AB","4100":"3 4 CB DB"},D:{"292":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"16":"F N PB HB","292":"5 K D G E A B C RB SB TB UB VB p YB"},F:{"2":"5 8 E B C ZB aB bB cB p eB","292":"0 1 6 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z"},G:{"16":"HB fB EB hB JB","292":"jB","804":"G kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"16":"uB vB","292":"4 BB F wB xB EB yB zB"},J:{"292":"D A"},K:{"2":"5 8 A B C p","292":"L"},L:{"292":"IB"},M:{"2":"3"},N:{"2":"A B"},O:{"292":"0B"},P:{"292":"F 1B 2B 3B 4B"},Q:{"292":"5B"},R:{"292":"6B"}},B:7,C:"CSS scrollbar styling"};

},{}],175:[function(require,module,exports){
module.exports={A:{A:{"1":"D G E A B","2":"gB","8":"K"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 2 3 4 6 7 9 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB"},D:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"1":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"1":"0 1 5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z ZB aB bB cB p eB"},G:{"1":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"1":"tB"},I:{"1":"4 BB F uB vB wB xB EB yB zB"},J:{"1":"D A"},K:{"1":"5 8 A B C L p"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:2,C:"CSS 2.1 selectors"};

},{}],176:[function(require,module,exports){
module.exports={A:{A:{"1":"E A B","2":"gB","8":"K","132":"D G"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB","2":"dB BB"},D:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"1":"5 F N K D G E A B C HB RB SB TB UB VB p YB","2":"PB"},F:{"1":"0 1 5 6 8 B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z ZB aB bB cB p eB","2":"E"},G:{"1":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"1":"tB"},I:{"1":"4 BB F uB vB wB xB EB yB zB"},J:{"1":"D A"},K:{"1":"5 8 A B C L p"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:2,C:"CSS3 selectors"};

},{}],177:[function(require,module,exports){
module.exports={A:{A:{"1":"E A B","2":"K D G gB"},B:{"1":"2 C d J M H I"},C:{"1":"3 4 9 AB CB DB","33":"0 1 2 6 7 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB XB WB"},D:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"1":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"1":"0 1 5 6 8 B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z ZB aB bB cB p eB","2":"E"},G:{"2":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"1":"4 yB zB","2":"BB F uB vB wB xB EB"},J:{"1":"A","2":"D"},K:{"1":"5 8 C L","16":"A B p"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:5,C:"::selection CSS pseudo-element"};

},{}],178:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"1":"3 4 9 AB CB DB","2":"2 6 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t XB WB","322":"0 1 7 u v w x y z GB FB"},D:{"1":"0 1 3 4 7 9 g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c","194":"6 e f"},E:{"1":"5 B C VB p YB","2":"F N K D PB HB RB SB","33":"G E A TB UB"},F:{"1":"0 1 6 T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"5 8 E B C J M H I O P Q R S ZB aB bB cB p eB"},G:{"1":"oB pB qB rB sB","2":"HB fB EB hB JB jB","33":"G kB lB mB nB"},H:{"2":"tB"},I:{"1":"4","2":"BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:4,C:"CSS Shapes Level 1"};

},{}],179:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E gB","6308":"A","6436":"B"},B:{"6436":"2 C d J M H I"},C:{"2":"2 6 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h XB WB","2052":"0 1 3 4 7 9 i j k l m n o L q r s t u v w x y z GB FB AB CB DB"},D:{"1":"iB KB IB LB MB NB OB","2":"0 1 2 3 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB","8258":"4 DB QB"},E:{"1":"5 B C p YB","2":"F N K D G PB HB RB SB TB","3108":"E A UB VB"},F:{"2":"5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w ZB aB bB cB p eB","8258":"0 1 x y z"},G:{"1":"pB qB rB sB","2":"G HB fB EB hB JB jB kB","3108":"lB mB nB oB"},H:{"2":"tB"},I:{"1":"4","2":"BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"2":"5 8 A B C L p"},L:{"1":"IB"},M:{"2052":"3"},N:{"2":"A B"},O:{"2":"0B"},P:{"2":"F 1B 2B 3B 4B"},Q:{"2":"5B"},R:{"2":"6B"}},B:4,C:"CSS Scroll snap"};

},{}],180:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J","4100":"M H I"},C:{"1":"3 4 7 9 GB FB AB CB DB","2":"2 dB BB F N K D G E A B C d J M H I O P Q R S T U XB WB","194":"V W X Y Z a","516":"0 1 6 b c e f g h i j k l m n o L q r s t u v w x y z"},D:{"2":"2 F N K D G E A B C d J M H I O P Q R g h i j k l m n o L q r s t u","322":"6 S T U V W X Y Z a b c e f v w x y","1028":"0 1 3 4 7 9 z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"2":"F N K PB HB RB","33":"5 G E A B C TB UB VB p YB","2084":"D SB"},F:{"2":"5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h ZB aB bB cB p eB","322":"i j k","1028":"0 1 l m n o L q r s t u v w x y z"},G:{"2":"HB fB EB hB","33":"G kB lB mB nB oB pB qB rB sB","2084":"JB jB"},H:{"2":"tB"},I:{"2":"BB F uB vB wB xB EB yB zB","1028":"4"},J:{"2":"D A"},K:{"2":"5 8 A B C p","1028":"L"},L:{"1028":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"1028":"0B"},P:{"1":"2B 3B 4B","2":"F 1B"},Q:{"322":"5B"},R:{"2":"6B"}},B:5,C:"CSS position:sticky"};

},{}],181:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 3 4 6 7 9 S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"2 dB BB F N K D G E A B C d J M H I O XB WB","66":"P Q R"},D:{"1":"0 1 3 4 6 7 9 X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 F N K D G E A B C d J M H I O P Q R S T U V W"},E:{"1":"5 E A B C UB VB p YB","2":"F N K D G PB HB RB SB TB"},F:{"1":"0 1 6 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"8 E B C ZB aB bB cB p eB","132":"5"},G:{"1":"lB mB nB oB pB qB rB sB","2":"G HB fB EB hB JB jB kB"},H:{"132":"tB"},I:{"1":"4 yB zB","2":"BB F uB vB wB xB EB"},J:{"2":"D A"},K:{"1":"L","2":"8 A B C p","132":"5"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:4,C:"CSS.supports() API"};

},{}],182:[function(require,module,exports){
module.exports={A:{A:{"1":"G E A B","2":"K D gB"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 2 3 4 6 7 9 BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB","132":"dB"},D:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"1":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"1":"0 1 5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z ZB aB bB cB p eB"},G:{"1":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"1":"tB"},I:{"1":"4 BB F uB vB wB xB EB yB zB"},J:{"1":"D A"},K:{"1":"5 8 A B C L p"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:2,C:"CSS Table display"};

},{}],183:[function(require,module,exports){
module.exports={A:{A:{"132":"K D G E A B gB"},B:{"4":"2 C d J M H I"},C:{"1":"0 1 3 4 7 9 s t u v w x y z GB FB AB CB DB","2":"dB BB F N K D G E A B XB WB","33":"2 6 C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r"},D:{"1":"0 1 3 4 7 9 q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c","322":"e f g h i j k l m n o L"},E:{"2":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"1":"0 1 6 e f g h i j k l m n o L q r s t u v w x y z","2":"5 8 E B C J M H I O P Q ZB aB bB cB p eB","578":"R S T U V W X Y Z a b c"},G:{"2":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"1":"4","2":"BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"2":"5 8 A B C L p"},L:{"1":"IB"},M:{"1":"3"},N:{"132":"A B"},O:{"1":"0B"},P:{"1":"1B 2B 3B 4B","2":"F"},Q:{"2":"5B"},R:{"1":"6B"}},B:5,C:"CSS3 text-align-last"};

},{}],184:[function(require,module,exports){
module.exports={A:{A:{"132":"K D G E A B gB"},B:{"132":"2 C d J M H I"},C:{"132":"0 1 2 3 4 6 7 9 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB"},D:{"132":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g","388":"0 1 3 4 7 9 h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"132":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"132":"5 8 E B C J M H I O P Q R S T ZB aB bB cB p eB","388":"0 1 6 U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z"},G:{"132":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"132":"tB"},I:{"132":"4 BB F uB vB wB xB EB yB zB"},J:{"132":"D A"},K:{"132":"5 8 A B C p","388":"L"},L:{"388":"IB"},M:{"132":"3"},N:{"132":"A B"},O:{"132":"0B"},P:{"132":"F","388":"1B 2B 3B 4B"},Q:{"388":"5B"},R:{"388":"6B"}},B:5,C:"CSS text-indent"};

},{}],185:[function(require,module,exports){
module.exports={A:{A:{"16":"K D gB","132":"G E A B"},B:{"132":"2 C d J M H I"},C:{"2":"2 6 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w XB WB","1025":"0 1 3 4 7 9 y z GB FB AB CB DB","1602":"x"},D:{"2":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l","322":"0 1 3 4 7 9 m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"2":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"2":"5 8 E B C J M H I O P Q R S T U V W X Y ZB aB bB cB p eB","322":"0 1 6 Z a b c e f g h i j k l m n o L q r s t u v w x y z"},G:{"2":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"2":"BB F uB vB wB xB EB yB zB","322":"4"},J:{"2":"D A"},K:{"2":"5 8 A B C p","322":"L"},L:{"322":"IB"},M:{"1025":"3"},N:{"132":"A B"},O:{"2":"0B"},P:{"2":"F","322":"1B 2B 3B 4B"},Q:{"322":"5B"},R:{"322":"6B"}},B:5,C:"CSS text-justify"};

},{}],186:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"1":"0 1 3 4 7 9 k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"2 6 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g XB WB","194":"h i j"},D:{"1":"0 1 3 4 7 9 r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q"},E:{"2":"F N K D G E PB HB RB SB TB UB","16":"A","33":"5 B C VB p YB"},F:{"1":"0 1 e f g h i j k l m n o L q r s t u v w x y z","2":"5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c ZB aB bB cB p eB"},G:{"1":"nB oB pB qB rB sB","2":"G HB fB EB hB JB jB kB lB mB"},H:{"2":"tB"},I:{"1":"4","2":"BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"1":"0B"},P:{"1":"1B 2B 3B 4B","2":"F"},Q:{"2":"5B"},R:{"1":"6B"}},B:4,C:"CSS text-orientation"};

},{}],187:[function(require,module,exports){
module.exports={A:{A:{"2":"K D gB","161":"G E A B"},B:{"161":"2 C d J M H I"},C:{"2":"0 1 2 3 4 6 7 9 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB"},D:{"2":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"2":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"2":"0 1 5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z ZB aB bB cB p eB"},G:{"2":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"2":"4 BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"2":"5 8 A B C L p"},L:{"2":"IB"},M:{"2":"3"},N:{"16":"A B"},O:{"2":"0B"},P:{"2":"F 1B 2B 3B 4B"},Q:{"2":"5B"},R:{"2":"6B"}},B:5,C:"CSS Text 4 text-spacing"};

},{}],188:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E gB","129":"A B"},B:{"129":"2 C d J M H I"},C:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB","2":"dB BB"},D:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"1":"5 F N K D G E A B C RB SB TB UB VB p YB","260":"PB HB"},F:{"1":"0 1 5 6 8 B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z ZB aB bB cB p eB","2":"E"},G:{"1":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"4":"tB"},I:{"1":"4 BB F uB vB wB xB EB yB zB"},J:{"1":"A","4":"D"},K:{"1":"5 8 A B C L p"},L:{"1":"IB"},M:{"1":"3"},N:{"129":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:4,C:"CSS3 Text-shadow"};

},{}],189:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E gB","132":"B","164":"A"},B:{"132":"2 C d J M H I"},C:{"2":"0 1 2 3 4 6 7 9 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB"},D:{"1":"0 1 3 4 7 9 z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x","260":"y"},E:{"2":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"1":"0 1 m n o L q r s t u v w x y z","2":"5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k ZB aB bB cB p eB","260":"l"},G:{"2":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"1":"4","2":"BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"2":"5 8 A B C L p"},L:{"1":"IB"},M:{"2":"3"},N:{"132":"B","164":"A"},O:{"2":"0B"},P:{"1":"1B 2B 3B 4B","16":"F"},Q:{"2":"5B"},R:{"1":"6B"}},B:5,C:"CSS touch-action level 2 values"};

},{}],190:[function(require,module,exports){
module.exports={A:{A:{"1":"B","2":"K D G E gB","289":"A"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 3 4 7 9 GB FB AB CB DB","2":"2 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X XB WB","194":"6 Y Z a b c e f g h i j k l m n o L q r s t u","1025":"v w x y z"},D:{"1":"0 1 3 4 7 9 f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e"},E:{"2":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"1":"0 1 6 S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"5 8 E B C J M H I O P Q R ZB aB bB cB p eB"},G:{"2":"G HB fB EB hB JB jB kB lB","516":"mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"1":"4","2":"BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"B","289":"A"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:2,C:"CSS touch-action property"};

},{}],191:[function(require,module,exports){
module.exports={A:{A:{"1":"A B","2":"K D G E gB"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 3 4 6 7 9 M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"dB BB XB WB","33":"2 N K D G E A B C d J","164":"F"},D:{"1":"0 1 3 4 6 7 9 V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","33":"2 F N K D G E A B C d J M H I O P Q R S T U"},E:{"1":"5 D G E A B C SB TB UB VB p YB","33":"K RB","164":"F N PB HB"},F:{"1":"0 1 5 6 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"E ZB aB","33":"C","164":"8 B bB cB p eB"},G:{"1":"G jB kB lB mB nB oB pB qB rB sB","33":"JB","164":"HB fB EB hB"},H:{"2":"tB"},I:{"1":"4 yB zB","33":"BB F uB vB wB xB EB"},J:{"1":"A","33":"D"},K:{"1":"5 L","33":"C","164":"8 A B p"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:5,C:"CSS3 Transitions"};

},{}],192:[function(require,module,exports){
module.exports={A:{A:{"132":"K D G E A B gB"},B:{"132":"2 C d J M H I"},C:{"1":"0 1 3 4 7 9 t u v w x y z GB FB AB CB DB","33":"6 H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s","132":"dB BB F N K D G E XB WB","292":"2 A B C d J M"},D:{"1":"0 1 3 4 7 9 r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","132":"2 F N K D G E A B C d J M","548":"6 H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q"},E:{"132":"F N K D G PB HB RB SB TB","548":"5 E A B C UB VB p YB"},F:{"132":"0 1 5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z ZB aB bB cB p eB"},G:{"132":"G HB fB EB hB JB jB kB","548":"lB mB nB oB pB qB rB sB"},H:{"16":"tB"},I:{"1":"4","16":"BB F uB vB wB xB EB yB zB"},J:{"16":"D A"},K:{"16":"5 8 A B C L p"},L:{"1":"IB"},M:{"1":"3"},N:{"132":"A B"},O:{"16":"0B"},P:{"1":"1B 2B 3B 4B","16":"F"},Q:{"16":"5B"},R:{"16":"6B"}},B:4,C:"CSS unicode-bidi property"};

},{}],193:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"1":"2 d J M H I","2":"C"},C:{"1":"0 1 3 4 6 7 9 W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"2 dB BB F N K D G E A B C d J M H I O P Q R S T U V XB WB"},D:{"1":"0 1 3 4 7 9 k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j"},E:{"1":"5 A B C UB VB p YB","2":"F N K D G E PB HB RB SB TB"},F:{"1":"0 1 6 X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"5 8 E B C J M H I O P Q R S T U V W ZB aB bB cB p eB"},G:{"1":"mB nB oB pB qB rB sB","2":"G HB fB EB hB JB jB kB lB"},H:{"2":"tB"},I:{"1":"4","2":"BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"2":"5 8 A B C L p"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"2":"5B"},R:{"1":"6B"}},B:4,C:"CSS unset value"};

},{}],194:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"1":"M H I","2":"2 C d","260":"J"},C:{"1":"0 1 3 4 6 7 9 a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"2 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z XB WB"},D:{"1":"0 1 3 4 7 9 s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q","194":"r"},E:{"1":"5 A B C UB VB p YB","2":"F N K D G E PB HB RB SB TB"},F:{"1":"0 1 f g h i j k l m n o L q r s t u v w x y z","2":"5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c ZB aB bB cB p eB","194":"e"},G:{"1":"mB nB oB pB qB rB sB","2":"G HB fB EB hB JB jB kB lB"},H:{"2":"tB"},I:{"1":"4","2":"BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"1":"0B"},P:{"1":"1B 2B 3B 4B","2":"F"},Q:{"2":"5B"},R:{"2":"6B"}},B:4,C:"CSS Variables (Custom Properties)"};

},{}],195:[function(require,module,exports){
module.exports={A:{A:{"1":"A B","2":"K D gB","129":"G E"},B:{"1":"2 C d J M H I"},C:{"2":"0 1 2 3 4 6 7 9 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB"},D:{"1":"0 1 3 4 6 7 9 U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 F N K D G E A B C d J M H I O P Q R S T"},E:{"1":"5 D G E A B C TB UB VB p YB","2":"F N K PB HB RB SB"},F:{"1":"0 1 5 6 C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","129":"8 E B ZB aB bB cB p eB"},G:{"1":"G jB kB lB mB nB oB pB qB rB sB","2":"HB fB EB hB JB"},H:{"1":"tB"},I:{"1":"4 yB zB","2":"BB F uB vB wB xB EB"},J:{"2":"D A"},K:{"1":"5 L","2":"8 A B C p"},L:{"1":"IB"},M:{"2":"3"},N:{"1":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:2,C:"CSS widows & orphans"};

},{}],196:[function(require,module,exports){
module.exports={A:{A:{"132":"K D G E A B gB"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 3 4 7 9 k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"2 6 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e XB WB","322":"f g h i j"},D:{"1":"0 1 3 4 7 9 r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"F N K","16":"D","33":"2 6 G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q"},E:{"1":"5 B C p YB","2":"F PB HB","16":"N","33":"K D G E A RB SB TB UB VB"},F:{"1":"0 1 e f g h i j k l m n o L q r s t u v w x y z","2":"5 8 E B C ZB aB bB cB p eB","33":"6 J M H I O P Q R S T U V W X Y Z a b c"},G:{"1":"pB qB rB sB","16":"HB fB EB","33":"G hB JB jB kB lB mB nB oB"},H:{"2":"tB"},I:{"1":"4","2":"uB vB wB","33":"BB F xB EB yB zB"},J:{"33":"D A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"36":"A B"},O:{"1":"0B"},P:{"1":"1B 2B 3B 4B","33":"F"},Q:{"33":"5B"},R:{"1":"6B"}},B:4,C:"CSS writing-mode property"};

},{}],197:[function(require,module,exports){
module.exports={A:{A:{"1":"K D gB","129":"G E A B"},B:{"1":"2 C d J M H I"},C:{"2":"0 1 2 3 4 6 7 9 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB"},D:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"1":"5 F N K D G E A B C RB SB TB UB VB p YB","2":"PB HB"},F:{"1":"0 1 6 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"5 8 E B C ZB aB bB cB p eB"},G:{"1":"G fB EB hB JB jB kB lB mB nB oB pB qB rB sB","2":"HB"},H:{"2":"tB"},I:{"1":"4 BB F uB vB wB xB EB yB zB"},J:{"1":"D A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"2":"3"},N:{"129":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:7,C:"CSS zoom"};

},{}],198:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"2":"0 1 2 3 4 6 7 9 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB"},D:{"2":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"2":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"2":"0 1 5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z ZB aB bB cB p eB"},G:{"2":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"2":"4 BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"2":"5 8 A B C L p"},L:{"2":"IB"},M:{"2":"3"},N:{"2":"A B"},O:{"2":"0B"},P:{"2":"F 1B 2B 3B 4B"},Q:{"2":"5B"},R:{"2":"6B"}},B:4,C:"CSS3 attr() function for all properties"};

},{}],199:[function(require,module,exports){
module.exports={A:{A:{"1":"G E A B","8":"K D gB"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 3 4 6 7 9 Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","33":"2 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X XB WB"},D:{"1":"0 1 2 3 4 6 7 9 A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","33":"F N K D G E"},E:{"1":"5 K D G E A B C RB SB TB UB VB p YB","33":"F N PB HB"},F:{"1":"0 1 5 6 8 B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z ZB aB bB cB p eB","2":"E"},G:{"1":"G hB JB jB kB lB mB nB oB pB qB rB sB","33":"HB fB EB"},H:{"1":"tB"},I:{"1":"4 F xB EB yB zB","33":"BB uB vB wB"},J:{"1":"A","33":"D"},K:{"1":"5 8 A B C L p"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:5,C:"CSS3 Box-sizing"};

},{}],200:[function(require,module,exports){
module.exports={A:{A:{"1":"E A B","2":"K D G gB"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 2 3 4 6 7 9 BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB","4":"dB"},D:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"1":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"1":"0 1 5 6 8 B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z aB bB cB p eB","2":"E","4":"ZB"},G:{"1":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"1":"tB"},I:{"1":"4 BB F uB vB wB xB EB yB zB"},J:{"1":"D A"},K:{"1":"5 8 A B C L p"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:2,C:"CSS3 Colors"};

},{}],201:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"1":"J M H I","2":"2 C d"},C:{"1":"0 1 3 4 6 7 9 W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","33":"2 dB BB F N K D G E A B C d J M H I O P Q R S T U V XB WB"},D:{"1":"QB iB KB IB LB MB NB OB","33":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB"},E:{"1":"5 B C p YB","33":"F N K D G E A PB HB RB SB TB UB VB"},F:{"1":"0 1 5 C y z eB","2":"8 E B ZB aB bB cB p","33":"6 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x"},G:{"2":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"1":"4","2":"BB F uB vB wB xB EB yB zB"},J:{"33":"D A"},K:{"2":"5 8 A B C p","33":"L"},L:{"1":"IB"},M:{"2":"3"},N:{"2":"A B"},O:{"2":"0B"},P:{"2":"F 1B 2B 3B 4B"},Q:{"33":"5B"},R:{"2":"6B"}},B:3,C:"CSS grab & grabbing cursors"};

},{}],202:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 3 4 6 7 9 T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","33":"2 dB BB F N K D G E A B C d J M H I O P Q R S XB WB"},D:{"1":"0 1 3 4 7 9 g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","33":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f"},E:{"1":"5 E A B C UB VB p YB","33":"F N K D G PB HB RB SB TB"},F:{"1":"0 1 5 6 C T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z eB","2":"8 E B ZB aB bB cB p","33":"J M H I O P Q R S"},G:{"2":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"1":"4","2":"BB F uB vB wB xB EB yB zB"},J:{"33":"D A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"2":"3"},N:{"2":"A B"},O:{"2":"0B"},P:{"2":"F 1B 2B 3B 4B"},Q:{"2":"5B"},R:{"2":"6B"}},B:4,C:"CSS3 Cursors: zoom-in & zoom-out"};

},{}],203:[function(require,module,exports){
module.exports={A:{A:{"1":"E A B","132":"K D G gB"},B:{"1":"d J M H I","260":"2 C"},C:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","4":"dB BB XB WB"},D:{"1":"0 1 2 3 4 6 7 9 N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","4":"F"},E:{"1":"5 N K D G E A B C RB SB TB UB VB p YB","4":"F PB HB"},F:{"1":"0 1 6 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","260":"5 8 E B C ZB aB bB cB p eB"},G:{"2":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"1":"4","2":"BB F uB vB wB xB EB yB zB"},J:{"2":"D","16":"A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"2":"3"},N:{"2":"A B"},O:{"2":"0B"},P:{"2":"F 1B 2B 3B 4B"},Q:{"2":"5B"},R:{"2":"6B"}},B:4,C:"CSS3 Cursors (original values)"};

},{}],204:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"2":"dB BB XB WB","33":"0 1 3 4 7 9 w x y z GB FB AB CB DB","164":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v"},D:{"1":"0 1 3 4 7 9 l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 F N K D G E A B C d J M H I O P","132":"6 Q R S T U V W X Y Z a b c e f g h i j k"},E:{"2":"F N K PB HB RB","132":"5 D G E A B C SB TB UB VB p YB"},F:{"1":"0 1 6 Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"E ZB aB bB","132":"J M H I O P Q R S T U V W X","164":"5 8 B C cB p eB"},G:{"2":"HB fB EB hB JB","132":"G jB kB lB mB nB oB pB qB rB sB"},H:{"164":"tB"},I:{"1":"4","2":"BB F uB vB wB xB EB","132":"yB zB"},J:{"132":"D A"},K:{"1":"L","2":"A","164":"5 8 B C p"},L:{"1":"IB"},M:{"33":"3"},N:{"2":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:5,C:"CSS3 tab-size"};

},{}],205:[function(require,module,exports){
module.exports={A:{A:{"1":"E A B","2":"K D G gB"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 2 3 4 6 7 9 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB"},D:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"1":"5 F N K D G E A B C RB SB TB UB VB p YB","2":"PB HB"},F:{"1":"0 1 5 6 8 B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z ZB aB bB cB p eB","2":"E"},G:{"1":"G fB EB hB JB jB kB lB mB nB oB pB qB rB sB","16":"HB"},H:{"1":"tB"},I:{"1":"4 BB F uB vB wB xB EB yB zB"},J:{"1":"D A"},K:{"1":"5 8 A B C L p"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:2,C:"CSS currentColor value"};

},{}],206:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E gB","8":"A B"},B:{"8":"2 C d J M H I"},C:{"2":"2 3 4 7 9 dB BB F N K D G E A B C d J M H I O P Q R GB FB AB CB DB XB WB","194":"S T U V W X Y","200":"0 1 6 Z a b c e f g h i j k l m n o L q r s t u v w x y z"},D:{"1":"0 1 3 4 6 7 9 c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB","2":"2 F N K D G E A B C d J M H I O P Q R S T U V MB NB OB","66":"W X Y Z a b"},E:{"2":"F N PB HB RB","8":"5 K D G E A B C SB TB UB VB p YB"},F:{"1":"0 1 6 P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"5 8 E B C ZB aB bB cB p eB","66":"J M H I O"},G:{"2":"HB fB EB hB JB","8":"G jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"1":"4 zB","2":"BB F uB vB wB xB EB yB"},J:{"2":"D A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"2":"3"},N:{"2":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:7,C:"Custom Elements (deprecated V0 spec)"};

},{}],207:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E gB","8":"A B"},B:{"8":"2 C d J M H I"},C:{"1":"3 4 AB CB DB","2":"2 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y XB WB","8":"6 Z a b c e f g h i j k l m n o L q r s","456":"0 1 t u v w x y z","712":"7 9 GB FB"},D:{"1":"4 QB iB KB IB LB MB NB OB","2":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u","8":"v w","132":"0 1 3 7 9 x y z GB FB AB CB DB"},E:{"2":"F N K D PB HB RB SB TB","8":"G E A UB","132":"5 B C VB p YB"},F:{"2":"5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j ZB aB bB cB p eB","132":"0 1 k l m n o L q r s t u v w x y z"},G:{"2":"G HB fB EB hB JB jB kB lB mB nB","132":"oB pB qB rB sB"},H:{"2":"tB"},I:{"1":"4","2":"BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"2":"5 8 A B C p","132":"L"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"1":"0B"},P:{"1":"2B 3B 4B","2":"F","132":"1B"},Q:{"8":"5B"},R:{"132":"6B"}},B:1,C:"Custom Elements (V1)"};

},{}],208:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G gB","132":"E A B"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 2 3 4 6 7 9 B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"dB BB F N XB WB","132":"K D G E A"},D:{"1":"0 1 3 4 6 7 9 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"F","16":"2 N K D G d","388":"E A B C"},E:{"1":"5 D G E A B C SB TB UB VB p YB","2":"F PB HB","16":"N K","388":"RB"},F:{"1":"0 1 5 6 C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z eB","2":"E ZB aB bB cB","132":"8 B p"},G:{"1":"G JB jB kB lB mB nB oB pB qB rB sB","2":"fB","16":"HB EB","388":"hB"},H:{"1":"tB"},I:{"1":"4 yB zB","2":"uB vB wB","388":"BB F xB EB"},J:{"1":"A","388":"D"},K:{"1":"5 C L","2":"A","132":"8 B p"},L:{"1":"IB"},M:{"1":"3"},N:{"132":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:1,C:"CustomEvent"};

},{}],209:[function(require,module,exports){
module.exports={A:{A:{"2":"gB","8":"K D G E","260":"A B"},B:{"260":"2 C d J","1284":"M H I"},C:{"8":"dB BB XB WB","516":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB"},D:{"1":"iB KB IB LB MB NB OB","8":"2 F N K D G E A B C d J M H I O","132":"0 1 3 4 6 7 9 P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB"},E:{"1":"5 YB","8":"F N K D G E A B C PB HB RB SB TB UB VB p"},F:{"1":"5 8 E B C ZB aB bB cB p eB","132":"0 1 6 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z"},G:{"1":"sB","8":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB"},H:{"2":"tB"},I:{"1":"zB","8":"BB F uB vB wB xB EB yB","132":"4"},J:{"1":"A","8":"D"},K:{"1":"5 8 A B C p","8":"L"},L:{"1":"IB"},M:{"516":"3"},N:{"8":"A B"},O:{"8":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:1,C:"Datalist element"};

},{}],210:[function(require,module,exports){
module.exports={A:{A:{"1":"B","4":"K D G E A gB"},B:{"1":"2 C d J M","129":"H I"},C:{"1":"2 6 K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t","4":"dB BB F N XB WB","129":"0 1 3 4 7 9 u v w x y z GB FB AB CB DB"},D:{"1":"o L q r s t u v w x","4":"F N K","129":"0 1 2 3 4 6 7 9 D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"4":"F N PB HB","129":"5 K D G E A B C RB SB TB UB VB p YB"},F:{"1":"5 6 8 C b c e f g h i j k p eB","4":"E B ZB aB bB cB","129":"0 1 J M H I O P Q R S T U V W X Y Z a l m n o L q r s t u v w x y z"},G:{"4":"HB fB EB","129":"G hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"4":"tB"},I:{"4":"uB vB wB","129":"4 BB F xB EB yB zB"},J:{"129":"D A"},K:{"1":"5 8 C p","4":"A B","129":"L"},L:{"129":"IB"},M:{"129":"3"},N:{"1":"B","4":"A"},O:{"129":"0B"},P:{"129":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"129":"6B"}},B:1,C:"dataset & data-* attributes"};

},{}],211:[function(require,module,exports){
module.exports={A:{A:{"2":"K D gB","132":"G","260":"E A B"},B:{"260":"2 C J M H I","772":"d"},C:{"1":"0 1 2 3 4 6 7 9 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB"},D:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"1":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"1":"0 1 5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z ZB aB bB cB p eB"},G:{"1":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"1":"tB"},I:{"1":"4 BB F uB vB wB xB EB yB zB"},J:{"1":"D A"},K:{"1":"5 8 A B C L p"},L:{"1":"IB"},M:{"1":"3"},N:{"260":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:6,C:"Data URIs"};

},{}],212:[function(require,module,exports){
module.exports={A:{A:{"2":"E A B gB","8":"K D G"},B:{"2":"2 C d J M H I"},C:{"1":"0 1 3 4 7 9 s t u v w x y z GB FB AB CB DB","2":"dB","8":"2 6 BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L XB WB","194":"q r"},D:{"1":"0 1 3 4 7 9 f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","8":"F N K D G E A B","257":"6 O P Q R S T U V W X Y Z a b c e","769":"2 C d J M H I"},E:{"1":"5 C YB","8":"F N PB HB RB","257":"K D G E A SB TB UB","1025":"B VB p"},F:{"1":"0 1 6 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"5 8 C p eB","8":"E B ZB aB bB cB"},G:{"1":"G JB jB kB lB mB qB rB sB","8":"HB fB EB hB","1025":"nB oB pB"},H:{"8":"tB"},I:{"1":"4 F xB EB yB zB","8":"BB uB vB wB"},J:{"1":"A","8":"D"},K:{"1":"L","8":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"769":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:1,C:"Details & Summary elements"};

},{}],213:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A gB","132":"B"},B:{"1":"2 C d J M H I"},C:{"2":"dB BB XB","4":"0 1 2 3 4 6 7 9 K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","8":"F N WB"},D:{"2":"F N K","4":"0 1 2 3 4 6 7 9 D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"2":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"2":"5 8 E B C ZB aB bB cB p eB","4":"0 1 6 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z"},G:{"2":"HB fB","4":"G EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"2":"uB vB wB","4":"4 BB F xB EB yB zB"},J:{"2":"D","4":"A"},K:{"1":"5 C","2":"8 A B p","4":"L"},L:{"4":"IB"},M:{"4":"3"},N:{"1":"B","2":"A"},O:{"4":"0B"},P:{"4":"F 1B 2B 3B 4B"},Q:{"4":"5B"},R:{"4":"6B"}},B:4,C:"DeviceOrientation & DeviceMotion events"};

},{}],214:[function(require,module,exports){
module.exports={A:{A:{"1":"B","2":"K D G E A gB"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 3 4 6 7 9 I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"2 dB BB F N K D G E A B C d J M H XB WB"},D:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"1":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"1":"0 1 5 6 C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z eB","2":"8 E B ZB aB bB cB p"},G:{"1":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"1":"tB"},I:{"1":"4 BB F uB vB wB xB EB yB zB"},J:{"1":"D A"},K:{"1":"5 C L","2":"8 A B p"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"B","2":"A"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:5,C:"Window.devicePixelRatio"};

},{}],215:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"2":"2 6 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v XB WB","194":"0 1 3 4 7 9 w x y z GB FB AB CB DB"},D:{"1":"0 1 3 4 7 9 g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a","322":"6 b c e f"},E:{"2":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"1":"0 1 6 T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"5 8 E B C J M H I ZB aB bB cB p eB","578":"O P Q R S"},G:{"2":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"1":"4","2":"BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"2":"3"},N:{"2":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:1,C:"Dialog element"};

},{}],216:[function(require,module,exports){
module.exports={A:{A:{"1":"B","16":"gB","129":"E A","130":"K D G"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 2 3 4 6 7 9 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB"},D:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"1":"5 F N K D G E A B C HB RB SB TB UB VB p YB","16":"PB"},F:{"1":"0 1 5 6 8 B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z ZB aB bB cB p eB","16":"E"},G:{"1":"G fB EB hB JB jB kB lB mB nB oB pB qB rB sB","16":"HB"},H:{"1":"tB"},I:{"1":"4 BB F wB xB EB yB zB","16":"uB vB"},J:{"1":"D A"},K:{"1":"5 8 A B C L p"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"B","129":"A"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:1,C:"EventTarget.dispatchEvent"};

},{}],217:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G gB","164":"E A","260":"B"},B:{"1":"H I","260":"2 C d J M"},C:{"1":"0 1 3 4 6 7 9 b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"dB BB F N K D G XB WB","516":"2 E A B C d J M H I O P Q R S T U V W X Y Z a"},D:{"1":"0 1 3 4 6 7 9 S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 F N K D G E A B C d J M H I O P Q R"},E:{"1":"K A B C RB UB VB p","2":"5 F N PB HB YB","1028":"D G E SB TB"},F:{"1":"0 1 5 6 C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"8 E B ZB aB bB cB p eB"},G:{"1":"lB mB nB oB pB qB rB","2":"HB fB EB hB JB sB","1028":"G jB kB"},H:{"1":"tB"},I:{"1":"4 yB zB","2":"BB F uB vB wB xB EB"},J:{"16":"D","1028":"A"},K:{"1":"5 L","16":"8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"164":"A","260":"B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:4,C:"Do Not Track API"};

},{}],218:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"dB BB XB WB"},D:{"1":"0 1 3 4 6 7 9 Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 F N K D G E A B C d J M H I O P Q R S T U V W X"},E:{"1":"5 G E A B C UB VB p YB","2":"F N K D PB HB RB SB TB"},F:{"1":"0 1 6 M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"5 8 E B C J ZB aB bB cB p eB"},G:{"1":"G kB lB mB nB oB pB qB rB sB","2":"HB fB EB hB JB jB"},H:{"2":"tB"},I:{"1":"4 yB zB","2":"BB F uB vB wB xB EB"},J:{"2":"D A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:1,C:"document.currentScript"};

},{}],219:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 2 3 4 6 7 9 BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB","16":"dB"},D:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"1":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"1":"0 1 5 6 8 B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z ZB aB bB cB p eB","16":"E"},G:{"1":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"1":"tB"},I:{"1":"4 BB F uB vB wB xB EB yB zB"},J:{"1":"D A"},K:{"1":"5 8 A B C L p"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:7,C:"document.evaluate & XPath"};

},{}],220:[function(require,module,exports){
module.exports={A:{A:{"1":"K D G E A B gB"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 2 3 4 6 7 9 E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"dB BB F N K D G XB WB"},D:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"1":"5 K D G E A B C SB TB UB VB p YB","16":"F N PB HB RB"},F:{"1":"0 1 5 6 8 B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z aB bB cB p eB","16":"E ZB"},G:{"1":"G jB kB lB mB nB oB pB qB rB sB","2":"HB fB","16":"EB hB JB"},H:{"2":"tB"},I:{"1":"xB EB yB zB","2":"4 BB F uB vB wB"},J:{"1":"A","2":"D"},K:{"1":"5 8 A B C L p"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"B","2":"A"},O:{"2":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:7,C:"Document.execCommand()"};

},{}],221:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"1":"d J M H I","16":"2 C"},C:{"1":"0 1 3 4 7 9 r s t u v w x y z GB FB AB CB DB","2":"2 6 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q XB WB"},D:{"1":"0 1 3 4 7 9 n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m"},E:{"1":"5 E A B C UB VB p YB","2":"F N K D G PB HB RB SB TB"},F:{"1":"0 1 6 a b c e f g h i j k l m n o L q r s t u v w x y z","2":"5 8 E B C J M H I O P Q R S T U V W X Y Z ZB aB bB cB p eB"},G:{"1":"lB mB nB oB pB qB rB sB","2":"G HB fB EB hB JB jB kB"},H:{"2":"tB"},I:{"1":"4","2":"BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:5,C:"document.scrollingElement"};

},{}],222:[function(require,module,exports){
module.exports={A:{A:{"1":"E A B","2":"K D G gB"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"dB BB XB WB"},D:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"1":"5 K D G E A B C RB SB TB UB VB p YB","2":"F PB HB","16":"N"},F:{"1":"0 1 5 6 8 B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z p eB","2":"E ZB aB bB cB"},G:{"1":"G fB EB hB JB jB kB lB mB nB oB pB qB rB sB","16":"HB"},H:{"1":"tB"},I:{"1":"4 BB F wB xB EB yB zB","16":"uB vB"},J:{"1":"D A"},K:{"1":"5 8 B C L p","2":"A"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:1,C:"document.head"};

},{}],223:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"1":"H I","2":"2 C d J M"},C:{"1":"0 1 3 4 7 9 s t u v w x y z GB FB AB CB DB","2":"2 6 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r XB WB"},D:{"1":"0 1 3 4 7 9 x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u","194":"v w"},E:{"1":"5 A B C VB p YB","2":"F N K D G E PB HB RB SB TB UB"},F:{"1":"0 1 k l m n o L q r s t u v w x y z","2":"5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i ZB aB bB cB p eB","194":"j"},G:{"1":"nB oB pB qB rB sB","2":"G HB fB EB hB JB jB kB lB mB"},H:{"2":"tB"},I:{"1":"4","2":"BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"1":"0B"},P:{"1":"2B 3B 4B","2":"F 1B"},Q:{"194":"5B"},R:{"2":"6B"}},B:1,C:"DOM manipulation convenience methods"};

},{}],224:[function(require,module,exports){
module.exports={A:{A:{"1":"E A B","2":"gB","8":"K D G"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 2 3 4 6 7 9 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB"},D:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"1":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"1":"0 1 5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z ZB aB bB cB p eB"},G:{"1":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"1":"tB"},I:{"1":"4 BB F uB vB wB xB EB yB zB"},J:{"1":"D A"},K:{"1":"5 8 A B C L p"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:1,C:"Document Object Model Range"};

},{}],225:[function(require,module,exports){
module.exports={A:{A:{"1":"E A B","2":"K D G gB"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 2 3 4 6 7 9 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB"},D:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"1":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"1":"0 1 5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z ZB aB bB cB p eB"},G:{"1":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"1":"tB"},I:{"1":"4 BB F uB vB wB xB EB yB zB"},J:{"1":"D A"},K:{"1":"5 8 A B C L p"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:1,C:"DOMContentLoaded"};

},{}],226:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"2":"0 1 2 3 4 6 7 9 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB"},D:{"1":"0 1 3 4 6 7 9 V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","16":"2 F N K D G E A B C d J M H I O P Q R S T U"},E:{"1":"5 K D G E A B C RB SB TB UB VB p YB","2":"F PB HB","16":"N"},F:{"1":"0 1 5 6 C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z eB","16":"8 E B ZB aB bB cB p"},G:{"1":"G jB kB lB mB nB oB pB qB rB sB","16":"HB fB EB hB JB"},H:{"16":"tB"},I:{"1":"4 F xB EB yB zB","16":"BB uB vB wB"},J:{"16":"D A"},K:{"16":"5 8 A B C L p"},L:{"1":"IB"},M:{"2":"3"},N:{"16":"A B"},O:{"16":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:5,C:"DOMFocusIn & DOMFocusOut events"};

},{}],227:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E gB","132":"A B"},B:{"132":"2 C d J M H I"},C:{"2":"2 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b XB WB","2564":"6 c e f g h i j k l m n o L q r","3076":"0 1 3 4 7 9 s t u v w x y z GB FB AB CB DB"},D:{"16":"F N K D","132":"0 1 2 6 7 E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB","388":"G","1028":"3 4 9 FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"16":"F PB HB","132":"N K D G E A RB SB TB UB VB","1028":"5 B C p YB"},F:{"2":"5 8 E B C ZB aB bB cB p eB","132":"6 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q","1028":"0 1 r s t u v w x y z"},G:{"16":"HB fB EB","132":"G hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"1":"4","132":"F xB EB yB zB","292":"BB uB vB wB"},J:{"16":"D","132":"A"},K:{"2":"5 8 A B C p","132":"L"},L:{"1":"IB"},M:{"1":"3"},N:{"132":"A B"},O:{"132":"0B"},P:{"132":"F 1B 2B 3B 4B"},Q:{"132":"5B"},R:{"132":"6B"}},B:4,C:"DOMMatrix"};

},{}],228:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"1":"2 d J M H I","2":"C"},C:{"1":"0 1 3 4 6 7 9 P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"2 dB BB F N K D G E A B C d J M H I O XB WB"},D:{"1":"0 1 3 4 6 7 9 d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 F N K D G E A B C"},E:{"1":"5 B C VB p YB","2":"F N K D G E A PB HB RB SB TB UB"},F:{"1":"0 1 6 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"5 8 E B C ZB aB bB cB p eB"},G:{"2":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"1":"4 yB zB","2":"BB F uB vB wB xB EB"},J:{"1":"A","2":"D"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:1,C:"Download attribute"};

},{}],229:[function(require,module,exports){
module.exports={A:{A:{"644":"K D G E gB","772":"A B"},B:{"1":"I","260":"2 C d J M H"},C:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB","8":"dB BB"},D:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"1":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"1":"0 1 5 6 C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","8":"8 E B ZB aB bB cB p eB"},G:{"1":"pB qB rB sB","2":"G HB fB EB hB JB jB kB lB mB nB oB"},H:{"2":"tB"},I:{"2":"4 BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"1":"5","2":"L","8":"8 A B C p"},L:{"2":"IB"},M:{"2":"3"},N:{"1":"A B"},O:{"2":"0B"},P:{"2":"F 1B 2B 3B 4B"},Q:{"2":"5B"},R:{"2":"6B"}},B:1,C:"Drag and Drop"};

},{}],230:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"1":"J M H I","2":"2 C d"},C:{"1":"0 1 3 4 7 9 e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"2 6 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c XB WB"},D:{"1":"0 1 3 4 7 9 k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j"},E:{"1":"5 E A B C UB VB p YB","2":"F N K D G PB HB RB SB TB"},F:{"1":"0 1 6 X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"5 8 E B C J M H I O P Q R S T U V W ZB aB bB cB p eB"},G:{"1":"lB mB nB oB pB qB rB sB","2":"G HB fB EB hB JB jB kB"},H:{"2":"tB"},I:{"1":"4","2":"BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"1":"0B"},P:{"1":"1B 2B 3B 4B","2":"F"},Q:{"2":"5B"},R:{"1":"6B"}},B:1,C:"Element.closest()"};

},{}],231:[function(require,module,exports){
module.exports={A:{A:{"1":"K D G E A B","16":"gB"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 2 3 4 6 7 9 BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB","16":"dB"},D:{"1":"0 1 3 4 6 7 9 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","16":"2 F N K D G E A B C d"},E:{"1":"5 N K D G E A B C RB SB TB UB VB p YB","16":"F PB HB"},F:{"1":"0 1 5 6 8 B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z p eB","16":"E ZB aB bB cB"},G:{"1":"G fB EB hB JB jB kB lB mB nB oB pB qB rB sB","16":"HB"},H:{"1":"tB"},I:{"1":"4 BB F wB xB EB yB zB","16":"uB vB"},J:{"1":"D A"},K:{"1":"5 C L","16":"8 A B p"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:5,C:"document.elementFromPoint()"};

},{}],232:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A gB","164":"B"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 3 4 7 9 h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"2 6 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g XB WB"},D:{"1":"0 1 3 4 7 9 l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c","132":"e f g h i j k"},E:{"1":"5 C YB","2":"F N K PB HB RB SB","164":"D G E A B TB UB VB p"},F:{"1":"0 1 6 Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"5 8 E B C J M H I O P Q ZB aB bB cB p eB","132":"R S T U V W X"},G:{"2":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"1":"4","2":"BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"2":"0B"},P:{"1":"1B 2B 3B 4B","2":"F"},Q:{"2":"5B"},R:{"2":"6B"}},B:3,C:"Encrypted Media Extensions"};

},{}],233:[function(require,module,exports){
module.exports={A:{A:{"1":"K D G E A B","2":"gB"},B:{"2":"2 C d J M H I"},C:{"2":"0 1 2 3 4 6 7 9 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB"},D:{"2":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"2":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"2":"0 1 5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z ZB aB bB cB p eB"},G:{"2":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"2":"4 BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"2":"5 8 A B C L p"},L:{"2":"IB"},M:{"2":"3"},N:{"2":"A B"},O:{"2":"0B"},P:{"2":"F 1B 2B 3B 4B"},Q:{"2":"5B"},R:{"2":"6B"}},B:7,C:"EOT - Embedded OpenType fonts"};

},{}],234:[function(require,module,exports){
module.exports={A:{A:{"1":"A B","2":"K D gB","260":"E","1026":"G"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 3 4 6 7 9 Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","4":"dB BB XB WB","132":"2 F N K D G E A B C d J M H I O P"},D:{"1":"0 1 3 4 6 7 9 S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","4":"2 F N K D G E A B C d J M H I","132":"O P Q R"},E:{"1":"5 K D G E A B C SB TB UB VB p YB","4":"F N PB HB RB"},F:{"1":"0 1 6 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","4":"8 E B C ZB aB bB cB p eB","132":"5"},G:{"1":"G JB jB kB lB mB nB oB pB qB rB sB","4":"HB fB EB hB"},H:{"132":"tB"},I:{"1":"4 yB zB","4":"BB uB vB wB","132":"xB EB","900":"F"},J:{"1":"A","4":"D"},K:{"1":"L","4":"8 A B C p","132":"5"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:6,C:"ECMAScript 5"};

},{}],235:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 3 4 7 9 o L q r s t u v w x y z GB FB AB CB DB","2":"2 6 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n XB WB"},D:{"1":"0 1 3 4 7 9 s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k","132":"l m n o L q r"},E:{"1":"5 E A B C UB VB p YB","2":"F N K D G PB HB RB SB TB"},F:{"1":"0 1 f g h i j k l m n o L q r s t u v w x y z","2":"5 8 E B C J M H I O P Q R S T U V W X ZB aB bB cB p eB","132":"6 Y Z a b c e"},G:{"1":"lB mB nB oB pB qB rB sB","2":"G HB fB EB hB JB jB kB"},H:{"2":"tB"},I:{"1":"4","2":"BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"1":"0B"},P:{"1":"1B 2B 3B 4B","2":"F"},Q:{"2":"5B"},R:{"1":"6B"}},B:6,C:"ES6 classes"};

},{}],236:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"1":"2 d J M H I","2":"C"},C:{"1":"0 1 3 4 6 7 9 V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"2 dB BB F N K D G E A B C d J M H I O P Q R S T U XB WB"},D:{"1":"0 1 3 4 7 9 i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h"},E:{"1":"5 A B C VB p YB","2":"F N K D G E PB HB RB SB TB UB"},F:{"1":"0 1 6 V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"5 8 E B C J M H I O P Q R S T U ZB aB bB cB p eB"},G:{"1":"nB oB pB qB rB sB","2":"G HB fB EB hB JB jB kB lB mB"},H:{"2":"tB"},I:{"1":"4","2":"BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"2":"5B"},R:{"1":"6B"}},B:6,C:"ES6 Generators"};

},{}],237:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"2":"0 1 2 3 6 7 9 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB XB WB","194":"4 DB"},D:{"1":"3 4 AB CB DB QB iB KB IB LB MB NB OB","2":"0 1 2 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB"},E:{"1":"5 C p YB","2":"F N K D G E A B PB HB RB SB TB UB VB"},F:{"1":"0 1 t u v w x y z","2":"5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s ZB aB bB cB p eB"},G:{"1":"pB qB rB sB","2":"G HB fB EB hB JB jB kB lB mB nB oB"},H:{"2":"tB"},I:{"1":"4","2":"BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"2":"3"},N:{"2":"A B"},O:{"2":"0B"},P:{"1":"4B","2":"F 1B 2B 3B"},Q:{"2":"5B"},R:{"2":"6B"}},B:6,C:"JavaScript modules: dynamic import()"};

},{}],238:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d","4097":"M H I","4290":"J"},C:{"1":"3 4 7 9 FB AB CB DB","2":"2 6 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w XB WB","322":"0 1 x y z GB"},D:{"1":"3 4 9 FB AB CB DB QB iB KB IB LB MB NB OB","2":"0 1 2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB","194":"7"},E:{"1":"5 B C p YB","2":"F N K D G E A PB HB RB SB TB UB","3076":"VB"},F:{"1":"0 1 r s t u v w x y z","2":"5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L ZB aB bB cB p eB","194":"q"},G:{"1":"pB qB rB sB","2":"G HB fB EB hB JB jB kB lB mB nB","3076":"oB"},H:{"2":"tB"},I:{"1":"4","2":"BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"2":"5 8 A B C L p"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"2":"0B"},P:{"1":"4B","2":"F 1B 2B 3B"},Q:{"2":"5B"},R:{"2":"6B"}},B:1,C:"JavaScript modules via script tag"};

},{}],239:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 3 4 6 7 9 b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"2 dB BB F N K D G E A B C d J XB WB","132":"M H I O P Q R S T","260":"U V W X Y Z","516":"a"},D:{"1":"0 1 3 4 6 7 9 e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 F N K D G E A B C d J M H I","1028":"O P Q R S T U V W X Y Z a b c"},E:{"1":"5 E A B C UB VB p YB","2":"F N K D G PB HB RB SB TB"},F:{"1":"0 1 6 Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"5 8 E B C ZB aB bB cB p eB","1028":"J M H I O P"},G:{"1":"lB mB nB oB pB qB rB sB","2":"G HB fB EB hB JB jB kB"},H:{"2":"tB"},I:{"1":"4","2":"BB F uB vB wB","1028":"xB EB yB zB"},J:{"2":"D A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:6,C:"ES6 Number"};

},{}],240:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 3 4 7 9 j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"2 6 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i XB WB"},D:{"1":"0 1 3 4 7 9 k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j"},E:{"1":"5 E A B C UB VB p YB","2":"F N K D G PB HB RB SB TB"},F:{"1":"0 1 6 X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"5 8 E B C J M H I O P Q R S T U V W ZB aB bB cB p eB"},G:{"1":"lB mB nB oB pB qB rB sB","2":"G HB fB EB hB JB jB kB"},H:{"2":"tB"},I:{"1":"4","2":"BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"2":"5B"},R:{"1":"6B"}},B:6,C:"String.prototype.includes"};

},{}],241:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"1":"0 1 2 3 4 6 7 9 K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"dB BB F N XB WB"},D:{"1":"0 1 2 3 4 6 7 9 K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"F N"},E:{"1":"5 N K D G E A B C RB SB TB UB VB p YB","2":"F PB HB"},F:{"1":"0 1 5 6 8 B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z p eB","4":"E ZB aB bB cB"},G:{"1":"G fB EB hB JB jB kB lB mB nB oB pB qB rB sB","2":"HB"},H:{"2":"tB"},I:{"1":"4 yB zB","2":"BB F uB vB wB xB EB"},J:{"1":"D A"},K:{"1":"5 8 C L p","4":"A B"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:1,C:"Server-sent events"};

},{}],242:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"2":"0 1 2 3 4 6 7 9 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB"},D:{"2":"0 1 2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB","132":"3 4 7 9 FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"2":"F N K D G E A B PB HB RB SB TB UB VB","772":"5 C p YB"},F:{"2":"5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L ZB aB bB cB p eB","132":"0 1 q r s t u v w x y z"},G:{"2":"G HB fB EB hB JB jB kB lB mB nB oB pB","16":"qB rB sB"},H:{"2":"tB"},I:{"2":"BB F uB vB wB xB EB yB zB","132":"4"},J:{"2":"D A"},K:{"2":"5 8 A B C L p"},L:{"132":"IB"},M:{"2":"3"},N:{"2":"A B"},O:{"2":"0B"},P:{"2":"F 1B 2B 3B","132":"4B"},Q:{"2":"5B"},R:{"2":"6B"}},B:7,C:"Feature Policy"};

},{}],243:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"1":"d J M H I","2":"2 C"},C:{"1":"0 1 3 4 7 9 j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"2 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c XB WB","1025":"i","1218":"6 e f g h"},D:{"1":"0 1 3 4 7 9 l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i","260":"j","772":"k"},E:{"1":"5 B C VB p YB","2":"F N K D G E A PB HB RB SB TB UB"},F:{"1":"0 1 6 Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"5 8 E B C J M H I O P Q R S T U V ZB aB bB cB p eB","260":"W","772":"X"},G:{"1":"oB pB qB rB sB","2":"G HB fB EB hB JB jB kB lB mB nB"},H:{"2":"tB"},I:{"1":"4","2":"BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:1,C:"Fetch"};

},{}],244:[function(require,module,exports){
module.exports={A:{A:{"16":"gB","132":"G E","388":"K D A B"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"dB BB XB WB"},D:{"1":"0 1 3 4 6 7 9 P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 F N K D G E A B C d J","16":"M H I O"},E:{"1":"5 K D G E A B C SB TB UB VB p YB","2":"F N PB HB RB"},F:{"1":"0 1 5 6 8 B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z aB bB cB p eB","16":"E ZB"},G:{"1":"G JB jB kB lB mB nB oB pB qB rB sB","2":"HB fB EB hB"},H:{"388":"tB"},I:{"1":"4 yB zB","2":"BB F uB vB wB xB EB"},J:{"1":"A","2":"D"},K:{"1":"5 8 A B C L p"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"A","260":"B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:1,C:"disabled attribute of the fieldset element"};

},{}],245:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E gB","260":"A B"},B:{"260":"2 C d J M H I"},C:{"1":"0 1 3 4 6 7 9 X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"dB BB XB","260":"2 F N K D G E A B C d J M H I O P Q R S T U V W WB"},D:{"1":"0 1 3 4 7 9 h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"F N","260":"2 6 d J M H I O P Q R S T U V W X Y Z a b c e f g","388":"K D G E A B C"},E:{"1":"5 A B C VB p YB","2":"F N PB HB","260":"K D G E SB TB UB","388":"RB"},F:{"1":"0 1 6 U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"E B ZB aB bB cB","260":"5 8 C J M H I O P Q R S T p eB"},G:{"1":"nB oB pB qB rB sB","2":"HB fB EB hB","260":"G JB jB kB lB mB"},H:{"2":"tB"},I:{"1":"4 zB","2":"uB vB wB","260":"yB","388":"BB F xB EB"},J:{"260":"A","388":"D"},K:{"1":"L","2":"A B","260":"5 8 C p"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A","260":"B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:5,C:"File API"};

},{}],246:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E gB","132":"A B"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB WB","2":"dB BB XB"},D:{"1":"0 1 2 3 4 6 7 9 K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"F N"},E:{"1":"5 K D G E A B C SB TB UB VB p YB","2":"F N PB HB RB"},F:{"1":"0 1 5 6 8 C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z p eB","2":"E B ZB aB bB cB"},G:{"1":"G JB jB kB lB mB nB oB pB qB rB sB","2":"HB fB EB hB"},H:{"2":"tB"},I:{"1":"4 BB F xB EB yB zB","2":"uB vB wB"},J:{"1":"A","2":"D"},K:{"1":"5 8 C L p","2":"A B"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:5,C:"FileReader API"};

},{}],247:[function(require,module,exports){
module.exports={A:{A:{"1":"A B","2":"K D G E gB"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 2 3 4 6 7 9 G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"dB BB F N K D XB WB"},D:{"1":"0 1 3 4 6 7 9 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","16":"2 F N K D G E A B C d"},E:{"1":"5 K D G E A B C SB TB UB VB p YB","2":"F N PB HB RB"},F:{"1":"0 1 5 6 C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z eB","2":"E ZB aB","16":"8 B bB cB p"},G:{"1":"G JB jB kB lB mB nB oB pB qB rB sB","2":"HB fB EB hB"},H:{"2":"tB"},I:{"1":"4 yB zB","2":"BB F uB vB wB xB EB"},J:{"1":"A","2":"D"},K:{"1":"5 8 C L","2":"A","16":"B p"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:5,C:"FileReaderSync"};

},{}],248:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"2":"0 1 2 3 4 6 7 9 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB"},D:{"2":"F N K D","33":"0 1 2 3 4 6 7 9 d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","36":"G E A B C"},E:{"2":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"2":"5 8 E B C ZB aB bB cB p eB","33":"0 1 6 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z"},G:{"2":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"2":"4 BB F uB vB wB xB EB yB zB"},J:{"2":"D","33":"A"},K:{"2":"5 8 A B C p","33":"L"},L:{"33":"IB"},M:{"2":"3"},N:{"2":"A B"},O:{"2":"0B"},P:{"2":"F","33":"1B 2B 3B 4B"},Q:{"2":"5B"},R:{"2":"6B"}},B:7,C:"Filesystem & FileWriter API"};

},{}],249:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"1":"M H I","2":"2 C d J"},C:{"1":"0 1 3 4 7 9 u v w x y z GB FB AB CB DB","2":"2 6 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t XB WB"},D:{"1":"0 1 3 4 7 9 z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m","16":"n o L","388":"q r s t u v w x y"},E:{"2":"F N K D G E A PB HB RB SB TB UB VB","516":"5 B C p YB"},F:{"1":"0 1 l m n o L q r s t u v w x y z","2":"5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k ZB aB bB cB p eB"},G:{"1":"pB qB rB sB","2":"G HB fB EB hB JB jB kB lB mB nB oB"},H:{"2":"tB"},I:{"1":"4","2":"uB vB wB","16":"BB F xB EB yB zB"},J:{"1":"A","2":"D"},K:{"1":"5","16":"8 A B C p","129":"L"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"1":"0B"},P:{"1":"1B 2B 3B 4B","129":"F"},Q:{"2":"5B"},R:{"1":"6B"}},B:6,C:"FLAC audio format"};

},{}],250:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E gB","1028":"B","1316":"A"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 3 4 6 7 9 X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","164":"2 dB BB F N K D G E A B C d J M H I O P Q XB WB","516":"R S T U V W"},D:{"1":"0 1 3 4 6 7 9 Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","33":"Q R S T U V W X","164":"2 F N K D G E A B C d J M H I O P"},E:{"1":"5 E A B C UB VB p YB","33":"D G SB TB","164":"F N K PB HB RB"},F:{"1":"0 1 5 6 H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"8 E B C ZB aB bB cB p eB","33":"J M"},G:{"1":"lB mB nB oB pB qB rB sB","33":"G jB kB","164":"HB fB EB hB JB"},H:{"1":"tB"},I:{"1":"4 yB zB","164":"BB F uB vB wB xB EB"},J:{"1":"A","164":"D"},K:{"1":"5 L","2":"8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"B","292":"A"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:4,C:"CSS Flexible Box Layout Module"};

},{}],251:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"1":"0 1 3 4 7 9 w x y z GB FB AB CB DB","2":"2 6 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v XB WB"},D:{"1":"1 3 4 7 9 GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"0 2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z"},E:{"2":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"1":"0 1 o L q r s t u v w x y z","2":"5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n ZB aB bB cB p eB"},G:{"2":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"1":"4","2":"BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"2":"0B"},P:{"1":"3B 4B","2":"F 1B 2B"},Q:{"2":"5B"},R:{"2":"6B"}},B:5,C:"display: flow-root"};

},{}],252:[function(require,module,exports){
module.exports={A:{A:{"1":"K D G E A B","2":"gB"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 3 4 7 9 v w x y z GB FB AB CB DB","2":"2 6 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u XB WB"},D:{"1":"0 1 3 4 6 7 9 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","16":"2 F N K D G E A B C d"},E:{"1":"5 K D G E A B C RB SB TB UB VB p YB","16":"F N PB HB"},F:{"1":"0 1 5 6 C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z eB","2":"E ZB aB bB cB","16":"8 B p"},G:{"1":"G hB JB jB kB lB mB nB oB pB qB rB sB","2":"HB fB EB"},H:{"2":"tB"},I:{"1":"4 F xB EB yB zB","2":"uB vB wB","16":"BB"},J:{"1":"D A"},K:{"1":"5 C L","2":"A","16":"8 B p"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:5,C:"focusin & focusout events"};

},{}],253:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"2":"0 1 2 3 4 6 7 9 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB"},D:{"1":"3 4 CB DB QB iB KB IB LB MB NB OB","2":"0 1 2 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB"},E:{"2":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"1":"0 1 u v w x y z","2":"5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t ZB aB bB cB p eB"},G:{"2":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"2":"4 BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"2":"5 8 A B C L p"},L:{"2":"IB"},M:{"2":"3"},N:{"2":"A B"},O:{"2":"0B"},P:{"2":"F 1B 2B 3B 4B"},Q:{"2":"5B"},R:{"2":"6B"}},B:1,C:"preventScroll support in focus"};

},{}],254:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"2":"2 6 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l XB WB","132":"0 1 3 4 7 9 m n o L q r s t u v w x y z GB FB AB CB DB"},D:{"1":"0 1 3 4 7 9 z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v","260":"w x y"},E:{"1":"5 B C p YB","2":"F N K D G PB HB RB SB TB","16":"E","132":"A UB VB"},F:{"1":"0 1 m n o L q r s t u v w x y z","2":"5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l ZB aB bB cB p eB"},G:{"1":"pB qB rB sB","2":"G HB fB EB hB JB jB kB","132":"lB mB nB oB"},H:{"2":"tB"},I:{"1":"4","2":"BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"2":"3"},N:{"2":"A B"},O:{"1":"0B"},P:{"1":"2B 3B 4B","2":"F 1B"},Q:{"1":"5B"},R:{"2":"6B"}},B:5,C:"system-ui value for font-family"};

},{}],255:[function(require,module,exports){
module.exports={A:{A:{"1":"A B","2":"K D G E gB"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 3 4 6 7 9 e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"dB BB XB WB","33":"J M H I O P Q R S T U V W X Y Z a b c","164":"2 F N K D G E A B C d"},D:{"1":"0 1 3 4 7 9 r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 F N K D G E A B C d J","33":"6 Q R S T U V W X Y Z a b c e f g h i j k l m n o L q","292":"M H I O P"},E:{"1":"5 A B C UB VB p YB","2":"D G E PB HB SB TB","4":"F N K RB"},F:{"1":"0 1 e f g h i j k l m n o L q r s t u v w x y z","2":"5 8 E B C ZB aB bB cB p eB","33":"6 J M H I O P Q R S T U V W X Y Z a b c"},G:{"1":"mB nB oB pB qB rB sB","2":"G jB kB lB","4":"HB fB EB hB JB"},H:{"2":"tB"},I:{"1":"4","2":"BB F uB vB wB xB EB","33":"yB zB"},J:{"2":"D","33":"A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"33":"0B"},P:{"1":"1B 2B 3B 4B","33":"F"},Q:{"1":"5B"},R:{"1":"6B"}},B:4,C:"CSS font-feature-settings"};

},{}],256:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"1":"0 1 3 4 6 7 9 e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"2 dB BB F N K D G E A B C d J M H I O P Q R S XB WB","194":"T U V W X Y Z a b c"},D:{"1":"0 1 3 4 6 7 9 c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 F N K D G E A B C d J M H I O P Q R S T U V W X","33":"Y Z a b"},E:{"1":"5 A B C UB VB p YB","2":"F N K PB HB RB SB","33":"D G E TB"},F:{"1":"0 1 6 P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"5 8 E B C J ZB aB bB cB p eB","33":"M H I O"},G:{"2":"HB fB EB hB JB jB","33":"G kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"1":"4 zB","2":"BB F uB vB wB xB EB","33":"yB"},J:{"2":"D","33":"A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:4,C:"CSS3 font-kerning"};

},{}],257:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"1":"0 1 3 4 7 9 k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"2 6 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c XB WB","194":"e f g h i j"},D:{"1":"0 1 3 4 7 9 e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c"},E:{"1":"5 A B C VB p YB","2":"F N K D G E PB HB RB SB TB UB"},F:{"1":"0 1 6 R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"5 8 E B C J M H I O P Q ZB aB bB cB p eB"},G:{"1":"nB oB pB qB rB sB","2":"G HB fB EB hB JB jB kB lB mB"},H:{"2":"tB"},I:{"1":"4","2":"BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:5,C:"CSS Font Loading"};

},{}],258:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"1":"0 1 2 3 4 6 7 9 BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB","2":"dB"},D:{"2":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l","194":"0 1 3 4 7 9 m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"2":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"2":"5 8 E B C J M H I O P Q R S T U V W X Y ZB aB bB cB p eB","194":"0 1 6 Z a b c e f g h i j k l m n o L q r s t u v w x y z"},G:{"2":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"2":"4 BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"2":"5 8 A B C L p"},L:{"2":"IB"},M:{"258":"3"},N:{"2":"A B"},O:{"2":"0B"},P:{"2":"F 1B 2B 3B 4B"},Q:{"194":"5B"},R:{"2":"6B"}},B:4,C:"CSS font-size-adjust"};

},{}],259:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"2":"2 dB BB F N K D G E A B C d J M H I O P Q R S T XB WB","804":"0 1 3 4 6 7 9 U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB"},D:{"2":"F","676":"0 1 2 3 4 6 7 9 N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"2":"PB HB","676":"5 F N K D G E A B C RB SB TB UB VB p YB"},F:{"2":"5 8 E B C ZB aB bB cB p eB","676":"0 1 6 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z"},G:{"2":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"2":"4 BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"2":"5 8 A B C L p"},L:{"2":"IB"},M:{"2":"3"},N:{"2":"A B"},O:{"2":"0B"},P:{"2":"F 1B 2B 3B 4B"},Q:{"2":"5B"},R:{"2":"6B"}},B:7,C:"CSS font-smooth"};

},{}],260:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G gB","4":"E A B"},B:{"1":"H I","4":"2 C d J M"},C:{"1":"0 1 3 4 7 9 n o L q r s t u v w x y z GB FB AB CB DB","2":"2 6 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e XB WB","194":"f g h i j k l m"},D:{"1":"0 1 3 4 7 9 f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","4":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e"},E:{"1":"5 A B C VB p YB","4":"F N K D G E PB HB RB SB TB UB"},F:{"1":"0 1 6 S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"5 8 E B C ZB aB bB cB p eB","4":"J M H I O P Q R"},G:{"1":"nB oB pB qB rB sB","4":"G HB fB EB hB JB jB kB lB mB"},H:{"2":"tB"},I:{"1":"4","4":"BB F uB vB wB xB EB yB zB"},J:{"2":"D","4":"A"},K:{"2":"5 8 A B C p","4":"L"},L:{"1":"IB"},M:{"1":"3"},N:{"4":"A B"},O:{"1":"0B"},P:{"1":"1B 2B 3B 4B","4":"F"},Q:{"1":"5B"},R:{"2":"6B"}},B:4,C:"Font unicode-range subsetting"};

},{}],261:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E gB","130":"A B"},B:{"130":"2 C d J M H I"},C:{"1":"0 1 3 4 6 7 9 e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"dB BB XB WB","130":"2 F N K D G E A B C d J M H I O P Q R S","322":"T U V W X Y Z a b c"},D:{"2":"2 F N K D G E A B C d J","130":"0 1 3 4 6 7 9 M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"1":"5 A B C UB VB p YB","2":"D G E PB HB SB TB","130":"F N K RB"},F:{"2":"5 8 E B C ZB aB bB cB p eB","130":"0 1 6 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z"},G:{"1":"mB nB oB pB qB rB sB","2":"G HB jB kB lB","130":"fB EB hB JB"},H:{"2":"tB"},I:{"2":"BB F uB vB wB xB EB","130":"4 yB zB"},J:{"2":"D","130":"A"},K:{"2":"5 8 A B C p","130":"L"},L:{"130":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"130":"0B"},P:{"130":"F 1B 2B 3B 4B"},Q:{"130":"5B"},R:{"130":"6B"}},B:4,C:"CSS font-variant-alternates"};

},{}],262:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"1":"0 1 3 4 6 7 9 e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"2 dB BB F N K D G E A B C d J M H I O P Q R S XB WB","132":"T U V W X Y Z a b c"},D:{"1":"3 4 AB CB DB QB iB KB IB LB MB NB OB","2":"0 1 2 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB"},E:{"2":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"1":"0 1 t u v w x y z","2":"5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s ZB aB bB cB p eB"},G:{"2":"G fB EB hB JB jB kB lB mB nB oB pB qB rB sB","16":"HB"},H:{"2":"tB"},I:{"2":"4 BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"2":"5 8 A B C L p"},L:{"2":"IB"},M:{"132":"3"},N:{"2":"A B"},O:{"2":"0B"},P:{"2":"F 1B 2B 3B 4B"},Q:{"2":"5B"},R:{"2":"6B"}},B:4,C:"CSS font-variant-east-asian "};

},{}],263:[function(require,module,exports){
module.exports={A:{A:{"1":"E A B","132":"K D G gB"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB","2":"dB BB"},D:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"1":"5 F N K D G E A B C HB RB SB TB UB VB p YB","2":"PB"},F:{"1":"0 1 5 6 8 B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z aB bB cB p eB","2":"E ZB"},G:{"1":"G EB hB JB jB kB lB mB nB oB pB qB rB sB","260":"HB fB"},H:{"2":"tB"},I:{"1":"4 F xB EB yB zB","2":"uB","4":"BB vB wB"},J:{"1":"A","4":"D"},K:{"1":"5 8 A B C L p"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:4,C:"@font-face Web fonts"};

},{}],264:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"1":"M H I","2":"2 C d J"},C:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"dB BB XB WB"},D:{"1":"0 1 2 3 4 6 7 9 A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"F N K D G E"},E:{"1":"5 K D G E A B C RB SB TB UB VB p YB","2":"F PB HB","16":"N"},F:{"1":"0 1 5 6 8 B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z ZB aB bB cB p eB","2":"E"},G:{"1":"G hB JB jB kB lB mB nB oB pB qB rB sB","2":"HB fB EB"},H:{"1":"tB"},I:{"1":"4 BB F xB EB yB zB","2":"uB vB wB"},J:{"1":"D A"},K:{"1":"5 8 A B C L p"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:1,C:"Form attribute"};

},{}],265:[function(require,module,exports){
module.exports={A:{A:{"1":"A B","2":"K D G E gB"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"dB BB XB WB"},D:{"1":"0 1 3 4 6 7 9 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","16":"2 F N K D G E A B C d"},E:{"1":"5 K D G E A B C RB SB TB UB VB p YB","2":"F N PB HB"},F:{"1":"0 1 5 6 8 B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z cB p eB","2":"E ZB","16":"aB bB"},G:{"1":"G hB JB jB kB lB mB nB oB pB qB rB sB","2":"HB fB EB"},H:{"1":"tB"},I:{"1":"4 F xB EB yB zB","2":"uB vB wB","16":"BB"},J:{"1":"A","2":"D"},K:{"1":"5 8 B C L p","16":"A"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:1,C:"Attributes for form submission"};

},{}],266:[function(require,module,exports){
module.exports={A:{A:{"1":"A B","2":"K D G E gB"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"dB BB XB WB"},D:{"1":"0 1 2 3 4 6 7 9 A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"F N K D G E"},E:{"1":"5 B C VB p YB","2":"F PB HB","132":"N K D G E A RB SB TB UB"},F:{"1":"0 1 5 6 8 B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z aB bB cB p eB","2":"E ZB"},G:{"1":"oB pB qB rB sB","2":"HB","132":"G fB EB hB JB jB kB lB mB nB"},H:{"516":"tB"},I:{"1":"4 zB","2":"BB uB vB wB","132":"F xB EB yB"},J:{"1":"A","132":"D"},K:{"1":"5 8 A B C L p"},L:{"1":"IB"},M:{"1":"3"},N:{"260":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:1,C:"Form validation"};

},{}],267:[function(require,module,exports){
module.exports={A:{A:{"2":"gB","4":"A B","8":"K D G E"},B:{"1":"M H I","4":"2 C d J"},C:{"4":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","8":"dB BB XB WB"},D:{"1":"3 4 9 FB AB CB DB QB iB KB IB LB MB NB OB","4":"0 1 2 6 7 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB"},E:{"4":"5 F N K D G E A B C RB SB TB UB VB p YB","8":"PB HB"},F:{"1":"0 1 5 8 E B C v w x y z ZB aB bB cB p eB","4":"6 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u"},G:{"2":"HB","4":"G fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"1":"4","2":"BB F uB vB wB xB EB","4":"yB zB"},J:{"2":"D","4":"A"},K:{"1":"5 8 A B C p","4":"L"},L:{"1":"IB"},M:{"4":"3"},N:{"4":"A B"},O:{"1":"0B"},P:{"1":"4B","4":"F 1B 2B 3B"},Q:{"4":"5B"},R:{"4":"6B"}},B:1,C:"HTML5 form features"};

},{}],268:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A gB","548":"B"},B:{"516":"2 C d J M H I"},C:{"1":"3 4 CB DB","2":"dB BB F N K D G E XB WB","676":"2 6 A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L","1700":"0 1 7 9 q r s t u v w x y z GB FB AB"},D:{"1":"IB LB MB NB OB","2":"2 F N K D G E A B C d","676":"J M H I O","804":"0 1 3 4 6 7 9 P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB"},E:{"2":"F N PB HB","676":"RB","804":"5 K D G E A B C SB TB UB VB p YB"},F:{"1":"5","2":"8 E B C ZB aB bB cB p eB","804":"0 1 6 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z"},G:{"2":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"2":"4 BB F uB vB wB xB EB yB zB"},J:{"2":"D","292":"A"},K:{"2":"5 8 A B C p","804":"L"},L:{"804":"IB"},M:{"1":"3"},N:{"2":"A","548":"B"},O:{"804":"0B"},P:{"804":"F 1B 2B 3B 4B"},Q:{"804":"5B"},R:{"804":"6B"}},B:1,C:"Full Screen API"};

},{}],269:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 3 4 6 7 9 Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"2 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X XB WB"},D:{"1":"0 1 3 4 6 7 9 U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 F N K D G E A B C d J M H I O P","33":"Q R S T"},E:{"1":"5 B C VB p YB","2":"F N K D G E A PB HB RB SB TB UB"},F:{"1":"0 1 6 T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"5 8 E B C J M H I O P Q R S ZB aB bB cB p eB"},G:{"1":"oB pB qB rB sB","2":"G HB fB EB hB JB jB kB lB mB nB"},H:{"2":"tB"},I:{"2":"4 BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"2":"5 8 A B C L p"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:5,C:"Gamepad API"};

},{}],270:[function(require,module,exports){
module.exports={A:{A:{"1":"E A B","2":"gB","8":"K D G"},B:{"1":"2 C d J M H I"},C:{"1":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x XB WB","8":"dB BB","129":"0 1 3 4 7 9 y z GB FB AB CB DB"},D:{"1":"2 6 N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s","4":"F","129":"0 1 3 4 7 9 t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"1":"5 N K D G E B C RB SB TB UB VB p YB","8":"F PB HB","129":"A"},F:{"1":"5 6 8 B C M H I O P Q R S T U V W X Y Z a b c e f g h cB p eB","2":"E J ZB","8":"aB bB","129":"0 1 i j k l m n o L q r s t u v w x y z"},G:{"1":"G HB fB EB hB JB jB kB lB mB","129":"nB oB pB qB rB sB"},H:{"2":"tB"},I:{"1":"BB F uB vB wB xB EB yB zB","129":"4"},J:{"1":"D A"},K:{"1":"5 8 B C L p","8":"A"},L:{"129":"IB"},M:{"129":"3"},N:{"1":"A B"},O:{"1":"0B"},P:{"1":"F","129":"1B 2B 3B 4B"},Q:{"129":"5B"},R:{"129":"6B"}},B:2,C:"Geolocation"};

},{}],271:[function(require,module,exports){
module.exports={A:{A:{"644":"K D gB","2049":"E A B","2692":"G"},B:{"2049":"2 C d J M H I"},C:{"1":"0 1 2 3 4 6 7 9 C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"dB","260":"F N K D G E A B","1156":"BB","1284":"XB","1796":"WB"},D:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"1":"5 F N K D G E A B C RB SB TB UB VB p YB","16":"PB HB"},F:{"1":"0 1 5 6 8 B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z cB p eB","16":"E ZB","132":"aB bB"},G:{"1":"G fB EB hB JB jB kB lB mB nB oB pB qB rB sB","16":"HB"},H:{"1":"tB"},I:{"1":"4 BB F wB xB EB yB zB","16":"uB vB"},J:{"1":"D A"},K:{"1":"5 8 B C L p","132":"A"},L:{"1":"IB"},M:{"1":"3"},N:{"2049":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:5,C:"Element.getBoundingClientRect()"};

},{}],272:[function(require,module,exports){
module.exports={A:{A:{"1":"E A B","2":"K D G gB"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"dB","132":"BB XB WB"},D:{"1":"0 1 2 3 4 6 7 9 B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","260":"F N K D G E A"},E:{"1":"5 N K D G E A B C RB SB TB UB VB p YB","260":"F PB HB"},F:{"1":"0 1 5 6 8 B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z cB p eB","260":"E ZB aB bB"},G:{"1":"G hB JB jB kB lB mB nB oB pB qB rB sB","260":"HB fB EB"},H:{"260":"tB"},I:{"1":"4 F xB EB yB zB","260":"BB uB vB wB"},J:{"1":"A","260":"D"},K:{"1":"5 8 B C L p","260":"A"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:2,C:"getComputedStyle"};

},{}],273:[function(require,module,exports){
module.exports={A:{A:{"1":"E A B","2":"gB","8":"K D G"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 2 3 4 6 7 9 BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB","8":"dB"},D:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"1":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"1":"0 1 5 6 8 B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z ZB aB bB cB p eB","2":"E"},G:{"1":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"1":"tB"},I:{"1":"4 BB F uB vB wB xB EB yB zB"},J:{"1":"D A"},K:{"1":"5 8 A B C L p"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:1,C:"getElementsByClassName"};

},{}],274:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A gB","33":"B"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 3 4 6 7 9 Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"2 dB BB F N K D G E A B C d J M H I O P XB WB"},D:{"1":"0 1 2 3 4 6 7 9 B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"F N K D G E A"},E:{"1":"5 D G E A B C SB TB UB VB p YB","2":"F N K PB HB RB"},F:{"1":"0 1 6 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"5 8 E B C ZB aB bB cB p eB"},G:{"1":"G jB kB lB mB nB oB pB qB rB sB","2":"HB fB EB hB JB"},H:{"2":"tB"},I:{"1":"4 yB zB","2":"BB F uB vB wB xB EB"},J:{"1":"A","2":"D"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A","33":"B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:4,C:"crypto.getRandomValues()"};

},{}],275:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"2":"0 1 2 3 4 6 7 9 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB"},D:{"1":"4 QB iB KB IB LB MB NB OB","2":"0 2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","194":"1 3 7 9 GB FB AB CB DB"},E:{"2":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"1":"0 1 x y z","2":"5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w ZB aB bB cB p eB"},G:{"2":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"1":"4","2":"BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"2":"5 8 A B C L p"},L:{"1":"IB"},M:{"2":"3"},N:{"2":"A B"},O:{"2":"0B"},P:{"2":"F 1B 2B 3B 4B"},Q:{"2":"5B"},R:{"2":"6B"}},B:4,C:"Gyroscope"};

},{}],276:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"1":"J M H I","2":"2 C d"},C:{"1":"0 1 3 4 7 9 r s t u v w x y z GB FB AB CB DB","2":"2 6 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q XB WB"},D:{"1":"0 1 3 4 7 9 g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f"},E:{"2":"F N K D PB HB RB SB TB","129":"5 B C VB p YB","194":"G E A UB"},F:{"1":"0 1 6 T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"5 8 E B C J M H I O P Q R S ZB aB bB cB p eB"},G:{"2":"HB fB EB hB JB jB","129":"oB pB qB rB sB","194":"G kB lB mB nB"},H:{"2":"tB"},I:{"1":"4","2":"BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:1,C:"navigator.hardwareConcurrency"};

},{}],277:[function(require,module,exports){
module.exports={A:{A:{"1":"G E A B","8":"K D gB"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB WB","8":"dB BB XB"},D:{"1":"0 1 2 3 4 6 7 9 N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","8":"F"},E:{"1":"5 N K D G E A B C RB SB TB UB VB p YB","8":"F PB HB"},F:{"1":"0 1 5 6 8 B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z cB p eB","8":"E ZB aB bB"},G:{"1":"G fB EB hB JB jB kB lB mB nB oB pB qB rB sB","2":"HB"},H:{"2":"tB"},I:{"1":"4 BB F vB wB xB EB yB zB","2":"uB"},J:{"1":"D A"},K:{"1":"5 8 B C L p","8":"A"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:1,C:"Hashchange event"};

},{}],278:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"2":"0 1 2 3 4 6 7 9 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB"},D:{"2":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"2":"F N K D G E A PB HB RB SB TB UB VB","130":"5 B C p YB"},F:{"2":"0 1 5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z ZB aB bB cB p eB"},G:{"2":"G HB fB EB hB JB jB kB lB mB nB oB","130":"pB qB rB sB"},H:{"2":"tB"},I:{"2":"4 BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"2":"5 8 A B C L p"},L:{"2":"IB"},M:{"2":"3"},N:{"2":"A B"},O:{"2":"0B"},P:{"2":"F 1B 2B 3B 4B"},Q:{"2":"5B"},R:{"2":"6B"}},B:6,C:"HEIF/ISO Base Media File Format"};

},{}],279:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A gB","132":"B"},B:{"132":"2 C d J M H I"},C:{"2":"0 1 2 3 4 6 7 9 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB"},D:{"2":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"2":"F N K D G E A PB HB RB SB TB UB VB","516":"5 B C p YB"},F:{"2":"0 1 5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z ZB aB bB cB p eB"},G:{"1":"pB qB rB sB","2":"G HB fB EB hB JB jB kB lB mB nB oB"},H:{"2":"tB"},I:{"2":"BB F uB vB wB xB EB yB zB","258":"4"},J:{"2":"D A"},K:{"2":"5 8 A B C L p"},L:{"258":"IB"},M:{"2":"3"},N:{"2":"A B"},O:{"2":"0B"},P:{"2":"F","258":"1B 2B 3B 4B"},Q:{"2":"5B"},R:{"2":"6B"}},B:6,C:"HEVC/H.265 video format"};

},{}],280:[function(require,module,exports){
module.exports={A:{A:{"1":"B","2":"K D G E A gB"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"dB BB XB WB"},D:{"1":"0 1 2 3 4 6 7 9 K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"F N"},E:{"1":"5 K D G E A B C RB SB TB UB VB p YB","2":"F N PB HB"},F:{"1":"0 1 5 6 8 C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z p eB","2":"E B ZB aB bB cB"},G:{"1":"G hB JB jB kB lB mB nB oB pB qB rB sB","2":"HB fB EB"},H:{"1":"tB"},I:{"1":"4 F xB EB yB zB","2":"BB uB vB wB"},J:{"1":"A","2":"D"},K:{"1":"5 8 C L p","2":"A B"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"B","2":"A"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:1,C:"hidden attribute"};

},{}],281:[function(require,module,exports){
module.exports={A:{A:{"1":"A B","2":"K D G E gB"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 3 4 6 7 9 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"2 dB BB F N K D G E A B C d XB WB"},D:{"1":"0 1 3 4 6 7 9 T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 F N K D G E A B C d J M H I O","33":"P Q R S"},E:{"1":"5 G E A B C UB VB p YB","2":"F N K D PB HB RB SB TB"},F:{"1":"0 1 6 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"5 8 E B C ZB aB bB cB p eB"},G:{"1":"G lB mB nB oB pB qB rB sB","2":"HB fB EB hB JB jB kB"},H:{"2":"tB"},I:{"1":"4 yB zB","2":"BB F uB vB wB xB EB"},J:{"1":"A","2":"D"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:2,C:"High Resolution Time API"};

},{}],282:[function(require,module,exports){
module.exports={A:{A:{"1":"A B","2":"K D G E gB"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"dB BB XB WB"},D:{"1":"0 1 2 3 4 6 7 9 N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"F"},E:{"1":"5 K D G E A B C SB TB UB VB p YB","2":"F PB HB","4":"N RB"},F:{"1":"0 1 5 6 8 C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z eB","2":"E B ZB aB bB cB p"},G:{"1":"G hB JB jB kB lB mB nB oB pB qB rB sB","2":"HB fB","4":"EB"},H:{"2":"tB"},I:{"1":"4 vB wB EB yB zB","2":"BB F uB xB"},J:{"1":"D A"},K:{"1":"5 8 C L p","2":"A B"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:1,C:"Session history management"};

},{}],283:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"2":"0 1 2 3 4 6 7 9 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB"},D:{"2":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"2":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"2":"0 1 5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z ZB aB bB cB p eB"},G:{"2":"HB fB EB hB","129":"G JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"1":"4 BB F xB EB yB zB","2":"uB","257":"vB wB"},J:{"1":"A","16":"D"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"2":"3"},N:{"2":"A B"},O:{"516":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"16":"5B"},R:{"1":"6B"}},B:4,C:"HTML Media Capture"};

},{}],284:[function(require,module,exports){
module.exports={A:{A:{"2":"gB","8":"K D G","260":"E A B"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 3 4 6 7 9 Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"dB","132":"BB XB WB","260":"2 F N K D G E A B C d J M H I O P"},D:{"1":"0 1 3 4 6 7 9 V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","132":"F N","260":"2 K D G E A B C d J M H I O P Q R S T U"},E:{"1":"5 D G E A B C SB TB UB VB p YB","132":"F PB HB","260":"N K RB"},F:{"1":"0 1 6 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","132":"E B ZB aB bB cB","260":"5 8 C p eB"},G:{"1":"G jB kB lB mB nB oB pB qB rB sB","132":"HB","260":"fB EB hB JB"},H:{"132":"tB"},I:{"1":"4 yB zB","132":"uB","260":"BB F vB wB xB EB"},J:{"260":"D A"},K:{"1":"L","132":"A","260":"5 8 B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"260":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:1,C:"HTML5 semantic elements"};

},{}],285:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"1":"2 C d J M H I"},C:{"2":"0 1 2 3 4 6 7 9 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB"},D:{"2":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"1":"5 K D G E A B C SB TB UB VB p YB","2":"F N PB HB RB"},F:{"2":"0 1 5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z ZB aB bB cB p eB"},G:{"1":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"1":"4 BB F xB EB yB zB","2":"uB vB wB"},J:{"1":"A","2":"D"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"2":"3"},N:{"2":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:7,C:"HTTP Live Streaming (HLS)"};

},{}],286:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A gB","132":"B"},B:{"1":"2 C d J M H I"},C:{"1":"f g h i j k l m n o L q r s t u v","2":"2 6 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e XB WB","513":"0 1 3 4 7 9 w x y z GB FB AB CB DB"},D:{"1":"k l m n o L q r s t","2":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j","513":"0 1 3 4 7 9 u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"1":"5 B C p YB","2":"F N K D G PB HB RB SB TB","260":"E A UB VB"},F:{"1":"6 X Y Z a b c e f g","2":"5 8 E B C J M H I O P Q R S T U V W ZB aB bB cB p eB","513":"0 1 h i j k l m n o L q r s t u v w x y z"},G:{"1":"lB mB nB oB pB qB rB sB","2":"G HB fB EB hB JB jB kB"},H:{"2":"tB"},I:{"1":"4","2":"BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"1":"L","2":"5 8 A B C p"},L:{"513":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"2":"0B"},P:{"1":"F","513":"1B 2B 3B 4B"},Q:{"513":"5B"},R:{"1":"6B"}},B:6,C:"HTTP/2 protocol"};

},{}],287:[function(require,module,exports){
module.exports={A:{A:{"1":"A B","2":"K D G E gB"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 3 4 6 7 9 X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"2 dB BB F N K D G E A B C d J M XB WB","4":"H I O P Q R S T U V W"},D:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"1":"5 N K D G E A B C RB SB TB UB VB p YB","2":"F PB HB"},F:{"1":"0 1 6 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"5 8 E B C ZB aB bB cB p eB"},G:{"1":"G EB hB JB jB kB lB mB nB oB pB qB rB sB","2":"HB fB"},H:{"2":"tB"},I:{"1":"4 BB F vB wB xB EB yB zB","2":"uB"},J:{"1":"D A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:1,C:"sandbox attribute for iframes"};

},{}],288:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"2":"0 1 2 3 4 6 7 9 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB"},D:{"2":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","66":"P Q R S T U V"},E:{"2":"5 F N K G E A B C PB HB RB SB UB VB p YB","130":"D TB"},F:{"2":"0 1 5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z ZB aB bB cB p eB"},G:{"2":"G HB fB EB hB JB kB lB mB nB oB pB qB rB sB","130":"jB"},H:{"2":"tB"},I:{"2":"4 BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"2":"5 8 A B C L p"},L:{"2":"IB"},M:{"2":"3"},N:{"2":"A B"},O:{"2":"0B"},P:{"2":"F 1B 2B 3B 4B"},Q:{"2":"5B"},R:{"2":"6B"}},B:7,C:"seamless attribute for iframes"};

},{}],289:[function(require,module,exports){
module.exports={A:{A:{"2":"gB","8":"K D G E A B"},B:{"8":"2 C d J M H I"},C:{"1":"0 1 3 4 6 7 9 U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"dB","8":"2 BB F N K D G E A B C d J M H I O P Q R S T XB WB"},D:{"1":"0 1 3 4 6 7 9 P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 F N K D G E A B C","8":"d J M H I O"},E:{"1":"5 K D G E A B C SB TB UB VB p YB","2":"PB HB","8":"F N RB"},F:{"1":"0 1 6 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"E B ZB aB bB cB","8":"5 8 C p eB"},G:{"1":"G JB jB kB lB mB nB oB pB qB rB sB","2":"HB","8":"fB EB hB"},H:{"2":"tB"},I:{"1":"4 yB zB","8":"BB F uB vB wB xB EB"},J:{"1":"A","8":"D"},K:{"1":"L","2":"A B","8":"5 8 C p"},L:{"1":"IB"},M:{"1":"3"},N:{"8":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:1,C:"srcdoc attribute for iframes"};

},{}],290:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"2":"2 6 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c XB WB","194":"0 1 3 4 7 9 e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB"},D:{"2":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v","322":"0 1 3 4 7 9 w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"2":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"2":"5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i ZB aB bB cB p eB","322":"0 1 j k l m n o L q r s t u v w x y z"},G:{"2":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"2":"4 BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"2":"5 8 A B C L p"},L:{"1":"IB"},M:{"2":"3"},N:{"2":"A B"},O:{"2":"0B"},P:{"1":"1B 2B 3B 4B","2":"F"},Q:{"322":"5B"},R:{"1":"6B"}},B:5,C:"ImageCapture API"};

},{}],291:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A gB","161":"B"},B:{"161":"2 C d J M H I"},C:{"2":"0 1 2 3 4 6 7 9 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB"},D:{"2":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"2":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"2":"0 1 5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z ZB aB bB cB p eB"},G:{"2":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"2":"4 BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"2":"5 8 A B C L p"},L:{"2":"IB"},M:{"2":"3"},N:{"2":"A","161":"B"},O:{"2":"0B"},P:{"2":"F 1B 2B 3B 4B"},Q:{"2":"5B"},R:{"2":"6B"}},B:5,C:"Input Method Editor API"};

},{}],292:[function(require,module,exports){
module.exports={A:{A:{"1":"E A B","2":"K D G gB"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 2 3 4 6 7 9 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB"},D:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"1":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"1":"0 1 5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z ZB aB bB cB p eB"},G:{"1":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"1":"tB"},I:{"1":"4 BB F uB vB wB xB EB yB zB"},J:{"1":"D A"},K:{"1":"5 8 A B C L p"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:1,C:"naturalWidth & naturalHeight image properties"};

},{}],293:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E gB","8":"A B"},B:{"8":"2 C d J M H I"},C:{"2":"2 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y XB WB","8":"0 1 3 4 7 9 Z a z GB FB AB CB DB","200":"6 b c e f g h i j k l m n o L q r s t u v w x y"},D:{"1":"0 1 3 4 7 9 f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB","2":"2 F N K D G E A B C d J M H I O P Q R S T U V W X Y MB NB OB","322":"6 Z a b c","584":"e"},E:{"2":"F N PB HB RB","8":"5 K D G E A B C SB TB UB VB p YB"},F:{"1":"0 1 6 S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"5 8 E B C J M ZB aB bB cB p eB","1090":"H I O P Q","2120":"R"},G:{"2":"HB fB EB hB JB","8":"G jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"1":"4","2":"BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"8":"3"},N:{"2":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:5,C:"HTML Imports"};

},{}],294:[function(require,module,exports){
module.exports={A:{A:{"1":"K D G E A B","16":"gB"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB WB","2":"dB BB","16":"XB"},D:{"1":"0 1 3 4 6 7 9 X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 F N K D G E A B C d J M H I O P Q R S T U V W"},E:{"1":"5 K D G E A B C SB TB UB VB p YB","2":"F N PB HB RB"},F:{"1":"0 1 5 6 C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z eB","2":"8 E B ZB aB bB cB p"},G:{"1":"rB sB","2":"G HB fB EB hB JB jB kB lB mB nB oB pB qB"},H:{"2":"tB"},I:{"1":"4 yB zB","2":"BB F uB vB wB xB EB"},J:{"2":"D A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"A B"},O:{"2":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:1,C:"indeterminate checkbox"};

},{}],295:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E gB","132":"A B"},B:{"132":"2 C d J M H I"},C:{"1":"0 1 3 4 6 7 9 M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"dB BB XB WB","33":"2 A B C d J","36":"F N K D G E"},D:{"1":"0 1 3 4 6 7 9 T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"A","8":"F N K D G E","33":"S","36":"2 B C d J M H I O P Q R"},E:{"1":"5 A B C VB p YB","8":"F N K D PB HB RB SB","260":"G E TB UB"},F:{"1":"0 1 6 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"E ZB aB","8":"5 8 B C bB cB p eB"},G:{"1":"nB oB pB qB rB sB","8":"HB fB EB hB JB jB","260":"G kB lB mB"},H:{"2":"tB"},I:{"1":"4 yB zB","8":"BB F uB vB wB xB EB"},J:{"1":"A","8":"D"},K:{"1":"L","2":"A","8":"5 8 B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"132":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:2,C:"IndexedDB"};

},{}],296:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"1":"0 1 3 4 7 9 u v w x y z GB FB AB CB DB","2":"2 6 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m XB WB","132":"n o L","260":"q r s t"},D:{"1":"1 3 4 7 9 GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q","132":"r s t u","260":"0 v w x y z"},E:{"1":"5 B C VB p YB","2":"F N K D G E A PB HB RB SB TB UB"},F:{"1":"0 1 o L q r s t u v w x y z","2":"5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c ZB aB bB cB p eB","132":"e f g h","260":"i j k l m n"},G:{"1":"oB pB qB rB sB","2":"G HB fB EB hB JB jB kB lB mB","16":"nB"},H:{"2":"tB"},I:{"1":"4","2":"BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"2":"0B"},P:{"1":"3B 4B","2":"F","260":"1B 2B"},Q:{"2":"5B"},R:{"2":"6B"}},B:4,C:"IndexedDB 2.0"};

},{}],297:[function(require,module,exports){
module.exports={A:{A:{"1":"G E A B","4":"gB","132":"K D"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 2 3 4 6 7 9 BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB","36":"dB"},D:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"1":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"1":"0 1 5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z ZB aB bB cB p eB"},G:{"1":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"1":"tB"},I:{"1":"4 BB F uB vB wB xB EB yB zB"},J:{"1":"D A"},K:{"1":"5 8 A B C L p"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:2,C:"CSS inline-block"};

},{}],298:[function(require,module,exports){
module.exports={A:{A:{"1":"K D G E A B","16":"gB"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 3 4 7 9 o L q r s t u v w x y z GB FB AB CB DB","2":"2 6 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n XB WB"},D:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"1":"5 F N K D G E A B C HB RB SB TB UB VB p YB","16":"PB"},F:{"1":"0 1 5 6 8 B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z ZB aB bB cB p eB","16":"E"},G:{"1":"G fB EB hB JB jB kB lB mB nB oB pB qB rB sB","16":"HB"},H:{"1":"tB"},I:{"1":"4 BB F wB xB EB yB zB","16":"uB vB"},J:{"1":"D A"},K:{"1":"5 8 A B C L p"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:1,C:"Node.innerText"};

},{}],299:[function(require,module,exports){
module.exports={A:{A:{"1":"K D G E A gB","132":"B"},B:{"132":"2 C d J M H I"},C:{"1":"2 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y XB WB","516":"0 1 3 4 6 7 9 Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB"},D:{"1":"H I O P Q R S T U V","2":"2 F N K D G E A B C d J M","132":"6 W X Y Z a b c e f g h i j","260":"0 1 3 4 7 9 k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"1":"K RB SB","2":"F N PB HB","2052":"5 D G E A B C TB UB VB p YB"},F:{"1":"0 1 5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z ZB aB bB cB p eB"},G:{"2":"HB fB EB","1025":"G hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"1025":"tB"},I:{"1":"4 BB F uB vB wB xB EB yB zB"},J:{"1":"D A"},K:{"1":"5 8 A B C L p"},L:{"1":"IB"},M:{"1":"3"},N:{"2052":"A B"},O:{"1025":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"260":"5B"},R:{"1":"6B"}},B:1,C:"autocomplete attribute: on & off values"};

},{}],300:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"1":"d J M H I","2":"2 C"},C:{"1":"0 1 3 4 6 7 9 Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"2 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X XB WB"},D:{"1":"0 1 3 4 6 7 9 P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 F N K D G E A B C d J M H I O"},E:{"1":"5 YB","2":"F N K D G E A B C PB HB RB SB TB UB VB p"},F:{"1":"0 1 5 6 8 B C H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z p eB","2":"E J M ZB aB bB cB"},G:{"1":"sB","2":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB"},H:{"2":"tB"},I:{"1":"4 yB zB","2":"BB F uB vB wB xB EB"},J:{"1":"D A"},K:{"1":"5 8 A B C L p"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:1,C:"Color input type"};

},{}],301:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"1":"2 d J M H I","132":"C"},C:{"2":"2 6 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v XB WB","1090":"w x y z","2052":"0 1 3 4 7 9 GB FB AB CB DB"},D:{"1":"0 1 3 4 6 7 9 U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 F N K D G E A B C d J M H I O","2052":"P Q R S T"},E:{"2":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"1":"0 1 5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z ZB aB bB cB p eB"},G:{"2":"HB fB EB","260":"G hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"1":"4 yB zB","2":"BB uB vB wB","514":"F xB EB"},J:{"1":"A","2":"D"},K:{"1":"5 8 A B C L p"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:1,C:"Date and time input types"};

},{}],302:[function(require,module,exports){
module.exports={A:{A:{"1":"A B","2":"K D G E gB"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"dB BB XB WB"},D:{"1":"0 1 2 3 4 6 7 9 N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"F"},E:{"1":"5 N K D G E A B C RB SB TB UB VB p YB","2":"F PB HB"},F:{"1":"0 1 5 6 8 B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z ZB aB bB cB p eB","2":"E"},G:{"1":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"1":"4 BB F xB EB yB zB","132":"uB vB wB"},J:{"1":"A","132":"D"},K:{"1":"5 8 A B C L p"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:1,C:"Email, telephone & URL input types"};

},{}],303:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G gB","2561":"A B","2692":"E"},B:{"2561":"2 C d J M H I"},C:{"1":"0 1 3 4 7 9 s t u v w x y z GB FB AB CB DB","16":"dB","1537":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r WB","1796":"BB XB"},D:{"1":"4 DB QB iB KB IB LB MB NB OB","16":"2 F N K D G E A B C d","1025":"0 1 3 7 9 e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB","1537":"6 J M H I O P Q R S T U V W X Y Z a b c"},E:{"16":"F N K PB HB","1025":"5 D G E A B C SB TB UB VB p YB","1537":"RB"},F:{"1":"0 1 5 v w x y z","16":"8 E B C ZB aB bB cB p","260":"eB","1025":"6 R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u","1537":"J M H I O P Q"},G:{"16":"HB fB EB","1025":"G kB lB mB nB oB pB qB rB sB","1537":"hB JB jB"},H:{"2":"tB"},I:{"16":"uB vB","1025":"4 zB","1537":"BB F wB xB EB yB"},J:{"1025":"A","1537":"D"},K:{"1":"5 8 A B C p","1025":"L"},L:{"1025":"IB"},M:{"1537":"3"},N:{"2561":"A B"},O:{"1537":"0B"},P:{"1025":"F 1B 2B 3B 4B"},Q:{"1025":"5B"},R:{"1025":"6B"}},B:1,C:"input event"};

},{}],304:[function(require,module,exports){
module.exports={A:{A:{"1":"A B","2":"K D G E gB"},B:{"2":"2 C d J M H I"},C:{"1":"0 1 3 4 7 9 g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"dB BB XB WB","132":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f"},D:{"1":"0 1 3 4 6 7 9 V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"F","16":"N K D G Q R S T U","132":"2 E A B C d J M H I O P"},E:{"1":"5 C p YB","2":"F N PB HB RB","132":"K D G E A B SB TB UB VB"},F:{"1":"0 1 6 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"5 8 E B C ZB aB bB cB p eB"},G:{"2":"JB jB","132":"G kB lB mB nB oB pB qB rB sB","514":"HB fB EB hB"},H:{"2":"tB"},I:{"2":"uB vB wB","260":"BB F xB EB","514":"4 yB zB"},J:{"132":"A","260":"D"},K:{"2":"5 8 A B C p","260":"L"},L:{"260":"IB"},M:{"2":"3"},N:{"514":"A","1028":"B"},O:{"2":"0B"},P:{"260":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"260":"6B"}},B:1,C:"accept attribute for file input"};

},{}],305:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"1":"d J M H I","2":"2 C"},C:{"1":"0 1 3 4 7 9 t u v w x y z GB FB AB CB DB","2":"2 6 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s XB WB"},D:{"1":"0 1 3 4 6 7 9 Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 F N K D G E A B C d J M H I O P Q R S T U V W X Y"},E:{"1":"5 C p YB","2":"F N K D G E A B PB HB RB SB TB UB VB"},F:{"1":"0 1 6 H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"5 8 E B C J M ZB aB bB cB p eB"},G:{"2":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"2":"4 BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"2":"5 8 A B C L p"},L:{"2":"IB"},M:{"2":"3"},N:{"2":"A B"},O:{"2":"0B"},P:{"2":"F 1B 2B 3B 4B"},Q:{"2":"5B"},R:{"2":"6B"}},B:7,C:"Directory selection from file input"};

},{}],306:[function(require,module,exports){
module.exports={A:{A:{"1":"A B","2":"K D G E gB"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB WB","2":"dB BB XB"},D:{"1":"0 1 2 3 4 6 7 9 N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"F"},E:{"1":"5 F N K D G E A B C RB SB TB UB VB p YB","2":"PB HB"},F:{"1":"0 1 5 6 8 B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z cB p eB","2":"E ZB aB bB"},G:{"1":"G JB jB kB lB mB nB oB pB qB rB sB","2":"HB fB EB hB"},H:{"130":"tB"},I:{"130":"4 BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"130":"5 8 A B C L p"},L:{"132":"IB"},M:{"130":"3"},N:{"2":"A B"},O:{"130":"0B"},P:{"130":"F","132":"1B 2B 3B 4B"},Q:{"1":"5B"},R:{"132":"6B"}},B:1,C:"Multiple file selection"};

},{}],307:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"2":"2 dB BB F N K D G E A B C d J M XB WB","4":"H I O P","194":"0 1 3 4 6 7 9 Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB"},D:{"1":"4 DB QB iB KB IB LB MB NB OB","2":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y","66":"0 1 3 7 9 z GB FB AB CB"},E:{"2":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"1":"0 1 w x y z","2":"5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l ZB aB bB cB p eB","66":"m n o L q r s t u v"},G:{"1":"sB","2":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB"},H:{"2":"tB"},I:{"1":"4","2":"BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"2":"5 8 A B C L p"},L:{"1":"IB"},M:{"194":"3"},N:{"2":"A B"},O:{"2":"0B"},P:{"2":"F 1B 2B 3B 4B"},Q:{"2":"5B"},R:{"2":"6B"}},B:1,C:"inputmode attribute"};

},{}],308:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"1":"H I","2":"2 C d J M"},C:{"1":"0 1 3 4 7 9 u v w x y z GB FB AB CB DB","2":"2 6 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t XB WB"},D:{"1":"0 1 3 4 7 9 j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i"},E:{"1":"5 B C VB p YB","2":"F N K D G E A PB HB RB SB TB UB"},F:{"1":"0 1 6 W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"5 8 E B C J M H I O P Q R S T U V ZB aB bB cB p eB"},G:{"1":"oB pB qB rB sB","2":"G HB fB EB hB JB jB kB lB mB nB"},H:{"2":"tB"},I:{"1":"4","2":"BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"1":"0B"},P:{"1":"1B 2B 3B 4B","2":"F"},Q:{"2":"5B"},R:{"1":"6B"}},B:1,C:"Minimum length attribute for input fields"};

},{}],309:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E gB","129":"A B"},B:{"129":"2 C","1025":"d J M H I"},C:{"2":"2 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X XB WB","513":"0 1 3 4 6 7 9 Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB"},D:{"1":"0 1 2 3 4 6 7 9 K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"F N"},E:{"1":"5 N K D G E A B C RB SB TB UB VB p YB","2":"F PB HB"},F:{"1":"0 1 5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z ZB aB bB cB p eB"},G:{"388":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"2":"BB uB vB wB","388":"4 F xB EB yB zB"},J:{"2":"D","388":"A"},K:{"1":"5 8 A B C p","388":"L"},L:{"388":"IB"},M:{"641":"3"},N:{"388":"A B"},O:{"388":"0B"},P:{"388":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"388":"6B"}},B:1,C:"Number input type"};

},{}],310:[function(require,module,exports){
module.exports={A:{A:{"1":"A B","2":"K D G E gB"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"dB BB XB WB"},D:{"1":"0 1 2 3 4 6 7 9 A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"F N K D G E"},E:{"1":"5 B C VB p YB","2":"F PB HB","16":"N","388":"K D G E A RB SB TB UB"},F:{"1":"0 1 5 6 8 B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z ZB aB bB cB p eB","2":"E"},G:{"1":"oB pB qB rB sB","16":"HB fB EB","388":"G hB JB jB kB lB mB nB"},H:{"2":"tB"},I:{"1":"4 zB","2":"BB F uB vB wB xB EB yB"},J:{"1":"A","2":"D"},K:{"1":"5 8 A B C p","132":"L"},L:{"1":"IB"},M:{"1":"3"},N:{"132":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:1,C:"Pattern attribute for input fields"};

},{}],311:[function(require,module,exports){
module.exports={A:{A:{"1":"A B","2":"K D G E gB"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"dB BB XB WB"},D:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"1":"5 N K D G E A B C RB SB TB UB VB p YB","132":"F PB HB"},F:{"1":"0 1 5 6 8 C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z eB","2":"E ZB aB bB cB","132":"B p"},G:{"1":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"1":"tB"},I:{"1":"4 BB uB vB wB EB yB zB","4":"F xB"},J:{"1":"D A"},K:{"1":"5 8 B C L p","2":"A"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:1,C:"input placeholder attribute"};

},{}],312:[function(require,module,exports){
module.exports={A:{A:{"1":"A B","2":"K D G E gB"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 3 4 6 7 9 S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"2 dB BB F N K D G E A B C d J M H I O P Q R XB WB"},D:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"1":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"1":"0 1 5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z ZB aB bB cB p eB"},G:{"1":"G hB JB jB kB lB mB nB oB pB qB rB sB","2":"HB fB EB"},H:{"2":"tB"},I:{"1":"4 EB yB zB","4":"BB F uB vB wB xB"},J:{"1":"D A"},K:{"1":"5 8 A B C L p"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:1,C:"Range input type"};

},{}],313:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E gB","129":"A B"},B:{"129":"2 C d J M H I"},C:{"2":"dB BB XB WB","129":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB"},D:{"1":"0 1 3 4 6 7 9 V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","16":"2 F N K D G E A B C d Q R S T U","129":"J M H I O P"},E:{"1":"5 K D G E A B C RB SB TB UB VB p YB","16":"F N PB HB"},F:{"1":"0 1 5 6 C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z eB","2":"E ZB aB bB cB","16":"8 B p"},G:{"1":"G hB JB jB kB lB mB nB oB pB qB rB sB","16":"HB fB EB"},H:{"129":"tB"},I:{"1":"4 yB zB","16":"uB vB","129":"BB F wB xB EB"},J:{"1":"D","129":"A"},K:{"1":"C","2":"A","16":"8 B p","129":"5 L"},L:{"1":"IB"},M:{"129":"3"},N:{"129":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:1,C:"Search input type"};

},{}],314:[function(require,module,exports){
module.exports={A:{A:{"1":"E A B","2":"K D G gB"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 2 3 4 6 7 9 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB"},D:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"1":"5 F N K D G E A B C RB SB TB UB VB p YB","16":"PB HB"},F:{"1":"0 1 5 6 8 B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z cB p eB","16":"E ZB aB bB"},G:{"1":"G fB EB hB JB jB kB lB mB nB oB pB qB rB sB","16":"HB"},H:{"2":"tB"},I:{"1":"4 BB F uB vB wB xB EB yB zB"},J:{"1":"D A"},K:{"1":"5 8 A B C L p"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:1,C:"Selection controls for input & textarea"};

},{}],315:[function(require,module,exports){
module.exports={A:{A:{"1":"K D G E A B","16":"gB"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 3 4 7 9 r s t u v w x y z GB FB AB CB DB","2":"2 6 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q XB WB"},D:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"1":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"1":"0 1 5 6 8 B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z ZB aB bB cB p eB","16":"E"},G:{"1":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"1":"tB"},I:{"1":"4 BB F wB xB EB yB zB","16":"uB vB"},J:{"1":"D A"},K:{"1":"5 8 A B C L p"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:1,C:"Element.insertAdjacentElement() & Element.insertAdjacentText()"};

},{}],316:[function(require,module,exports){
module.exports={A:{A:{"1":"A B","16":"gB","132":"K D G E"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 2 3 4 6 7 9 G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"dB BB F N K D XB WB"},D:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"1":"5 F N K D G E A B C RB SB TB UB VB p YB","2":"PB HB"},F:{"1":"0 1 5 6 8 B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z aB bB cB p eB","16":"E ZB"},G:{"1":"G fB EB hB JB jB kB lB mB nB oB pB qB rB sB","16":"HB"},H:{"1":"tB"},I:{"1":"4 BB F wB xB EB yB zB","16":"uB vB"},J:{"1":"D A"},K:{"1":"5 8 A B C L p"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:4,C:"Element.insertAdjacentHTML()"};

},{}],317:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H","130":"I"},C:{"1":"1 3 4 7 9 GB FB AB CB DB","2":"0 2 6 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z XB WB"},D:{"1":"3 4 AB CB DB QB iB KB IB LB MB NB OB","2":"0 1 2 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB"},E:{"2":"F N K D G E A B C PB HB RB SB TB UB VB p","16":"5 YB"},F:{"1":"0 1 t u v w x y z","2":"5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s ZB aB bB cB p eB"},G:{"2":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"1":"4","2":"BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"2":"5 8 A B C L p"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"2":"0B"},P:{"2":"F 1B 2B 3B 4B"},Q:{"2":"5B"},R:{"2":"6B"}},B:6,C:"Intl.PluralRules API"};

},{}],318:[function(require,module,exports){
module.exports={A:{A:{"1":"B","2":"K D G E A gB"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 3 4 6 7 9 Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"2 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X XB WB"},D:{"1":"0 1 3 4 6 7 9 T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 F N K D G E A B C d J M H I O P Q R S"},E:{"1":"5 A B C VB p YB","2":"F N K D G E PB HB RB SB TB UB"},F:{"1":"0 1 6 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"5 8 E B C ZB aB bB cB p eB"},G:{"1":"nB oB pB qB rB sB","2":"G HB fB EB hB JB jB kB lB mB"},H:{"2":"tB"},I:{"1":"4 yB zB","2":"BB F uB vB wB xB EB"},J:{"2":"D A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"B","2":"A"},O:{"2":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"2":"5B"},R:{"1":"6B"}},B:6,C:"Internationalization API"};

},{}],319:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"1":"M H I","2":"2 C d","516":"J"},C:{"1":"0 1 3 4 7 9 y z GB FB AB CB DB","2":"2 6 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u XB WB","194":"v w x"},D:{"1":"1 3 7 9 GB FB AB","2":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t","516":"0 u v w x y z","1025":"4 CB DB QB iB KB IB LB MB NB OB"},E:{"1":"5 YB","2":"F N K D G E A B C PB HB RB SB TB UB VB p"},F:{"1":"0 1 o L q r s t u v w x y z","2":"5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g ZB aB bB cB p eB","516":"h i j k l m n"},G:{"1":"sB","2":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB"},H:{"2":"tB"},I:{"1":"4","2":"BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"516":"0B"},P:{"1":"3B 4B","2":"F","516":"1B 2B"},Q:{"2":"5B"},R:{"2":"6B"}},B:5,C:"IntersectionObserver"};

},{}],320:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"2":"dB","257":"4 DB","932":"0 1 2 3 6 7 9 BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB XB WB"},D:{"2":"2 F N K D G E A B C d J M H I O P Q","545":"6 R S T U V W X Y Z a b c e f g h i j k l m n o","1537":"0 1 3 4 7 9 L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"2":"F N K PB HB RB","516":"5 B C p YB","548":"E A UB VB","676":"D G SB TB"},F:{"2":"5 8 E B C ZB aB bB cB p eB","513":"6","545":"J M H I O P Q R S T U V W X Y Z a b","1537":"0 1 c e f g h i j k l m n o L q r s t u v w x y z"},G:{"2":"HB fB EB hB JB","548":"lB mB nB oB pB qB rB sB","676":"G jB kB"},H:{"2":"tB"},I:{"2":"BB F uB vB wB xB EB","545":"yB zB","1537":"4"},J:{"2":"D","545":"A"},K:{"2":"5 8 A B C p","1537":"L"},L:{"1537":"IB"},M:{"932":"3"},N:{"2":"A B"},O:{"1":"0B"},P:{"545":"F","1537":"1B 2B 3B 4B"},Q:{"545":"5B"},R:{"1537":"6B"}},B:5,C:"Intrinsic & Extrinsic Sizing"};

},{}],321:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"2":"0 1 2 3 4 6 7 9 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB"},D:{"2":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"1":"5 K D G E A B C SB TB UB VB p YB","2":"F PB HB","129":"N RB"},F:{"2":"0 1 5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z ZB aB bB cB p eB"},G:{"1":"G hB JB jB kB lB mB nB oB pB qB rB sB","2":"HB fB EB"},H:{"2":"tB"},I:{"2":"4 BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"2":"5 8 A B C L p"},L:{"2":"IB"},M:{"2":"3"},N:{"2":"A B"},O:{"2":"0B"},P:{"2":"F 1B 2B 3B 4B"},Q:{"2":"5B"},R:{"2":"6B"}},B:6,C:"JPEG 2000 image format"};

},{}],322:[function(require,module,exports){
module.exports={A:{A:{"1":"E A B","2":"K D G gB"},B:{"1":"2 C d J M H I"},C:{"2":"0 1 2 3 4 6 7 9 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB"},D:{"2":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"2":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"2":"0 1 5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z ZB aB bB cB p eB"},G:{"2":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"2":"4 BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"2":"5 8 A B C L p"},L:{"2":"IB"},M:{"2":"3"},N:{"1":"A B"},O:{"2":"0B"},P:{"2":"F 1B 2B 3B 4B"},Q:{"2":"5B"},R:{"2":"6B"}},B:6,C:"JPEG XR image format"};

},{}],323:[function(require,module,exports){
module.exports={A:{A:{"1":"E A B","2":"K D gB","129":"G"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB","2":"dB BB"},D:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"1":"5 F N K D G E A B C RB SB TB UB VB p YB","2":"PB HB"},F:{"1":"0 1 5 6 8 B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z bB cB p eB","2":"E ZB aB"},G:{"1":"G fB EB hB JB jB kB lB mB nB oB pB qB rB sB","2":"HB"},H:{"1":"tB"},I:{"1":"4 BB F uB vB wB xB EB yB zB"},J:{"1":"D A"},K:{"1":"5 8 A B C L p"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:6,C:"JSON parsing"};

},{}],324:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J","132":"M H I"},C:{"1":"0 1 3 4 7 9 v w x y z GB FB AB CB DB","2":"2 6 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u XB WB"},D:{"1":"3 4 7 9 FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","132":"0 1 GB"},E:{"1":"5 B C p YB","2":"F N K D G E A PB HB RB SB TB UB","132":"VB"},F:{"1":"0 1 q r s t u v w x y z","2":"5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m ZB aB bB cB p eB","132":"n o L"},G:{"1":"pB qB rB sB","2":"G HB fB EB hB JB jB kB lB mB nB","132":"oB"},H:{"2":"tB"},I:{"1":"4","2":"BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"132":"0B"},P:{"1":"4B","2":"F 1B 2B","132":"3B"},Q:{"132":"5B"},R:{"2":"6B"}},B:5,C:"CSS justify-content: space-evenly"};

},{}],325:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"1":"I","2":"2 C d J M H"},C:{"1":"0 1 2 3 4 6 7 9 BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB","2":"dB"},D:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"1":"5 N K D G E A B C RB SB TB UB VB p YB","2":"F PB HB"},F:{"1":"0 1 6 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"5 8 E B C ZB aB bB cB p eB"},G:{"1":"G EB hB JB jB kB lB mB nB oB pB qB rB sB","16":"HB fB"},H:{"2":"tB"},I:{"1":"4 yB zB","2":"uB vB wB","132":"BB F xB EB"},J:{"1":"A","2":"D"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:7,C:"High-quality kerning pairs & ligatures"};

},{}],326:[function(require,module,exports){
module.exports={A:{A:{"1":"E A B","2":"K D G gB"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 2 3 4 6 7 9 BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB","16":"dB"},D:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"1":"5 F N K D G E A B C RB SB TB UB VB p YB","16":"PB HB"},F:{"1":"0 1 5 6 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"8 E B ZB aB bB cB p eB","16":"C"},G:{"1":"G hB JB jB kB lB mB nB oB pB qB rB sB","16":"HB fB EB"},H:{"2":"tB"},I:{"1":"4 BB F wB xB EB yB zB","16":"uB vB"},J:{"1":"D A"},K:{"1":"5","2":"8 A B p","16":"C","130":"L"},L:{"1":"IB"},M:{"130":"3"},N:{"130":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:7,C:"KeyboardEvent.charCode"};

},{}],327:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"1":"0 1 3 4 7 9 h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"2 6 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g XB WB"},D:{"1":"0 1 3 4 7 9 r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k","194":"l m n o L q"},E:{"1":"5 B C VB p YB","2":"F N K D G E A PB HB RB SB TB UB"},F:{"1":"0 1 e f g h i j k l m n o L q r s t u v w x y z","2":"5 8 E B C J M H I O P Q R S T U V W X ZB aB bB cB p eB","194":"6 Y Z a b c"},G:{"1":"oB pB qB rB sB","2":"G HB fB EB hB JB jB kB lB mB nB"},H:{"2":"tB"},I:{"2":"4 BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"2":"5 8 A B C p","194":"L"},L:{"194":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"2":"0B"},P:{"2":"F","194":"1B 2B 3B 4B"},Q:{"2":"5B"},R:{"194":"6B"}},B:5,C:"KeyboardEvent.code"};

},{}],328:[function(require,module,exports){
module.exports={A:{A:{"1":"E A B","2":"K D G gB"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 3 4 6 7 9 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"2 dB BB F N K D G E A B C d XB WB"},D:{"1":"0 1 3 4 6 7 9 Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 F N K D G E A B C d J M H I O P Q R S T U V W X Y"},E:{"1":"5 B C VB p YB","2":"F N K D G E A PB HB RB SB TB UB"},F:{"1":"0 1 5 6 H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"8 E B J M ZB aB bB cB p eB","16":"C"},G:{"1":"oB pB qB rB sB","2":"G HB fB EB hB JB jB kB lB mB nB"},H:{"2":"tB"},I:{"1":"4 yB zB","2":"BB F uB vB wB xB EB"},J:{"2":"D A"},K:{"1":"5 L","2":"8 A B p","16":"C"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:5,C:"KeyboardEvent.getModifierState()"};

},{}],329:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G gB","260":"E A B"},B:{"260":"2 C d J M H I"},C:{"1":"0 1 3 4 6 7 9 Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"2 dB BB F N K D G E A B C d J M H I O P Q R XB WB","132":"S T U V W X"},D:{"1":"0 1 3 4 7 9 u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t"},E:{"1":"5 B C VB p YB","2":"F N K D G E A PB HB RB SB TB UB"},F:{"1":"0 1 5 h i j k l m n o L q r s t u v w x y z","2":"6 8 E B J M H I O P Q R S T U V W X Y Z a b c e f g ZB aB bB cB p eB","16":"C"},G:{"1":"oB pB qB rB sB","2":"G HB fB EB hB JB jB kB lB mB nB"},H:{"2":"tB"},I:{"2":"4 BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"1":"5","2":"8 A B p","16":"C L"},L:{"1":"IB"},M:{"1":"3"},N:{"260":"A B"},O:{"2":"0B"},P:{"1":"1B 2B 3B 4B","2":"F"},Q:{"2":"5B"},R:{"2":"6B"}},B:5,C:"KeyboardEvent.key"};

},{}],330:[function(require,module,exports){
module.exports={A:{A:{"1":"E A B","2":"K D G gB"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 3 4 6 7 9 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"2 dB BB F N K D G E A B C d XB WB"},D:{"1":"0 1 3 4 6 7 9 Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","132":"2 F N K D G E A B C d J M H I O P Q R S T U V W X Y"},E:{"1":"5 D G E A B C SB TB UB VB p YB","16":"K PB HB","132":"F N RB"},F:{"1":"0 1 5 6 H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"8 E B ZB aB bB cB p eB","16":"C","132":"J M"},G:{"1":"G kB lB mB nB oB pB qB rB sB","16":"HB fB EB","132":"hB JB jB"},H:{"2":"tB"},I:{"1":"4 yB zB","16":"uB vB","132":"BB F wB xB EB"},J:{"132":"D A"},K:{"1":"5 L","2":"8 A B p","16":"C"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:5,C:"KeyboardEvent.location"};

},{}],331:[function(require,module,exports){
module.exports={A:{A:{"1":"E A B","2":"K D G gB"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 2 3 4 6 7 9 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB"},D:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"1":"5 K D G E A B C RB SB TB UB VB p YB","2":"F PB HB","16":"N"},F:{"1":"0 1 5 6 8 B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z aB bB cB p eB","16":"E ZB"},G:{"1":"G hB JB jB kB lB mB nB oB pB qB rB sB","16":"HB fB EB"},H:{"2":"tB"},I:{"1":"4 BB F wB xB EB","16":"uB vB","132":"yB zB"},J:{"1":"D A"},K:{"1":"5 8 A B C p","132":"L"},L:{"132":"IB"},M:{"132":"3"},N:{"1":"A B"},O:{"1":"0B"},P:{"2":"F","132":"1B 2B 3B 4B"},Q:{"1":"5B"},R:{"132":"6B"}},B:7,C:"KeyboardEvent.which"};

},{}],332:[function(require,module,exports){
module.exports={A:{A:{"1":"B","2":"K D G E A gB"},B:{"1":"2 C d J M H I"},C:{"2":"0 1 2 3 4 6 7 9 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB"},D:{"2":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"2":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"2":"0 1 5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z ZB aB bB cB p eB"},G:{"2":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"2":"4 BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"2":"5 8 A B C L p"},L:{"2":"IB"},M:{"2":"3"},N:{"1":"B","2":"A"},O:{"2":"0B"},P:{"2":"F 1B 2B 3B 4B"},Q:{"2":"5B"},R:{"2":"6B"}},B:7,C:"Resource Hints: Lazyload"};

},{}],333:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A gB","2052":"B"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 3 4 7 9 n o L q r s t u v w x y z GB FB AB CB DB","194":"2 6 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m XB WB"},D:{"1":"0 1 3 4 7 9 s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 F N K D G E A B C d J M H I","322":"6 O P Q R S T U V W X Y Z a b c e f g h i j","516":"k l m n o L q r"},E:{"1":"5 B C p YB","2":"F N K D G E PB HB RB SB TB UB","1028":"A VB"},F:{"1":"0 1 f g h i j k l m n o L q r s t u v w x y z","2":"5 8 E B C ZB aB bB cB p eB","322":"J M H I O P Q R S T U V W","516":"6 X Y Z a b c e"},G:{"1":"pB qB rB sB","2":"G HB fB EB hB JB jB kB lB mB","1028":"nB oB"},H:{"2":"tB"},I:{"1":"4","2":"BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"B","2":"A"},O:{"1":"0B"},P:{"1":"1B 2B 3B 4B","516":"F"},Q:{"2":"5B"},R:{"516":"6B"}},B:6,C:"let"};

},{}],334:[function(require,module,exports){
module.exports={A:{A:{"1":"B","2":"K D G E A gB"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 2 3 4 6 7 9 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB"},D:{"129":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"257":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"129":"0 1 6 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","513":"5 8 E B C ZB aB bB cB p eB"},G:{"1026":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"1026":"tB"},I:{"1":"BB F uB vB wB xB EB","513":"4 yB zB"},J:{"1":"D","1026":"A"},K:{"1026":"5 8 A B C L p"},L:{"1":"IB"},M:{"1":"3"},N:{"1026":"A B"},O:{"257":"0B"},P:{"1":"1B 2B 3B 4B","513":"F"},Q:{"129":"5B"},R:{"1":"6B"}},B:1,C:"PNG favicons"};

},{}],335:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"2":"dB BB XB WB","260":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j","1025":"0 1 3 4 7 9 k l m n o L q r s t u v w x y z GB FB AB CB DB"},D:{"2":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB","16":"MB NB OB"},E:{"2":"F N K D G PB HB RB SB TB","516":"5 E A B C UB VB p YB"},F:{"1":"0 1 n o L q r s t u v w x y z","2":"5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m ZB aB bB cB p eB"},G:{"130":"G HB fB EB hB JB jB kB","516":"lB mB nB oB pB qB rB sB"},H:{"130":"tB"},I:{"2":"4 BB F uB vB wB xB EB yB zB"},J:{"2":"D","130":"A"},K:{"130":"5 8 A B C L p"},L:{"2":"IB"},M:{"2":"3"},N:{"130":"A B"},O:{"2":"0B"},P:{"2":"F 1B 2B 3B 4B"},Q:{"2":"5B"},R:{"2":"6B"}},B:1,C:"SVG favicons"};

},{}],336:[function(require,module,exports){
module.exports={A:{A:{"1":"A B","2":"K D G gB","132":"E"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB","2":"dB BB"},D:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"1":"5 N K D G E A B C RB SB TB UB VB p YB","2":"F PB HB"},F:{"1":"0 1 6 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"5 8 E B C ZB aB bB cB p eB"},G:{"16":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"16":"4 BB F uB vB wB xB EB yB zB"},J:{"16":"D A"},K:{"16":"5 8 A B C L p"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"B","2":"A"},O:{"16":"0B"},P:{"1":"1B 2B 3B 4B","16":"F"},Q:{"1":"5B"},R:{"1":"6B"}},B:5,C:"Resource Hints: dns-prefetch"};

},{}],337:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d","260":"J M H I"},C:{"1":"0 1 3 4 7 9 j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"2 6 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h XB WB","129":"i"},D:{"1":"0 1 3 4 7 9 L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o"},E:{"1":"5 C p YB","2":"F N K D G E A B PB HB RB SB TB UB VB"},F:{"1":"0 1 6 c e f g h i j k l m n o L q r s t u v w x y z","2":"5 8 E B C J M H I O P Q R S T U V W X Y Z a b ZB aB bB cB p eB"},G:{"1":"qB rB sB","2":"G HB fB EB hB JB jB kB lB mB nB oB pB"},H:{"2":"tB"},I:{"1":"4","2":"BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"16":"3"},N:{"2":"A B"},O:{"16":"0B"},P:{"1":"1B 2B 3B 4B","2":"F"},Q:{"1":"5B"},R:{"1":"6B"}},B:5,C:"Resource Hints: preconnect"};

},{}],338:[function(require,module,exports){
module.exports={A:{A:{"1":"B","2":"K D G E A gB"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 2 3 4 6 7 9 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB"},D:{"1":"0 1 2 3 4 6 7 9 G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"F N K D"},E:{"2":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"1":"0 1 6 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"5 8 E B C ZB aB bB cB p eB"},G:{"2":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"1":"4 F yB zB","2":"BB uB vB wB xB EB"},J:{"2":"D A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"B","2":"A"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:5,C:"Resource Hints: prefetch"};

},{}],339:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M","1028":"H I"},C:{"2":"2 6 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y XB WB","132":"z","578":"0 1 3 4 7 9 GB FB AB CB DB"},D:{"1":"0 1 3 4 7 9 t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s"},E:{"1":"5 C p YB","2":"F N K D G E A PB HB RB SB TB UB VB","322":"B"},F:{"1":"0 1 g h i j k l m n o L q r s t u v w x y z","2":"5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f ZB aB bB cB p eB"},G:{"1":"qB rB sB","2":"G HB fB EB hB JB jB kB lB mB nB oB","322":"pB"},H:{"2":"tB"},I:{"1":"4","2":"BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"578":"3"},N:{"2":"A B"},O:{"2":"0B"},P:{"1":"1B 2B 3B 4B","2":"F"},Q:{"2":"5B"},R:{"2":"6B"}},B:4,C:"Resource Hints: preload"};

},{}],340:[function(require,module,exports){
module.exports={A:{A:{"1":"B","2":"K D G E A gB"},B:{"2":"2 C d J M H I"},C:{"2":"0 1 2 3 4 6 7 9 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB"},D:{"1":"0 1 2 3 4 6 7 9 d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"F N K D G E A B C"},E:{"2":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"1":"0 1 6 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"5 8 E B C ZB aB bB cB p eB"},G:{"2":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"2":"4 BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"2":"5 8 A B C L p"},L:{"1":"IB"},M:{"2":"3"},N:{"1":"B","2":"A"},O:{"2":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"2":"5B"},R:{"1":"6B"}},B:5,C:"Resource Hints: prerender"};

},{}],341:[function(require,module,exports){
module.exports={A:{A:{"1":"B","16":"gB","132":"K D G E A"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 3 4 6 7 9 Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","132":"2 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X XB WB"},D:{"1":"0 1 3 4 6 7 9 T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","132":"2 F N K D G E A B C d J M H I O P Q R S"},E:{"1":"5 A B C VB p YB","132":"F N K D G E PB HB RB SB TB UB"},F:{"1":"0 1 6 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","16":"8 E B C ZB aB bB cB p eB","132":"5"},G:{"1":"nB oB pB qB rB sB","132":"G HB fB EB hB JB jB kB lB mB"},H:{"132":"tB"},I:{"1":"4 yB zB","132":"BB F uB vB wB xB EB"},J:{"132":"D A"},K:{"1":"L","16":"8 A B C p","132":"5"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"B","132":"A"},O:{"132":"0B"},P:{"1":"1B 2B 3B 4B","132":"F"},Q:{"132":"5B"},R:{"1":"6B"}},B:6,C:"localeCompare()"};

},{}],342:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"2":"0 1 2 3 4 6 7 9 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB"},D:{"1":"4 QB iB KB IB LB MB NB OB","2":"0 2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","194":"1 3 7 9 GB FB AB CB DB"},E:{"2":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"1":"0 1 x y z","2":"5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w ZB aB bB cB p eB"},G:{"2":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"2":"4 BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"2":"5 8 A B C L p"},L:{"194":"IB"},M:{"2":"3"},N:{"2":"A B"},O:{"2":"0B"},P:{"2":"F 1B 2B 3B 4B"},Q:{"2":"5B"},R:{"2":"6B"}},B:4,C:"Magnetometer"};

},{}],343:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G gB","36":"E A B"},B:{"1":"J M H I","36":"2 C d"},C:{"1":"0 1 3 4 6 7 9 e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"dB BB XB","36":"2 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c WB"},D:{"1":"0 1 3 4 6 7 9 e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","36":"2 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c"},E:{"1":"5 G E A B C TB UB VB p YB","2":"F PB HB","36":"N K D RB SB"},F:{"1":"0 1 6 Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"E B ZB aB bB cB p","36":"5 8 C J M H I O P eB"},G:{"1":"G kB lB mB nB oB pB qB rB sB","2":"HB","36":"fB EB hB JB jB"},H:{"2":"tB"},I:{"1":"4","2":"uB","36":"BB F vB wB xB EB yB zB"},J:{"36":"D A"},K:{"1":"L","2":"A B","36":"5 8 C p"},L:{"1":"IB"},M:{"1":"3"},N:{"36":"A B"},O:{"1":"0B"},P:{"1":"1B 2B 3B 4B","36":"F"},Q:{"1":"5B"},R:{"1":"6B"}},B:1,C:"matches() DOM method"};

},{}],344:[function(require,module,exports){
module.exports={A:{A:{"1":"A B","2":"K D G E gB"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 2 3 4 6 7 9 K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"dB BB F N XB WB"},D:{"1":"0 1 2 3 4 6 7 9 E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"F N K D G"},E:{"1":"5 K D G E A B C RB SB TB UB VB p YB","2":"F N PB HB"},F:{"1":"0 1 5 6 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"8 E B C ZB aB bB cB p eB"},G:{"1":"G hB JB jB kB lB mB nB oB pB qB rB sB","2":"HB fB EB"},H:{"1":"tB"},I:{"1":"4 BB F xB EB yB zB","2":"uB vB wB"},J:{"1":"A","2":"D"},K:{"1":"5 L","2":"8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:5,C:"matchMedia"};

},{}],345:[function(require,module,exports){
module.exports={A:{A:{"2":"E A B gB","8":"K D G"},B:{"2":"2 C d J M H I"},C:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","129":"dB BB XB WB"},D:{"1":"T","8":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"1":"5 A B C VB p YB","260":"F N K D G E PB HB RB SB TB UB"},F:{"2":"E","4":"5 8 B C ZB aB bB cB p eB","8":"0 1 6 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z"},G:{"1":"G hB JB jB kB lB mB nB oB pB qB rB sB","8":"HB fB EB"},H:{"8":"tB"},I:{"8":"4 BB F uB vB wB xB EB yB zB"},J:{"1":"A","8":"D"},K:{"8":"5 8 A B C L p"},L:{"8":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"4":"0B"},P:{"8":"F 1B 2B 3B 4B"},Q:{"8":"5B"},R:{"8":"6B"}},B:2,C:"MathML"};

},{}],346:[function(require,module,exports){
module.exports={A:{A:{"1":"A B","16":"gB","900":"K D G E"},B:{"1025":"2 C d J M H I"},C:{"1":"0 1 3 4 7 9 u v w x y z GB FB AB CB DB","900":"dB BB XB WB","1025":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t"},D:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"1":"5 K D G E A B C RB SB TB UB VB p YB","16":"N PB","900":"F HB"},F:{"1":"0 1 6 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","16":"E","132":"5 8 B C ZB aB bB cB p eB"},G:{"1":"fB EB hB JB jB lB mB nB oB pB qB rB sB","16":"HB","2052":"G kB"},H:{"132":"tB"},I:{"1":"BB F wB xB EB yB zB","16":"uB vB","4097":"4"},J:{"1":"D A"},K:{"132":"5 8 A B C p","4100":"L"},L:{"4097":"IB"},M:{"4097":"3"},N:{"1":"A B"},O:{"1":"0B"},P:{"4097":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:1,C:"maxlength attribute for input and textarea elements"};

},{}],347:[function(require,module,exports){
module.exports={A:{A:{"1":"E A B","2":"K D G gB"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 3 4 6 7 9 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"2 dB BB F N K D G E A B C d XB WB"},D:{"1":"2 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c","2":"0 1 3 4 6 7 9 e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB","16":"MB NB OB"},E:{"1":"5 K D G E A B C RB SB TB UB VB p YB","2":"F N PB HB"},F:{"1":"5 8 B C J M H I O P Q R S T aB bB cB p eB","2":"0 1 6 E U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z ZB"},G:{"1":"G hB JB jB kB lB mB nB oB pB qB rB sB","16":"HB fB EB"},H:{"16":"tB"},I:{"1":"4 F xB EB yB zB","16":"BB uB vB wB"},J:{"16":"D A"},K:{"1":"5 C L","16":"8 A B p"},L:{"1":"IB"},M:{"1":"3"},N:{"16":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"2":"5B"},R:{"1":"6B"}},B:1,C:"Media attribute"};

},{}],348:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"2":"2 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c XB WB","132":"0 1 3 4 6 7 9 e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB"},D:{"2":"2 F N K D G E A B C d J M H","132":"0 1 3 4 6 7 9 I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"2":"F N PB HB RB","132":"5 K D G E A B C SB TB UB VB p YB"},F:{"2":"5 8 E B C ZB aB bB cB p eB","132":"0 1 6 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z"},G:{"2":"HB fB EB hB JB jB","132":"G kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"2":"BB F uB vB wB xB EB","132":"4 yB zB"},J:{"2":"D A"},K:{"2":"5 8 A B C L p"},L:{"132":"IB"},M:{"132":"3"},N:{"132":"A B"},O:{"2":"0B"},P:{"2":"F 1B","132":"2B 3B 4B"},Q:{"2":"5B"},R:{"2":"6B"}},B:2,C:"Media Fragments"};

},{}],349:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"2":"0 1 2 3 4 6 7 9 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB"},D:{"1":"0 1 3 4 7 9 GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z"},E:{"2":"F N K D G E A B C PB HB RB SB TB UB VB p","16":"5 YB"},F:{"2":"0 1 5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z ZB aB bB cB p eB"},G:{"2":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"2":"4 BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"2":"5 8 A B C L p"},L:{"2":"IB"},M:{"2":"3"},N:{"2":"A B"},O:{"2":"0B"},P:{"2":"F 1B 2B 3B 4B"},Q:{"2":"5B"},R:{"2":"6B"}},B:6,C:"Media Session API"};

},{}],350:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"2":"2 6 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l XB WB","260":"0 1 3 4 7 9 m n o L q r s t u v w x y z GB FB AB CB DB"},D:{"1":"3 4 9 AB CB DB QB iB KB IB LB MB NB OB","2":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t","324":"0 1 7 u v w x y z GB FB"},E:{"2":"F N K D G E A PB HB RB SB TB UB VB","132":"5 B C p YB"},F:{"1":"0 1 r s t u v w x y z","2":"5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e ZB aB bB cB p eB","324":"f g h i j k l m n o L q"},G:{"2":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"1":"4","2":"BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"2":"5 8 A B C L p"},L:{"1":"IB"},M:{"260":"3"},N:{"2":"A B"},O:{"132":"0B"},P:{"1":"4B","2":"F","132":"1B 2B 3B"},Q:{"132":"5B"},R:{"2":"6B"}},B:5,C:"Media Capture from DOM Elements API"};

},{}],351:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"1":"0 1 3 4 6 7 9 Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"2 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X XB WB"},D:{"1":"0 1 3 4 7 9 s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L","194":"q r"},E:{"2":"F N K D G E A B C PB HB RB SB TB UB VB p","322":"5 YB"},F:{"1":"0 1 f g h i j k l m n o L q r s t u v w x y z","2":"5 8 E B C J M H I O P Q R S T U V W X Y Z a b c ZB aB bB cB p eB","194":"6 e"},G:{"2":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"2":"4 BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"2":"5 8 A B C L p"},L:{"1":"IB"},M:{"2":"3"},N:{"2":"A B"},O:{"2":"0B"},P:{"1":"1B 2B 3B 4B","2":"F"},Q:{"2":"5B"},R:{"2":"6B"}},B:5,C:"MediaRecorder API"};

},{}],352:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A gB","260":"B"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 3 4 7 9 l m n o L q r s t u v w x y z GB FB AB CB DB","2":"2 dB BB F N K D G E A B C d J M H I O P Q R S T XB WB","194":"6 U V W X Y Z a b c e f g h i j k"},D:{"1":"0 1 3 4 6 7 9 a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 F N K D G E A B C d J M","33":"S T U V W X Y Z","66":"H I O P Q R"},E:{"1":"5 G E A B C UB VB p YB","2":"F N K D PB HB RB SB TB"},F:{"1":"0 1 6 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"5 8 E B C ZB aB bB cB p eB"},G:{"2":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"1":"4 zB","2":"BB F uB vB wB xB EB yB"},J:{"2":"D A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"B","2":"A"},O:{"1":"0B"},P:{"514":"F 1B 2B 3B 4B"},Q:{"2":"5B"},R:{"1":"6B"}},B:4,C:"Media Source Extensions"};

},{}],353:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"2":"dB BB F N K D XB WB","132":"0 1 2 3 4 6 7 9 G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB"},D:{"2":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j","322":"r s t u","578":"k l m n o L q","2114":"0 1 3 4 7 9 v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"2":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"2":"5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c ZB aB bB cB p eB","322":"e f g h","2114":"0 1 i j k l m n o L q r s t u v w x y z"},G:{"2":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"2":"4 BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"2":"5 8 A B C L p"},L:{"2":"IB"},M:{"1156":"3"},N:{"2":"A B"},O:{"2":"0B"},P:{"2":"F 1B 2B 3B 4B"},Q:{"2114":"5B"},R:{"2":"6B"}},B:7,C:"Context menu item (menuitem element)"};

},{}],354:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"2":"0 1 2 3 4 6 7 9 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB"},D:{"2":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"2":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"2":"0 1 5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z ZB aB bB cB p eB"},G:{"2":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"2":"4 BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"2":"5 8 A B C L p"},L:{"1":"IB"},M:{"2":"3"},N:{"2":"A B"},O:{"2":"0B"},P:{"1":"2B 3B 4B","2":"F","16":"1B"},Q:{"2":"5B"},R:{"2":"6B"}},B:1,C:"theme-color Meta Tag"};

},{}],355:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"1":"2 d J M H I","2":"C"},C:{"1":"0 1 3 4 6 7 9 M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"2 dB BB F N K D G E A B C d J XB WB"},D:{"1":"0 1 2 3 4 6 7 9 G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"F N K D"},E:{"1":"5 K D G E A B C SB TB UB VB p YB","2":"F N PB HB RB"},F:{"1":"0 1 5 6 8 B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z p eB","2":"E ZB aB bB cB"},G:{"1":"oB pB qB rB sB","2":"G HB fB EB hB JB jB kB lB mB nB"},H:{"1":"tB"},I:{"1":"4 yB zB","2":"BB F uB vB wB xB EB"},J:{"1":"D A"},K:{"1":"5 8 B C L p","2":"A"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:1,C:"meter element"};

},{}],356:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"2":"0 1 2 3 4 6 7 9 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB"},D:{"1":"0 1 3 4 7 9 m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l"},E:{"2":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"1":"0 1 6 Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"5 8 E B C J M H I O P Q R S T U V W X Y ZB aB bB cB p eB"},G:{"2":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"1":"4","2":"BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"2":"3"},N:{"2":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"2":"5B"},R:{"1":"6B"}},B:5,C:"Web MIDI API"};

},{}],357:[function(require,module,exports){
module.exports={A:{A:{"1":"E A B","8":"K gB","129":"D","257":"G"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 2 3 4 6 7 9 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB"},D:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"1":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"1":"0 1 5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z ZB aB bB cB p eB"},G:{"1":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"1":"tB"},I:{"1":"4 BB F uB vB wB xB EB yB zB"},J:{"1":"D A"},K:{"1":"5 8 A B C L p"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:2,C:"CSS min/max-width/height"};

},{}],358:[function(require,module,exports){
module.exports={A:{A:{"1":"E A B","2":"K D G gB"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 3 4 6 7 9 R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"dB BB","132":"2 F N K D G E A B C d J M H I O P Q XB WB"},D:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"1":"5 F N K D G E A B C RB SB TB UB VB p YB","2":"PB HB"},F:{"1":"0 1 6 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"5 8 E B C ZB aB bB cB p eB"},G:{"1":"G fB EB hB JB jB kB lB mB nB oB pB qB rB sB","2":"HB"},H:{"2":"tB"},I:{"1":"4 BB F wB xB EB yB zB","2":"uB vB"},J:{"1":"D A"},K:{"1":"5 8 B C L p","2":"A"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:6,C:"MP3 audio format"};

},{}],359:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"1":"2 C d J M H I"},C:{"2":"0 1 2 3 4 6 7 9 dB BB F N K D G E A B C d J M H I O P S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB","386":"Q R"},D:{"2":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"2":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"2":"0 1 5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z ZB aB bB cB p eB"},G:{"2":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"2":"4 BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"2":"5 8 A B C L p"},L:{"2":"IB"},M:{"2":"3"},N:{"2":"A B"},O:{"2":"0B"},P:{"2":"F 1B 2B 3B 4B"},Q:{"2":"5B"},R:{"2":"6B"}},B:6,C:"Dynamic Adaptive Streaming over HTTP (MPEG-DASH)"};

},{}],360:[function(require,module,exports){
module.exports={A:{A:{"1":"E A B","2":"K D G gB"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 3 4 7 9 e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"2 dB BB F N K D G E A B C d J M H I O P XB WB","4":"6 Q R S T U V W X Y Z a b c"},D:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"1":"5 F N K D G E A B C HB RB SB TB UB VB p YB","2":"PB"},F:{"1":"0 1 6 U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"5 8 E B C J M H I O P Q R S T ZB aB bB cB p eB"},G:{"1":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"1":"4 yB zB","4":"BB F uB vB xB EB","132":"wB"},J:{"1":"D A"},K:{"1":"5 8 B C L p","2":"A"},L:{"1":"IB"},M:{"260":"3"},N:{"1":"A B"},O:{"4":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:6,C:"MPEG-4/H.264 video format"};

},{}],361:[function(require,module,exports){
module.exports={A:{A:{"1":"E A B","2":"K D G gB"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB WB","2":"dB BB XB"},D:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"1":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"1":"0 1 5 6 8 B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z bB cB p eB","2":"E ZB aB"},G:{"1":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"1":"tB"},I:{"1":"4 BB F uB vB wB xB EB yB zB"},J:{"1":"D A"},K:{"1":"5 8 A B C L p"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:4,C:"CSS3 Multiple backgrounds"};

},{}],362:[function(require,module,exports){
module.exports={A:{A:{"1":"A B","2":"K D G E gB"},B:{"1":"2 C d J M H I"},C:{"132":"0 1 3 7 9 v w x y z GB FB AB","164":"2 6 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u XB WB","516":"4 CB DB"},D:{"420":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s","516":"0 1 3 4 7 9 t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"1":"5 A B C VB p YB","132":"E UB","164":"D G TB","420":"F N K PB HB RB SB"},F:{"1":"5 8 C p eB","2":"E B ZB aB bB cB","420":"6 J M H I O P Q R S T U V W X Y Z a b c e f","516":"0 1 g h i j k l m n o L q r s t u v w x y z"},G:{"1":"nB oB pB qB rB sB","132":"lB mB","164":"G jB kB","420":"HB fB EB hB JB"},H:{"1":"tB"},I:{"420":"BB F uB vB wB xB EB yB zB","516":"4"},J:{"420":"D A"},K:{"1":"5 8 C p","2":"A B","132":"L"},L:{"516":"IB"},M:{"132":"3"},N:{"1":"A B"},O:{"1":"0B"},P:{"1":"1B 2B 3B 4B","420":"F"},Q:{"132":"5B"},R:{"132":"6B"}},B:4,C:"CSS3 Multiple column layout"};

},{}],363:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G gB","260":"E A B"},B:{"260":"2 C d J M H I"},C:{"2":"dB BB F N XB WB","260":"0 1 2 3 4 6 7 9 K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB"},D:{"16":"2 F N K D G E A B C d","132":"0 1 3 4 6 7 9 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"16":"PB HB","132":"5 F N K D G E A B C RB SB TB UB VB p YB"},F:{"1":"5 C eB","2":"E ZB aB bB cB","16":"8 B p","132":"0 1 6 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z"},G:{"16":"HB fB","132":"G EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"16":"uB vB","132":"4 BB F wB xB EB yB zB"},J:{"132":"D A"},K:{"1":"5 C","2":"A","16":"8 B p","132":"L"},L:{"132":"IB"},M:{"260":"3"},N:{"260":"A B"},O:{"132":"0B"},P:{"132":"F 1B 2B 3B 4B"},Q:{"132":"5B"},R:{"132":"6B"}},B:5,C:"Mutation events"};

},{}],364:[function(require,module,exports){
module.exports={A:{A:{"1":"B","2":"K D G gB","8":"E A"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 3 4 6 7 9 d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"2 dB BB F N K D G E A B C XB WB"},D:{"1":"0 1 3 4 6 7 9 W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 F N K D G E A B C d J M H","33":"I O P Q R S T U V"},E:{"1":"5 D G E A B C SB TB UB VB p YB","2":"F N PB HB RB","33":"K"},F:{"1":"0 1 6 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"5 8 E B C ZB aB bB cB p eB"},G:{"1":"G jB kB lB mB nB oB pB qB rB sB","2":"HB fB EB hB","33":"JB"},H:{"2":"tB"},I:{"1":"4 yB zB","2":"BB uB vB wB","8":"F xB EB"},J:{"1":"A","2":"D"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"B","8":"A"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:1,C:"Mutation Observer"};

},{}],365:[function(require,module,exports){
module.exports={A:{A:{"1":"G E A B","2":"gB","8":"K D"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB","4":"dB BB"},D:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"1":"5 F N K D G E A B C RB SB TB UB VB p YB","2":"PB HB"},F:{"1":"0 1 5 6 8 B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z bB cB p eB","2":"E ZB aB"},G:{"1":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"1":"4 BB F uB vB wB xB EB yB zB"},J:{"1":"D A"},K:{"1":"5 8 B C L p","2":"A"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:1,C:"Web Storage - name/value pairs"};

},{}],366:[function(require,module,exports){
module.exports={A:{A:{"1":"E A B","2":"K D G gB"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 2 3 4 6 7 9 D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"dB BB F N K XB WB"},D:{"1":"0 1 2 3 4 6 7 9 d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"F N","33":"K D G E A B C"},E:{"1":"5 G E A B C UB VB p YB","2":"F N K D PB HB RB SB TB"},F:{"1":"0 1 6 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"5 8 E B C ZB aB bB cB p eB"},G:{"1":"G lB mB nB oB pB qB rB sB","2":"HB fB EB hB JB jB kB"},H:{"2":"tB"},I:{"1":"4 F xB EB yB zB","2":"BB uB vB wB"},J:{"1":"A","2":"D"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:2,C:"Navigation Timing API"};

},{}],367:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"1":"M H I","2":"2 C d J"},C:{"1":"0 1 3 4 6 7 9 b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"2 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a XB WB"},D:{"1":"0 1 3 4 7 9 g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f"},E:{"1":"5 A B C VB p YB","2":"F N K D G E PB HB RB SB TB UB"},F:{"1":"0 1 6 T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"5 8 E B C J M H I O P Q R S ZB aB bB cB p eB"},G:{"1":"oB pB qB rB sB","2":"G HB fB EB hB JB jB kB lB mB nB"},H:{"16":"tB"},I:{"1":"4","2":"BB F uB vB wB xB EB yB zB"},J:{"16":"D A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"16":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"16":"5B"},R:{"16":"6B"}},B:2,C:"Navigator Language API"};

},{}],368:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"2":"0 1 2 3 4 6 7 9 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB"},D:{"2":"0 1 2 6 7 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB","1028":"3 4 9 FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"2":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"2":"5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q ZB aB bB cB p eB","1028":"0 1 r s t u v w x y z"},G:{"2":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"1":"4","2":"uB yB zB","132":"BB F vB wB xB EB"},J:{"2":"D A"},K:{"2":"5 8 A B C p","516":"L"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"2":"0B"},P:{"1":"4B","132":"F","516":"1B 2B 3B"},Q:{"2":"5B"},R:{"516":"6B"}},B:7,C:"Network Information API"};

},{}],369:[function(require,module,exports){
module.exports={A:{A:{"16":"gB","644":"E A B","2308":"K D G"},B:{"1":"2 d J M H I","16":"C"},C:{"1":"0 1 2 3 4 6 7 9 E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"dB BB F N K D G XB WB"},D:{"1":"0 1 3 4 6 7 9 V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","16":"2 F N K D G E A B C d J M H I O P Q R S T U"},E:{"1":"5 D G E A B C SB TB UB VB p YB","16":"F N K PB HB","1668":"RB"},F:{"1":"0 1 5 6 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","16":"8 E B C ZB aB bB cB p","132":"eB"},G:{"1":"G jB kB lB mB nB oB pB qB rB sB","16":"HB fB EB hB JB"},H:{"16":"tB"},I:{"1":"4 yB zB","16":"BB uB vB wB","1668":"F xB EB"},J:{"16":"D A"},K:{"16":"5 8 A B C L p"},L:{"1":"IB"},M:{"1":"3"},N:{"16":"A B"},O:{"16":"0B"},P:{"1":"1B 2B 3B 4B","16":"F"},Q:{"1":"5B"},R:{"1":"6B"}},B:1,C:"Node.contains()"};

},{}],370:[function(require,module,exports){
module.exports={A:{A:{"16":"gB","132":"E A B","260":"K D G"},B:{"1":"2 d J M H I","16":"C"},C:{"1":"0 1 2 3 4 6 7 9 E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"dB BB F N K D G XB WB"},D:{"1":"0 1 3 4 6 7 9 V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","16":"2 F N K D G E A B C d J M H I O P Q R S T U"},E:{"1":"5 K D G E A B C RB SB TB UB VB p YB","16":"F N PB HB"},F:{"1":"0 1 6 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","16":"8 E B ZB aB bB cB p","132":"5 C eB"},G:{"1":"G JB jB kB lB mB nB oB pB qB rB sB","16":"HB fB EB hB"},H:{"16":"tB"},I:{"1":"4 F xB EB yB zB","16":"BB uB vB wB"},J:{"16":"D A"},K:{"16":"5 8 A B C L p"},L:{"1":"IB"},M:{"1":"3"},N:{"16":"A B"},O:{"16":"0B"},P:{"1":"1B 2B 3B 4B","16":"F"},Q:{"1":"5B"},R:{"1":"6B"}},B:1,C:"Node.parentElement"};

},{}],371:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"1":"d J M H I","2":"2 C"},C:{"1":"0 1 3 4 6 7 9 R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"2 dB BB F N K D G E A B C d J M H I O P Q XB WB"},D:{"1":"0 1 3 4 6 7 9 R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"F","36":"2 N K D G E A B C d J M H I O P Q"},E:{"1":"5 K D G E A B C SB TB UB VB p YB","2":"F N PB HB RB"},F:{"1":"0 1 6 U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"5 8 E B C J M H I O P Q R S T ZB aB bB cB p eB"},G:{"2":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"2":"BB F uB vB wB xB EB","36":"4 yB zB"},J:{"1":"A","2":"D"},K:{"2":"5 8 A B C p","36":"L"},L:{"513":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"2":"0B"},P:{"36":"F","258":"1B 2B 3B 4B"},Q:{"2":"5B"},R:{"258":"6B"}},B:1,C:"Web Notifications"};

},{}],372:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J","260":"M H I"},C:{"1":"0 1 3 4 7 9 f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"2 6 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e XB WB"},D:{"1":"0 1 3 4 6 7 9 a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z"},E:{"1":"5 A B C VB p YB","2":"F N K D PB HB RB SB","132":"G E TB UB"},F:{"1":"0 1 6 O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"E J M H I ZB aB bB","33":"5 8 B C cB p eB"},G:{"1":"nB oB pB qB rB sB","2":"HB fB EB hB JB jB","132":"G kB lB mB"},H:{"33":"tB"},I:{"1":"4 zB","2":"BB F uB vB wB xB EB yB"},J:{"2":"D A"},K:{"1":"L","2":"A","33":"5 8 B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:4,C:"CSS3 object-fit/object-position"};

},{}],373:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"2":"0 1 2 3 4 6 7 9 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB"},D:{"1":"f g h i j k l m n o L q r s","2":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"2":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"1":"6 S T U V W X Y Z a b c e f","2":"0 1 5 8 E B C J M H I O P Q R g h i j k l m n o L q r s t u v w x y z ZB aB bB cB p eB"},G:{"2":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"2":"4 BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"2":"5 8 A B C L p"},L:{"2":"IB"},M:{"2":"3"},N:{"2":"A B"},O:{"2":"0B"},P:{"1":"F","2":"1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:7,C:"Object.observe data binding"};

},{}],374:[function(require,module,exports){
module.exports={A:{A:{"8":"K D G E A B gB"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 3 4 7 9 q r s t u v w x y z GB FB AB CB DB","8":"2 6 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L XB WB"},D:{"1":"0 1 3 4 7 9 x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","8":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w"},E:{"1":"5 B C VB p YB","8":"F N K D G E A PB HB RB SB TB UB"},F:{"1":"0 1 k l m n o L q r s t u v w x y z","8":"5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j ZB aB bB cB p eB"},G:{"1":"oB pB qB rB sB","8":"G HB fB EB hB JB jB kB lB mB nB"},H:{"8":"tB"},I:{"1":"4","8":"BB F uB vB wB xB EB yB zB"},J:{"8":"D A"},K:{"1":"L","8":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"8":"A B"},O:{"1":"0B"},P:{"1":"2B 3B 4B","8":"F 1B"},Q:{"1":"5B"},R:{"8":"6B"}},B:6,C:"Object.values method"};

},{}],375:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"1":"2 d J M H I","2":"C"},C:{"2":"0 1 2 3 4 6 7 9 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB"},D:{"2":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"2":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"2":"0 1 5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z ZB aB bB cB p eB"},G:{"2":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"2":"4 BB F uB vB wB xB EB yB zB"},J:{"2":"D","130":"A"},K:{"2":"5 8 A B C L p"},L:{"2":"IB"},M:{"2":"3"},N:{"2":"A B"},O:{"2":"0B"},P:{"2":"F 1B 2B 3B 4B"},Q:{"2":"5B"},R:{"2":"6B"}},B:6,C:"Object RTC (ORTC) API for WebRTC"};

},{}],376:[function(require,module,exports){
module.exports={A:{A:{"1":"A B","2":"E gB","8":"K D G"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB","4":"BB","8":"dB"},D:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"1":"5 F N K D G E A B C RB SB TB UB VB p YB","8":"PB HB"},F:{"1":"0 1 5 6 8 B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z cB p eB","2":"E ZB","8":"aB bB"},G:{"1":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"1":"4 BB F uB vB wB xB EB yB zB"},J:{"1":"D A"},K:{"1":"5 8 B C L p","2":"A"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:7,C:"Offline web applications"};

},{}],377:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"2":"2 6 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m XB WB","194":"0 1 3 4 7 9 n o L q r s t u v w x y z GB FB AB CB DB"},D:{"1":"iB KB IB LB MB NB OB","2":"0 2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","322":"1 3 4 7 9 GB FB AB CB DB QB"},E:{"2":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"2":"5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n ZB aB bB cB p eB","322":"0 1 o L q r s t u v w x y z"},G:{"2":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"1":"4","2":"BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"2":"5 8 A B C L p"},L:{"1":"IB"},M:{"194":"3"},N:{"2":"A B"},O:{"2":"0B"},P:{"2":"F 1B 2B 3B 4B"},Q:{"2":"5B"},R:{"2":"6B"}},B:1,C:"OffscreenCanvas"};

},{}],378:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"1":"H I","2":"2 C d J M"},C:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB","2":"dB BB"},D:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"2":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"1":"0 1 5 6 8 B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z bB cB p eB","2":"E ZB aB"},G:{"2":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"1":"4 BB F wB xB EB yB zB","16":"uB vB"},J:{"1":"A","2":"D"},K:{"1":"5 8 B C L p","2":"A"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:6,C:"Ogg Vorbis audio format"};

},{}],379:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G gB","8":"E A B"},B:{"1":"H I","8":"2 C d J M"},C:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB","2":"dB BB"},D:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"2":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"1":"0 1 5 6 8 B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z bB cB p eB","2":"E ZB aB"},G:{"2":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"2":"4 BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"2":"5 8 A B C L p"},L:{"2":"IB"},M:{"1":"3"},N:{"8":"A B"},O:{"1":"0B"},P:{"2":"F 1B 2B 3B 4B"},Q:{"2":"5B"},R:{"2":"6B"}},B:6,C:"Ogg/Theora video format"};

},{}],380:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"1":"0 1 3 4 6 7 9 I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"2 dB BB F N K D G E A B C d J M H XB WB"},D:{"1":"0 1 3 4 6 7 9 P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 F N K D G E A B C d J","16":"M H I O"},E:{"1":"5 D G E A B C SB TB UB VB p YB","2":"F N PB HB RB","16":"K"},F:{"1":"0 1 5 6 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"8 E B ZB aB bB cB p eB","16":"C"},G:{"1":"G JB jB kB lB mB nB oB pB qB rB sB","2":"HB fB EB hB"},H:{"1":"tB"},I:{"1":"4 yB zB","2":"BB F uB vB wB xB EB"},J:{"1":"A","2":"D"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:1,C:"Reversed attribute of ordered lists"};

},{}],381:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"1":"M H I","2":"2 C d J"},C:{"1":"0 1 3 4 7 9 t u v w x y z GB FB AB CB DB","2":"2 6 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s XB WB"},D:{"1":"0 1 3 4 7 9 y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x"},E:{"1":"5 A B C VB p YB","2":"F N K D G E PB HB RB SB TB UB"},F:{"1":"0 1 l m n o L q r s t u v w x y z","2":"5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k ZB aB bB cB p eB"},G:{"1":"nB oB pB qB rB sB","2":"G HB fB EB hB JB jB kB lB mB"},H:{"2":"tB"},I:{"1":"4","2":"BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"1":"0B"},P:{"1":"2B 3B 4B","2":"F 1B"},Q:{"2":"5B"},R:{"2":"6B"}},B:1,C:"\"once\" event listener option"};

},{}],382:[function(require,module,exports){
module.exports={A:{A:{"1":"E A B","2":"K D gB","260":"G"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 3 4 7 9 k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB","2":"dB BB","516":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j"},D:{"1":"0 1 3 4 6 7 9 d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 F N K D G E A B C"},E:{"1":"5 N K D G E A B C RB SB TB UB VB p YB","2":"F PB HB"},F:{"1":"0 1 6 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"8 E B C ZB aB bB cB p eB","4":"5"},G:{"1":"G EB hB JB jB kB lB mB nB oB pB qB rB sB","16":"HB fB"},H:{"2":"tB"},I:{"1":"4 BB F wB xB EB yB zB","16":"uB vB"},J:{"1":"A","132":"D"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:1,C:"Online/offline status"};

},{}],383:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"1":"d J M H I","2":"2 C"},C:{"1":"0 1 3 4 6 7 9 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"2 dB BB F N K D G E A B C d XB WB"},D:{"1":"0 1 3 4 6 7 9 c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b"},E:{"2":"F N K D G E A PB HB RB SB TB UB VB","132":"5 B C p YB"},F:{"1":"0 1 6 P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"5 8 E B C J M H I O ZB aB bB cB p eB"},G:{"2":"G HB fB EB hB JB jB kB lB mB nB oB","132":"pB qB rB sB"},H:{"2":"tB"},I:{"2":"4 BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"2":"5 8 A B C L p"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"2":"0B"},P:{"1":"1B 2B 3B 4B","2":"F"},Q:{"2":"5B"},R:{"1":"6B"}},B:6,C:"Opus"};

},{}],384:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"2":"0 1 2 3 4 6 7 9 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB"},D:{"1":"4 QB iB KB IB LB MB NB OB","2":"0 2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","194":"1 3 7 9 GB FB AB CB DB"},E:{"2":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"1":"0 1 x y z","2":"5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w ZB aB bB cB p eB"},G:{"2":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"1":"4","2":"BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"2":"5 8 A B C L p"},L:{"1":"IB"},M:{"2":"3"},N:{"2":"A B"},O:{"2":"0B"},P:{"2":"F 1B 2B 3B 4B"},Q:{"2":"5B"},R:{"2":"6B"}},B:4,C:"Orientation Sensor"};

},{}],385:[function(require,module,exports){
module.exports={A:{A:{"2":"K D gB","260":"G","388":"E A B"},B:{"1":"J M H I","388":"2 C d"},C:{"1":"0 1 2 3 4 6 7 9 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB"},D:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"1":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"1":"0 1 6 C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z eB","129":"5","260":"8 E B ZB aB bB cB p"},G:{"1":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"1":"4 BB F uB vB wB xB EB yB zB"},J:{"1":"D A"},K:{"1":"5 C L","260":"8 A B p"},L:{"1":"IB"},M:{"1":"3"},N:{"388":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:4,C:"CSS outline properties"};

},{}],386:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"1":"J M H I","2":"2 C d"},C:{"1":"0 1 3 4 7 9 r s t u v w x y z GB FB AB CB DB","2":"2 6 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q XB WB"},D:{"1":"0 1 3 4 7 9 GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z"},E:{"1":"5 A B C VB p YB","2":"F N K D G E PB HB RB SB TB UB"},F:{"1":"0 1 n o L q r s t u v w x y z","2":"5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m ZB aB bB cB p eB"},G:{"1":"nB oB pB qB rB sB","2":"G HB fB EB hB JB jB kB lB mB"},H:{"2":"tB"},I:{"1":"4","2":"BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"2":"0B"},P:{"1":"3B 4B","2":"F 1B 2B"},Q:{"2":"5B"},R:{"2":"6B"}},B:6,C:"String.prototype.padStart(), String.prototype.padEnd()"};

},{}],387:[function(require,module,exports){
module.exports={A:{A:{"1":"B","2":"K D G E A gB"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 2 3 4 6 7 9 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB"},D:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"1":"5 N K D G E A B C RB SB TB UB VB p YB","2":"F PB HB"},F:{"1":"0 1 6 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"5 8 E B C ZB aB bB cB p eB"},G:{"1":"G hB JB jB kB lB mB nB oB pB qB rB sB","16":"HB fB EB"},H:{"2":"tB"},I:{"1":"4 BB F wB xB EB yB zB","16":"uB vB"},J:{"1":"D A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"B","2":"A"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:1,C:"PageTransitionEvent"};

},{}],388:[function(require,module,exports){
module.exports={A:{A:{"1":"A B","2":"K D G E gB"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 3 4 6 7 9 I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"dB BB F N K D G E XB WB","33":"2 A B C d J M H"},D:{"1":"0 1 3 4 6 7 9 c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 F N K D G E A B C","33":"d J M H I O P Q R S T U V W X Y Z a b"},E:{"1":"5 D G E A B C SB TB UB VB p YB","2":"F N K PB HB RB"},F:{"1":"0 1 5 6 P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"8 E B C ZB aB bB cB p eB","33":"J M H I O"},G:{"1":"G jB kB lB mB nB oB pB qB rB sB","2":"HB fB EB hB JB"},H:{"2":"tB"},I:{"1":"4","2":"BB F uB vB wB xB EB","33":"yB zB"},J:{"1":"A","2":"D"},K:{"1":"5 L","2":"8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"A B"},O:{"1":"0B"},P:{"1":"1B 2B 3B 4B","33":"F"},Q:{"1":"5B"},R:{"1":"6B"}},B:2,C:"Page Visibility"};

},{}],389:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"1":"M H I","2":"2 C d J"},C:{"1":"0 1 3 4 7 9 s t u v w x y z GB FB AB CB DB","2":"2 6 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r XB WB"},D:{"1":"0 1 3 4 7 9 u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t"},E:{"1":"5 A B C VB p YB","2":"F N K D G E PB HB RB SB TB UB"},F:{"1":"0 1 h i j k l m n o L q r s t u v w x y z","2":"5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g ZB aB bB cB p eB"},G:{"1":"nB oB pB qB rB sB","2":"G HB fB EB hB JB jB kB lB mB"},H:{"2":"tB"},I:{"1":"4","2":"BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"1":"0B"},P:{"1":"1B 2B 3B 4B","2":"F"},Q:{"2":"5B"},R:{"2":"6B"}},B:1,C:"Passive event listeners"};

},{}],390:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"2":"0 1 2 3 6 7 9 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB XB WB","16":"4 DB"},D:{"2":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB","16":"MB NB OB"},E:{"1":"C","2":"F N K D G E A B PB HB RB SB TB UB VB p","16":"5 YB"},F:{"2":"5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v ZB aB bB cB p eB","16":"0 1 w x y z"},G:{"2":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"16":"tB"},I:{"2":"BB F uB vB wB xB EB yB zB","16":"4"},J:{"2":"D","16":"A"},K:{"2":"5 8 A B C p","16":"L"},L:{"16":"IB"},M:{"16":"3"},N:{"2":"A","16":"B"},O:{"16":"0B"},P:{"2":"F 1B 2B","16":"3B 4B"},Q:{"16":"5B"},R:{"16":"6B"}},B:1,C:"Password Rules"};

},{}],391:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C","132":"d J M H I"},C:{"1":"0 1 3 4 7 9 r s t u v w x y z GB FB AB CB DB","2":"2 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z XB WB","132":"6 a b c e f g h i j k l m n o L q"},D:{"1":"QB iB KB IB LB MB NB OB","2":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e","132":"0 1 3 4 7 9 f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB"},E:{"1":"5 A B C UB VB p YB","2":"F N K D PB HB RB SB","132":"G E TB"},F:{"1":"0 1 y z","2":"5 8 E B C J M H I O P Q R ZB aB bB cB p eB","132":"6 S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x"},G:{"1":"lB mB nB oB pB qB rB sB","2":"HB fB EB hB JB jB","16":"G","132":"kB"},H:{"2":"tB"},I:{"1":"4","2":"BB F uB vB wB xB EB yB zB"},J:{"1":"A","2":"D"},K:{"2":"5 8 A B C p","132":"L"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"132":"0B"},P:{"132":"F 1B 2B 3B 4B"},Q:{"132":"5B"},R:{"132":"6B"}},B:1,C:"Path2D"};

},{}],392:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C","322":"d","8196":"J M H I"},C:{"2":"2 6 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x XB WB","4162":"0 1 3 7 9 y z GB FB AB CB","16452":"4 DB"},D:{"1":"OB","2":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v","194":"0 1 w x y z","1090":"7 GB","8196":"3 4 9 FB AB CB DB QB iB KB IB LB MB NB"},E:{"1":"5 YB","2":"F N K D G E PB HB RB SB TB UB","514":"A B VB","8196":"C p"},F:{"2":"5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i ZB aB bB cB p eB","194":"j k l m n o L q","8196":"0 1 r s t u v w x y z"},G:{"1":"sB","2":"G HB fB EB hB JB jB kB lB mB","514":"nB oB pB","8196":"qB rB"},H:{"2":"tB"},I:{"2":"4 BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"2":"5 8 A B C L p"},L:{"2052":"IB"},M:{"2":"3"},N:{"2":"A B"},O:{"2":"0B"},P:{"2":"F","8196":"1B 2B 3B 4B"},Q:{"194":"5B"},R:{"2":"6B"}},B:4,C:"Payment Request API"};

},{}],393:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"1":"0 1 3 4 7 9 L q r s t u v w x y z GB FB AB CB DB","2":"2 6 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o XB WB"},D:{"1":"0 1 3 4 7 9 m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l"},E:{"2":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"1":"0 1 6 Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"5 8 E B C J M H I O P Q R S T U V W X Y ZB aB bB cB p eB"},G:{"2":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"2":"4 BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"2":"5 8 A B C L p"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"2":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"2":"5B"},R:{"2":"6B"}},B:7,C:"Permissions API"};

},{}],394:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"2":"0 1 2 3 4 6 7 9 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB"},D:{"1":"KB IB LB MB NB OB","2":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB","66":"iB"},E:{"2":"F N K D G E PB HB RB SB TB UB","196":"5 A B C VB p YB"},F:{"2":"5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f ZB aB bB cB p eB","260":"0 1 h i j k l m n o L q r s t u v w x y z","324":"g"},G:{"2":"G HB fB EB hB JB jB kB lB mB","196":"nB oB pB qB rB sB"},H:{"2":"tB"},I:{"2":"4 BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"2":"5 8 A B C L p"},L:{"516":"IB"},M:{"516":"3"},N:{"2":"A B"},O:{"2":"0B"},P:{"2":"F 1B 2B 3B 4B"},Q:{"2":"5B"},R:{"2":"6B"}},B:7,C:"Picture-in-Picture"};

},{}],395:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"1":"2 d J M H I","2":"C"},C:{"1":"0 1 3 4 7 9 h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"2 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c XB WB","578":"6 e f g"},D:{"1":"0 1 3 4 7 9 h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f","194":"g"},E:{"1":"5 A B C UB VB p YB","2":"F N K D G E PB HB RB SB TB"},F:{"1":"0 1 6 U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"5 8 E B C J M H I O P Q R S ZB aB bB cB p eB","322":"T"},G:{"1":"mB nB oB pB qB rB sB","2":"G HB fB EB hB JB jB kB lB"},H:{"2":"tB"},I:{"1":"4","2":"BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:1,C:"Picture element"};

},{}],396:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"1":"H I","2":"2 C d J M"},C:{"2":"dB","194":"0 1 2 3 4 6 7 9 BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB"},D:{"1":"0 1 3 4 6 7 9 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","16":"2 F N K D G E A B C d"},E:{"1":"5 K D G E A B C SB TB UB VB p YB","2":"F N PB HB RB"},F:{"1":"0 1 6 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"5 8 E B C ZB aB bB cB p eB"},G:{"1":"G hB JB jB kB lB mB nB oB pB qB rB sB","2":"HB fB EB"},H:{"2":"tB"},I:{"1":"4 yB zB","2":"BB F uB vB wB xB EB"},J:{"2":"D A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"194":"3"},N:{"2":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:1,C:"Ping attribute"};

},{}],397:[function(require,module,exports){
module.exports={A:{A:{"1":"D G E A B","2":"gB","8":"K"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 2 3 4 6 7 9 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB"},D:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"1":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"1":"0 1 5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z ZB aB bB cB p eB"},G:{"1":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"1":"tB"},I:{"1":"4 BB F uB vB wB xB EB yB zB"},J:{"1":"D A"},K:{"1":"5 8 A B C L p"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:2,C:"PNG alpha transparency"};

},{}],398:[function(require,module,exports){
module.exports={A:{A:{"1":"B","2":"K D G E A gB"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB WB","2":"dB BB XB"},D:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"1":"5 F N K D G E A B C RB SB TB UB VB p YB","2":"PB HB"},F:{"1":"0 1 6 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"5 8 E B C ZB aB bB cB p eB"},G:{"1":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"1":"4 BB F uB vB wB xB EB yB zB"},J:{"1":"D A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"B","2":"A"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:7,C:"CSS pointer-events (for HTML)"};

},{}],399:[function(require,module,exports){
module.exports={A:{A:{"1":"B","2":"K D G E gB","164":"A"},B:{"1":"2 C d J M H I"},C:{"1":"3 4 7 9 GB FB AB CB DB","2":"dB BB F N XB WB","8":"2 6 K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j","328":"0 1 k l m n o L q r s t u v w x y z"},D:{"1":"0 1 3 4 7 9 y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 F N K D G E A B C d J M H I O P Q","8":"6 R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u","584":"v w x"},E:{"2":"F N K PB HB RB","8":"D G E A B C SB TB UB VB p","1096":"5 YB"},F:{"1":"0 1 l m n o L q r s t u v w x y z","2":"5 8 E B C ZB aB bB cB p eB","8":"6 J M H I O P Q R S T U V W X Y Z a b c e f g h","584":"i j k"},G:{"8":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"1":"4","8":"BB F uB vB wB xB EB yB zB"},J:{"8":"D A"},K:{"1":"L","2":"A","8":"5 8 B C p"},L:{"1":"IB"},M:{"328":"3"},N:{"1":"B","36":"A"},O:{"8":"0B"},P:{"1":"2B 3B 4B","2":"1B","8":"F"},Q:{"584":"5B"},R:{"2":"6B"}},B:2,C:"Pointer events"};

},{}],400:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"1":"2 d J M H I","2":"C"},C:{"1":"0 1 3 4 7 9 k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"2 dB BB F N K D G E A B C XB WB","33":"6 d J M H I O P Q R S T U V W X Y Z a b c e f g h i j"},D:{"1":"0 1 3 4 7 9 g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 F N K D G E A B C d J","33":"6 R S T U V W X Y Z a b c e f","66":"M H I O P Q"},E:{"1":"5 B C VB p YB","2":"F N K D G E A PB HB RB SB TB UB"},F:{"1":"0 1 6 T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"5 8 E B C ZB aB bB cB p eB","33":"J M H I O P Q R S"},G:{"1":"oB pB qB rB sB","2":"G HB fB EB hB JB jB kB lB mB nB"},H:{"2":"tB"},I:{"2":"4 BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"2":"5 8 A B C L p"},L:{"2":"IB"},M:{"2":"3"},N:{"2":"A B"},O:{"2":"0B"},P:{"2":"F 1B 2B 3B 4B"},Q:{"2":"5B"},R:{"2":"6B"}},B:2,C:"Pointer Lock API"};

},{}],401:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"1":"4","2":"0 1 2 3 6 7 9 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB"},D:{"2":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"1":"5 YB","2":"F N K D G E A B C PB HB RB SB TB UB VB p"},F:{"2":"0 1 5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z ZB aB bB cB p eB"},G:{"2":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"2":"4 BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"2":"5 8 A B C L p"},L:{"2":"IB"},M:{"2":"3"},N:{"2":"A B"},O:{"2":"0B"},P:{"2":"F 1B 2B 3B 4B"},Q:{"2":"5B"},R:{"2":"6B"}},B:7,C:"prefers-color-scheme media query"};

},{}],402:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"1":"3 4 AB CB DB","2":"0 1 2 6 7 9 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB XB WB"},D:{"1":"NB OB","2":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB"},E:{"1":"5 B C VB p YB","2":"F N K D G E A PB HB RB SB TB UB"},F:{"2":"0 1 5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z ZB aB bB cB p eB"},G:{"1":"oB pB qB rB sB","2":"G HB fB EB hB JB jB kB lB mB nB"},H:{"2":"tB"},I:{"2":"4 BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"2":"5 8 A B C L p"},L:{"2":"IB"},M:{"2":"3"},N:{"2":"A B"},O:{"2":"0B"},P:{"2":"F 1B 2B 3B 4B"},Q:{"2":"5B"},R:{"2":"6B"}},B:7,C:"prefers-reduced-motion media query"};

},{}],403:[function(require,module,exports){
module.exports={A:{A:{"1":"A B","2":"K D G E gB"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 2 3 4 6 7 9 K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"dB BB F N XB WB"},D:{"1":"0 1 2 3 4 6 7 9 G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"F N K D"},E:{"1":"5 K D G E A B C SB TB UB VB p YB","2":"F N PB HB RB"},F:{"1":"0 1 5 6 8 B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z p eB","2":"E ZB aB bB cB"},G:{"2":"HB fB EB hB JB","132":"G jB kB lB mB nB oB pB qB rB sB"},H:{"1":"tB"},I:{"1":"4 yB zB","2":"BB F uB vB wB xB EB"},J:{"1":"D A"},K:{"1":"5 8 B C L p","2":"A"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:1,C:"progress element"};

},{}],404:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"1":"I","2":"2 C d J M H"},C:{"1":"1 3 4 7 9 GB FB AB CB DB","2":"0 2 6 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z XB WB"},D:{"1":"3 4 AB CB DB QB iB KB IB LB MB NB OB","2":"0 1 2 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB"},E:{"1":"5 C p YB","2":"F N K D G E A B PB HB RB SB TB UB VB"},F:{"1":"0 1 t u v w x y z","2":"5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s ZB aB bB cB p eB"},G:{"1":"pB qB rB sB","2":"G HB fB EB hB JB jB kB lB mB nB oB"},H:{"2":"tB"},I:{"1":"4","2":"BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"1":"0B"},P:{"1":"4B","2":"F 1B 2B 3B"},Q:{"2":"5B"},R:{"2":"6B"}},B:6,C:"Promise.prototype.finally"};

},{}],405:[function(require,module,exports){
module.exports={A:{A:{"8":"K D G E A B gB"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 3 4 6 7 9 Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","4":"W X","8":"2 dB BB F N K D G E A B C d J M H I O P Q R S T U V XB WB"},D:{"1":"0 1 3 4 6 7 9 c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","4":"b","8":"2 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a"},E:{"1":"5 G E A B C TB UB VB p YB","8":"F N K D PB HB RB SB"},F:{"1":"0 1 6 P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","4":"O","8":"5 8 E B C J M H I ZB aB bB cB p eB"},G:{"1":"G kB lB mB nB oB pB qB rB sB","8":"HB fB EB hB JB jB"},H:{"8":"tB"},I:{"1":"4 zB","8":"BB F uB vB wB xB EB yB"},J:{"8":"D A"},K:{"1":"L","8":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"8":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:6,C:"Promises"};

},{}],406:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"1":"0 1 3 4 6 7 9 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"2 dB BB F N K D G E A B C d XB WB"},D:{"2":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"2":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"2":"0 1 5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z ZB aB bB cB p eB"},G:{"2":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"2":"4 BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"2":"5 8 A B C L p"},L:{"2":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"2":"0B"},P:{"2":"F 1B 2B 3B 4B"},Q:{"2":"5B"},R:{"2":"6B"}},B:4,C:"Proximity API"};

},{}],407:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 3 4 6 7 9 I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"2 dB BB F N K D G E A B C d J M H XB WB"},D:{"1":"0 1 3 4 7 9 s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 F N K D G E A B C d J M H I h i j k l m n o L q r","66":"6 O P Q R S T U V W X Y Z a b c e f g"},E:{"1":"5 A B C VB p YB","2":"F N K D G E PB HB RB SB TB UB"},F:{"1":"0 1 f g h i j k l m n o L q r s t u v w x y z","2":"5 6 8 E B C U V W X Y Z a b c e ZB aB bB cB p eB","66":"J M H I O P Q R S T"},G:{"1":"nB oB pB qB rB sB","2":"G HB fB EB hB JB jB kB lB mB"},H:{"2":"tB"},I:{"1":"4","2":"BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"1":"0B"},P:{"1":"1B 2B 3B 4B","2":"F"},Q:{"2":"5B"},R:{"2":"6B"}},B:6,C:"Proxy object"};

},{}],408:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"1":"0 1 3 4 7 9 e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"2 6 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c XB WB"},D:{"1":"0 1 3 4 7 9 h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB","2":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g LB MB NB OB"},E:{"2":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"1":"0 1 6 U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"5 8 E B C J M H I O ZB aB bB cB p eB","4":"S","16":"P Q R T"},G:{"2":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"1":"4","2":"BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"2":"5 8 A B C L p"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"2":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"2":"5B"},R:{"1":"6B"}},B:6,C:"Public Key Pinning"};

},{}],409:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"1":"H I","2":"2 C d J M"},C:{"2":"2 6 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m XB WB","257":"0 1 3 4 9 n L q r s t u w x y z GB FB AB CB DB","1281":"7 o v"},D:{"2":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m","257":"0 1 3 4 7 9 t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","388":"n o L q r s"},E:{"2":"F N K D G E PB HB RB SB TB","514":"5 A B C UB VB p YB"},F:{"2":"5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f ZB aB bB cB p eB","16":"g h i j k","257":"0 1 l m n o L q r s t u v w x y z"},G:{"2":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"2":"4 BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"2":"6B"}},B:5,C:"Push API"};

},{}],410:[function(require,module,exports){
module.exports={A:{A:{"1":"E A B","2":"gB","8":"K D","132":"G"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB","8":"dB BB"},D:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"1":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"1":"0 1 5 6 8 B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z aB bB cB p eB","8":"E ZB"},G:{"1":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"1":"tB"},I:{"1":"4 BB F uB vB wB xB EB yB zB"},J:{"1":"D A"},K:{"1":"5 8 A B C L p"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:1,C:"querySelector/querySelectorAll"};

},{}],411:[function(require,module,exports){
module.exports={A:{A:{"1":"K D G E A B","16":"gB"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","16":"dB BB XB WB"},D:{"1":"0 1 3 4 6 7 9 V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","16":"2 F N K D G E A B C d J M H I O P Q R S T U"},E:{"1":"5 K D G E A B C RB SB TB UB VB p YB","16":"F N PB HB"},F:{"1":"0 1 6 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","16":"E ZB","132":"5 8 B C aB bB cB p eB"},G:{"1":"G jB kB lB mB nB oB pB qB rB sB","16":"HB fB EB hB JB"},H:{"1":"tB"},I:{"1":"4 BB F wB xB EB yB zB","16":"uB vB"},J:{"1":"D A"},K:{"1":"L","132":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"257":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:1,C:"readonly attribute of input and textarea elements"};

},{}],412:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A gB","132":"B"},B:{"132":"2 C d J M H I"},C:{"1":"0 1 3 4 7 9 f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"2 6 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e XB WB"},D:{"1":"3 4 9 FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 F N K D G E A B C d J M H I O P","260":"0 1 6 7 Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB"},E:{"1":"5 C p YB","2":"F N K D PB HB RB SB","132":"G E A B TB UB VB"},F:{"1":"0 1 6 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"5 8 E B C ZB aB bB cB p eB"},G:{"2":"HB fB EB hB JB jB","132":"G kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"1":"4","2":"BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"260":"0B"},P:{"1":"1B 2B 3B 4B","2":"F"},Q:{"1":"5B"},R:{"1":"6B"}},B:5,C:"Referrer Policy"};

},{}],413:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"1":"0 1 2 3 4 6 7 9 BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB","2":"dB"},D:{"2":"F N K D G E A B C","129":"0 1 2 3 4 6 7 9 d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"2":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"2":"8 E B ZB aB bB cB p","129":"0 1 5 6 C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z eB"},G:{"2":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"2":"4 BB F uB vB wB xB EB yB zB"},J:{"2":"D","129":"A"},K:{"2":"5 8 A B C L p"},L:{"2":"IB"},M:{"2":"3"},N:{"2":"A B"},O:{"2":"0B"},P:{"2":"F 1B 2B 3B 4B"},Q:{"2":"5B"},R:{"2":"6B"}},B:1,C:"Custom protocol handling"};

},{}],414:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"1":"0 1 3 4 7 9 v w x y z GB FB AB CB DB","2":"2 6 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u XB WB"},D:{"1":"0 1 3 4 7 9 s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r"},E:{"1":"5 B C VB p YB","2":"F N K D G E A PB HB RB SB TB UB"},F:{"1":"0 1 f g h i j k l m n o L q r s t u v w x y z","2":"5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e ZB aB bB cB p eB"},G:{"1":"oB pB qB rB sB","2":"G HB fB EB hB JB jB kB lB mB nB"},H:{"2":"tB"},I:{"1":"4","2":"BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"1":"0B"},P:{"1":"1B 2B 3B 4B","2":"F"},Q:{"1":"5B"},R:{"1":"6B"}},B:1,C:"rel=noopener"};

},{}],415:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A gB","132":"B"},B:{"1":"2 d J M H I","16":"C"},C:{"1":"0 1 3 4 6 7 9 c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"2 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b XB WB"},D:{"1":"0 1 3 4 6 7 9 M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","16":"2 F N K D G E A B C d J"},E:{"1":"5 N K D G E A B C RB SB TB UB VB p YB","2":"F PB HB"},F:{"1":"0 1 6 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"5 8 E B C ZB aB bB cB p eB"},G:{"1":"G fB EB hB JB jB kB lB mB nB oB pB qB rB sB","2":"HB"},H:{"2":"tB"},I:{"1":"4 BB F wB xB EB yB zB","16":"uB vB"},J:{"1":"D A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:1,C:"Link type \"noreferrer\""};

},{}],416:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"1":"I","2":"2 C d J M","132":"H"},C:{"1":"0 1 3 4 6 7 9 Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"2 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y XB WB"},D:{"1":"4 CB DB QB iB KB IB LB MB NB OB","2":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s","132":"0 1 3 7 9 t u v w x y z GB FB AB"},E:{"1":"5 E A B C UB VB p YB","2":"F N K D G PB HB RB SB TB"},F:{"1":"0 1 v w x y z","2":"5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f ZB aB bB cB p eB","132":"g h i j k l m n o L q r s t u"},G:{"1":"lB mB nB oB pB qB rB sB","2":"G HB fB EB hB JB jB kB"},H:{"2":"tB"},I:{"1":"4","2":"BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"2":"5 8 A B C L p"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"132":"0B"},P:{"2":"F","132":"1B 2B 3B 4B"},Q:{"2":"5B"},R:{"2":"6B"}},B:1,C:"relList (DOMTokenList)"};

},{}],417:[function(require,module,exports){
module.exports={A:{A:{"1":"B","2":"K D G gB","132":"E A"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB WB","2":"dB BB XB"},D:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"1":"5 N K D G E A B C RB SB TB UB VB p YB","2":"F PB HB"},F:{"1":"0 1 5 6 C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z eB","2":"8 E B ZB aB bB cB p"},G:{"1":"G fB EB JB jB kB lB mB nB oB pB qB rB sB","2":"HB","260":"hB"},H:{"1":"tB"},I:{"1":"4 BB F uB vB wB xB EB yB zB"},J:{"1":"D A"},K:{"1":"5 C L","2":"8 A B p"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:4,C:"rem (root em) units"};

},{}],418:[function(require,module,exports){
module.exports={A:{A:{"1":"A B","2":"K D G E gB"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 3 4 6 7 9 S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"dB BB XB WB","33":"2 B C d J M H I O P Q R","164":"F N K D G E A"},D:{"1":"0 1 3 4 6 7 9 T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"F N K D G E","33":"R S","164":"I O P Q","420":"2 A B C d J M H"},E:{"1":"5 D G E A B C SB TB UB VB p YB","2":"F N PB HB RB","33":"K"},F:{"1":"0 1 6 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"5 8 E B C ZB aB bB cB p eB"},G:{"1":"G jB kB lB mB nB oB pB qB rB sB","2":"HB fB EB hB","33":"JB"},H:{"2":"tB"},I:{"1":"4 yB zB","2":"BB F uB vB wB xB EB"},J:{"1":"A","2":"D"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:1,C:"requestAnimationFrame"};

},{}],419:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"1":"0 1 3 4 7 9 y z GB FB AB CB DB","2":"2 6 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v XB WB","194":"w x"},D:{"1":"0 1 3 4 7 9 q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L"},E:{"2":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"1":"0 1 6 e f g h i j k l m n o L q r s t u v w x y z","2":"5 8 E B C J M H I O P Q R S T U V W X Y Z a b c ZB aB bB cB p eB"},G:{"2":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"1":"4","2":"BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"1":"0B"},P:{"1":"1B 2B 3B 4B","2":"F"},Q:{"2":"5B"},R:{"1":"6B"}},B:5,C:"requestIdleCallback"};

},{}],420:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"2":"0 1 2 3 4 6 7 9 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB"},D:{"1":"3 4 CB DB QB iB KB IB LB MB NB OB","2":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w","194":"0 1 7 9 x y z GB FB AB"},E:{"2":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"1":"0 1 v w x y z","2":"5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j ZB aB bB cB p eB","194":"k l m n o L q r s t u"},G:{"2":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"1":"4","2":"BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"2":"5 8 A B C L p"},L:{"1":"IB"},M:{"2":"3"},N:{"2":"A B"},O:{"2":"0B"},P:{"2":"F 1B 2B 3B 4B"},Q:{"2":"5B"},R:{"2":"6B"}},B:7,C:"Resize Observer"};

},{}],421:[function(require,module,exports){
module.exports={A:{A:{"1":"A B","2":"K D G E gB"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 3 4 7 9 e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"2 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z XB WB","194":"6 a b c"},D:{"1":"0 1 3 4 6 7 9 U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 F N K D G E A B C d J M H I O P Q R S T"},E:{"1":"5 C p YB","2":"F N K D G E A PB HB RB SB TB UB VB","260":"B"},F:{"1":"0 1 6 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"5 8 E B C ZB aB bB cB p eB"},G:{"1":"pB qB rB sB","2":"G HB fB EB hB JB jB kB lB mB nB oB"},H:{"2":"tB"},I:{"1":"4 yB zB","2":"BB F uB vB wB xB EB"},J:{"2":"D A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:4,C:"Resource Timing"};

},{}],422:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 3 4 6 7 9 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"2 dB BB F N K D G E A B C d XB WB"},D:{"1":"0 1 3 4 7 9 q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m","194":"n o L"},E:{"1":"5 A B C VB p YB","2":"F N K D G E PB HB RB SB TB UB"},F:{"1":"0 1 6 e f g h i j k l m n o L q r s t u v w x y z","2":"5 8 E B C J M H I O P Q R S T U V W X Y Z ZB aB bB cB p eB","194":"a b c"},G:{"1":"nB oB pB qB rB sB","2":"G HB fB EB hB JB jB kB lB mB"},H:{"2":"tB"},I:{"1":"4","2":"BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"2":"5 8 A B C L p"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"1":"0B"},P:{"1":"1B 2B 3B 4B","2":"F"},Q:{"2":"5B"},R:{"1":"6B"}},B:6,C:"Rest parameters"};

},{}],423:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d","516":"J M H I"},C:{"1":"0 1 3 4 7 9 n o L q r s t u v w x y z GB FB AB CB DB","2":"2 dB BB F N K D G E A B C d J M H I O P Q XB WB","33":"6 R S T U V W X Y Z a b c e f g h i j k l m"},D:{"1":"0 1 3 4 7 9 z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 F N K D G E A B C d J M H I O P Q R","33":"6 S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y"},E:{"1":"5 B C p YB","2":"F N K D G E A PB HB RB SB TB UB VB"},F:{"1":"0 1 m n o L q r s t u v w x y z","2":"5 8 E B C J M H ZB aB bB cB p eB","33":"6 I O P Q R S T U V W X Y Z a b c e f g h i j k l"},G:{"1":"pB qB rB sB","2":"G HB fB EB hB JB jB kB lB mB nB oB"},H:{"2":"tB"},I:{"1":"4","2":"BB F uB vB wB xB EB yB zB"},J:{"2":"D","130":"A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"2":"0B"},P:{"33":"F 1B 2B 3B 4B"},Q:{"33":"5B"},R:{"33":"6B"}},B:5,C:"WebRTC Peer-to-peer connections"};

},{}],424:[function(require,module,exports){
module.exports={A:{A:{"4":"K D G E A B gB"},B:{"4":"2 C d J M H I"},C:{"1":"0 1 3 4 7 9 h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","8":"2 6 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g XB WB"},D:{"4":"0 1 2 3 4 6 7 9 N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","8":"F"},E:{"4":"5 N K D G E A B C RB SB TB UB VB p YB","8":"F PB HB"},F:{"4":"0 1 6 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","8":"5 8 E B C ZB aB bB cB p eB"},G:{"4":"G hB JB jB kB lB mB nB oB pB qB rB sB","8":"HB fB EB"},H:{"8":"tB"},I:{"4":"4 BB F xB EB yB zB","8":"uB vB wB"},J:{"4":"A","8":"D"},K:{"4":"L","8":"5 8 A B C p"},L:{"4":"IB"},M:{"1":"3"},N:{"4":"A B"},O:{"4":"0B"},P:{"4":"F 1B 2B 3B 4B"},Q:{"4":"5B"},R:{"4":"6B"}},B:1,C:"Ruby annotation"};

},{}],425:[function(require,module,exports){
module.exports={A:{A:{"1":"G E A B","2":"K D gB"},B:{"2":"2 C d J M H I"},C:{"2":"0 1 2 3 4 6 7 9 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB"},D:{"1":"2 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a","2":"0 1 3 4 6 7 9 b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"1":"N K RB","2":"5 D G E A B C TB UB VB p YB","16":"SB","129":"F PB HB"},F:{"1":"5 8 E B C J M H I ZB aB bB cB p eB","2":"0 1 6 O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z"},G:{"1":"fB EB hB JB jB","2":"G kB lB mB nB oB pB qB rB sB","129":"HB"},H:{"1":"tB"},I:{"1":"BB F uB vB wB xB EB yB","2":"4 zB"},J:{"1":"D A"},K:{"1":"5 8 A B C p","2":"L"},L:{"2":"IB"},M:{"2":"3"},N:{"1":"A B"},O:{"2":"0B"},P:{"2":"F 1B 2B 3B 4B"},Q:{"2":"5B"},R:{"2":"6B"}},B:5,C:"display: run-in"};

},{}],426:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A gB","388":"B"},B:{"1":"I","2":"2 C d J","129":"M H"},C:{"1":"3 4 7 9 FB AB CB DB","2":"0 1 2 6 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB XB WB"},D:{"1":"0 1 3 4 7 9 u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t"},E:{"1":"5 C YB","2":"F N K D G E A B PB HB RB SB TB UB VB p"},F:{"1":"0 1 i j k l m n o L q r s t u v w x y z","2":"5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h ZB aB bB cB p eB"},G:{"1":"rB sB","2":"G HB fB EB hB JB jB kB lB mB nB oB pB qB"},H:{"2":"tB"},I:{"1":"4","2":"BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"2":"0B"},P:{"1":"1B 2B 3B 4B","2":"F"},Q:{"2":"5B"},R:{"1":"6B"}},B:6,C:"'SameSite' cookie attribute"};

},{}],427:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A gB","164":"B"},B:{"36":"2 C d J M H I"},C:{"1":"0 1 3 4 7 9 n o L q r s t u v w x y z GB FB AB CB DB","2":"2 dB BB F N K D G E A B C d J M H XB WB","36":"6 I O P Q R S T U V W X Y Z a b c e f g h i j k l m"},D:{"1":"0 1 3 4 7 9 h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g"},E:{"2":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"1":"0 1 6 U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"5 8 E B C J M H I O P Q R S T ZB aB bB cB p eB"},G:{"2":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"2":"4 BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A","36":"B"},O:{"1":"0B"},P:{"1":"1B 2B 3B 4B","16":"F"},Q:{"2":"5B"},R:{"1":"6B"}},B:5,C:"Screen Orientation"};

},{}],428:[function(require,module,exports){
module.exports={A:{A:{"1":"A B","2":"K D G E gB"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB WB","2":"dB BB XB"},D:{"1":"0 1 2 3 4 6 7 9 G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"F N K D"},E:{"1":"5 K D G E A B C RB SB TB UB VB p YB","2":"F PB HB","132":"N"},F:{"1":"0 1 6 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"5 8 E B C ZB aB bB cB p eB"},G:{"1":"G hB JB jB kB lB mB nB oB pB qB rB sB","2":"HB fB EB"},H:{"2":"tB"},I:{"1":"4 BB F xB EB yB zB","2":"uB vB wB"},J:{"1":"D A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:1,C:"async attribute for external scripts"};

},{}],429:[function(require,module,exports){
module.exports={A:{A:{"1":"A B","132":"K D G E gB"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 3 4 6 7 9 a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"dB BB","257":"2 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z XB WB"},D:{"1":"0 1 2 3 4 6 7 9 G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"F N K D"},E:{"1":"5 N K D G E A B C RB SB TB UB VB p YB","2":"F PB HB"},F:{"1":"0 1 6 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"5 8 E B C ZB aB bB cB p eB"},G:{"1":"G hB JB jB kB lB mB nB oB pB qB rB sB","2":"HB fB EB"},H:{"2":"tB"},I:{"1":"4 BB F xB EB yB zB","2":"uB vB wB"},J:{"1":"D A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:1,C:"defer attribute for external scripts"};

},{}],430:[function(require,module,exports){
module.exports={A:{A:{"2":"K D gB","132":"G E A B"},B:{"132":"2 C d J M H I"},C:{"1":"0 1 3 4 7 9 f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","132":"2 6 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e XB WB"},D:{"1":"3 4 9 FB AB CB DB QB iB KB IB LB MB NB OB","132":"0 1 2 6 7 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB"},E:{"2":"F N PB HB","132":"5 K D G E A B C RB SB TB UB VB p YB"},F:{"1":"0 1 r s t u v w x y z","2":"E ZB aB bB cB","16":"8 B p","132":"5 6 C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q eB"},G:{"16":"HB fB EB","132":"G hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"16":"uB vB","132":"4 BB F wB xB EB yB zB"},J:{"132":"D A"},K:{"132":"5 8 A B C L p"},L:{"1":"IB"},M:{"1":"3"},N:{"132":"A B"},O:{"132":"0B"},P:{"132":"F 1B 2B 3B 4B"},Q:{"132":"5B"},R:{"132":"6B"}},B:5,C:"scrollIntoView"};

},{}],431:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"2":"0 1 2 3 4 6 7 9 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB"},D:{"1":"0 1 3 4 6 7 9 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","16":"2 F N K D G E A B C d"},E:{"1":"5 K D G E A B C RB SB TB UB VB p YB","16":"F N PB HB"},F:{"1":"0 1 6 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"5 8 E B C ZB aB bB cB p eB"},G:{"1":"G hB JB jB kB lB mB nB oB pB qB rB sB","16":"HB fB EB"},H:{"2":"tB"},I:{"1":"4 BB F wB xB EB yB zB","16":"uB vB"},J:{"1":"D A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"2":"3"},N:{"2":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:7,C:"Element.scrollIntoViewIfNeeded()"};

},{}],432:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"2":"0 1 2 3 4 6 7 9 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB"},D:{"1":"0 1 2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"3 4 7 9 GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"2":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"1":"0 1 6 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"5 8 E B C ZB aB bB cB p eB"},G:{"2":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"1":"4","2":"BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"2":"5 8 A B C L p"},L:{"2":"IB"},M:{"2":"3"},N:{"2":"A B"},O:{"2":"0B"},P:{"1":"1B 2B 3B 4B","2":"F"},Q:{"2":"5B"},R:{"2":"6B"}},B:6,C:"SDCH Accept-Encoding/Content-Encoding"};

},{}],433:[function(require,module,exports){
module.exports={A:{A:{"1":"E A B","16":"gB","260":"K D G"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 3 4 7 9 v w x y z GB FB AB CB DB","132":"2 6 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l XB WB","2180":"m n o L q r s t u"},D:{"1":"0 1 3 4 6 7 9 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","16":"2 F N K D G E A B C d"},E:{"1":"5 K D G E A B C RB SB TB UB VB p YB","16":"F N PB HB"},F:{"1":"0 1 6 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","132":"5 8 E B C ZB aB bB cB p eB"},G:{"16":"EB","132":"HB fB","516":"G hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"1":"4 yB zB","16":"BB F uB vB wB xB","1025":"EB"},J:{"1":"A","16":"D"},K:{"1":"L","16":"8 A B C p","132":"5"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"B","16":"A"},O:{"1025":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:5,C:"Selection API"};

},{}],434:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"1":"3 4 9 FB AB CB DB","2":"0 1 2 6 7 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB XB WB"},D:{"1":"4 CB DB QB iB KB IB LB MB NB OB","2":"0 1 2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB","196":"7 9 FB AB","324":"3"},E:{"2":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"1":"0 1 v w x y z","2":"5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u ZB aB bB cB p eB"},G:{"2":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"1":"4","2":"BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"2":"5 8 A B C L p"},L:{"1":"IB"},M:{"2":"3"},N:{"2":"A B"},O:{"2":"0B"},P:{"2":"F 1B 2B 3B 4B"},Q:{"2":"5B"},R:{"2":"6B"}},B:5,C:"Server Timing"};

},{}],435:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"1":"H I","2":"2 C d","322":"J M"},C:{"1":"0 1 3 4 9 n L q r s t u w x y z GB FB AB CB DB","2":"2 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b XB WB","194":"6 c e f g h i j k l m","513":"7 o v"},D:{"1":"0 1 3 4 7 9 o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i","4":"j k l m n"},E:{"1":"5 C p YB","2":"F N K D G E A B PB HB RB SB TB UB VB"},F:{"1":"0 1 6 b c e f g h i j k l m n o L q r s t u v w x y z","2":"5 8 E B C J M H I O P Q R S T U V ZB aB bB cB p eB","4":"W X Y Z a"},G:{"1":"qB rB sB","2":"G HB fB EB hB JB jB kB lB mB nB oB pB"},H:{"2":"tB"},I:{"2":"BB F uB vB wB xB EB yB zB","4":"4"},J:{"2":"D A"},K:{"2":"5 8 A B C p","4":"L"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"4":"5B"},R:{"4":"6B"}},B:5,C:"Service Workers"};

},{}],436:[function(require,module,exports){
module.exports={A:{A:{"1":"A B","2":"K D G E gB"},B:{"1":"2 C d J M H I"},C:{"2":"0 1 2 3 4 6 7 9 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB"},D:{"2":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"2":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"2":"0 1 5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z ZB aB bB cB p eB"},G:{"2":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"2":"4 BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"2":"5 8 A B C L p"},L:{"2":"IB"},M:{"2":"3"},N:{"1":"A B"},O:{"2":"0B"},P:{"2":"F 1B 2B 3B 4B"},Q:{"2":"5B"},R:{"2":"6B"}},B:7,C:"Efficient Script Yielding: setImmediate()"};

},{}],437:[function(require,module,exports){
module.exports={A:{A:{"1":"K D G E A B","2":"gB"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 2 3 4 6 7 9 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB"},D:{"1":"0 1 3 4 7 9 h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","132":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g"},E:{"1":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"1":"0 1 5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z ZB aB bB cB p eB"},G:{"1":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"16":"tB"},I:{"1":"4 BB F vB wB xB EB yB zB","260":"uB"},J:{"1":"D A"},K:{"16":"5 8 A B C L p"},L:{"1":"IB"},M:{"16":"3"},N:{"16":"A B"},O:{"16":"0B"},P:{"1":"1B 2B 3B 4B","16":"F"},Q:{"1":"5B"},R:{"1":"6B"}},B:6,C:"SHA-2 SSL certificates"};

},{}],438:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"2":"2 3 4 9 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X FB AB CB DB XB WB","194":"0 1 6 Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","322":"7 GB"},D:{"1":"0 1 3 4 7 9 e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB","2":"2 F N K D G E A B C d J M H I O P Q R S T MB NB OB","33":"6 U V W X Y Z a b c"},E:{"2":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"1":"0 1 6 R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"5 8 E B C ZB aB bB cB p eB","33":"J M H I O P Q"},G:{"2":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"1":"4","2":"BB F uB vB wB xB EB","33":"yB zB"},J:{"2":"D A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"2":"3"},N:{"2":"A B"},O:{"1":"0B"},P:{"1":"1B 2B 3B 4B","33":"F"},Q:{"1":"5B"},R:{"1":"6B"}},B:7,C:"Shadow DOM (deprecated V0 spec)"};

},{}],439:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"1":"3 4 AB CB DB","2":"0 2 6 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z XB WB","322":"1","578":"7 9 GB FB"},D:{"1":"0 1 3 4 7 9 w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v"},E:{"2":"F N K D G E PB HB RB SB TB UB","132":"5 A B C VB p YB"},F:{"1":"0 1 j k l m n o L q r s t u v w x y z","2":"5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i ZB aB bB cB p eB"},G:{"2":"G HB fB EB hB JB jB kB lB mB","132":"nB oB pB qB rB sB"},H:{"2":"tB"},I:{"1":"4","2":"BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"1":"0B"},P:{"1":"2B 3B 4B","2":"F","4":"1B"},Q:{"1":"5B"},R:{"2":"6B"}},B:5,C:"Shadow DOM (V1)"};

},{}],440:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J","194":"M H I"},C:{"2":"2 6 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z XB WB","194":"0 1 3 4 7 9 GB FB AB CB DB"},D:{"1":"QB iB KB IB LB MB NB OB","2":"0 1 2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB","194":"3 4 7 9 FB AB CB DB"},E:{"2":"F N K D G E A PB HB RB SB TB UB","194":"5 B C VB p YB"},F:{"2":"5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L ZB aB bB cB p eB","194":"0 1 q r s t u v w x y z"},G:{"2":"G HB fB EB hB JB jB kB lB mB nB","194":"oB pB qB rB sB"},H:{"2":"tB"},I:{"2":"BB F uB vB wB xB EB yB zB","16":"4"},J:{"2":"D A"},K:{"2":"5 8 A B C L p"},L:{"194":"IB"},M:{"194":"3"},N:{"2":"A B"},O:{"1":"0B"},P:{"2":"F 1B 2B 3B 4B"},Q:{"2":"5B"},R:{"2":"6B"}},B:6,C:"Shared Array Buffer"};

},{}],441:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"1":"0 1 3 4 6 7 9 Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"2 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X XB WB"},D:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"1":"N K RB","2":"5 F D G E A B C PB HB SB TB UB VB p YB"},F:{"1":"0 1 5 6 8 B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z cB p eB","2":"E ZB aB bB"},G:{"1":"hB JB","2":"G HB fB EB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"2":"4 BB F uB vB wB xB EB yB zB"},J:{"1":"D A"},K:{"1":"5 8 B C p","2":"L","16":"A"},L:{"2":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"1":"0B"},P:{"1":"F","2":"1B 2B 3B 4B"},Q:{"2":"5B"},R:{"2":"6B"}},B:1,C:"Shared Web Workers"};

},{}],442:[function(require,module,exports){
module.exports={A:{A:{"1":"E A B","2":"K gB","132":"D G"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 2 3 4 6 7 9 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB"},D:{"1":"0 1 2 3 4 6 7 9 K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"F N"},E:{"1":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"1":"0 1 5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z ZB aB bB cB p eB"},G:{"1":"G fB EB hB JB jB kB lB mB nB oB pB qB rB sB","2":"HB"},H:{"1":"tB"},I:{"1":"4 BB F xB EB yB zB","2":"uB vB wB"},J:{"1":"A","2":"D"},K:{"1":"5 8 A B C L p"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:6,C:"Server Name Indication"};

},{}],443:[function(require,module,exports){
module.exports={A:{A:{"1":"B","2":"K D G E A gB"},B:{"2":"2 C d J M H I"},C:{"1":"2 6 d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t","2":"0 1 3 4 7 9 dB BB F N K D G E A B C u v w x y z GB FB AB CB DB XB WB"},D:{"1":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t","2":"0 1 3 4 7 9 u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"1":"G E A B C UB VB p","2":"F N K D PB HB RB SB TB","129":"5 YB"},F:{"1":"5 6 J M H I O P Q R S T U V W X Y Z a b c e f g h i l n","2":"0 1 8 E B C j k m o L q r s t u v w x y z ZB aB bB cB p eB"},G:{"1":"G kB lB mB nB oB pB qB rB","2":"HB fB EB hB JB jB","257":"sB"},H:{"2":"tB"},I:{"1":"BB F xB EB yB zB","2":"4 uB vB wB"},J:{"2":"D A"},K:{"1":"5","2":"8 A B C L p"},L:{"2":"IB"},M:{"2":"3"},N:{"1":"B","2":"A"},O:{"2":"0B"},P:{"1":"F","2":"1B 2B 3B 4B"},Q:{"2":"5B"},R:{"16":"6B"}},B:7,C:"SPDY protocol"};

},{}],444:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"2":"2 dB BB F N K D G E A B C d J M H I O P Q XB WB","322":"0 1 3 4 6 7 9 R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB"},D:{"2":"2 F N K D G E A B C d J M H I O P Q R S T","164":"0 1 3 4 6 7 9 U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"2":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"2":"5 8 E B C J M H I O P Q R S T U V ZB aB bB cB p eB","164":"0 1 6 W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z"},G:{"2":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"2":"4 BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"2":"5 8 A B C L p"},L:{"164":"IB"},M:{"2":"3"},N:{"2":"A B"},O:{"2":"0B"},P:{"164":"F 1B 2B 3B 4B"},Q:{"164":"5B"},R:{"164":"6B"}},B:7,C:"Speech Recognition API"};

},{}],445:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"1":"d J M H I","2":"2 C"},C:{"1":"0 1 3 4 7 9 s t u v w x y z GB FB AB CB DB","2":"2 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z XB WB","194":"6 a b c e f g h i j k l m n o L q r"},D:{"1":"6 c e f g h i j k l m n o L q r s t u v w x","2":"2 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b","257":"0 1 3 4 7 9 y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"1":"5 D G E A B C TB UB VB p YB","2":"F N K PB HB RB SB"},F:{"1":"0 1 6 W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"5 8 E B C J M H I O P Q R S T U V ZB aB bB cB p eB"},G:{"1":"G jB kB lB mB nB oB pB qB rB sB","2":"HB fB EB hB JB"},H:{"2":"tB"},I:{"2":"4 BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"2":"5 8 A B C L p"},L:{"1":"IB"},M:{"2":"3"},N:{"2":"A B"},O:{"2":"0B"},P:{"1":"1B 2B 3B 4B","2":"F"},Q:{"1":"5B"},R:{"2":"6B"}},B:7,C:"Speech Synthesis API"};

},{}],446:[function(require,module,exports){
module.exports={A:{A:{"1":"A B","2":"K D G E gB"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 2 3 4 6 7 9 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB"},D:{"1":"0 1 2 3 4 6 7 9 E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"F N K D G"},E:{"1":"5 K D G E A B C RB SB TB UB VB p YB","2":"F N PB HB"},F:{"1":"0 1 5 6 8 B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z bB cB p eB","2":"E ZB aB"},G:{"4":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"4":"tB"},I:{"4":"4 BB F uB vB wB xB EB yB zB"},J:{"1":"A","4":"D"},K:{"4":"5 8 A B C L p"},L:{"4":"IB"},M:{"4":"3"},N:{"4":"A B"},O:{"4":"0B"},P:{"4":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"4":"6B"}},B:1,C:"Spellcheck attribute"};

},{}],447:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"2":"0 1 2 3 4 6 7 9 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB"},D:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"1":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"1":"0 1 5 6 8 B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z bB cB p eB","2":"E ZB aB"},G:{"1":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"1":"4 BB F uB vB wB xB EB yB zB"},J:{"1":"D A"},K:{"1":"5 8 B C L p","2":"A"},L:{"1":"IB"},M:{"2":"3"},N:{"2":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:7,C:"Web SQL Database"};

},{}],448:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"1":"M H I","260":"C","514":"2 d J"},C:{"1":"0 1 3 4 7 9 h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"2 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a XB WB","194":"6 b c e f g"},D:{"1":"0 1 3 4 7 9 h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c","260":"6 e f g"},E:{"1":"5 E A B C UB VB p YB","2":"F N K D PB HB RB SB","260":"G TB"},F:{"1":"0 1 6 U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"5 8 E B C J M H I O P ZB aB bB cB p eB","260":"Q R S T"},G:{"1":"lB mB nB oB pB qB rB sB","2":"HB fB EB hB JB jB","260":"G kB"},H:{"2":"tB"},I:{"1":"4","2":"BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:1,C:"Srcset and sizes attributes"};

},{}],449:[function(require,module,exports){
module.exports={A:{A:{"1":"E A B","2":"K D G gB"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 2 3 4 6 7 9 A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"dB BB F N K D G E XB WB"},D:{"1":"0 1 3 4 6 7 9 V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","16":"2 F N K D G E A B C d J M H I O P Q R S T U"},E:{"1":"5 K D G E A B C RB SB TB UB VB p YB","16":"F N PB HB"},F:{"1":"0 1 5 6 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"8 E B ZB aB bB cB p eB","16":"C"},G:{"1":"G JB jB kB lB mB nB oB pB qB rB sB","16":"HB fB EB hB"},H:{"16":"tB"},I:{"1":"4 F xB EB yB zB","16":"BB uB vB wB"},J:{"16":"D A"},K:{"16":"5 8 A B C L p"},L:{"1":"IB"},M:{"1":"3"},N:{"16":"A B"},O:{"16":"0B"},P:{"1":"1B 2B 3B 4B","16":"F"},Q:{"1":"5B"},R:{"1":"6B"}},B:1,C:"Event.stopImmediatePropagation()"};

},{}],450:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 3 4 7 9 l m n o L q r s t u v w x y z GB FB AB CB DB","2":"2 dB BB F N K D G E A B C d J M XB WB","129":"f g h i j k","420":"6 H I O P Q R S T U V W X Y Z a b c e"},D:{"1":"0 1 3 4 7 9 w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 F N K D G E A B C d J M H I O P","420":"6 Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v"},E:{"1":"5 B C p YB","2":"F N K D G E A PB HB RB SB TB UB VB"},F:{"1":"0 1 j k l m n o L q r s t u v w x y z","2":"8 E B J M H ZB aB bB cB p eB","420":"5 6 C I O P Q R S T U V W X Y Z a b c e f g h i"},G:{"2":"G HB fB EB hB JB jB kB lB mB nB oB","513":"pB qB rB sB"},H:{"2":"tB"},I:{"1":"4","2":"BB F uB vB wB xB EB yB zB"},J:{"2":"D","420":"A"},K:{"1":"L","2":"8 A B p","420":"5 C"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"1":"0B"},P:{"1":"2B 3B 4B","420":"F 1B"},Q:{"420":"5B"},R:{"420":"6B"}},B:4,C:"getUserMedia/Stream API"};

},{}],451:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A gB","130":"B"},B:{"16":"2 C","260":"d J","5124":"M H I"},C:{"2":"2 6 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z XB WB","2626":"0 1 3 4 7 9 GB FB AB CB DB"},D:{"2":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u","260":"0 1 v w x y z","1028":"3 4 7 9 GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"2":"F N K D G E PB HB RB SB TB UB","3076":"5 A B C VB p YB"},F:{"2":"5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h ZB aB bB cB p eB","260":"i j k l m n o","1028":"0 1 L q r s t u v w x y z"},G:{"2":"G HB fB EB hB JB jB kB lB mB","16":"nB","1028":"oB pB qB rB sB"},H:{"2":"tB"},I:{"2":"BB F uB vB wB xB EB yB zB","260":"4"},J:{"2":"D A"},K:{"2":"5 8 A B C p","1028":"L"},L:{"1028":"IB"},M:{"2626":"3"},N:{"2":"A B"},O:{"2":"0B"},P:{"2":"F 1B 2B","1028":"3B 4B"},Q:{"2":"5B"},R:{"2":"6B"}},B:1,C:"Streams"};

},{}],452:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A gB","129":"B"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"dB BB XB WB"},D:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"1":"5 D G E A B C TB UB VB p YB","2":"F N K PB HB RB SB"},F:{"1":"0 1 5 6 C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"8 E B ZB aB bB cB p eB"},G:{"1":"G jB kB lB mB nB oB pB qB rB sB","2":"HB fB EB hB JB"},H:{"2":"tB"},I:{"1":"4 yB zB","2":"BB F uB vB wB xB EB"},J:{"1":"D A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"2":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:6,C:"Strict Transport Security"};

},{}],453:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"1":"6 Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x","2":"2 3 4 9 dB BB F N K D G E A B C d J M H I O P FB AB CB DB XB WB","322":"0 1 7 y z GB"},D:{"2":"0 1 2 3 4 7 9 F N K D G E A B C d J M H I O g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","194":"6 P Q R S T U V W X Y Z a b c e f"},E:{"2":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"2":"0 1 5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z ZB aB bB cB p eB"},G:{"2":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"2":"4 BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"2":"5 8 A B C L p"},L:{"2":"IB"},M:{"322":"3"},N:{"2":"A B"},O:{"2":"0B"},P:{"2":"F 1B 2B 3B 4B"},Q:{"2":"5B"},R:{"2":"6B"}},B:7,C:"Scoped CSS"};

},{}],454:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"1":"H I","2":"2 C d J M"},C:{"1":"0 1 3 4 7 9 m n o L q r s t u v w x y z GB FB AB CB DB","2":"2 6 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l XB WB"},D:{"1":"0 1 3 4 7 9 o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n"},E:{"1":"5 B C p YB","2":"F N K D G E A PB HB RB SB TB UB VB"},F:{"1":"0 1 6 b c e f g h i j k l m n o L q r s t u v w x y z","2":"5 8 E B C J M H I O P Q R S T U V W X Y Z a ZB aB bB cB p eB"},G:{"1":"qB rB sB","2":"G HB fB EB hB JB jB kB lB mB nB oB","194":"pB"},H:{"2":"tB"},I:{"1":"4","2":"BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"1":"0B"},P:{"1":"1B 2B 3B 4B","2":"F"},Q:{"1":"5B"},R:{"1":"6B"}},B:2,C:"Subresource Integrity"};

},{}],455:[function(require,module,exports){
module.exports={A:{A:{"1":"E A B","2":"K D G gB"},B:{"1":"M H I","516":"2 C d J"},C:{"1":"0 1 3 4 6 7 9 T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"dB BB XB WB","260":"2 F N K D G E A B C d J M H I O P Q R S"},D:{"1":"0 1 2 3 4 6 7 9 N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","4":"F"},E:{"1":"5 N K D G E A B C RB SB TB UB VB p YB","2":"PB","132":"F HB"},F:{"1":"0 1 5 6 8 B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z ZB aB bB cB p eB","2":"E"},G:{"1":"G EB hB JB jB kB lB mB nB oB pB qB rB sB","132":"HB fB"},H:{"260":"tB"},I:{"1":"4 BB F xB EB yB zB","2":"uB vB wB"},J:{"1":"D A"},K:{"1":"L","260":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:4,C:"SVG in CSS backgrounds"};

},{}],456:[function(require,module,exports){
module.exports={A:{A:{"1":"A B","2":"K D G E gB"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 2 3 4 6 7 9 BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB","2":"dB"},D:{"1":"0 1 2 3 4 6 7 9 G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"F","4":"N K D"},E:{"1":"5 K D G E A B C SB TB UB VB p YB","2":"F N PB HB RB"},F:{"1":"0 1 5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z ZB aB bB cB p eB"},G:{"1":"G JB jB kB lB mB nB oB pB qB rB sB","2":"HB fB EB hB"},H:{"1":"tB"},I:{"1":"4 yB zB","2":"BB F uB vB wB xB EB"},J:{"1":"A","2":"D"},K:{"1":"5 8 A B C L p"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:2,C:"SVG filters"};

},{}],457:[function(require,module,exports){
module.exports={A:{A:{"2":"E A B gB","8":"K D G"},B:{"2":"2 C d J M H I"},C:{"2":"0 1 2 3 4 6 7 9 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB"},D:{"1":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g","2":"0 1 3 4 7 9 u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","130":"h i j k l m n o L q r s t"},E:{"1":"5 F N K D G E A B C HB RB SB TB UB VB p YB","2":"PB"},F:{"1":"5 8 E B C J M H I O P Q R S T ZB aB bB cB p eB","2":"0 1 g h i j k l m n o L q r s t u v w x y z","130":"6 U V W X Y Z a b c e f"},G:{"1":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"258":"tB"},I:{"1":"BB F xB EB yB zB","2":"4 uB vB wB"},J:{"1":"D A"},K:{"1":"5 8 A B C L p"},L:{"130":"IB"},M:{"2":"3"},N:{"2":"A B"},O:{"2":"0B"},P:{"1":"F","130":"1B 2B 3B 4B"},Q:{"1":"5B"},R:{"130":"6B"}},B:7,C:"SVG fonts"};

},{}],458:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G gB","260":"E A B"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 3 4 6 7 9 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"2 dB BB F N K D G E A B C d XB WB"},D:{"1":"0 1 3 4 7 9 t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e","132":"f g h i j k l m n o L q r s"},E:{"1":"5 C p YB","2":"F N K D E A B PB HB RB SB UB VB","132":"G TB"},F:{"1":"0 1 5 g h i j k l m n o L q r s t u v w x y z","2":"J M H I O P Q R","4":"8 B C aB bB cB p eB","16":"E ZB","132":"6 S T U V W X Y Z a b c e f"},G:{"1":"qB rB sB","2":"HB fB EB hB JB jB lB mB nB oB pB","132":"G kB"},H:{"1":"tB"},I:{"1":"4","2":"BB F uB vB wB xB EB yB zB"},J:{"2":"D","132":"A"},K:{"1":"5 L","4":"8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"A B"},O:{"1":"0B"},P:{"1":"1B 2B 3B 4B","132":"F"},Q:{"132":"5B"},R:{"132":"6B"}},B:2,C:"SVG fragment identifiers"};

},{}],459:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G gB","388":"E A B"},B:{"260":"2 C d J M H I"},C:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB","2":"dB","4":"BB"},D:{"4":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"2":"PB HB","4":"5 F N K D G E A B C RB SB TB UB VB p YB"},F:{"4":"0 1 5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z ZB aB bB cB p eB"},G:{"4":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"2":"BB F uB vB wB xB EB","4":"4 yB zB"},J:{"1":"A","2":"D"},K:{"4":"5 8 A B C L p"},L:{"4":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"2":"0B"},P:{"4":"F 1B 2B 3B 4B"},Q:{"4":"5B"},R:{"4":"6B"}},B:2,C:"SVG effects for HTML"};

},{}],460:[function(require,module,exports){
module.exports={A:{A:{"2":"gB","8":"K D G","129":"E A B"},B:{"1":"H I","129":"2 C d J M"},C:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","8":"dB BB XB WB"},D:{"1":"0 1 2 3 4 6 7 9 D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","8":"F N K"},E:{"1":"5 E A B C UB VB p YB","8":"F N PB HB","129":"K D G RB SB TB"},F:{"1":"0 1 5 6 C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z eB","2":"8 B cB p","8":"E ZB aB bB"},G:{"1":"lB mB nB oB pB qB rB sB","8":"HB fB EB","129":"G hB JB jB kB"},H:{"1":"tB"},I:{"1":"4 yB zB","2":"uB vB wB","129":"BB F xB EB"},J:{"1":"A","129":"D"},K:{"1":"5 C L","8":"8 A B p"},L:{"1":"IB"},M:{"1":"3"},N:{"129":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:1,C:"Inline SVG in HTML5"};

},{}],461:[function(require,module,exports){
module.exports={A:{A:{"1":"E A B","2":"K D G gB"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"dB BB XB WB"},D:{"1":"0 1 3 4 6 7 9 X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","132":"2 F N K D G E A B C d J M H I O P Q R S T U V W"},E:{"1":"5 E A B C UB VB p YB","2":"PB","4":"HB","132":"F N K D G RB SB TB"},F:{"1":"0 1 5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z ZB aB bB cB p eB"},G:{"1":"lB mB nB oB pB qB rB sB","132":"G HB fB EB hB JB jB kB"},H:{"1":"tB"},I:{"1":"4 yB zB","2":"uB vB wB","132":"BB F xB EB"},J:{"1":"D A"},K:{"1":"5 8 A B C L p"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:1,C:"SVG in HTML img element"};

},{}],462:[function(require,module,exports){
module.exports={A:{A:{"2":"gB","8":"K D G E A B"},B:{"8":"2 C d J M H I"},C:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","8":"dB BB XB WB"},D:{"1":"0 1 2 3 4 6 7 9 N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","4":"F"},E:{"1":"5 K D G E A B C SB TB UB VB p YB","8":"PB HB","132":"F N RB"},F:{"1":"0 1 5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z ZB aB bB cB p eB"},G:{"1":"G JB jB kB lB mB nB oB pB qB rB sB","132":"HB fB EB hB"},H:{"2":"tB"},I:{"1":"4 BB F xB EB yB zB","2":"uB vB wB"},J:{"1":"D A"},K:{"1":"5 8 A B C L p"},L:{"1":"IB"},M:{"1":"3"},N:{"8":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:2,C:"SVG SMIL animation"};

},{}],463:[function(require,module,exports){
module.exports={A:{A:{"2":"gB","8":"K D G","257":"E A B"},B:{"257":"2 C d J M H I"},C:{"1":"0 1 2 3 4 6 7 9 BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB","4":"dB"},D:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"1":"5 F N K D G E A B C HB RB SB TB UB VB p YB","4":"PB"},F:{"1":"0 1 5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z ZB aB bB cB p eB"},G:{"1":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"1":"tB"},I:{"1":"4 yB zB","2":"uB vB wB","132":"BB F xB EB"},J:{"1":"D A"},K:{"1":"5 8 A B C L p"},L:{"1":"IB"},M:{"1":"3"},N:{"257":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:2,C:"SVG (basic support)"};

},{}],464:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 3 4 7 9 f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"2 6 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e XB WB"},D:{"1":"0 1 3 4 7 9 h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g"},E:{"1":"5 E A B C PB HB RB SB TB UB VB p YB","2":"F N K D G"},F:{"1":"0 1 6 U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"5 8 E B C J M H I O P Q R S T ZB aB bB cB p eB"},G:{"1":"lB mB nB oB pB qB rB sB","2":"G HB fB EB hB JB jB kB"},H:{"2":"tB"},I:{"1":"4 BB F uB vB wB xB EB yB zB"},J:{"16":"D A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"16":"0B"},P:{"16":"F 1B 2B 3B 4B"},Q:{"16":"5B"},R:{"16":"6B"}},B:6,C:"Symbols"};

},{}],465:[function(require,module,exports){
module.exports={A:{A:{"1":"D G E A B","16":"K gB"},B:{"1":"2 C d J M H I"},C:{"16":"dB BB XB WB","129":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB"},D:{"1":"0 1 3 4 6 7 9 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","16":"2 F N K D G E A B C d"},E:{"16":"F N PB HB","257":"5 K D G E A B C RB SB TB UB VB p YB"},F:{"1":"0 1 5 6 8 B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z ZB aB bB cB p eB","16":"E"},G:{"769":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"16":"tB"},I:{"16":"4 BB F uB vB wB xB EB yB zB"},J:{"16":"D A"},K:{"16":"5 8 A B C L p"},L:{"1":"IB"},M:{"1":"3"},N:{"16":"A B"},O:{"16":"0B"},P:{"16":"F 1B 2B 3B 4B"},Q:{"2":"5B"},R:{"16":"6B"}},B:1,C:"tabindex global attribute"};

},{}],466:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"1":"2 d J M H I","16":"C"},C:{"1":"0 1 3 4 6 7 9 e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"2 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c XB WB"},D:{"1":"0 1 3 4 7 9 k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j"},E:{"1":"5 A B C UB VB p YB","2":"F N K D G E PB HB RB SB TB"},F:{"1":"0 1 6 Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"5 8 E B C J M H I O P Q R S T U V W X ZB aB bB cB p eB"},G:{"1":"lB mB nB oB pB qB rB sB","2":"G HB fB EB hB JB jB kB"},H:{"2":"tB"},I:{"1":"4","2":"BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"2":"5B"},R:{"1":"6B"}},B:6,C:"ES6 Template Literals (Template Strings)"};

},{}],467:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"1":"J M H I","2":"C","388":"2 d"},C:{"1":"0 1 3 4 6 7 9 R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"2 dB BB F N K D G E A B C d J M H I O P Q XB WB"},D:{"1":"0 1 3 4 7 9 e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 F N K D G E A B C d J M H I O P Q R S T U","132":"6 V W X Y Z a b c"},E:{"1":"5 E A B C UB VB p YB","2":"F N K D PB HB RB","388":"G TB","514":"SB"},F:{"1":"0 1 6 R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"5 8 E B C ZB aB bB cB p eB","132":"J M H I O P Q"},G:{"1":"lB mB nB oB pB qB rB sB","2":"HB fB EB hB JB jB","388":"G kB"},H:{"2":"tB"},I:{"1":"4 yB zB","2":"BB F uB vB wB xB EB"},J:{"2":"D A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:1,C:"HTML templates"};

},{}],468:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G A B gB","16":"E"},B:{"2":"2 C d J M H I"},C:{"2":"0 1 2 3 4 6 7 9 dB BB K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB","16":"F N"},D:{"2":"0 1 2 3 4 6 7 9 F N K D G E A d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","16":"B C"},E:{"2":"F K PB HB RB","16":"5 N D G E A B C SB TB UB VB p YB"},F:{"2":"0 1 5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z ZB aB bB cB eB","16":"p"},G:{"2":"HB fB EB hB JB","16":"G jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"2":"4 BB F uB vB xB EB yB zB","16":"wB"},J:{"2":"A","16":"D"},K:{"2":"5 8 A B C L p"},L:{"2":"IB"},M:{"2":"3"},N:{"2":"A B"},O:{"2":"0B"},P:{"2":"F 1B 2B 3B 4B"},Q:{"2":"5B"},R:{"2":"6B"}},B:7,C:"Test feature - updated"};

},{}],469:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"2":"dB BB F N XB WB","1028":"0 1 3 4 7 9 f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","1060":"2 6 K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e"},D:{"2":"2 F N K D G E A B C d J M H I O P Q R S T U","226":"6 V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2052":"0 1 3 4 7 9 GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"2":"F N K D PB HB RB SB","772":"5 YB","804":"G E A B C UB VB p","1316":"TB"},F:{"2":"5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c ZB aB bB cB p eB","226":"e f g h i j k l m","2052":"0 1 n o L q r s t u v w x y z"},G:{"2":"HB fB EB hB JB jB","292":"G kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"1":"4","2":"BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"2":"5 8 A B C p","2052":"L"},L:{"2052":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"2052":"0B"},P:{"2":"F 1B 2B","2052":"3B 4B"},Q:{"2":"5B"},R:{"1":"6B"}},B:4,C:"text-decoration styling"};

},{}],470:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"1":"0 1 3 4 7 9 L q r s t u v w x y z GB FB AB CB DB","2":"2 6 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n XB WB","322":"o"},D:{"2":"2 F N K D G E A B C d J M H I O P Q R S T","164":"0 1 3 4 6 7 9 U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"1":"5 G E A B C TB UB VB p YB","2":"F N K PB HB RB","164":"D SB"},F:{"2":"5 8 E B C ZB aB bB cB p eB","164":"0 1 6 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z"},G:{"1":"G jB kB lB mB nB oB pB qB rB sB","2":"HB fB EB hB JB"},H:{"2":"tB"},I:{"2":"BB F uB vB wB xB EB","164":"4 yB zB"},J:{"2":"D","164":"A"},K:{"2":"5 8 A B C p","164":"L"},L:{"164":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"164":"0B"},P:{"164":"F 1B 2B 3B 4B"},Q:{"164":"5B"},R:{"164":"6B"}},B:4,C:"text-emphasis styling"};

},{}],471:[function(require,module,exports){
module.exports={A:{A:{"1":"K D G E A B","2":"gB"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 2 3 4 6 7 9 D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","8":"dB BB F N K XB WB"},D:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"1":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"1":"0 1 5 6 8 B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z p eB","33":"E ZB aB bB cB"},G:{"1":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"1":"tB"},I:{"1":"4 BB F uB vB wB xB EB yB zB"},J:{"1":"D A"},K:{"1":"5 L","33":"8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:4,C:"CSS3 Text-overflow"};

},{}],472:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"33":"2 C d J M H I"},C:{"2":"0 1 2 3 4 6 7 9 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB"},D:{"1":"0 1 3 4 7 9 x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 6 F N K D G E A B C d J M H I O P Q R S T U W X Y Z a b c e f g h i j k l m n o L q r s t u v w","258":"V"},E:{"2":"5 F N K D G E A B C PB HB SB TB UB VB p YB","258":"RB"},F:{"1":"0 1 m o L q r s t u v w x y z","2":"5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l n ZB aB bB cB p eB"},G:{"2":"HB fB EB","33":"G hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"1":"4","2":"BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"33":"3"},N:{"161":"A B"},O:{"1":"0B"},P:{"1":"1B 2B 3B 4B","2":"F"},Q:{"2":"5B"},R:{"2":"6B"}},B:7,C:"CSS text-size-adjust"};

},{}],473:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d","161":"J M H I"},C:{"2":"2 6 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q XB WB","161":"0 1 3 4 7 9 s t u v w x y z GB FB AB CB DB","450":"r"},D:{"33":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"1":"5 B C p YB","33":"F N K D G E A PB HB RB SB TB UB VB"},F:{"2":"5 8 E B C ZB aB bB cB p eB","33":"0 1 6 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z"},G:{"33":"G fB EB hB JB jB kB lB mB nB oB pB qB rB sB","36":"HB"},H:{"2":"tB"},I:{"2":"BB","33":"4 F uB vB wB xB EB yB zB"},J:{"33":"D A"},K:{"2":"5 8 A B C p","33":"L"},L:{"33":"IB"},M:{"161":"3"},N:{"2":"A B"},O:{"33":"0B"},P:{"33":"F 1B 2B 3B 4B"},Q:{"33":"5B"},R:{"33":"6B"}},B:7,C:"CSS text-stroke and text-fill"};

},{}],474:[function(require,module,exports){
module.exports={A:{A:{"1":"E A B","2":"K D G gB"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 2 3 4 6 7 9 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB"},D:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"1":"5 F N K D G E A B C HB RB SB TB UB VB p YB","16":"PB"},F:{"1":"0 1 5 6 8 B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z ZB aB bB cB p eB","16":"E"},G:{"1":"G fB EB hB JB jB kB lB mB nB oB pB qB rB sB","16":"HB"},H:{"1":"tB"},I:{"1":"4 BB F wB xB EB yB zB","16":"uB vB"},J:{"1":"D A"},K:{"1":"5 8 A B C L p"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:1,C:"Node.textContent"};

},{}],475:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"1":"0 1 3 4 6 7 9 P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"2 dB BB F N K D G E A B C d J M H I XB WB","132":"O"},D:{"1":"0 1 3 4 7 9 h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g"},E:{"1":"5 B C VB p YB","2":"F N K D G E A PB HB RB SB TB UB"},F:{"1":"0 1 6 U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"5 8 E B C J M H I O P Q R S T ZB aB bB cB p eB"},G:{"1":"oB pB qB rB sB","2":"G HB fB EB hB JB jB kB lB mB nB"},H:{"2":"tB"},I:{"1":"4","2":"BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"2":"5B"},R:{"1":"6B"}},B:1,C:"TextEncoder & TextDecoder"};

},{}],476:[function(require,module,exports){
module.exports={A:{A:{"1":"B","2":"K D gB","66":"G E A"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 3 4 6 7 9 T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"2 dB BB F N K D G E A B C d J M H I O P Q R XB WB","66":"S"},D:{"1":"0 1 3 4 6 7 9 R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 F N K D G E A B C d J M H I O P Q"},E:{"1":"5 D G E A B C TB UB VB p YB","2":"F N K PB HB RB SB"},F:{"1":"0 1 5 6 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"8 E B C ZB aB bB cB p eB"},G:{"1":"G hB JB jB kB lB mB nB oB pB qB rB sB","2":"HB fB EB"},H:{"1":"tB"},I:{"1":"4","2":"BB F uB vB wB xB EB yB zB"},J:{"1":"A","2":"D"},K:{"1":"5 L","2":"8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"B","66":"A"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:6,C:"TLS 1.1"};

},{}],477:[function(require,module,exports){
module.exports={A:{A:{"1":"B","2":"K D gB","66":"G E A"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 3 4 6 7 9 W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"2 dB BB F N K D G E A B C d J M H I O P Q R S XB WB","66":"T U V"},D:{"1":"0 1 3 4 6 7 9 Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 F N K D G E A B C d J M H I O P Q R S T U V W X Y"},E:{"1":"5 D G E A B C TB UB VB p YB","2":"F N K PB HB RB SB"},F:{"1":"0 1 5 6 H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"E J M ZB","66":"8 B C aB bB cB p eB"},G:{"1":"G hB JB jB kB lB mB nB oB pB qB rB sB","2":"HB fB EB"},H:{"1":"tB"},I:{"1":"4","2":"BB F uB vB wB xB EB yB zB"},J:{"1":"A","2":"D"},K:{"1":"5 L","2":"8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"B","66":"A"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:6,C:"TLS 1.2"};

},{}],478:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"1":"0 1 3 4 7 9 w x y z GB FB AB CB DB","2":"2 6 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t XB WB","66":"u","516":"v"},D:{"1":"0 1 3 4 7 9 z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w","66":"x y"},E:{"2":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"1":"0 1","2":"5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j ZB aB bB cB p eB","1090":"k l m n o L q r s t u v w x y z"},G:{"1":"sB","2":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB"},H:{"2":"tB"},I:{"2":"BB F uB vB wB xB EB yB zB","16":"4"},J:{"2":"D","16":"A"},K:{"2":"5 8 A B C p","16":"L"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A","16":"B"},O:{"16":"0B"},P:{"1":"2B 3B 4B","16":"F 1B"},Q:{"16":"5B"},R:{"16":"6B"}},B:6,C:"TLS 1.3"};

},{}],479:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d","257":"J M H I"},C:{"2":"0 1 2 3 6 7 9 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB XB WB","16":"4 DB"},D:{"2":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h","16":"0 i j k l m n o L q r s t u v w x y z","194":"1 3 4 7 9 GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"2":"F N K D G PB HB RB SB TB","16":"5 E A B C UB VB p YB"},F:{"2":"5 8 E B C J M H I O P Q R S T U V W X Y ZB aB bB cB p eB","16":"0 1 6 Z a b c e f g h i j k l m n o L q r s t u v w x y z"},G:{"2":"G HB fB EB hB JB jB kB","16":"lB mB nB oB pB qB rB sB"},H:{"16":"tB"},I:{"2":"BB F uB vB wB xB EB yB zB","16":"4"},J:{"2":"D A"},K:{"2":"5 8 A B C p","16":"L"},L:{"16":"IB"},M:{"16":"3"},N:{"2":"A","16":"B"},O:{"16":"0B"},P:{"16":"F 1B 2B 3B 4B"},Q:{"16":"5B"},R:{"16":"6B"}},B:6,C:"Token Binding"};

},{}],480:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E gB","8":"A B"},B:{"578":"2 C d J M H I"},C:{"1":"0 1 3 4 7 9 I O P Q R S T v w x y z GB FB AB CB DB","2":"dB BB XB WB","4":"2 F N K D G E A B C d J M H","194":"6 U V W X Y Z a b c e f g h i j k l m n o L q r s t u"},D:{"1":"0 1 3 4 6 7 9 R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 F N K D G E A B C d J M H I O P Q"},E:{"2":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"1":"0 1 6 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"5 8 E B C ZB aB bB cB p eB"},G:{"1":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"1":"4 BB F uB vB wB xB EB yB zB"},J:{"1":"D A"},K:{"1":"5 8 B C L p","2":"A"},L:{"1":"IB"},M:{"1":"3"},N:{"8":"A","260":"B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:2,C:"Touch events"};

},{}],481:[function(require,module,exports){
module.exports={A:{A:{"2":"gB","8":"K D G","129":"A B","161":"E"},B:{"1":"H I","129":"2 C d J M"},C:{"1":"0 1 3 4 6 7 9 M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"dB BB","33":"2 F N K D G E A B C d J XB WB"},D:{"1":"0 1 3 4 7 9 f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","33":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e"},E:{"1":"5 E A B C UB VB p YB","33":"F N K D G PB HB RB SB TB"},F:{"1":"0 1 5 6 S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"E ZB aB","33":"8 B C J M H I O P Q R bB cB p eB"},G:{"1":"lB mB nB oB pB qB rB sB","33":"G HB fB EB hB JB jB kB"},H:{"2":"tB"},I:{"1":"4","33":"BB F uB vB wB xB EB yB zB"},J:{"33":"D A"},K:{"1":"5 8 B C L p","2":"A"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:5,C:"CSS3 2D Transforms"};

},{}],482:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E gB","132":"A B"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 3 4 6 7 9 M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"dB BB F N K D G E XB WB","33":"2 A B C d J"},D:{"1":"0 1 3 4 7 9 f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"F N K D G E A B","33":"2 6 C d J M H I O P Q R S T U V W X Y Z a b c e"},E:{"2":"PB HB","33":"F N K D G RB SB TB","257":"5 E A B C UB VB p YB"},F:{"1":"0 1 6 S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"5 8 E B C ZB aB bB cB p eB","33":"J M H I O P Q R"},G:{"33":"G HB fB EB hB JB jB kB","257":"lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"1":"4","2":"uB vB wB","33":"BB F xB EB yB zB"},J:{"33":"D A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"132":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:5,C:"CSS3 3D Transforms"};

},{}],483:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G gB","132":"E A B"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB","2":"dB BB"},D:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"1":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"1":"0 1 5 6 8 B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z aB bB cB p eB","2":"E ZB"},G:{"1":"G EB hB JB jB kB lB mB nB oB pB qB rB sB","2":"HB fB"},H:{"2":"tB"},I:{"1":"4 BB F vB wB xB EB yB zB","2":"uB"},J:{"1":"D A"},K:{"1":"5 8 A B C L p"},L:{"1":"IB"},M:{"1":"3"},N:{"132":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:6,C:"TTF/OTF - TrueType and OpenType font support"};

},{}],484:[function(require,module,exports){
module.exports={A:{A:{"1":"B","2":"K D G E gB","132":"A"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"dB BB XB WB"},D:{"1":"0 1 2 3 4 6 7 9 D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"F N K"},E:{"1":"5 K D G E A B C SB TB UB VB p YB","2":"F N PB HB","260":"RB"},F:{"1":"0 1 5 6 C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z eB","2":"8 E B ZB aB bB cB p"},G:{"1":"G hB JB jB kB lB mB nB oB pB qB rB sB","2":"HB fB","260":"EB"},H:{"1":"tB"},I:{"1":"4 F xB EB yB zB","2":"BB uB vB wB"},J:{"1":"A","2":"D"},K:{"1":"5 C L","2":"8 A B p"},L:{"1":"IB"},M:{"1":"3"},N:{"132":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:6,C:"Typed Arrays"};

},{}],485:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"2":"2 6 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L XB WB","322":"0 1 3 4 7 9 q r s t u v w x y z GB FB AB CB DB"},D:{"1":"0 1 3 4 7 9 k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g","130":"h i j"},E:{"2":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"1":"0 1 j l m n o L q r s t u v w x y z","2":"5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i k ZB aB bB cB p eB"},G:{"2":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"2":"4 BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"2":"5 8 A B C L p"},L:{"2":"IB"},M:{"2":"3"},N:{"2":"A B"},O:{"2":"0B"},P:{"2":"F 1B 2B 3B 4B"},Q:{"2":"5B"},R:{"2":"6B"}},B:6,C:"FIDO U2F API"};

},{}],486:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"2":"0 1 2 3 4 6 7 9 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB"},D:{"1":"0 1 3 4 7 9 s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r"},E:{"1":"5 B C p YB","2":"F N K D G E A PB HB RB SB TB UB VB"},F:{"1":"0 1 f g h i j k l m n o L q r s t u v w x y z","2":"5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e ZB aB bB cB p eB"},G:{"1":"qB rB sB","2":"G HB fB EB hB JB jB kB lB mB nB oB","16":"pB"},H:{"2":"tB"},I:{"1":"4","2":"BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"2":"3"},N:{"2":"A B"},O:{"1":"0B"},P:{"1":"1B 2B 3B 4B","2":"F"},Q:{"2":"5B"},R:{"2":"6B"}},B:1,C:"unhandledrejection/rejectionhandled events"};

},{}],487:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"1":"H I","2":"2 C d J M"},C:{"1":"0 1 3 4 7 9 l m n o L q r s t u v w x y z GB FB AB CB DB","2":"2 6 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k XB WB"},D:{"1":"0 1 3 4 7 9 m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l"},E:{"1":"5 B C VB p YB","2":"F N K D G E A PB HB RB SB TB UB"},F:{"1":"0 1 6 Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"5 8 E B C J M H I O P Q R S T U V W X Y ZB aB bB cB p eB"},G:{"1":"oB pB qB rB sB","2":"G HB fB EB hB JB jB kB lB mB nB"},H:{"2":"tB"},I:{"1":"4","2":"BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"2":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:4,C:"Upgrade Insecure Requests"};

},{}],488:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 3 4 6 7 9 V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"2 dB BB F N K D G E A B C d J M H I O P Q R S T U XB WB"},D:{"1":"0 1 3 4 6 7 9 b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 F N K D G E A B C d J M H I O P Q R","130":"S T U V W X Y Z a"},E:{"1":"5 G E A B C TB UB VB p YB","2":"F N K PB HB RB SB","130":"D"},F:{"1":"0 1 6 O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"5 8 E B C ZB aB bB cB p eB","130":"J M H I"},G:{"1":"G kB lB mB nB oB pB qB rB sB","2":"HB fB EB hB JB","130":"jB"},H:{"2":"tB"},I:{"1":"4 zB","2":"BB F uB vB wB xB EB","130":"yB"},J:{"2":"D","130":"A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:1,C:"URL API"};

},{}],489:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"1":"H I","2":"2 C d J M"},C:{"1":"0 1 3 4 7 9 n o L q r s t u v w x y z GB FB AB CB DB","2":"2 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X XB WB","132":"6 Y Z a b c e f g h i j k l m"},D:{"1":"0 1 3 4 7 9 s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r"},E:{"1":"5 B C VB p YB","2":"F N K D G E A PB HB RB SB TB UB"},F:{"1":"0 1 f g h i j k l m n o L q r s t u v w x y z","2":"5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e ZB aB bB cB p eB"},G:{"1":"oB pB qB rB sB","2":"G HB fB EB hB JB jB kB lB mB nB"},H:{"2":"tB"},I:{"1":"4","2":"BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"1":"0B"},P:{"1":"1B 2B 3B 4B","2":"F"},Q:{"2":"5B"},R:{"2":"6B"}},B:1,C:"URLSearchParams"};

},{}],490:[function(require,module,exports){
module.exports={A:{A:{"1":"A B","2":"K D G E gB"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"dB BB XB WB"},D:{"1":"0 1 2 3 4 6 7 9 d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"F N K D G E A B C"},E:{"1":"5 K D G E A B C SB TB UB VB p YB","2":"F PB HB","132":"N RB"},F:{"1":"0 1 5 6 C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z eB","2":"8 E B ZB aB bB cB p"},G:{"1":"G hB JB jB kB lB mB nB oB pB qB rB sB","2":"HB fB EB"},H:{"1":"tB"},I:{"1":"4 BB F xB EB yB zB","2":"uB vB wB"},J:{"1":"D A"},K:{"1":"5 8 C L","2":"A B p"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:6,C:"ECMAScript 5 Strict Mode"};

},{}],491:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E gB","33":"A B"},B:{"33":"2 C d J M H I"},C:{"33":"0 1 2 3 4 6 7 9 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB"},D:{"1":"0 1 3 4 7 9 x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","33":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w"},E:{"33":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"1":"0 1 k l m n o L q r s t u v w x y z","2":"5 8 E B C ZB aB bB cB p eB","33":"6 J M H I O P Q R S T U V W X Y Z a b c e f g h i j"},G:{"33":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"1":"4","33":"BB F uB vB wB xB EB yB zB"},J:{"33":"D A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"33":"3"},N:{"33":"A B"},O:{"2":"0B"},P:{"33":"F 1B 2B 3B 4B"},Q:{"33":"5B"},R:{"2":"6B"}},B:5,C:"CSS user-select: none"};

},{}],492:[function(require,module,exports){
module.exports={A:{A:{"1":"A B","2":"K D G E gB"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 3 4 7 9 h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"2 6 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g XB WB"},D:{"1":"0 1 3 4 6 7 9 U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 F N K D G E A B C d J M H I O P Q R S T"},E:{"1":"5 B C p YB","2":"F N K D G E A PB HB RB SB TB UB VB"},F:{"1":"0 1 6 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"5 8 E B C ZB aB bB cB p eB"},G:{"1":"pB qB rB sB","2":"G HB fB EB hB JB jB kB lB mB nB oB"},H:{"2":"tB"},I:{"1":"4 yB zB","2":"BB F uB vB wB xB EB"},J:{"2":"D A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:2,C:"User Timing API"};

},{}],493:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"1":"H I","2":"2 C d J M"},C:{"2":"2 6 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v XB WB","4609":"3 4 9 AB CB DB","4674":"FB","5698":"7","7490":"0 w x y z","7746":"1 GB"},D:{"1":"4 QB iB KB IB LB MB NB OB","2":"0 1 2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","4097":"DB","4290":"7 GB FB","6148":"3 9 AB CB"},E:{"2":"F N K D G E A PB HB RB SB TB UB VB","4609":"5 B C p YB"},F:{"1":"0 1 x y z","2":"5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r ZB aB bB cB p eB","4097":"w","6148":"s t u v"},G:{"2":"G HB fB EB hB JB jB kB lB mB nB oB","4097":"pB qB rB sB"},H:{"2":"tB"},I:{"1":"4","2":"BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"2":"5 8 A B C L p"},L:{"1":"IB"},M:{"4097":"3"},N:{"2":"A B"},O:{"2":"0B"},P:{"2":"F 1B 2B 3B","4097":"4B"},Q:{"2":"5B"},R:{"2":"6B"}},B:5,C:"Variable fonts"};

},{}],494:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"1":"0 1 3 4 6 7 9 M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"dB BB F N K D G E A XB WB","33":"2 B C d J"},D:{"1":"0 1 3 4 6 7 9 Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 F N K D G E A B C d J M H I O P Q R S T U V W X Y"},E:{"2":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"1":"0 1 6 H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"5 8 E B C J M ZB aB bB cB p eB"},G:{"2":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"1":"4 yB zB","2":"BB F uB vB wB xB EB"},J:{"1":"A","2":"D"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:2,C:"Vibration API"};

},{}],495:[function(require,module,exports){
module.exports={A:{A:{"1":"E A B","2":"K D G gB"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 3 4 6 7 9 P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"dB BB","260":"2 F N K D G E A B C d J M H I O XB WB"},D:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"1":"F N K D G E A RB SB TB UB VB","2":"PB HB","513":"5 B C p YB"},F:{"1":"0 1 5 6 8 B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z bB cB p eB","2":"E ZB aB"},G:{"1":"G HB fB EB hB JB jB kB lB mB nB oB","513":"pB qB rB sB"},H:{"2":"tB"},I:{"1":"4 BB F wB xB EB yB zB","132":"uB vB"},J:{"1":"D A"},K:{"1":"5 8 B C L p","2":"A"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:1,C:"Video element"};

},{}],496:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"1":"2 C d J M H I"},C:{"2":"2 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b XB WB","194":"0 1 3 4 6 7 9 c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB"},D:{"2":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n","322":"0 1 3 4 7 9 o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"1":"5 D G E A B C SB TB UB VB p YB","2":"F N K PB HB RB"},F:{"2":"5 8 E B C J M H I O P Q R S T U V W X Y Z a ZB aB bB cB p eB","322":"0 1 6 b c e f g h i j k l m n o L q r s t u v w x y z"},G:{"1":"G jB kB lB mB nB oB pB qB rB sB","2":"HB fB EB hB JB"},H:{"2":"tB"},I:{"2":"4 BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"2":"5 8 A B C p","322":"L"},L:{"322":"IB"},M:{"2":"3"},N:{"2":"A B"},O:{"2":"0B"},P:{"2":"F 1B 2B 3B 4B"},Q:{"2":"5B"},R:{"2":"6B"}},B:1,C:"Video Tracks"};

},{}],497:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G gB","132":"E","260":"A B"},B:{"1":"M H I","260":"2 C d J"},C:{"1":"0 1 3 4 6 7 9 O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"2 dB BB F N K D G E A B C d J M H I XB WB"},D:{"1":"0 1 3 4 6 7 9 V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 F N K D G E A B C d J M H I O","260":"P Q R S T U"},E:{"1":"5 D G E A B C SB TB UB VB p YB","2":"F N PB HB RB","260":"K"},F:{"1":"0 1 6 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"5 8 E B C ZB aB bB cB p eB"},G:{"1":"G kB lB mB nB oB pB qB rB sB","2":"HB fB EB hB","516":"jB","772":"JB"},H:{"2":"tB"},I:{"1":"4 yB zB","2":"BB F uB vB wB xB EB"},J:{"1":"A","2":"D"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"260":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:4,C:"Viewport units: vw, vh, vmin, vmax"};

},{}],498:[function(require,module,exports){
module.exports={A:{A:{"2":"K D gB","4":"G E A B"},B:{"4":"2 C d J M H I"},C:{"4":"0 1 2 3 4 6 7 9 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB"},D:{"4":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"2":"PB HB","4":"5 F N K D G E A B C RB SB TB UB VB p YB"},F:{"2":"E","4":"0 1 5 6 8 B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z ZB aB bB cB p eB"},G:{"4":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"4":"tB"},I:{"2":"BB F uB vB wB xB EB","4":"4 yB zB"},J:{"2":"D A"},K:{"4":"5 8 A B C L p"},L:{"4":"IB"},M:{"4":"3"},N:{"4":"A B"},O:{"2":"0B"},P:{"4":"F 1B 2B 3B 4B"},Q:{"4":"5B"},R:{"4":"6B"}},B:2,C:"WAI-ARIA Accessibility features"};

},{}],499:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"1":"M H I","2":"2 C d","578":"J"},C:{"1":"0 1 3 4 7 9 w x y z GB FB AB CB DB","2":"2 6 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L XB WB","194":"q r s t u","1025":"v"},D:{"1":"0 1 3 4 7 9 GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t","322":"u v w x y z"},E:{"1":"5 B C p YB","2":"F N K D G E A PB HB RB SB TB UB VB"},F:{"1":"0 1 n o L q r s t u v w x y z","2":"5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g ZB aB bB cB p eB","322":"h i j k l m"},G:{"1":"pB qB rB sB","2":"G HB fB EB hB JB jB kB lB mB nB oB"},H:{"2":"tB"},I:{"1":"4","2":"BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"2":"0B"},P:{"1":"3B 4B","2":"F 1B 2B"},Q:{"322":"5B"},R:{"2":"6B"}},B:6,C:"WebAssembly"};

},{}],500:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB","2":"dB BB"},D:{"1":"0 1 2 3 4 6 7 9 G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"F N K D"},E:{"1":"5 F N K D G E A B C RB SB TB UB VB p YB","2":"PB HB"},F:{"1":"0 1 5 6 8 B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z bB cB p eB","2":"E ZB aB"},G:{"1":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"1":"4 BB F wB xB EB yB zB","16":"uB vB"},J:{"1":"D A"},K:{"1":"5 8 B C L p","16":"A"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:6,C:"Wav audio format"};

},{}],501:[function(require,module,exports){
module.exports={A:{A:{"1":"K D gB","2":"G E A B"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 2 3 4 6 7 9 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB"},D:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"1":"5 F N K D G E A B C HB RB SB TB UB VB p YB","16":"PB"},F:{"1":"0 1 5 6 8 B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z ZB aB bB cB p eB","16":"E"},G:{"1":"G hB JB jB kB lB mB nB oB pB qB rB sB","16":"HB fB EB"},H:{"1":"tB"},I:{"1":"4 BB F wB xB EB yB zB","16":"uB vB"},J:{"1":"D A"},K:{"1":"5 8 B C L p","2":"A"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:1,C:"wbr (word break opportunity) element"};

},{}],502:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"2":"2 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b XB WB","260":"3 4 7 9 GB FB AB CB DB","516":"0 1 q r s t u v w x y z","580":"6 c e f g h i j k l m n o L"},D:{"2":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e","132":"f g h","260":"0 1 3 4 7 9 i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"1":"YB","2":"F N K D G E A PB HB RB SB TB UB VB","4":"5","1090":"B C p"},F:{"2":"5 8 E B C J M H I O P Q R ZB aB bB cB p eB","132":"S T U","260":"0 1 6 V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z"},G:{"2":"G HB fB EB hB JB jB kB lB mB nB oB","4":"sB","1090":"pB qB rB"},H:{"2":"tB"},I:{"2":"BB F uB vB wB xB EB yB zB","260":"4"},J:{"2":"D A"},K:{"2":"5 8 A B C p","260":"L"},L:{"260":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"260":"0B"},P:{"260":"F 1B 2B 3B 4B"},Q:{"260":"5B"},R:{"260":"6B"}},B:5,C:"Web Animations API"};

},{}],503:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M","514":"H I"},C:{"2":"0 1 2 3 4 6 7 9 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB"},D:{"2":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h","132":"0 1 3 7 9 i j k l m n o L q r s t u v w x y z GB FB AB CB DB","260":"4 QB iB KB IB LB MB NB OB"},E:{"2":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"2":"0 1 5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z ZB aB bB cB p eB"},G:{"2":"G HB fB EB hB JB jB kB lB mB nB oB pB","132":"qB rB sB"},H:{"2":"tB"},I:{"2":"4 BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"2":"5 8 A B C p","132":"L"},L:{"1":"IB"},M:{"132":"3"},N:{"2":"A B"},O:{"132":"0B"},P:{"132":"F 1B 2B 3B 4B"},Q:{"132":"5B"},R:{"132":"6B"}},B:5,C:"Web App Manifest"};

},{}],504:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"2":"0 1 2 3 4 6 7 9 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB"},D:{"2":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n","194":"o L q r s t u v","706":"w x y","1025":"0 1 3 4 7 9 z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"2":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"2":"5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e ZB aB bB cB p eB","450":"f g h i","706":"j k l","1025":"0 1 m n o L q r s t u v w x y z"},G:{"2":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"2":"BB F uB vB wB xB EB yB zB","1025":"4"},J:{"2":"D A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1025":"IB"},M:{"2":"3"},N:{"2":"A B"},O:{"2":"0B"},P:{"1":"2B 3B 4B","2":"F 1B"},Q:{"706":"5B"},R:{"2":"6B"}},B:7,C:"Web Bluetooth"};

},{}],505:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"2":"0 1 2 3 4 6 7 9 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB"},D:{"2":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","258":"I O P Q R S T"},E:{"1":"5 YB","2":"F N K D G E A B C PB HB RB TB UB VB p","16":"SB"},F:{"2":"0 1 5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z ZB aB bB cB p eB"},G:{"1":"sB","2":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB"},H:{"2":"tB"},I:{"2":"BB F uB vB wB xB EB yB","514":"4 zB"},J:{"2":"D A"},K:{"2":"5 8 A B C L p"},L:{"1":"IB"},M:{"514":"3"},N:{"2":"A B"},O:{"2":"0B"},P:{"2":"F","514":"1B 2B 3B 4B"},Q:{"2":"5B"},R:{"16":"6B"}},B:7,C:"Web Share API"};

},{}],506:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"1":"I","2":"C","226":"2 d J M H"},C:{"1":"3 4 7 9 FB AB CB DB","2":"0 1 2 6 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB XB WB"},D:{"1":"4 QB iB KB IB LB MB NB OB","2":"0 1 2 3 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB"},E:{"2":"F N K D G E A B C PB HB RB SB TB UB VB p","322":"5 YB"},F:{"1":"0 1 x y z","2":"5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w ZB aB bB cB p eB"},G:{"2":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"1":"4","2":"BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"2":"5 8 A B C L p"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"2":"0B"},P:{"2":"F 1B 2B 3B 4B"},Q:{"2":"5B"},R:{"2":"6B"}},B:2,C:"Web Authentication API"};

},{}],507:[function(require,module,exports){
module.exports={A:{A:{"2":"gB","8":"K D G E A","129":"B"},B:{"129":"2 C d J M H I"},C:{"1":"0 1 3 4 6 7 9 T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"dB BB XB WB","129":"2 F N K D G E A B C d J M H I O P Q R S"},D:{"1":"0 1 3 4 6 7 9 c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"F N K D","129":"2 G E A B C d J M H I O P Q R S T U V W X Y Z a b"},E:{"1":"5 G E A B C UB VB p YB","2":"F N PB HB","129":"K D RB SB TB"},F:{"1":"0 1 6 O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"8 E B ZB aB bB cB p eB","129":"5 C J M H I"},G:{"1":"G kB lB mB nB oB pB qB rB sB","2":"HB fB EB hB JB jB"},H:{"2":"tB"},I:{"1":"4","2":"BB F uB vB wB xB EB yB zB"},J:{"1":"A","2":"D"},K:{"1":"5 C L","2":"8 A B p"},L:{"1":"IB"},M:{"1":"3"},N:{"8":"A","129":"B"},O:{"129":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:6,C:"WebGL - 3D Canvas graphics"};

},{}],508:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"1":"0 1 3 4 7 9 u v w x y z GB FB AB CB DB","2":"2 dB BB F N K D G E A B C d J M H I O P Q R S T XB WB","194":"l m n","450":"6 U V W X Y Z a b c e f g h i j k","2242":"o L q r s t"},D:{"1":"0 1 3 4 7 9 z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l","578":"m n o L q r s t u v w x y"},E:{"2":"F N K D G E A PB HB RB SB TB UB","1090":"5 B C VB p YB"},F:{"1":"0 1 m n o L q r s t u v w x y z","2":"5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l ZB aB bB cB p eB"},G:{"2":"G HB fB EB hB JB jB kB lB mB nB oB pB qB","1090":"rB sB"},H:{"2":"tB"},I:{"2":"4 BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"2":"0B"},P:{"1":"3B 4B","2":"F 1B 2B"},Q:{"578":"5B"},R:{"2":"6B"}},B:6,C:"WebGL 2.0"};

},{}],509:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G gB","8":"E A B"},B:{"4":"d J M H I","8":"2 C"},C:{"1":"0 1 3 4 6 7 9 X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"dB BB XB WB","4":"2 F N K D G E A B C d J M H I O P Q R S T U V W"},D:{"1":"0 1 3 4 6 7 9 U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"F N","4":"2 K D G E A B C d J M H I O P Q R S T"},E:{"2":"PB","8":"5 F N K D G E A B C HB RB SB TB UB VB p YB"},F:{"1":"0 1 6 M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"E ZB aB bB","4":"5 8 B C J cB p eB"},G:{"2":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"1":"4","2":"uB vB","4":"BB F wB xB EB yB zB"},J:{"2":"D A"},K:{"2":"5 8 A B C p","4":"L"},L:{"1":"IB"},M:{"1":"3"},N:{"8":"A B"},O:{"1":"0B"},P:{"1":"1B 2B 3B 4B","4":"F"},Q:{"1":"5B"},R:{"1":"6B"}},B:6,C:"WebM video format"};

},{}],510:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"1":"I","2":"2 C d J M H"},C:{"1":"4 CB DB","2":"dB BB XB WB","8":"0 1 2 3 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB"},D:{"1":"0 1 3 4 6 7 9 b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"F N","8":"K D G","132":"2 E A B C d J M H I O P Q R","260":"S T U V W X Y Z a"},E:{"2":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"1":"0 1 6 O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"E ZB aB bB","8":"B cB","132":"8 p eB","260":"5 C J M H I"},G:{"2":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"1":"tB"},I:{"1":"4 EB yB zB","2":"BB uB vB wB","132":"F xB"},J:{"2":"D A"},K:{"1":"5 8 C L p","2":"A","132":"B"},L:{"1":"IB"},M:{"8":"3"},N:{"2":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:7,C:"WebP image format"};

},{}],511:[function(require,module,exports){
module.exports={A:{A:{"1":"A B","2":"K D G E gB"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 2 3 4 6 7 9 B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"dB BB XB WB","132":"F N","292":"K D G E A"},D:{"1":"0 1 3 4 6 7 9 M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","132":"2 F N K D G E A B C d","260":"J"},E:{"1":"5 D G E A B C TB UB VB p YB","2":"F PB HB","132":"N RB","260":"K SB"},F:{"1":"0 1 5 6 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"E ZB aB bB cB","132":"8 B C p eB"},G:{"1":"G JB jB kB lB mB nB oB pB qB rB sB","2":"HB fB","132":"EB hB"},H:{"2":"tB"},I:{"1":"4 yB zB","2":"BB F uB vB wB xB EB"},J:{"1":"A","129":"D"},K:{"1":"5 L","2":"A","132":"8 B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:1,C:"Web Sockets"};

},{}],512:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"2":"0 1 2 3 4 6 7 9 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB"},D:{"1":"3 4 9 FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w","66":"0 1 7 x y z GB"},E:{"2":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"1":"0 1 r s t u v w x y z","2":"5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j ZB aB bB cB p eB","66":"k l m n o L q"},G:{"2":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"2":"4 BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"2":"5 8 A B C L p"},L:{"1":"IB"},M:{"2":"3"},N:{"2":"A B"},O:{"2":"0B"},P:{"2":"F 1B 2B 3B 4B"},Q:{"2":"5B"},R:{"2":"6B"}},B:7,C:"WebUSB"};

},{}],513:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d","513":"J M H I"},C:{"2":"2 6 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w XB WB","129":"0 1 3 4 7 9 y z GB FB AB CB DB","194":"x"},D:{"2":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","322":"0 1 3 4 7 9 GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"2":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"2":"0 1 5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z ZB aB bB cB p eB"},G:{"2":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"2":"tB"},I:{"2":"4 BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"2":"5 8 A B C L p"},L:{"2049":"IB"},M:{"2":"3"},N:{"2":"A B"},O:{"2":"0B"},P:{"1025":"F","1028":"1B 2B 3B 4B"},Q:{"2":"5B"},R:{"322":"6B"}},B:7,C:"WebXR API"};

},{}],514:[function(require,module,exports){
module.exports={A:{A:{"1":"A B","2":"K D G E gB"},B:{"1":"2 C d J M H I"},C:{"2":"2 dB BB F N K D G E A B C d J M H I O P Q R S XB WB","66":"T U V W X Y Z","129":"0 1 3 4 6 7 9 a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB"},D:{"1":"0 1 3 4 6 7 9 I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 F N K D G E A B C d J M H"},E:{"1":"5 K D G E A B C SB TB UB VB p YB","2":"F N PB HB RB"},F:{"1":"0 1 6 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"5 8 E B C ZB aB bB cB p eB"},G:{"1":"G jB kB lB mB nB oB pB qB rB sB","2":"HB fB EB hB JB"},H:{"2":"tB"},I:{"1":"4 yB zB","2":"BB F uB vB wB xB EB"},J:{"1":"A","2":"D"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"B","2":"A"},O:{"2":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:5,C:"WebVTT - Web Video Text Tracks"};

},{}],515:[function(require,module,exports){
module.exports={A:{A:{"1":"A B","2":"gB","8":"K D G E"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB","8":"dB BB"},D:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"1":"5 F N K D G E A B C RB SB TB UB VB p YB","8":"PB HB"},F:{"1":"0 1 5 6 8 B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z cB p eB","2":"E ZB","8":"aB bB"},G:{"1":"G hB JB jB kB lB mB nB oB pB qB rB sB","2":"HB fB EB"},H:{"2":"tB"},I:{"1":"4 uB yB zB","2":"BB F vB wB xB EB"},J:{"1":"D A"},K:{"1":"5 8 B C L p","8":"A"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:1,C:"Web Workers"};

},{}],516:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"2":"2 C d J M H I"},C:{"1":"0 1 3 4 7 9 f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"2 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X XB WB","194":"6 Y Z a b c e"},D:{"1":"0 1 3 4 7 9 f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e"},E:{"1":"5 A B C UB VB p YB","2":"F N K D G E PB HB RB SB TB"},F:{"1":"0 1 6 T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"5 8 E B C J M H I O P Q R S ZB aB bB cB p eB"},G:{"1":"mB nB oB pB qB rB sB","2":"G HB fB EB hB JB jB kB lB"},H:{"2":"tB"},I:{"1":"4","2":"BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:5,C:"CSS will-change property"};

},{}],517:[function(require,module,exports){
module.exports={A:{A:{"1":"E A B","2":"K D G gB"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB WB","2":"dB BB XB"},D:{"1":"0 1 2 3 4 6 7 9 N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"F"},E:{"1":"5 K D G E A B C RB SB TB UB VB p YB","2":"F N PB HB"},F:{"1":"0 1 5 6 8 C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z p eB","2":"E B ZB aB bB cB"},G:{"1":"G hB JB jB kB lB mB nB oB pB qB rB sB","2":"HB fB EB"},H:{"2":"tB"},I:{"1":"4 yB zB","2":"BB uB vB wB xB EB","130":"F"},J:{"1":"D A"},K:{"1":"5 8 B C L p","2":"A"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:2,C:"WOFF - Web Open Font Format"};

},{}],518:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E A B gB"},B:{"1":"d J M H I","2":"2 C"},C:{"1":"0 1 3 4 7 9 i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"2 6 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h XB WB"},D:{"1":"0 1 3 4 7 9 f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","2":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e"},E:{"1":"5 C YB","2":"F N K D G E PB HB RB SB TB UB","132":"A B VB p"},F:{"1":"0 1 6 S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"5 8 E B C J M H I O P Q R ZB aB bB cB p eB"},G:{"1":"nB oB pB qB rB sB","2":"G HB fB EB hB JB jB kB lB mB"},H:{"2":"tB"},I:{"1":"4","2":"BB F uB vB wB xB EB yB zB"},J:{"2":"D A"},K:{"1":"L","2":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"2":"A B"},O:{"2":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:4,C:"WOFF 2.0 - Web Open Font Format"};

},{}],519:[function(require,module,exports){
module.exports={A:{A:{"1":"K D G E A B gB"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 3 4 6 7 9 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"2 dB BB F N K D G E A B C d XB WB"},D:{"1":"0 1 3 4 7 9 n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","4":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m"},E:{"1":"5 E A B C UB VB p YB","4":"F N K D G PB HB RB SB TB"},F:{"1":"0 1 6 a b c e f g h i j k l m n o L q r s t u v w x y z","2":"5 8 E B C ZB aB bB cB p eB","4":"J M H I O P Q R S T U V W X Y Z"},G:{"1":"lB mB nB oB pB qB rB sB","4":"G HB fB EB hB JB jB kB"},H:{"2":"tB"},I:{"1":"4","4":"BB F uB vB wB xB EB yB zB"},J:{"4":"D A"},K:{"2":"5 8 A B C p","4":"L"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"A B"},O:{"4":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"4":"5B"},R:{"1":"6B"}},B:5,C:"CSS3 word-break"};

},{}],520:[function(require,module,exports){
module.exports={A:{A:{"4":"K D G E A B gB"},B:{"1":"I","4":"2 C d J M H"},C:{"1":"0 1 3 4 7 9 s t u v w x y z GB FB AB CB DB","2":"dB BB","4":"2 6 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r XB WB"},D:{"1":"0 1 3 4 6 7 9 S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","4":"2 F N K D G E A B C d J M H I O P Q R"},E:{"1":"5 D G E A B C SB TB UB VB p YB","4":"F N K PB HB RB"},F:{"1":"0 1 5 6 J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"E ZB aB","4":"8 B C bB cB p eB"},G:{"1":"G jB kB lB mB nB oB pB qB rB sB","4":"HB fB EB hB JB"},H:{"4":"tB"},I:{"1":"4 yB zB","4":"BB F uB vB wB xB EB"},J:{"1":"A","4":"D"},K:{"1":"L","4":"5 8 A B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"4":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:5,C:"CSS3 Overflow-wrap"};

},{}],521:[function(require,module,exports){
module.exports={A:{A:{"2":"K D gB","132":"G E","260":"A B"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 2 3 4 6 7 9 BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB","2":"dB"},D:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"1":"5 F N K D G E A B C RB SB TB UB VB p YB","2":"PB HB"},F:{"1":"0 1 5 6 8 B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z ZB aB bB cB p eB","2":"E"},G:{"1":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"1":"tB"},I:{"1":"4 BB F uB vB wB xB EB yB zB"},J:{"1":"D A"},K:{"1":"5 8 A B C L p"},L:{"1":"IB"},M:{"1":"3"},N:{"4":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:1,C:"Cross-document messaging"};

},{}],522:[function(require,module,exports){
module.exports={A:{A:{"1":"G E A B","2":"K D gB"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 3 4 6 7 9 I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","4":"2 F N K D G E A B C d J M H","16":"dB BB XB WB"},D:{"4":"0 1 3 4 6 7 9 V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","16":"2 F N K D G E A B C d J M H I O P Q R S T U"},E:{"4":"5 K D G E A B C RB SB TB UB VB p YB","16":"F N PB HB"},F:{"4":"0 1 5 6 C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z eB","16":"8 E B ZB aB bB cB p"},G:{"4":"G jB kB lB mB nB oB pB qB rB sB","16":"HB fB EB hB JB"},H:{"2":"tB"},I:{"4":"4 F xB EB yB zB","16":"BB uB vB wB"},J:{"4":"D A"},K:{"4":"5 L","16":"8 A B C p"},L:{"4":"IB"},M:{"1":"3"},N:{"1":"A B"},O:{"4":"0B"},P:{"4":"F 1B 2B 3B 4B"},Q:{"4":"5B"},R:{"4":"6B"}},B:6,C:"X-Frame-Options HTTP header"};

},{}],523:[function(require,module,exports){
module.exports={A:{A:{"2":"K D G E gB","132":"A B"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 2 3 4 6 7 9 C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","2":"dB BB","260":"A B","388":"K D G E","900":"F N XB WB"},D:{"1":"0 1 3 4 6 7 9 a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","16":"F N K","132":"Y Z","388":"2 D G E A B C d J M H I O P Q R S T U V W X"},E:{"1":"5 G E A B C TB UB VB p YB","2":"F PB HB","132":"D SB","388":"N K RB"},F:{"1":"0 1 5 6 C I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","2":"8 E B ZB aB bB cB p eB","132":"J M H"},G:{"1":"G kB lB mB nB oB pB qB rB sB","2":"HB fB EB","132":"jB","388":"hB JB"},H:{"2":"tB"},I:{"1":"4 zB","2":"uB vB wB","388":"yB","900":"BB F xB EB"},J:{"132":"A","388":"D"},K:{"1":"5 C L","2":"8 A B p"},L:{"1":"IB"},M:{"1":"3"},N:{"132":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:1,C:"XMLHttpRequest advanced features"};

},{}],524:[function(require,module,exports){
module.exports={A:{A:{"1":"E A B","2":"K D G gB"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 2 3 4 6 7 9 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB"},D:{"1":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"1":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"1":"0 1 5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z ZB aB bB cB p eB"},G:{"1":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"1":"tB"},I:{"1":"4 BB F uB vB wB xB EB yB zB"},J:{"1":"D A"},K:{"1":"5 8 A B C L p"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"2":"6B"}},B:1,C:"XHTML served as application/xhtml+xml"};

},{}],525:[function(require,module,exports){
module.exports={A:{A:{"2":"E A B gB","4":"K D G"},B:{"2":"2 C d J M H I"},C:{"8":"0 1 2 3 4 6 7 9 dB BB F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB XB WB"},D:{"8":"0 1 2 3 4 6 7 9 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB"},E:{"8":"5 F N K D G E A B C PB HB RB SB TB UB VB p YB"},F:{"8":"0 1 5 6 8 E B C J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z ZB aB bB cB p eB"},G:{"8":"G HB fB EB hB JB jB kB lB mB nB oB pB qB rB sB"},H:{"8":"tB"},I:{"8":"4 BB F uB vB wB xB EB yB zB"},J:{"8":"D A"},K:{"8":"5 8 A B C L p"},L:{"8":"IB"},M:{"8":"3"},N:{"2":"A B"},O:{"8":"0B"},P:{"8":"F 1B 2B 3B 4B"},Q:{"8":"5B"},R:{"8":"6B"}},B:7,C:"XHTML+SMIL animation"};

},{}],526:[function(require,module,exports){
module.exports={A:{A:{"1":"A B","260":"K D G E gB"},B:{"1":"2 C d J M H I"},C:{"1":"0 1 2 3 4 6 7 9 C d J M H I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB","132":"B","260":"dB BB F N K D XB WB","516":"G E A"},D:{"1":"0 1 3 4 6 7 9 a b c e f g h i j k l m n o L q r s t u v w x y z GB FB AB CB DB QB iB KB IB LB MB NB OB","132":"2 F N K D G E A B C d J M H I O P Q R S T U V W X Y Z"},E:{"1":"5 G E A B C TB UB VB p YB","132":"F N K D PB HB RB SB"},F:{"1":"0 1 6 I O P Q R S T U V W X Y Z a b c e f g h i j k l m n o L q r s t u v w x y z","16":"E ZB","132":"5 8 B C J M H aB bB cB p eB"},G:{"1":"G kB lB mB nB oB pB qB rB sB","132":"HB fB EB hB JB jB"},H:{"132":"tB"},I:{"1":"4 yB zB","132":"BB F uB vB wB xB EB"},J:{"132":"D A"},K:{"1":"L","16":"A","132":"5 8 B C p"},L:{"1":"IB"},M:{"1":"3"},N:{"1":"A B"},O:{"1":"0B"},P:{"1":"F 1B 2B 3B 4B"},Q:{"1":"5B"},R:{"1":"6B"}},B:4,C:"DOM Parsing and Serialization"};

},{}],527:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = {
    1: "ls", // WHATWG Living Standard
    2: "rec", // W3C Recommendation
    3: "pr", // W3C Proposed Recommendation
    4: "cr", // W3C Candidate Recommendation
    5: "wd", // W3C Working Draft
    6: "other", // Non-W3C, but reputable
    7: "unoff" // Unofficial, Editor's Draft or W3C "Note"
};

},{}],528:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = {
    y: 1 << 0,
    n: 1 << 1,
    a: 1 << 2,
    p: 1 << 3,
    u: 1 << 4,
    x: 1 << 5,
    d: 1 << 6
};

},{}],529:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.agents = undefined;

var _browsers = require('./browsers');

var _browserVersions = require('./browserVersions');

var agentsData = require('../../data/agents');

function unpackBrowserVersions(versionsData) {
    return Object.keys(versionsData).reduce(function (usage, version) {
        usage[_browserVersions.browserVersions[version]] = versionsData[version];
        return usage;
    }, {});
}

var agents = exports.agents = Object.keys(agentsData).reduce(function (map, key) {
    var versionsData = agentsData[key];
    map[_browsers.browsers[key]] = Object.keys(versionsData).reduce(function (data, entry) {
        if (entry === 'A') {
            data.usage_global = unpackBrowserVersions(versionsData[entry]);
        } else if (entry === 'C') {
            data.versions = versionsData[entry].reduce(function (list, version) {
                if (version === '') {
                    list.push(null);
                } else {
                    list.push(_browserVersions.browserVersions[version]);
                }
                return list;
            }, []);
        } else if (entry === 'D') {
            data.prefix_exceptions = unpackBrowserVersions(versionsData[entry]);
        } else if (entry === 'E') {
            data.browser = versionsData[entry];
        } else if (entry === 'F') {
            data.release_date = Object.keys(versionsData[entry]).reduce(function (map, key) {
                map[_browserVersions.browserVersions[key]] = versionsData[entry][key];
                return map;
            }, {});
        } else {
            // entry is B
            data.prefix = versionsData[entry];
        }
        return data;
    }, {});
    return map;
}, {});
},{"../../data/agents":19,"./browserVersions":530,"./browsers":531}],530:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
var browserVersions = exports.browserVersions = require('../../data/browserVersions');
},{"../../data/browserVersions":20}],531:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
var browsers = exports.browsers = require('../../data/browsers');
},{"../../data/browsers":21}],532:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = unpackFeature;

var _statuses = require('../lib/statuses');

var _statuses2 = _interopRequireDefault(_statuses);

var _supported = require('../lib/supported');

var _supported2 = _interopRequireDefault(_supported);

var _browsers = require('./browsers');

var _browserVersions = require('./browserVersions');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var MATH2LOG = Math.log(2);

function unpackSupport(cipher) {
    // bit flags
    var stats = Object.keys(_supported2.default).reduce(function (list, support) {
        if (cipher & _supported2.default[support]) list.push(support);
        return list;
    }, []);

    // notes
    var notes = cipher >> 7;
    var notesArray = [];
    while (notes) {
        var note = Math.floor(Math.log(notes) / MATH2LOG) + 1;
        notesArray.unshift('#' + note);
        notes -= Math.pow(2, note - 1);
    }

    return stats.concat(notesArray).join(' ');
}

function unpackFeature(packed) {
    var unpacked = { status: _statuses2.default[packed.B], title: packed.C };
    unpacked.stats = Object.keys(packed.A).reduce(function (browserStats, key) {
        var browser = packed.A[key];
        browserStats[_browsers.browsers[key]] = Object.keys(browser).reduce(function (stats, support) {
            var packedVersions = browser[support].split(' ');
            var unpacked = unpackSupport(support);
            packedVersions.forEach(function (v) {
                return stats[_browserVersions.browserVersions[v]] = unpacked;
            });
            return stats;
        }, {});
        return browserStats;
    }, {});
    return unpacked;
}
},{"../lib/statuses":527,"../lib/supported":528,"./browserVersions":530,"./browsers":531}],533:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
/*
 * Load this dynamically so that it
 * doesn't appear in the rollup bundle.
 */

var features = exports.features = require('../../data/features');
},{"../../data/features":22}],534:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _agents = require('./agents');

Object.defineProperty(exports, 'agents', {
  enumerable: true,
  get: function get() {
    return _agents.agents;
  }
});

var _feature = require('./feature');

Object.defineProperty(exports, 'feature', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_feature).default;
  }
});

var _features = require('./features');

Object.defineProperty(exports, 'features', {
  enumerable: true,
  get: function get() {
    return _features.features;
  }
});

var _region = require('./region');

Object.defineProperty(exports, 'region', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_region).default;
  }
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./agents":529,"./feature":532,"./features":533,"./region":535}],535:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = unpackRegion;

var _browsers = require('./browsers');

function unpackRegion(packed) {
    return Object.keys(packed).reduce(function (list, browser) {
        var data = packed[browser];
        list[_browsers.browsers[browser]] = Object.keys(data).reduce(function (memo, key) {
            var stats = data[key];
            if (key === '_') {
                stats.split(' ').forEach(function (version) {
                    return memo[version] = null;
                });
            } else {
                memo[key] = stats;
            }
            return memo;
        }, {});
        return list;
    }, {});
}
},{"./browsers":531}],536:[function(require,module,exports){
/* MIT license */
var cssKeywords = require('color-name');

// NOTE: conversions should only return primitive values (i.e. arrays, or
//       values that give correct `typeof` results).
//       do not use box values types (i.e. Number(), String(), etc.)

var reverseKeywords = {};
for (var key in cssKeywords) {
	if (cssKeywords.hasOwnProperty(key)) {
		reverseKeywords[cssKeywords[key]] = key;
	}
}

var convert = module.exports = {
	rgb: {channels: 3, labels: 'rgb'},
	hsl: {channels: 3, labels: 'hsl'},
	hsv: {channels: 3, labels: 'hsv'},
	hwb: {channels: 3, labels: 'hwb'},
	cmyk: {channels: 4, labels: 'cmyk'},
	xyz: {channels: 3, labels: 'xyz'},
	lab: {channels: 3, labels: 'lab'},
	lch: {channels: 3, labels: 'lch'},
	hex: {channels: 1, labels: ['hex']},
	keyword: {channels: 1, labels: ['keyword']},
	ansi16: {channels: 1, labels: ['ansi16']},
	ansi256: {channels: 1, labels: ['ansi256']},
	hcg: {channels: 3, labels: ['h', 'c', 'g']},
	apple: {channels: 3, labels: ['r16', 'g16', 'b16']},
	gray: {channels: 1, labels: ['gray']}
};

// hide .channels and .labels properties
for (var model in convert) {
	if (convert.hasOwnProperty(model)) {
		if (!('channels' in convert[model])) {
			throw new Error('missing channels property: ' + model);
		}

		if (!('labels' in convert[model])) {
			throw new Error('missing channel labels property: ' + model);
		}

		if (convert[model].labels.length !== convert[model].channels) {
			throw new Error('channel and label counts mismatch: ' + model);
		}

		var channels = convert[model].channels;
		var labels = convert[model].labels;
		delete convert[model].channels;
		delete convert[model].labels;
		Object.defineProperty(convert[model], 'channels', {value: channels});
		Object.defineProperty(convert[model], 'labels', {value: labels});
	}
}

convert.rgb.hsl = function (rgb) {
	var r = rgb[0] / 255;
	var g = rgb[1] / 255;
	var b = rgb[2] / 255;
	var min = Math.min(r, g, b);
	var max = Math.max(r, g, b);
	var delta = max - min;
	var h;
	var s;
	var l;

	if (max === min) {
		h = 0;
	} else if (r === max) {
		h = (g - b) / delta;
	} else if (g === max) {
		h = 2 + (b - r) / delta;
	} else if (b === max) {
		h = 4 + (r - g) / delta;
	}

	h = Math.min(h * 60, 360);

	if (h < 0) {
		h += 360;
	}

	l = (min + max) / 2;

	if (max === min) {
		s = 0;
	} else if (l <= 0.5) {
		s = delta / (max + min);
	} else {
		s = delta / (2 - max - min);
	}

	return [h, s * 100, l * 100];
};

convert.rgb.hsv = function (rgb) {
	var rdif;
	var gdif;
	var bdif;
	var h;
	var s;

	var r = rgb[0] / 255;
	var g = rgb[1] / 255;
	var b = rgb[2] / 255;
	var v = Math.max(r, g, b);
	var diff = v - Math.min(r, g, b);
	var diffc = function (c) {
		return (v - c) / 6 / diff + 1 / 2;
	};

	if (diff === 0) {
		h = s = 0;
	} else {
		s = diff / v;
		rdif = diffc(r);
		gdif = diffc(g);
		bdif = diffc(b);

		if (r === v) {
			h = bdif - gdif;
		} else if (g === v) {
			h = (1 / 3) + rdif - bdif;
		} else if (b === v) {
			h = (2 / 3) + gdif - rdif;
		}
		if (h < 0) {
			h += 1;
		} else if (h > 1) {
			h -= 1;
		}
	}

	return [
		h * 360,
		s * 100,
		v * 100
	];
};

convert.rgb.hwb = function (rgb) {
	var r = rgb[0];
	var g = rgb[1];
	var b = rgb[2];
	var h = convert.rgb.hsl(rgb)[0];
	var w = 1 / 255 * Math.min(r, Math.min(g, b));

	b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));

	return [h, w * 100, b * 100];
};

convert.rgb.cmyk = function (rgb) {
	var r = rgb[0] / 255;
	var g = rgb[1] / 255;
	var b = rgb[2] / 255;
	var c;
	var m;
	var y;
	var k;

	k = Math.min(1 - r, 1 - g, 1 - b);
	c = (1 - r - k) / (1 - k) || 0;
	m = (1 - g - k) / (1 - k) || 0;
	y = (1 - b - k) / (1 - k) || 0;

	return [c * 100, m * 100, y * 100, k * 100];
};

/**
 * See https://en.m.wikipedia.org/wiki/Euclidean_distance#Squared_Euclidean_distance
 * */
function comparativeDistance(x, y) {
	return (
		Math.pow(x[0] - y[0], 2) +
		Math.pow(x[1] - y[1], 2) +
		Math.pow(x[2] - y[2], 2)
	);
}

convert.rgb.keyword = function (rgb) {
	var reversed = reverseKeywords[rgb];
	if (reversed) {
		return reversed;
	}

	var currentClosestDistance = Infinity;
	var currentClosestKeyword;

	for (var keyword in cssKeywords) {
		if (cssKeywords.hasOwnProperty(keyword)) {
			var value = cssKeywords[keyword];

			// Compute comparative distance
			var distance = comparativeDistance(rgb, value);

			// Check if its less, if so set as closest
			if (distance < currentClosestDistance) {
				currentClosestDistance = distance;
				currentClosestKeyword = keyword;
			}
		}
	}

	return currentClosestKeyword;
};

convert.keyword.rgb = function (keyword) {
	return cssKeywords[keyword];
};

convert.rgb.xyz = function (rgb) {
	var r = rgb[0] / 255;
	var g = rgb[1] / 255;
	var b = rgb[2] / 255;

	// assume sRGB
	r = r > 0.04045 ? Math.pow(((r + 0.055) / 1.055), 2.4) : (r / 12.92);
	g = g > 0.04045 ? Math.pow(((g + 0.055) / 1.055), 2.4) : (g / 12.92);
	b = b > 0.04045 ? Math.pow(((b + 0.055) / 1.055), 2.4) : (b / 12.92);

	var x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805);
	var y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);
	var z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);

	return [x * 100, y * 100, z * 100];
};

convert.rgb.lab = function (rgb) {
	var xyz = convert.rgb.xyz(rgb);
	var x = xyz[0];
	var y = xyz[1];
	var z = xyz[2];
	var l;
	var a;
	var b;

	x /= 95.047;
	y /= 100;
	z /= 108.883;

	x = x > 0.008856 ? Math.pow(x, 1 / 3) : (7.787 * x) + (16 / 116);
	y = y > 0.008856 ? Math.pow(y, 1 / 3) : (7.787 * y) + (16 / 116);
	z = z > 0.008856 ? Math.pow(z, 1 / 3) : (7.787 * z) + (16 / 116);

	l = (116 * y) - 16;
	a = 500 * (x - y);
	b = 200 * (y - z);

	return [l, a, b];
};

convert.hsl.rgb = function (hsl) {
	var h = hsl[0] / 360;
	var s = hsl[1] / 100;
	var l = hsl[2] / 100;
	var t1;
	var t2;
	var t3;
	var rgb;
	var val;

	if (s === 0) {
		val = l * 255;
		return [val, val, val];
	}

	if (l < 0.5) {
		t2 = l * (1 + s);
	} else {
		t2 = l + s - l * s;
	}

	t1 = 2 * l - t2;

	rgb = [0, 0, 0];
	for (var i = 0; i < 3; i++) {
		t3 = h + 1 / 3 * -(i - 1);
		if (t3 < 0) {
			t3++;
		}
		if (t3 > 1) {
			t3--;
		}

		if (6 * t3 < 1) {
			val = t1 + (t2 - t1) * 6 * t3;
		} else if (2 * t3 < 1) {
			val = t2;
		} else if (3 * t3 < 2) {
			val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
		} else {
			val = t1;
		}

		rgb[i] = val * 255;
	}

	return rgb;
};

convert.hsl.hsv = function (hsl) {
	var h = hsl[0];
	var s = hsl[1] / 100;
	var l = hsl[2] / 100;
	var smin = s;
	var lmin = Math.max(l, 0.01);
	var sv;
	var v;

	l *= 2;
	s *= (l <= 1) ? l : 2 - l;
	smin *= lmin <= 1 ? lmin : 2 - lmin;
	v = (l + s) / 2;
	sv = l === 0 ? (2 * smin) / (lmin + smin) : (2 * s) / (l + s);

	return [h, sv * 100, v * 100];
};

convert.hsv.rgb = function (hsv) {
	var h = hsv[0] / 60;
	var s = hsv[1] / 100;
	var v = hsv[2] / 100;
	var hi = Math.floor(h) % 6;

	var f = h - Math.floor(h);
	var p = 255 * v * (1 - s);
	var q = 255 * v * (1 - (s * f));
	var t = 255 * v * (1 - (s * (1 - f)));
	v *= 255;

	switch (hi) {
		case 0:
			return [v, t, p];
		case 1:
			return [q, v, p];
		case 2:
			return [p, v, t];
		case 3:
			return [p, q, v];
		case 4:
			return [t, p, v];
		case 5:
			return [v, p, q];
	}
};

convert.hsv.hsl = function (hsv) {
	var h = hsv[0];
	var s = hsv[1] / 100;
	var v = hsv[2] / 100;
	var vmin = Math.max(v, 0.01);
	var lmin;
	var sl;
	var l;

	l = (2 - s) * v;
	lmin = (2 - s) * vmin;
	sl = s * vmin;
	sl /= (lmin <= 1) ? lmin : 2 - lmin;
	sl = sl || 0;
	l /= 2;

	return [h, sl * 100, l * 100];
};

// http://dev.w3.org/csswg/css-color/#hwb-to-rgb
convert.hwb.rgb = function (hwb) {
	var h = hwb[0] / 360;
	var wh = hwb[1] / 100;
	var bl = hwb[2] / 100;
	var ratio = wh + bl;
	var i;
	var v;
	var f;
	var n;

	// wh + bl cant be > 1
	if (ratio > 1) {
		wh /= ratio;
		bl /= ratio;
	}

	i = Math.floor(6 * h);
	v = 1 - bl;
	f = 6 * h - i;

	if ((i & 0x01) !== 0) {
		f = 1 - f;
	}

	n = wh + f * (v - wh); // linear interpolation

	var r;
	var g;
	var b;
	switch (i) {
		default:
		case 6:
		case 0: r = v; g = n; b = wh; break;
		case 1: r = n; g = v; b = wh; break;
		case 2: r = wh; g = v; b = n; break;
		case 3: r = wh; g = n; b = v; break;
		case 4: r = n; g = wh; b = v; break;
		case 5: r = v; g = wh; b = n; break;
	}

	return [r * 255, g * 255, b * 255];
};

convert.cmyk.rgb = function (cmyk) {
	var c = cmyk[0] / 100;
	var m = cmyk[1] / 100;
	var y = cmyk[2] / 100;
	var k = cmyk[3] / 100;
	var r;
	var g;
	var b;

	r = 1 - Math.min(1, c * (1 - k) + k);
	g = 1 - Math.min(1, m * (1 - k) + k);
	b = 1 - Math.min(1, y * (1 - k) + k);

	return [r * 255, g * 255, b * 255];
};

convert.xyz.rgb = function (xyz) {
	var x = xyz[0] / 100;
	var y = xyz[1] / 100;
	var z = xyz[2] / 100;
	var r;
	var g;
	var b;

	r = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);
	g = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);
	b = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);

	// assume sRGB
	r = r > 0.0031308
		? ((1.055 * Math.pow(r, 1.0 / 2.4)) - 0.055)
		: r * 12.92;

	g = g > 0.0031308
		? ((1.055 * Math.pow(g, 1.0 / 2.4)) - 0.055)
		: g * 12.92;

	b = b > 0.0031308
		? ((1.055 * Math.pow(b, 1.0 / 2.4)) - 0.055)
		: b * 12.92;

	r = Math.min(Math.max(0, r), 1);
	g = Math.min(Math.max(0, g), 1);
	b = Math.min(Math.max(0, b), 1);

	return [r * 255, g * 255, b * 255];
};

convert.xyz.lab = function (xyz) {
	var x = xyz[0];
	var y = xyz[1];
	var z = xyz[2];
	var l;
	var a;
	var b;

	x /= 95.047;
	y /= 100;
	z /= 108.883;

	x = x > 0.008856 ? Math.pow(x, 1 / 3) : (7.787 * x) + (16 / 116);
	y = y > 0.008856 ? Math.pow(y, 1 / 3) : (7.787 * y) + (16 / 116);
	z = z > 0.008856 ? Math.pow(z, 1 / 3) : (7.787 * z) + (16 / 116);

	l = (116 * y) - 16;
	a = 500 * (x - y);
	b = 200 * (y - z);

	return [l, a, b];
};

convert.lab.xyz = function (lab) {
	var l = lab[0];
	var a = lab[1];
	var b = lab[2];
	var x;
	var y;
	var z;

	y = (l + 16) / 116;
	x = a / 500 + y;
	z = y - b / 200;

	var y2 = Math.pow(y, 3);
	var x2 = Math.pow(x, 3);
	var z2 = Math.pow(z, 3);
	y = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;
	x = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;
	z = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;

	x *= 95.047;
	y *= 100;
	z *= 108.883;

	return [x, y, z];
};

convert.lab.lch = function (lab) {
	var l = lab[0];
	var a = lab[1];
	var b = lab[2];
	var hr;
	var h;
	var c;

	hr = Math.atan2(b, a);
	h = hr * 360 / 2 / Math.PI;

	if (h < 0) {
		h += 360;
	}

	c = Math.sqrt(a * a + b * b);

	return [l, c, h];
};

convert.lch.lab = function (lch) {
	var l = lch[0];
	var c = lch[1];
	var h = lch[2];
	var a;
	var b;
	var hr;

	hr = h / 360 * 2 * Math.PI;
	a = c * Math.cos(hr);
	b = c * Math.sin(hr);

	return [l, a, b];
};

convert.rgb.ansi16 = function (args) {
	var r = args[0];
	var g = args[1];
	var b = args[2];
	var value = 1 in arguments ? arguments[1] : convert.rgb.hsv(args)[2]; // hsv -> ansi16 optimization

	value = Math.round(value / 50);

	if (value === 0) {
		return 30;
	}

	var ansi = 30
		+ ((Math.round(b / 255) << 2)
		| (Math.round(g / 255) << 1)
		| Math.round(r / 255));

	if (value === 2) {
		ansi += 60;
	}

	return ansi;
};

convert.hsv.ansi16 = function (args) {
	// optimization here; we already know the value and don't need to get
	// it converted for us.
	return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
};

convert.rgb.ansi256 = function (args) {
	var r = args[0];
	var g = args[1];
	var b = args[2];

	// we use the extended greyscale palette here, with the exception of
	// black and white. normal palette only has 4 greyscale shades.
	if (r === g && g === b) {
		if (r < 8) {
			return 16;
		}

		if (r > 248) {
			return 231;
		}

		return Math.round(((r - 8) / 247) * 24) + 232;
	}

	var ansi = 16
		+ (36 * Math.round(r / 255 * 5))
		+ (6 * Math.round(g / 255 * 5))
		+ Math.round(b / 255 * 5);

	return ansi;
};

convert.ansi16.rgb = function (args) {
	var color = args % 10;

	// handle greyscale
	if (color === 0 || color === 7) {
		if (args > 50) {
			color += 3.5;
		}

		color = color / 10.5 * 255;

		return [color, color, color];
	}

	var mult = (~~(args > 50) + 1) * 0.5;
	var r = ((color & 1) * mult) * 255;
	var g = (((color >> 1) & 1) * mult) * 255;
	var b = (((color >> 2) & 1) * mult) * 255;

	return [r, g, b];
};

convert.ansi256.rgb = function (args) {
	// handle greyscale
	if (args >= 232) {
		var c = (args - 232) * 10 + 8;
		return [c, c, c];
	}

	args -= 16;

	var rem;
	var r = Math.floor(args / 36) / 5 * 255;
	var g = Math.floor((rem = args % 36) / 6) / 5 * 255;
	var b = (rem % 6) / 5 * 255;

	return [r, g, b];
};

convert.rgb.hex = function (args) {
	var integer = ((Math.round(args[0]) & 0xFF) << 16)
		+ ((Math.round(args[1]) & 0xFF) << 8)
		+ (Math.round(args[2]) & 0xFF);

	var string = integer.toString(16).toUpperCase();
	return '000000'.substring(string.length) + string;
};

convert.hex.rgb = function (args) {
	var match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
	if (!match) {
		return [0, 0, 0];
	}

	var colorString = match[0];

	if (match[0].length === 3) {
		colorString = colorString.split('').map(function (char) {
			return char + char;
		}).join('');
	}

	var integer = parseInt(colorString, 16);
	var r = (integer >> 16) & 0xFF;
	var g = (integer >> 8) & 0xFF;
	var b = integer & 0xFF;

	return [r, g, b];
};

convert.rgb.hcg = function (rgb) {
	var r = rgb[0] / 255;
	var g = rgb[1] / 255;
	var b = rgb[2] / 255;
	var max = Math.max(Math.max(r, g), b);
	var min = Math.min(Math.min(r, g), b);
	var chroma = (max - min);
	var grayscale;
	var hue;

	if (chroma < 1) {
		grayscale = min / (1 - chroma);
	} else {
		grayscale = 0;
	}

	if (chroma <= 0) {
		hue = 0;
	} else
	if (max === r) {
		hue = ((g - b) / chroma) % 6;
	} else
	if (max === g) {
		hue = 2 + (b - r) / chroma;
	} else {
		hue = 4 + (r - g) / chroma + 4;
	}

	hue /= 6;
	hue %= 1;

	return [hue * 360, chroma * 100, grayscale * 100];
};

convert.hsl.hcg = function (hsl) {
	var s = hsl[1] / 100;
	var l = hsl[2] / 100;
	var c = 1;
	var f = 0;

	if (l < 0.5) {
		c = 2.0 * s * l;
	} else {
		c = 2.0 * s * (1.0 - l);
	}

	if (c < 1.0) {
		f = (l - 0.5 * c) / (1.0 - c);
	}

	return [hsl[0], c * 100, f * 100];
};

convert.hsv.hcg = function (hsv) {
	var s = hsv[1] / 100;
	var v = hsv[2] / 100;

	var c = s * v;
	var f = 0;

	if (c < 1.0) {
		f = (v - c) / (1 - c);
	}

	return [hsv[0], c * 100, f * 100];
};

convert.hcg.rgb = function (hcg) {
	var h = hcg[0] / 360;
	var c = hcg[1] / 100;
	var g = hcg[2] / 100;

	if (c === 0.0) {
		return [g * 255, g * 255, g * 255];
	}

	var pure = [0, 0, 0];
	var hi = (h % 1) * 6;
	var v = hi % 1;
	var w = 1 - v;
	var mg = 0;

	switch (Math.floor(hi)) {
		case 0:
			pure[0] = 1; pure[1] = v; pure[2] = 0; break;
		case 1:
			pure[0] = w; pure[1] = 1; pure[2] = 0; break;
		case 2:
			pure[0] = 0; pure[1] = 1; pure[2] = v; break;
		case 3:
			pure[0] = 0; pure[1] = w; pure[2] = 1; break;
		case 4:
			pure[0] = v; pure[1] = 0; pure[2] = 1; break;
		default:
			pure[0] = 1; pure[1] = 0; pure[2] = w;
	}

	mg = (1.0 - c) * g;

	return [
		(c * pure[0] + mg) * 255,
		(c * pure[1] + mg) * 255,
		(c * pure[2] + mg) * 255
	];
};

convert.hcg.hsv = function (hcg) {
	var c = hcg[1] / 100;
	var g = hcg[2] / 100;

	var v = c + g * (1.0 - c);
	var f = 0;

	if (v > 0.0) {
		f = c / v;
	}

	return [hcg[0], f * 100, v * 100];
};

convert.hcg.hsl = function (hcg) {
	var c = hcg[1] / 100;
	var g = hcg[2] / 100;

	var l = g * (1.0 - c) + 0.5 * c;
	var s = 0;

	if (l > 0.0 && l < 0.5) {
		s = c / (2 * l);
	} else
	if (l >= 0.5 && l < 1.0) {
		s = c / (2 * (1 - l));
	}

	return [hcg[0], s * 100, l * 100];
};

convert.hcg.hwb = function (hcg) {
	var c = hcg[1] / 100;
	var g = hcg[2] / 100;
	var v = c + g * (1.0 - c);
	return [hcg[0], (v - c) * 100, (1 - v) * 100];
};

convert.hwb.hcg = function (hwb) {
	var w = hwb[1] / 100;
	var b = hwb[2] / 100;
	var v = 1 - b;
	var c = v - w;
	var g = 0;

	if (c < 1) {
		g = (v - c) / (1 - c);
	}

	return [hwb[0], c * 100, g * 100];
};

convert.apple.rgb = function (apple) {
	return [(apple[0] / 65535) * 255, (apple[1] / 65535) * 255, (apple[2] / 65535) * 255];
};

convert.rgb.apple = function (rgb) {
	return [(rgb[0] / 255) * 65535, (rgb[1] / 255) * 65535, (rgb[2] / 255) * 65535];
};

convert.gray.rgb = function (args) {
	return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
};

convert.gray.hsl = convert.gray.hsv = function (args) {
	return [0, 0, args[0]];
};

convert.gray.hwb = function (gray) {
	return [0, 100, gray[0]];
};

convert.gray.cmyk = function (gray) {
	return [0, 0, 0, gray[0]];
};

convert.gray.lab = function (gray) {
	return [gray[0], 0, 0];
};

convert.gray.hex = function (gray) {
	var val = Math.round(gray[0] / 100 * 255) & 0xFF;
	var integer = (val << 16) + (val << 8) + val;

	var string = integer.toString(16).toUpperCase();
	return '000000'.substring(string.length) + string;
};

convert.rgb.gray = function (rgb) {
	var val = (rgb[0] + rgb[1] + rgb[2]) / 3;
	return [val / 255 * 100];
};

},{"color-name":539}],537:[function(require,module,exports){
var conversions = require('./conversions');
var route = require('./route');

var convert = {};

var models = Object.keys(conversions);

function wrapRaw(fn) {
	var wrappedFn = function (args) {
		if (args === undefined || args === null) {
			return args;
		}

		if (arguments.length > 1) {
			args = Array.prototype.slice.call(arguments);
		}

		return fn(args);
	};

	// preserve .conversion property if there is one
	if ('conversion' in fn) {
		wrappedFn.conversion = fn.conversion;
	}

	return wrappedFn;
}

function wrapRounded(fn) {
	var wrappedFn = function (args) {
		if (args === undefined || args === null) {
			return args;
		}

		if (arguments.length > 1) {
			args = Array.prototype.slice.call(arguments);
		}

		var result = fn(args);

		// we're assuming the result is an array here.
		// see notice in conversions.js; don't use box types
		// in conversion functions.
		if (typeof result === 'object') {
			for (var len = result.length, i = 0; i < len; i++) {
				result[i] = Math.round(result[i]);
			}
		}

		return result;
	};

	// preserve .conversion property if there is one
	if ('conversion' in fn) {
		wrappedFn.conversion = fn.conversion;
	}

	return wrappedFn;
}

models.forEach(function (fromModel) {
	convert[fromModel] = {};

	Object.defineProperty(convert[fromModel], 'channels', {value: conversions[fromModel].channels});
	Object.defineProperty(convert[fromModel], 'labels', {value: conversions[fromModel].labels});

	var routes = route(fromModel);
	var routeModels = Object.keys(routes);

	routeModels.forEach(function (toModel) {
		var fn = routes[toModel];

		convert[fromModel][toModel] = wrapRounded(fn);
		convert[fromModel][toModel].raw = wrapRaw(fn);
	});
});

module.exports = convert;

},{"./conversions":536,"./route":538}],538:[function(require,module,exports){
var conversions = require('./conversions');

/*
	this function routes a model to all other models.

	all functions that are routed have a property `.conversion` attached
	to the returned synthetic function. This property is an array
	of strings, each with the steps in between the 'from' and 'to'
	color models (inclusive).

	conversions that are not possible simply are not included.
*/

function buildGraph() {
	var graph = {};
	// https://jsperf.com/object-keys-vs-for-in-with-closure/3
	var models = Object.keys(conversions);

	for (var len = models.length, i = 0; i < len; i++) {
		graph[models[i]] = {
			// http://jsperf.com/1-vs-infinity
			// micro-opt, but this is simple.
			distance: -1,
			parent: null
		};
	}

	return graph;
}

// https://en.wikipedia.org/wiki/Breadth-first_search
function deriveBFS(fromModel) {
	var graph = buildGraph();
	var queue = [fromModel]; // unshift -> queue -> pop

	graph[fromModel].distance = 0;

	while (queue.length) {
		var current = queue.pop();
		var adjacents = Object.keys(conversions[current]);

		for (var len = adjacents.length, i = 0; i < len; i++) {
			var adjacent = adjacents[i];
			var node = graph[adjacent];

			if (node.distance === -1) {
				node.distance = graph[current].distance + 1;
				node.parent = current;
				queue.unshift(adjacent);
			}
		}
	}

	return graph;
}

function link(from, to) {
	return function (args) {
		return to(from(args));
	};
}

function wrapConversion(toModel, graph) {
	var path = [graph[toModel].parent, toModel];
	var fn = conversions[graph[toModel].parent][toModel];

	var cur = graph[toModel].parent;
	while (graph[cur].parent) {
		path.unshift(graph[cur].parent);
		fn = link(conversions[graph[cur].parent][cur], fn);
		cur = graph[cur].parent;
	}

	fn.conversion = path;
	return fn;
}

module.exports = function (fromModel) {
	var graph = deriveBFS(fromModel);
	var conversion = {};

	var models = Object.keys(graph);
	for (var len = models.length, i = 0; i < len; i++) {
		var toModel = models[i];
		var node = graph[toModel];

		if (node.parent === null) {
			// no possible conversion, or this node is the source model.
			continue;
		}

		conversion[toModel] = wrapConversion(toModel, graph);
	}

	return conversion;
};


},{"./conversions":536}],539:[function(require,module,exports){
'use strict'

module.exports = {
	"aliceblue": [240, 248, 255],
	"antiquewhite": [250, 235, 215],
	"aqua": [0, 255, 255],
	"aquamarine": [127, 255, 212],
	"azure": [240, 255, 255],
	"beige": [245, 245, 220],
	"bisque": [255, 228, 196],
	"black": [0, 0, 0],
	"blanchedalmond": [255, 235, 205],
	"blue": [0, 0, 255],
	"blueviolet": [138, 43, 226],
	"brown": [165, 42, 42],
	"burlywood": [222, 184, 135],
	"cadetblue": [95, 158, 160],
	"chartreuse": [127, 255, 0],
	"chocolate": [210, 105, 30],
	"coral": [255, 127, 80],
	"cornflowerblue": [100, 149, 237],
	"cornsilk": [255, 248, 220],
	"crimson": [220, 20, 60],
	"cyan": [0, 255, 255],
	"darkblue": [0, 0, 139],
	"darkcyan": [0, 139, 139],
	"darkgoldenrod": [184, 134, 11],
	"darkgray": [169, 169, 169],
	"darkgreen": [0, 100, 0],
	"darkgrey": [169, 169, 169],
	"darkkhaki": [189, 183, 107],
	"darkmagenta": [139, 0, 139],
	"darkolivegreen": [85, 107, 47],
	"darkorange": [255, 140, 0],
	"darkorchid": [153, 50, 204],
	"darkred": [139, 0, 0],
	"darksalmon": [233, 150, 122],
	"darkseagreen": [143, 188, 143],
	"darkslateblue": [72, 61, 139],
	"darkslategray": [47, 79, 79],
	"darkslategrey": [47, 79, 79],
	"darkturquoise": [0, 206, 209],
	"darkviolet": [148, 0, 211],
	"deeppink": [255, 20, 147],
	"deepskyblue": [0, 191, 255],
	"dimgray": [105, 105, 105],
	"dimgrey": [105, 105, 105],
	"dodgerblue": [30, 144, 255],
	"firebrick": [178, 34, 34],
	"floralwhite": [255, 250, 240],
	"forestgreen": [34, 139, 34],
	"fuchsia": [255, 0, 255],
	"gainsboro": [220, 220, 220],
	"ghostwhite": [248, 248, 255],
	"gold": [255, 215, 0],
	"goldenrod": [218, 165, 32],
	"gray": [128, 128, 128],
	"green": [0, 128, 0],
	"greenyellow": [173, 255, 47],
	"grey": [128, 128, 128],
	"honeydew": [240, 255, 240],
	"hotpink": [255, 105, 180],
	"indianred": [205, 92, 92],
	"indigo": [75, 0, 130],
	"ivory": [255, 255, 240],
	"khaki": [240, 230, 140],
	"lavender": [230, 230, 250],
	"lavenderblush": [255, 240, 245],
	"lawngreen": [124, 252, 0],
	"lemonchiffon": [255, 250, 205],
	"lightblue": [173, 216, 230],
	"lightcoral": [240, 128, 128],
	"lightcyan": [224, 255, 255],
	"lightgoldenrodyellow": [250, 250, 210],
	"lightgray": [211, 211, 211],
	"lightgreen": [144, 238, 144],
	"lightgrey": [211, 211, 211],
	"lightpink": [255, 182, 193],
	"lightsalmon": [255, 160, 122],
	"lightseagreen": [32, 178, 170],
	"lightskyblue": [135, 206, 250],
	"lightslategray": [119, 136, 153],
	"lightslategrey": [119, 136, 153],
	"lightsteelblue": [176, 196, 222],
	"lightyellow": [255, 255, 224],
	"lime": [0, 255, 0],
	"limegreen": [50, 205, 50],
	"linen": [250, 240, 230],
	"magenta": [255, 0, 255],
	"maroon": [128, 0, 0],
	"mediumaquamarine": [102, 205, 170],
	"mediumblue": [0, 0, 205],
	"mediumorchid": [186, 85, 211],
	"mediumpurple": [147, 112, 219],
	"mediumseagreen": [60, 179, 113],
	"mediumslateblue": [123, 104, 238],
	"mediumspringgreen": [0, 250, 154],
	"mediumturquoise": [72, 209, 204],
	"mediumvioletred": [199, 21, 133],
	"midnightblue": [25, 25, 112],
	"mintcream": [245, 255, 250],
	"mistyrose": [255, 228, 225],
	"moccasin": [255, 228, 181],
	"navajowhite": [255, 222, 173],
	"navy": [0, 0, 128],
	"oldlace": [253, 245, 230],
	"olive": [128, 128, 0],
	"olivedrab": [107, 142, 35],
	"orange": [255, 165, 0],
	"orangered": [255, 69, 0],
	"orchid": [218, 112, 214],
	"palegoldenrod": [238, 232, 170],
	"palegreen": [152, 251, 152],
	"paleturquoise": [175, 238, 238],
	"palevioletred": [219, 112, 147],
	"papayawhip": [255, 239, 213],
	"peachpuff": [255, 218, 185],
	"peru": [205, 133, 63],
	"pink": [255, 192, 203],
	"plum": [221, 160, 221],
	"powderblue": [176, 224, 230],
	"purple": [128, 0, 128],
	"rebeccapurple": [102, 51, 153],
	"red": [255, 0, 0],
	"rosybrown": [188, 143, 143],
	"royalblue": [65, 105, 225],
	"saddlebrown": [139, 69, 19],
	"salmon": [250, 128, 114],
	"sandybrown": [244, 164, 96],
	"seagreen": [46, 139, 87],
	"seashell": [255, 245, 238],
	"sienna": [160, 82, 45],
	"silver": [192, 192, 192],
	"skyblue": [135, 206, 235],
	"slateblue": [106, 90, 205],
	"slategray": [112, 128, 144],
	"slategrey": [112, 128, 144],
	"snow": [255, 250, 250],
	"springgreen": [0, 255, 127],
	"steelblue": [70, 130, 180],
	"tan": [210, 180, 140],
	"teal": [0, 128, 128],
	"thistle": [216, 191, 216],
	"tomato": [255, 99, 71],
	"turquoise": [64, 224, 208],
	"violet": [238, 130, 238],
	"wheat": [245, 222, 179],
	"white": [255, 255, 255],
	"whitesmoke": [245, 245, 245],
	"yellow": [255, 255, 0],
	"yellowgreen": [154, 205, 50]
};

},{}],540:[function(require,module,exports){
/* MIT license */
var colorNames = require('color-name');
var swizzle = require('simple-swizzle');

var reverseNames = {};

// create a list of reverse color names
for (var name in colorNames) {
	if (colorNames.hasOwnProperty(name)) {
		reverseNames[colorNames[name]] = name;
	}
}

var cs = module.exports = {
	to: {},
	get: {}
};

cs.get = function (string) {
	var prefix = string.substring(0, 3).toLowerCase();
	var val;
	var model;
	switch (prefix) {
		case 'hsl':
			val = cs.get.hsl(string);
			model = 'hsl';
			break;
		case 'hwb':
			val = cs.get.hwb(string);
			model = 'hwb';
			break;
		default:
			val = cs.get.rgb(string);
			model = 'rgb';
			break;
	}

	if (!val) {
		return null;
	}

	return {model: model, value: val};
};

cs.get.rgb = function (string) {
	if (!string) {
		return null;
	}

	var abbr = /^#([a-f0-9]{3,4})$/i;
	var hex = /^#([a-f0-9]{6})([a-f0-9]{2})?$/i;
	var rgba = /^rgba?\(\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/;
	var per = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/;
	var keyword = /(\D+)/;

	var rgb = [0, 0, 0, 1];
	var match;
	var i;
	var hexAlpha;

	if (match = string.match(hex)) {
		hexAlpha = match[2];
		match = match[1];

		for (i = 0; i < 3; i++) {
			// https://jsperf.com/slice-vs-substr-vs-substring-methods-long-string/19
			var i2 = i * 2;
			rgb[i] = parseInt(match.slice(i2, i2 + 2), 16);
		}

		if (hexAlpha) {
			rgb[3] = Math.round((parseInt(hexAlpha, 16) / 255) * 100) / 100;
		}
	} else if (match = string.match(abbr)) {
		match = match[1];
		hexAlpha = match[3];

		for (i = 0; i < 3; i++) {
			rgb[i] = parseInt(match[i] + match[i], 16);
		}

		if (hexAlpha) {
			rgb[3] = Math.round((parseInt(hexAlpha + hexAlpha, 16) / 255) * 100) / 100;
		}
	} else if (match = string.match(rgba)) {
		for (i = 0; i < 3; i++) {
			rgb[i] = parseInt(match[i + 1], 0);
		}

		if (match[4]) {
			rgb[3] = parseFloat(match[4]);
		}
	} else if (match = string.match(per)) {
		for (i = 0; i < 3; i++) {
			rgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);
		}

		if (match[4]) {
			rgb[3] = parseFloat(match[4]);
		}
	} else if (match = string.match(keyword)) {
		if (match[1] === 'transparent') {
			return [0, 0, 0, 0];
		}

		rgb = colorNames[match[1]];

		if (!rgb) {
			return null;
		}

		rgb[3] = 1;

		return rgb;
	} else {
		return null;
	}

	for (i = 0; i < 3; i++) {
		rgb[i] = clamp(rgb[i], 0, 255);
	}
	rgb[3] = clamp(rgb[3], 0, 1);

	return rgb;
};

cs.get.hsl = function (string) {
	if (!string) {
		return null;
	}

	var hsl = /^hsla?\(\s*([+-]?(?:\d*\.)?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/;
	var match = string.match(hsl);

	if (match) {
		var alpha = parseFloat(match[4]);
		var h = (parseFloat(match[1]) + 360) % 360;
		var s = clamp(parseFloat(match[2]), 0, 100);
		var l = clamp(parseFloat(match[3]), 0, 100);
		var a = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);

		return [h, s, l, a];
	}

	return null;
};

cs.get.hwb = function (string) {
	if (!string) {
		return null;
	}

	var hwb = /^hwb\(\s*([+-]?\d*[\.]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/;
	var match = string.match(hwb);

	if (match) {
		var alpha = parseFloat(match[4]);
		var h = ((parseFloat(match[1]) % 360) + 360) % 360;
		var w = clamp(parseFloat(match[2]), 0, 100);
		var b = clamp(parseFloat(match[3]), 0, 100);
		var a = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);
		return [h, w, b, a];
	}

	return null;
};

cs.to.hex = function () {
	var rgba = swizzle(arguments);

	return (
		'#' +
		hexDouble(rgba[0]) +
		hexDouble(rgba[1]) +
		hexDouble(rgba[2]) +
		(rgba[3] < 1
			? (hexDouble(Math.round(rgba[3] * 255)))
			: '')
	);
};

cs.to.rgb = function () {
	var rgba = swizzle(arguments);

	return rgba.length < 4 || rgba[3] === 1
		? 'rgb(' + Math.round(rgba[0]) + ', ' + Math.round(rgba[1]) + ', ' + Math.round(rgba[2]) + ')'
		: 'rgba(' + Math.round(rgba[0]) + ', ' + Math.round(rgba[1]) + ', ' + Math.round(rgba[2]) + ', ' + rgba[3] + ')';
};

cs.to.rgb.percent = function () {
	var rgba = swizzle(arguments);

	var r = Math.round(rgba[0] / 255 * 100);
	var g = Math.round(rgba[1] / 255 * 100);
	var b = Math.round(rgba[2] / 255 * 100);

	return rgba.length < 4 || rgba[3] === 1
		? 'rgb(' + r + '%, ' + g + '%, ' + b + '%)'
		: 'rgba(' + r + '%, ' + g + '%, ' + b + '%, ' + rgba[3] + ')';
};

cs.to.hsl = function () {
	var hsla = swizzle(arguments);
	return hsla.length < 4 || hsla[3] === 1
		? 'hsl(' + hsla[0] + ', ' + hsla[1] + '%, ' + hsla[2] + '%)'
		: 'hsla(' + hsla[0] + ', ' + hsla[1] + '%, ' + hsla[2] + '%, ' + hsla[3] + ')';
};

// hwb is a bit different than rgb(a) & hsl(a) since there is no alpha specific syntax
// (hwb have alpha optional & 1 is default value)
cs.to.hwb = function () {
	var hwba = swizzle(arguments);

	var a = '';
	if (hwba.length >= 4 && hwba[3] !== 1) {
		a = ', ' + hwba[3];
	}

	return 'hwb(' + hwba[0] + ', ' + hwba[1] + '%, ' + hwba[2] + '%' + a + ')';
};

cs.to.keyword = function (rgb) {
	return reverseNames[rgb.slice(0, 3)];
};

// helpers
function clamp(num, min, max) {
	return Math.min(Math.max(min, num), max);
}

function hexDouble(num) {
	var str = num.toString(16).toUpperCase();
	return (str.length < 2) ? '0' + str : str;
}

},{"color-name":539,"simple-swizzle":1120}],541:[function(require,module,exports){
'use strict';

var colorString = require('color-string');
var convert = require('color-convert');

var _slice = [].slice;

var skippedModels = [
	// to be honest, I don't really feel like keyword belongs in color convert, but eh.
	'keyword',

	// gray conflicts with some method names, and has its own method defined.
	'gray',

	// shouldn't really be in color-convert either...
	'hex'
];

var hashedModelKeys = {};
Object.keys(convert).forEach(function (model) {
	hashedModelKeys[_slice.call(convert[model].labels).sort().join('')] = model;
});

var limiters = {};

function Color(obj, model) {
	if (!(this instanceof Color)) {
		return new Color(obj, model);
	}

	if (model && model in skippedModels) {
		model = null;
	}

	if (model && !(model in convert)) {
		throw new Error('Unknown model: ' + model);
	}

	var i;
	var channels;

	if (typeof obj === 'undefined') {
		this.model = 'rgb';
		this.color = [0, 0, 0];
		this.valpha = 1;
	} else if (obj instanceof Color) {
		this.model = obj.model;
		this.color = obj.color.slice();
		this.valpha = obj.valpha;
	} else if (typeof obj === 'string') {
		var result = colorString.get(obj);
		if (result === null) {
			throw new Error('Unable to parse color from string: ' + obj);
		}

		this.model = result.model;
		channels = convert[this.model].channels;
		this.color = result.value.slice(0, channels);
		this.valpha = typeof result.value[channels] === 'number' ? result.value[channels] : 1;
	} else if (obj.length) {
		this.model = model || 'rgb';
		channels = convert[this.model].channels;
		var newArr = _slice.call(obj, 0, channels);
		this.color = zeroArray(newArr, channels);
		this.valpha = typeof obj[channels] === 'number' ? obj[channels] : 1;
	} else if (typeof obj === 'number') {
		// this is always RGB - can be converted later on.
		obj &= 0xFFFFFF;
		this.model = 'rgb';
		this.color = [
			(obj >> 16) & 0xFF,
			(obj >> 8) & 0xFF,
			obj & 0xFF
		];
		this.valpha = 1;
	} else {
		this.valpha = 1;

		var keys = Object.keys(obj);
		if ('alpha' in obj) {
			keys.splice(keys.indexOf('alpha'), 1);
			this.valpha = typeof obj.alpha === 'number' ? obj.alpha : 0;
		}

		var hashedKeys = keys.sort().join('');
		if (!(hashedKeys in hashedModelKeys)) {
			throw new Error('Unable to parse color from object: ' + JSON.stringify(obj));
		}

		this.model = hashedModelKeys[hashedKeys];

		var labels = convert[this.model].labels;
		var color = [];
		for (i = 0; i < labels.length; i++) {
			color.push(obj[labels[i]]);
		}

		this.color = zeroArray(color);
	}

	// perform limitations (clamping, etc.)
	if (limiters[this.model]) {
		channels = convert[this.model].channels;
		for (i = 0; i < channels; i++) {
			var limit = limiters[this.model][i];
			if (limit) {
				this.color[i] = limit(this.color[i]);
			}
		}
	}

	this.valpha = Math.max(0, Math.min(1, this.valpha));

	if (Object.freeze) {
		Object.freeze(this);
	}
}

Color.prototype = {
	toString: function () {
		return this.string();
	},

	toJSON: function () {
		return this[this.model]();
	},

	string: function (places) {
		var self = this.model in colorString.to ? this : this.rgb();
		self = self.round(typeof places === 'number' ? places : 1);
		var args = self.valpha === 1 ? self.color : self.color.concat(this.valpha);
		return colorString.to[self.model](args);
	},

	percentString: function (places) {
		var self = this.rgb().round(typeof places === 'number' ? places : 1);
		var args = self.valpha === 1 ? self.color : self.color.concat(this.valpha);
		return colorString.to.rgb.percent(args);
	},

	array: function () {
		return this.valpha === 1 ? this.color.slice() : this.color.concat(this.valpha);
	},

	object: function () {
		var result = {};
		var channels = convert[this.model].channels;
		var labels = convert[this.model].labels;

		for (var i = 0; i < channels; i++) {
			result[labels[i]] = this.color[i];
		}

		if (this.valpha !== 1) {
			result.alpha = this.valpha;
		}

		return result;
	},

	unitArray: function () {
		var rgb = this.rgb().color;
		rgb[0] /= 255;
		rgb[1] /= 255;
		rgb[2] /= 255;

		if (this.valpha !== 1) {
			rgb.push(this.valpha);
		}

		return rgb;
	},

	unitObject: function () {
		var rgb = this.rgb().object();
		rgb.r /= 255;
		rgb.g /= 255;
		rgb.b /= 255;

		if (this.valpha !== 1) {
			rgb.alpha = this.valpha;
		}

		return rgb;
	},

	round: function (places) {
		places = Math.max(places || 0, 0);
		return new Color(this.color.map(roundToPlace(places)).concat(this.valpha), this.model);
	},

	alpha: function (val) {
		if (arguments.length) {
			return new Color(this.color.concat(Math.max(0, Math.min(1, val))), this.model);
		}

		return this.valpha;
	},

	// rgb
	red: getset('rgb', 0, maxfn(255)),
	green: getset('rgb', 1, maxfn(255)),
	blue: getset('rgb', 2, maxfn(255)),

	hue: getset(['hsl', 'hsv', 'hsl', 'hwb', 'hcg'], 0, function (val) { return ((val % 360) + 360) % 360; }), // eslint-disable-line brace-style

	saturationl: getset('hsl', 1, maxfn(100)),
	lightness: getset('hsl', 2, maxfn(100)),

	saturationv: getset('hsv', 1, maxfn(100)),
	value: getset('hsv', 2, maxfn(100)),

	chroma: getset('hcg', 1, maxfn(100)),
	gray: getset('hcg', 2, maxfn(100)),

	white: getset('hwb', 1, maxfn(100)),
	wblack: getset('hwb', 2, maxfn(100)),

	cyan: getset('cmyk', 0, maxfn(100)),
	magenta: getset('cmyk', 1, maxfn(100)),
	yellow: getset('cmyk', 2, maxfn(100)),
	black: getset('cmyk', 3, maxfn(100)),

	x: getset('xyz', 0, maxfn(100)),
	y: getset('xyz', 1, maxfn(100)),
	z: getset('xyz', 2, maxfn(100)),

	l: getset('lab', 0, maxfn(100)),
	a: getset('lab', 1),
	b: getset('lab', 2),

	keyword: function (val) {
		if (arguments.length) {
			return new Color(val);
		}

		return convert[this.model].keyword(this.color);
	},

	hex: function (val) {
		if (arguments.length) {
			return new Color(val);
		}

		return colorString.to.hex(this.rgb().round().color);
	},

	rgbNumber: function () {
		var rgb = this.rgb().color;
		return ((rgb[0] & 0xFF) << 16) | ((rgb[1] & 0xFF) << 8) | (rgb[2] & 0xFF);
	},

	luminosity: function () {
		// http://www.w3.org/TR/WCAG20/#relativeluminancedef
		var rgb = this.rgb().color;

		var lum = [];
		for (var i = 0; i < rgb.length; i++) {
			var chan = rgb[i] / 255;
			lum[i] = (chan <= 0.03928) ? chan / 12.92 : Math.pow(((chan + 0.055) / 1.055), 2.4);
		}

		return 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];
	},

	contrast: function (color2) {
		// http://www.w3.org/TR/WCAG20/#contrast-ratiodef
		var lum1 = this.luminosity();
		var lum2 = color2.luminosity();

		if (lum1 > lum2) {
			return (lum1 + 0.05) / (lum2 + 0.05);
		}

		return (lum2 + 0.05) / (lum1 + 0.05);
	},

	level: function (color2) {
		var contrastRatio = this.contrast(color2);
		if (contrastRatio >= 7.1) {
			return 'AAA';
		}

		return (contrastRatio >= 4.5) ? 'AA' : '';
	},

	isDark: function () {
		// YIQ equation from http://24ways.org/2010/calculating-color-contrast
		var rgb = this.rgb().color;
		var yiq = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1000;
		return yiq < 128;
	},

	isLight: function () {
		return !this.isDark();
	},

	negate: function () {
		var rgb = this.rgb();
		for (var i = 0; i < 3; i++) {
			rgb.color[i] = 255 - rgb.color[i];
		}
		return rgb;
	},

	lighten: function (ratio) {
		var hsl = this.hsl();
		hsl.color[2] += hsl.color[2] * ratio;
		return hsl;
	},

	darken: function (ratio) {
		var hsl = this.hsl();
		hsl.color[2] -= hsl.color[2] * ratio;
		return hsl;
	},

	saturate: function (ratio) {
		var hsl = this.hsl();
		hsl.color[1] += hsl.color[1] * ratio;
		return hsl;
	},

	desaturate: function (ratio) {
		var hsl = this.hsl();
		hsl.color[1] -= hsl.color[1] * ratio;
		return hsl;
	},

	whiten: function (ratio) {
		var hwb = this.hwb();
		hwb.color[1] += hwb.color[1] * ratio;
		return hwb;
	},

	blacken: function (ratio) {
		var hwb = this.hwb();
		hwb.color[2] += hwb.color[2] * ratio;
		return hwb;
	},

	grayscale: function () {
		// http://en.wikipedia.org/wiki/Grayscale#Converting_color_to_grayscale
		var rgb = this.rgb().color;
		var val = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;
		return Color.rgb(val, val, val);
	},

	fade: function (ratio) {
		return this.alpha(this.valpha - (this.valpha * ratio));
	},

	opaquer: function (ratio) {
		return this.alpha(this.valpha + (this.valpha * ratio));
	},

	rotate: function (degrees) {
		var hsl = this.hsl();
		var hue = hsl.color[0];
		hue = (hue + degrees) % 360;
		hue = hue < 0 ? 360 + hue : hue;
		hsl.color[0] = hue;
		return hsl;
	},

	mix: function (mixinColor, weight) {
		// ported from sass implementation in C
		// https://github.com/sass/libsass/blob/0e6b4a2850092356aa3ece07c6b249f0221caced/functions.cpp#L209
		var color1 = mixinColor.rgb();
		var color2 = this.rgb();
		var p = weight === undefined ? 0.5 : weight;

		var w = 2 * p - 1;
		var a = color1.alpha() - color2.alpha();

		var w1 = (((w * a === -1) ? w : (w + a) / (1 + w * a)) + 1) / 2.0;
		var w2 = 1 - w1;

		return Color.rgb(
				w1 * color1.red() + w2 * color2.red(),
				w1 * color1.green() + w2 * color2.green(),
				w1 * color1.blue() + w2 * color2.blue(),
				color1.alpha() * p + color2.alpha() * (1 - p));
	}
};

// model conversion methods and static constructors
Object.keys(convert).forEach(function (model) {
	if (skippedModels.indexOf(model) !== -1) {
		return;
	}

	var channels = convert[model].channels;

	// conversion methods
	Color.prototype[model] = function () {
		if (this.model === model) {
			return new Color(this);
		}

		if (arguments.length) {
			return new Color(arguments, model);
		}

		var newAlpha = typeof arguments[channels] === 'number' ? channels : this.valpha;
		return new Color(assertArray(convert[this.model][model].raw(this.color)).concat(newAlpha), model);
	};

	// 'static' construction methods
	Color[model] = function (color) {
		if (typeof color === 'number') {
			color = zeroArray(_slice.call(arguments), channels);
		}
		return new Color(color, model);
	};
});

function roundTo(num, places) {
	return Number(num.toFixed(places));
}

function roundToPlace(places) {
	return function (num) {
		return roundTo(num, places);
	};
}

function getset(model, channel, modifier) {
	model = Array.isArray(model) ? model : [model];

	model.forEach(function (m) {
		(limiters[m] || (limiters[m] = []))[channel] = modifier;
	});

	model = model[0];

	return function (val) {
		var result;

		if (arguments.length) {
			if (modifier) {
				val = modifier(val);
			}

			result = this[model]();
			result.color[channel] = val;
			return result;
		}

		result = this[model]().color[channel];
		if (modifier) {
			result = modifier(result);
		}

		return result;
	};
}

function maxfn(max) {
	return function (v) {
		return Math.max(0, Math.min(max, v));
	};
}

function assertArray(val) {
	return Array.isArray(val) ? val : [val];
}

function zeroArray(arr, length) {
	for (var i = 0; i < length; i++) {
		if (typeof arr[i] !== 'number') {
			arr[i] = 0;
		}
	}

	return arr;
}

module.exports = Color;

},{"color-convert":537,"color-string":540}],542:[function(require,module,exports){
'use strict';

var comment = module.exports = function () {
	return new RegExp('(?:' + comment.line().source + ')|(?:' + comment.block().source + ')', 'gm');
};

comment.line = function () {
	return /(?:^|\s)\/\/(.+?)$/gm;
};

comment.block = function () {
	return /\/\*([\S\s]*?)\*\//gm;
};

},{}],543:[function(require,module,exports){
(function (Buffer){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.

function isArray(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }
  return objectToString(arg) === '[object Array]';
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = Buffer.isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

}).call(this,{"isBuffer":require("../../is-buffer/index.js")})
},{"../../is-buffer/index.js":731}],544:[function(require,module,exports){
//      
'use strict';

function cacheWrapper   (cache                 , key        , fn         )    {
  if (!cache) {
    return fn();
  }

  const cached = cache.get(key);
  if (cached !== undefined) {
    return cached;
  }

  const result = fn();
  cache.set(key, result);
  return result;
}

module.exports = cacheWrapper;

},{}],545:[function(require,module,exports){
(function (process){
//      
'use strict';

const path = require('path');
const get = require('lodash.get');
const loaders = require('./loaders');
const readFile = require('./readFile');
const cacheWrapper = require('./cacheWrapper');
const getDirectory = require('./getDirectory');

const MODE_SYNC = 'sync';

// An object value represents a config object.
// null represents that the loader did not find anything relevant.
// undefined represents that the loader found something relevant
// but it was empty.
                                              

class Explorer {
                                                      
                                                 
                                                        
                                                   
                          

  constructor(options                 ) {
    this.loadCache = options.cache ? new Map() : null;
    this.loadSyncCache = options.cache ? new Map() : null;
    this.searchCache = options.cache ? new Map() : null;
    this.searchSyncCache = options.cache ? new Map() : null;
    this.config = options;
    this.validateConfig();
  }

  clearLoadCache() {
    if (this.loadCache) {
      this.loadCache.clear();
    }
    if (this.loadSyncCache) {
      this.loadSyncCache.clear();
    }
  }

  clearSearchCache() {
    if (this.searchCache) {
      this.searchCache.clear();
    }
    if (this.searchSyncCache) {
      this.searchSyncCache.clear();
    }
  }

  clearCaches() {
    this.clearLoadCache();
    this.clearSearchCache();
  }

  validateConfig() {
    const config = this.config;

    config.searchPlaces.forEach(place => {
      const loaderKey = path.extname(place) || 'noExt';
      const loader = config.loaders[loaderKey];
      if (!loader) {
        throw new Error(
          `No loader specified for ${getExtensionDescription(
            place
          )}, so searchPlaces item "${place}" is invalid`
        );
      }
    });
  }

  search(searchFrom         )                             {
    searchFrom = searchFrom || process.cwd();
    return getDirectory(searchFrom).then(dir => {
      return this.searchFromDirectory(dir);
    });
  }

  searchFromDirectory(dir        )                             {
    const absoluteDir = path.resolve(process.cwd(), dir);
    const run = () => {
      return this.searchDirectory(absoluteDir).then(result => {
        const nextDir = this.nextDirectoryToSearch(absoluteDir, result);
        if (nextDir) {
          return this.searchFromDirectory(nextDir);
        }
        return this.config.transform(result);
      });
    };

    if (this.searchCache) {
      return cacheWrapper(this.searchCache, absoluteDir, run);
    }
    return run();
  }

  searchSync(searchFrom         )                    {
    searchFrom = searchFrom || process.cwd();
    const dir = getDirectory.sync(searchFrom);
    return this.searchFromDirectorySync(dir);
  }

  searchFromDirectorySync(dir        )                    {
    const absoluteDir = path.resolve(process.cwd(), dir);
    const run = () => {
      const result = this.searchDirectorySync(absoluteDir);
      const nextDir = this.nextDirectoryToSearch(absoluteDir, result);
      if (nextDir) {
        return this.searchFromDirectorySync(nextDir);
      }
      return this.config.transform(result);
    };

    if (this.searchSyncCache) {
      return cacheWrapper(this.searchSyncCache, absoluteDir, run);
    }
    return run();
  }

  searchDirectory(dir        )                             {
    return this.config.searchPlaces.reduce((prevResultPromise, place) => {
      return prevResultPromise.then(prevResult => {
        if (this.shouldSearchStopWithResult(prevResult)) {
          return prevResult;
        }
        return this.loadSearchPlace(dir, place);
      });
    }, Promise.resolve(null));
  }

  searchDirectorySync(dir        )                    {
    let result = null;
    for (const place of this.config.searchPlaces) {
      result = this.loadSearchPlaceSync(dir, place);
      if (this.shouldSearchStopWithResult(result)) break;
    }
    return result;
  }

  shouldSearchStopWithResult(result                   )          {
    if (result === null) return false;
    if (result.isEmpty && this.config.ignoreEmptySearchPlaces) return false;
    return true;
  }

  loadSearchPlace(dir        , place        )                             {
    const filepath = path.join(dir, place);
    return readFile(filepath).then(content => {
      return this.createCosmiconfigResult(filepath, content);
    });
  }

  loadSearchPlaceSync(dir        , place        )                    {
    const filepath = path.join(dir, place);
    const content = readFile.sync(filepath);
    return this.createCosmiconfigResultSync(filepath, content);
  }

  nextDirectoryToSearch(
    currentDir        ,
    currentResult                   
  )          {
    if (this.shouldSearchStopWithResult(currentResult)) {
      return null;
    }
    const nextDir = nextDirUp(currentDir);
    if (nextDir === currentDir || currentDir === this.config.stopDir) {
      return null;
    }
    return nextDir;
  }

  loadPackageProp(filepath        , content        ) {
    const parsedContent = loaders.loadJson(filepath, content);
    const packagePropValue = get(parsedContent, this.config.packageProp);
    return packagePropValue || null;
  }

  getLoaderEntryForFile(filepath        )              {
    if (path.basename(filepath) === 'package.json') {
      const loader = this.loadPackageProp.bind(this);
      return { sync: loader, async: loader };
    }

    const loaderKey = path.extname(filepath) || 'noExt';
    return this.config.loaders[loaderKey] || {};
  }

  getSyncLoaderForFile(filepath        )             {
    const entry = this.getLoaderEntryForFile(filepath);
    if (!entry.sync) {
      throw new Error(
        `No sync loader specified for ${getExtensionDescription(filepath)}`
      );
    }
    return entry.sync;
  }

  getAsyncLoaderForFile(filepath        )              {
    const entry = this.getLoaderEntryForFile(filepath);
    const loader = entry.async || entry.sync;
    if (!loader) {
      throw new Error(
        `No async loader specified for ${getExtensionDescription(filepath)}`
      );
    }
    return loader;
  }

  loadFileContent(
    mode                  ,
    filepath        ,
    content               
  )                                                 {
    if (content === null) {
      return null;
    }
    if (content.trim() === '') {
      return undefined;
    }
    const loader =
      mode === MODE_SYNC
        ? this.getSyncLoaderForFile(filepath)
        : this.getAsyncLoaderForFile(filepath);
    return loader(filepath, content);
  }

  loadedContentToCosmiconfigResult(
    filepath        ,
    loadedContent                   
  )                    {
    if (loadedContent === null) {
      return null;
    }
    if (loadedContent === undefined) {
      return { filepath, config: undefined, isEmpty: true };
    }
    return { config: loadedContent, filepath };
  }

  createCosmiconfigResult(
    filepath        ,
    content               
  )                             {
    return Promise.resolve()
      .then(() => {
        return this.loadFileContent('async', filepath, content);
      })
      .then(loaderResult => {
        return this.loadedContentToCosmiconfigResult(filepath, loaderResult);
      });
  }

  createCosmiconfigResultSync(
    filepath        ,
    content               
  )                    {
    const loaderResult = this.loadFileContent('sync', filepath, content);
    return this.loadedContentToCosmiconfigResult(filepath, loaderResult);
  }

  validateFilePath(filepath         ) {
    if (!filepath) {
      throw new Error('load and loadSync must pass a non-empty string');
    }
  }

  load(filepath        )                             {
    return Promise.resolve().then(() => {
      this.validateFilePath(filepath);
      const absoluteFilePath = path.resolve(process.cwd(), filepath);
      return cacheWrapper(this.loadCache, absoluteFilePath, () => {
        return readFile(absoluteFilePath, { throwNotFound: true })
          .then(content => {
            return this.createCosmiconfigResult(absoluteFilePath, content);
          })
          .then(this.config.transform);
      });
    });
  }

  loadSync(filepath        )                    {
    this.validateFilePath(filepath);
    const absoluteFilePath = path.resolve(process.cwd(), filepath);
    return cacheWrapper(this.loadSyncCache, absoluteFilePath, () => {
      const content = readFile.sync(absoluteFilePath, { throwNotFound: true });
      const result = this.createCosmiconfigResultSync(
        absoluteFilePath,
        content
      );
      return this.config.transform(result);
    });
  }
}

module.exports = function createExplorer(options                 ) {
  const explorer = new Explorer(options);

  return {
    search: explorer.search.bind(explorer),
    searchSync: explorer.searchSync.bind(explorer),
    load: explorer.load.bind(explorer),
    loadSync: explorer.loadSync.bind(explorer),
    clearLoadCache: explorer.clearLoadCache.bind(explorer),
    clearSearchCache: explorer.clearSearchCache.bind(explorer),
    clearCaches: explorer.clearCaches.bind(explorer),
  };
};

function nextDirUp(dir        )         {
  return path.dirname(dir);
}

function getExtensionDescription(filepath        )         {
  const ext = path.extname(filepath);
  return ext ? `extension "${ext}"` : 'files without extensions';
}

}).call(this,require('_process'))
},{"./cacheWrapper":544,"./getDirectory":546,"./loaders":548,"./readFile":549,"_process":1098,"lodash.get":784,"path":802}],546:[function(require,module,exports){
//      
'use strict';

const path = require('path');
const isDirectory = require('is-directory');

function getDirectory(filepath        )                  {
  return new Promise((resolve, reject) => {
    return isDirectory(filepath, (err, filepathIsDirectory) => {
      if (err) {
        return reject(err);
      }
      return resolve(filepathIsDirectory ? filepath : path.dirname(filepath));
    });
  });
}

getDirectory.sync = function getDirectorySync(filepath        )         {
  return isDirectory.sync(filepath) ? filepath : path.dirname(filepath);
};

module.exports = getDirectory;

},{"is-directory":745,"path":802}],547:[function(require,module,exports){
//      
'use strict';

const os = require('os');
const createExplorer = require('./createExplorer');
const loaders = require('./loaders');

module.exports = cosmiconfig;

function cosmiconfig(
  moduleName        ,
  options   
                         
                     
                                 
                                      
                     
                    
                                                       
   
) {
  options = options || {};
  const defaults = {
    packageProp: moduleName,
    searchPlaces: [
      'package.json',
      `.${moduleName}rc`,
      `.${moduleName}rc.json`,
      `.${moduleName}rc.yaml`,
      `.${moduleName}rc.yml`,
      `.${moduleName}rc.js`,
      `${moduleName}.config.js`,
    ],
    ignoreEmptySearchPlaces: true,
    stopDir: os.homedir(),
    cache: true,
    transform: identity,
  };
  const normalizedOptions                  = Object.assign(
    {},
    defaults,
    options,
    {
      loaders: normalizeLoaders(options.loaders),
    }
  );

  return createExplorer(normalizedOptions);
}

cosmiconfig.loadJs = loaders.loadJs;
cosmiconfig.loadJson = loaders.loadJson;
cosmiconfig.loadYaml = loaders.loadYaml;

function normalizeLoaders(rawLoaders         )          {
  const defaults = {
    '.js': { sync: loaders.loadJs, async: loaders.loadJs },
    '.json': { sync: loaders.loadJson, async: loaders.loadJson },
    '.yaml': { sync: loaders.loadYaml, async: loaders.loadYaml },
    '.yml': { sync: loaders.loadYaml, async: loaders.loadYaml },
    noExt: { sync: loaders.loadYaml, async: loaders.loadYaml },
  };

  if (!rawLoaders) {
    return defaults;
  }

  return Object.keys(rawLoaders).reduce((result, ext) => {
    const entry = rawLoaders && rawLoaders[ext];
    if (typeof entry === 'function') {
      result[ext] = { sync: entry, async: entry };
    } else {
      result[ext] = entry;
    }
    return result;
  }, defaults);
}

function identity(x) {
  return x;
}

},{"./createExplorer":545,"./loaders":548,"os":800}],548:[function(require,module,exports){
//      
'use strict';

const parseJson = require('parse-json');
const yaml = require('js-yaml');
const importFresh = require('import-fresh');

function loadJs(filepath        )         {
  const result = importFresh(filepath);
  return result;
}

function loadJson(filepath        , content        )         {
  try {
    return parseJson(content);
  } catch (err) {
    err.message = `JSON Error in ${filepath}:\n${err.message}`;
    throw err;
  }
}

function loadYaml(filepath        , content        )         {
  return yaml.safeLoad(content, { filename: filepath });
}

module.exports = {
  loadJs,
  loadJson,
  loadYaml,
};

},{"import-fresh":726,"js-yaml":753,"parse-json":801}],549:[function(require,module,exports){
//      
'use strict';

const fs = require('fs');

                
                          
  

function readFile(filepath        , options          )                         {
  options = options || {};
  const throwNotFound = options.throwNotFound || false;

  return new Promise((resolve, reject) => {
    fs.readFile(filepath, 'utf8', (err, content) => {
      if (err && err.code === 'ENOENT' && !throwNotFound) {
        return resolve(null);
      }
      if (err) return reject(err);
      resolve(content);
    });
  });
}

readFile.sync = function readFileSync(
  filepath        ,
  options          
)                {
  options = options || {};
  const throwNotFound = options.throwNotFound || false;

  try {
    return fs.readFileSync(filepath, 'utf8');
  } catch (err) {
    if (err.code === 'ENOENT' && !throwNotFound) {
      return null;
    }
    throw err;
  }
};

module.exports = readFile;

},{"fs":8}],550:[function(require,module,exports){
module.exports={
  "aliceblue": "#f0f8ff",
  "antiquewhite": "#faebd7",
  "aqua": "#00ffff",
  "aquamarine": "#7fffd4",
  "azure": "#f0ffff",
  "beige": "#f5f5dc",
  "bisque": "#ffe4c4",
  "black": "#000000",
  "blanchedalmond": "#ffebcd",
  "blue": "#0000ff",
  "blueviolet": "#8a2be2",
  "brown": "#a52a2a",
  "burlywood": "#deb887",
  "cadetblue": "#5f9ea0",
  "chartreuse": "#7fff00",
  "chocolate": "#d2691e",
  "coral": "#ff7f50",
  "cornflowerblue": "#6495ed",
  "cornsilk": "#fff8dc",
  "crimson": "#dc143c",
  "cyan": "#00ffff",
  "darkblue": "#00008b",
  "darkcyan": "#008b8b",
  "darkgoldenrod": "#b8860b",
  "darkgray": "#a9a9a9",
  "darkgreen": "#006400",
  "darkgrey": "#a9a9a9",
  "darkkhaki": "#bdb76b",
  "darkmagenta": "#8b008b",
  "darkolivegreen": "#556b2f",
  "darkorange": "#ff8c00",
  "darkorchid": "#9932cc",
  "darkred": "#8b0000",
  "darksalmon": "#e9967a",
  "darkseagreen": "#8fbc8f",
  "darkslateblue": "#483d8b",
  "darkslategray": "#2f4f4f",
  "darkslategrey": "#2f4f4f",
  "darkturquoise": "#00ced1",
  "darkviolet": "#9400d3",
  "deeppink": "#ff1493",
  "deepskyblue": "#00bfff",
  "dimgray": "#696969",
  "dimgrey": "#696969",
  "dodgerblue": "#1e90ff",
  "firebrick": "#b22222",
  "floralwhite": "#fffaf0",
  "forestgreen": "#228b22",
  "fuchsia": "#ff00ff",
  "gainsboro": "#dcdcdc",
  "ghostwhite": "#f8f8ff",
  "gold": "#ffd700",
  "goldenrod": "#daa520",
  "gray": "#808080",
  "green": "#008000",
  "greenyellow": "#adff2f",
  "grey": "#808080",
  "honeydew": "#f0fff0",
  "hotpink": "#ff69b4",
  "indianred": "#cd5c5c",
  "indigo": "#4b0082",
  "ivory": "#fffff0",
  "khaki": "#f0e68c",
  "lavender": "#e6e6fa",
  "lavenderblush": "#fff0f5",
  "lawngreen": "#7cfc00",
  "lemonchiffon": "#fffacd",
  "lightblue": "#add8e6",
  "lightcoral": "#f08080",
  "lightcyan": "#e0ffff",
  "lightgoldenrodyellow": "#fafad2",
  "lightgray": "#d3d3d3",
  "lightgreen": "#90ee90",
  "lightgrey": "#d3d3d3",
  "lightpink": "#ffb6c1",
  "lightsalmon": "#ffa07a",
  "lightseagreen": "#20b2aa",
  "lightskyblue": "#87cefa",
  "lightslategray": "#778899",
  "lightslategrey": "#778899",
  "lightsteelblue": "#b0c4de",
  "lightyellow": "#ffffe0",
  "lime": "#00ff00",
  "limegreen": "#32cd32",
  "linen": "#faf0e6",
  "magenta": "#ff00ff",
  "maroon": "#800000",
  "mediumaquamarine": "#66cdaa",
  "mediumblue": "#0000cd",
  "mediumorchid": "#ba55d3",
  "mediumpurple": "#9370db",
  "mediumseagreen": "#3cb371",
  "mediumslateblue": "#7b68ee",
  "mediumspringgreen": "#00fa9a",
  "mediumturquoise": "#48d1cc",
  "mediumvioletred": "#c71585",
  "midnightblue": "#191970",
  "mintcream": "#f5fffa",
  "mistyrose": "#ffe4e1",
  "moccasin": "#ffe4b5",
  "navajowhite": "#ffdead",
  "navy": "#000080",
  "oldlace": "#fdf5e6",
  "olive": "#808000",
  "olivedrab": "#6b8e23",
  "orange": "#ffa500",
  "orangered": "#ff4500",
  "orchid": "#da70d6",
  "palegoldenrod": "#eee8aa",
  "palegreen": "#98fb98",
  "paleturquoise": "#afeeee",
  "palevioletred": "#db7093",
  "papayawhip": "#ffefd5",
  "peachpuff": "#ffdab9",
  "peru": "#cd853f",
  "pink": "#ffc0cb",
  "plum": "#dda0dd",
  "powderblue": "#b0e0e6",
  "purple": "#800080",
  "rebeccapurple": "#663399",
  "red": "#ff0000",
  "rosybrown": "#bc8f8f",
  "royalblue": "#4169e1",
  "saddlebrown": "#8b4513",
  "salmon": "#fa8072",
  "sandybrown": "#f4a460",
  "seagreen": "#2e8b57",
  "seashell": "#fff5ee",
  "sienna": "#a0522d",
  "silver": "#c0c0c0",
  "skyblue": "#87ceeb",
  "slateblue": "#6a5acd",
  "slategray": "#708090",
  "slategrey": "#708090",
  "snow": "#fffafa",
  "springgreen": "#00ff7f",
  "steelblue": "#4682b4",
  "tan": "#d2b48c",
  "teal": "#008080",
  "thistle": "#d8bfd8",
  "tomato": "#ff6347",
  "turquoise": "#40e0d0",
  "violet": "#ee82ee",
  "wheat": "#f5deb3",
  "white": "#ffffff",
  "whitesmoke": "#f5f5f5",
  "yellow": "#ffff00",
  "yellowgreen": "#9acd32"
}

},{}],551:[function(require,module,exports){
(function (__dirname){
'use strict';

const fs = require('fs');
const path = require('path');

const postcss = require('postcss');
const timsort = require('timsort').sort;

module.exports = postcss.plugin('css-declaration-sorter', function (options) {
  return function (css) {
    let sortOrderPath;

    options = options || {};

    // Use included sorting order if order is passed and not alphabetically
    if (options.order && options.order !== 'alphabetically') {
      sortOrderPath = path.join(__dirname, '../orders/', options.order) + '.json';
    } else if (options.customOrder) {
      sortOrderPath = options.customOrder;
    } else {
      // Fallback to the default sorting order
      return processCss(css, 'alphabetically');
    }

    // Load in the array containing the order from a JSON file
    return new Promise(function (resolve, reject) {
      fs.readFile(sortOrderPath, function (error, data) {
        if (error) return reject(error);
        resolve(data);
      });
    }).then(function (data) {
      return processCss(css, JSON.parse(data));
    });
  };
});

function processCss (css, sortOrder) {
  const comments = [];
  const rulesCache = [];

  css.walk(function (node) {
    const nodes = node.nodes;
    const type = node.type;

    if (type === 'comment') {
      // Don't do anything to root comments or the last newline comment
      const isNewlineNode = ~node.raws.before.indexOf('\n');
      const lastNewlineNode = isNewlineNode && !node.next();
      const onlyNode = !node.prev() && !node.next();

      if (lastNewlineNode || onlyNode || node.parent.type === 'root') {
        return;
      }

      if (isNewlineNode) {
        const pairedNode = node.next() ? node.next() : node.prev().prev();
        if (pairedNode) {
          comments.unshift({
            'comment': node,
            'pairedNode': pairedNode,
            'insertPosition': node.next() ? 'Before' : 'After',
          });
          node.remove();
        }
      } else {
        const pairedNode = node.prev() ? node.prev() : node.next().next();
        if (pairedNode) {
          comments.push({
            'comment': node,
            'pairedNode': pairedNode,
            'insertPosition': 'After',
          });
          node.remove();
        }
      }
      return;
    }

    // Add rule-like nodes to a cache so that we can remove all
    // comment nodes before we start sorting.
    const isRule = type === 'rule' || type === 'atrule';
    if (isRule && nodes && nodes.length > 1) {
      rulesCache.push(nodes);
    }
  });

  // Perform a sort once all comment nodes are removed
  rulesCache.forEach(function (nodes) {
    sortCssDecls(nodes, sortOrder);
  });

  // Add comments back to the nodes they are paired with
  comments.forEach(function (node) {
    const pairedNode = node.pairedNode;
    node.comment.remove();
    pairedNode.parent['insert' + node.insertPosition](pairedNode, node.comment);
  });
}

// Sort CSS declarations alphabetically or using the set sorting order
function sortCssDecls (cssDecls, sortOrder) {
  if (sortOrder === 'alphabetically') {
    timsort(cssDecls, function (a, b) {
      if (a.type === 'decl' && b.type === 'decl') {
        return comparator(a.prop, b.prop);
      } else {
        return compareDifferentType(a, b);
      }
    });
  } else {
    timsort(cssDecls, function (a, b) {
      if (a.type === 'decl' && b.type === 'decl') {
        const aIndex = sortOrder.indexOf(a.prop);
        const bIndex = sortOrder.indexOf(b.prop);
        return comparator(aIndex, bIndex);
      } else {
        return compareDifferentType(a, b);
      }
    });
  }
}

function comparator (a, b) {
  return a === b ? 0 : a < b ? -1 : 1;
}

function compareDifferentType (a, b) {
  if (b.type === 'atrule') { return  0; }

  return (a.type === 'decl') ? -1 : (b.type === 'decl') ? 1 : 0;
}

}).call(this,"/node_modules/css-declaration-sorter/src")
},{"fs":8,"path":802,"postcss":1074,"timsort":1197}],552:[function(require,module,exports){
'use strict'

module.exports = adapterFactory;

function adapterFactory(implementation){
	ensureImplementation(implementation);

	var adapter = {}

	var baseAdapter = {
		removeSubsets: function (nodes){
			return removeSubsets(adapter, nodes);
		},
		existsOne: function(test, elems){
			return existsOne(adapter, test, elems);
		},
		getSiblings: function(elem){
			return getSiblings(adapter, elem);
		},
		hasAttrib: function(elem, name){
			return hasAttrib(adapter, elem, name);
		},
		findOne: function(test, arr){
			return findOne(adapter, test, arr);
		},
		findAll: function(test, elems){
			return findAll(adapter, test, elems)
		}
	};

	Object.assign(adapter, baseAdapter, implementation);

	return adapter;
}

var expectImplemented = [
	"isTag", "getAttributeValue", "getChildren", "getName", "getParent",
	"getText"
];

function ensureImplementation(implementation){
	if(!implementation)	throw new TypeError("Expected implementation")

	var notImplemented = expectImplemented.filter(function(fname){
		return typeof implementation[fname] !== "function";
	});

	if(notImplemented.length){
		var notList = "(" + notImplemented.join(", ") + ")";
		var message = "Expected functions " + notList + " to be implemented";
		throw new Error(message);
	}
}

function removeSubsets(adapter, nodes){
	var idx = nodes.length, node, ancestor, replace;

	// Check if each node (or one of its ancestors) is already contained in the
	// array.
	while(--idx > -1){
		node = ancestor = nodes[idx];

		// Temporarily remove the node under consideration
		nodes[idx] = null;
		replace = true;

		while(ancestor){
			if(nodes.indexOf(ancestor) > -1){
				replace = false;
				nodes.splice(idx, 1);
				break;
			}
			ancestor = adapter.getParent(ancestor)
		}

		// If the node has been found to be unique, re-insert it.
		if(replace){
			nodes[idx] = node;
		}
	}

	return nodes;
}

function existsOne(adapter, test, elems){
	return elems.some(function(elem){
		return adapter.isTag(elem) ?
			test(elem) || adapter.existsOne(test, adapter.getChildren(elem)) :
			false;
	});
}

function getSiblings(adapter, elem){
	var parent = adapter.getParent(elem);
	return parent && adapter.getChildren(parent);
}


function hasAttrib(adapter, elem, name){
	return adapter.getAttributeValue(elem,name) !== undefined
}

function findOne(adapter, test, arr){
	var elem = null;

	for(var i = 0, l = arr.length; i < l && !elem; i++){
		if(test(arr[i])){
			elem = arr[i];
		} else {
			var childs = adapter.getChildren(arr[i]);
			if(childs && childs.length > 0){
				elem = adapter.findOne(test, childs);
			}
		}
	}

	return elem;
}

function findAll(adapter, test, elems){
	var result = [];

	for(var i = 0, j = elems.length; i < j; i++){
		if(!adapter.isTag(elems[i])) continue;
		if(test(elems[i])) result.push(elems[i]);
		var childs = adapter.getChildren(elems[i]);
		if(childs) result = result.concat(adapter.findAll(test, childs));
	}

	return result;
}

},{}],553:[function(require,module,exports){
"use strict";

module.exports = CSSselect;

var DomUtils = require("domutils");
var falseFunc = require("boolbase").falseFunc;
var compileRaw = require("./lib/compile.js");

function wrapCompile(func) {
    return function addAdapter(selector, options, context) {
        options = options || {};
        options.adapter = options.adapter || DomUtils;

        return func(selector, options, context);
    };
}

var compile = wrapCompile(compileRaw);
var compileUnsafe = wrapCompile(compileRaw.compileUnsafe);

function getSelectorFunc(searchFunc) {
    return function select(query, elems, options) {
        options = options || {};
        options.adapter = options.adapter || DomUtils;

        if (typeof query !== "function") {
            query = compileUnsafe(query, options, elems);
        }
        if (query.shouldTestNextSiblings) {
            elems = appendNextSiblings((options && options.context) || elems, options.adapter);
        }
        if (!Array.isArray(elems)) elems = options.adapter.getChildren(elems);
        else elems = options.adapter.removeSubsets(elems);
        return searchFunc(query, elems, options);
    };
}

function getNextSiblings(elem, adapter) {
    var siblings = adapter.getSiblings(elem);
    if (!Array.isArray(siblings)) return [];
    siblings = siblings.slice(0);
    while (siblings.shift() !== elem);
    return siblings;
}

function appendNextSiblings(elems, adapter) {
    // Order matters because jQuery seems to check the children before the siblings
    if (!Array.isArray(elems)) elems = [elems];
    var newElems = elems.slice(0);

    for (var i = 0, len = elems.length; i < len; i++) {
        var nextSiblings = getNextSiblings(newElems[i], adapter);
        newElems.push.apply(newElems, nextSiblings);
    }
    return newElems;
}

var selectAll = getSelectorFunc(function selectAll(query, elems, options) {
    return query === falseFunc || !elems || elems.length === 0 ? [] : options.adapter.findAll(query, elems);
});

var selectOne = getSelectorFunc(function selectOne(query, elems, options) {
    return query === falseFunc || !elems || elems.length === 0 ? null : options.adapter.findOne(query, elems);
});

function is(elem, query, options) {
    options = options || {};
    options.adapter = options.adapter || DomUtils;
    return (typeof query === "function" ? query : compile(query, options))(elem);
}

/*
	the exported interface
*/
function CSSselect(query, elems, options) {
    return selectAll(query, elems, options);
}

CSSselect.compile = compile;
CSSselect.filters = compileRaw.Pseudos.filters;
CSSselect.pseudos = compileRaw.Pseudos.pseudos;

CSSselect.selectAll = selectAll;
CSSselect.selectOne = selectOne;

CSSselect.is = is;

//legacy methods (might be removed)
CSSselect.parse = compile;
CSSselect.iterate = selectAll;

//hooks
CSSselect._compileUnsafe = compileUnsafe;
CSSselect._compileToken = compileRaw.compileToken;

},{"./lib/compile.js":555,"boolbase":6,"domutils":678}],554:[function(require,module,exports){
var falseFunc = require("boolbase").falseFunc;

//https://github.com/slevithan/XRegExp/blob/master/src/xregexp.js#L469
var reChars = /[-[\]{}()*+?.,\\^$|#\s]/g;

/*
	attribute selectors
*/
var attributeRules = {
    __proto__: null,
    equals: function(next, data, options) {
        var name = data.name;
        var value = data.value;
        var adapter = options.adapter;

        if (data.ignoreCase) {
            value = value.toLowerCase();

            return function equalsIC(elem) {
                var attr = adapter.getAttributeValue(elem, name);
                return attr != null && attr.toLowerCase() === value && next(elem);
            };
        }

        return function equals(elem) {
            return adapter.getAttributeValue(elem, name) === value && next(elem);
        };
    },
    hyphen: function(next, data, options) {
        var name = data.name;
        var value = data.value;
        var len = value.length;
        var adapter = options.adapter;

        if (data.ignoreCase) {
            value = value.toLowerCase();

            return function hyphenIC(elem) {
                var attr = adapter.getAttributeValue(elem, name);
                return (
                    attr != null &&
                    (attr.length === len || attr.charAt(len) === "-") &&
                    attr.substr(0, len).toLowerCase() === value &&
                    next(elem)
                );
            };
        }

        return function hyphen(elem) {
            var attr = adapter.getAttributeValue(elem, name);
            return (
                attr != null &&
                attr.substr(0, len) === value &&
                (attr.length === len || attr.charAt(len) === "-") &&
                next(elem)
            );
        };
    },
    element: function(next, data, options) {
        var name = data.name;
        var value = data.value;
        var adapter = options.adapter;

        if (/\s/.test(value)) {
            return falseFunc;
        }

        value = value.replace(reChars, "\\$&");

        var pattern = "(?:^|\\s)" + value + "(?:$|\\s)",
            flags = data.ignoreCase ? "i" : "",
            regex = new RegExp(pattern, flags);

        return function element(elem) {
            var attr = adapter.getAttributeValue(elem, name);
            return attr != null && regex.test(attr) && next(elem);
        };
    },
    exists: function(next, data, options) {
        var name = data.name;
        var adapter = options.adapter;

        return function exists(elem) {
            return adapter.hasAttrib(elem, name) && next(elem);
        };
    },
    start: function(next, data, options) {
        var name = data.name;
        var value = data.value;
        var len = value.length;
        var adapter = options.adapter;

        if (len === 0) {
            return falseFunc;
        }

        if (data.ignoreCase) {
            value = value.toLowerCase();

            return function startIC(elem) {
                var attr = adapter.getAttributeValue(elem, name);
                return attr != null && attr.substr(0, len).toLowerCase() === value && next(elem);
            };
        }

        return function start(elem) {
            var attr = adapter.getAttributeValue(elem, name);
            return attr != null && attr.substr(0, len) === value && next(elem);
        };
    },
    end: function(next, data, options) {
        var name = data.name;
        var value = data.value;
        var len = -value.length;
        var adapter = options.adapter;

        if (len === 0) {
            return falseFunc;
        }

        if (data.ignoreCase) {
            value = value.toLowerCase();

            return function endIC(elem) {
                var attr = adapter.getAttributeValue(elem, name);
                return attr != null && attr.substr(len).toLowerCase() === value && next(elem);
            };
        }

        return function end(elem) {
            var attr = adapter.getAttributeValue(elem, name);
            return attr != null && attr.substr(len) === value && next(elem);
        };
    },
    any: function(next, data, options) {
        var name = data.name;
        var value = data.value;
        var adapter = options.adapter;

        if (value === "") {
            return falseFunc;
        }

        if (data.ignoreCase) {
            var regex = new RegExp(value.replace(reChars, "\\$&"), "i");

            return function anyIC(elem) {
                var attr = adapter.getAttributeValue(elem, name);
                return attr != null && regex.test(attr) && next(elem);
            };
        }

        return function any(elem) {
            var attr = adapter.getAttributeValue(elem, name);
            return attr != null && attr.indexOf(value) >= 0 && next(elem);
        };
    },
    not: function(next, data, options) {
        var name = data.name;
        var value = data.value;
        var adapter = options.adapter;

        if (value === "") {
            return function notEmpty(elem) {
                return !!adapter.getAttributeValue(elem, name) && next(elem);
            };
        } else if (data.ignoreCase) {
            value = value.toLowerCase();

            return function notIC(elem) {
                var attr = adapter.getAttributeValue(elem, name);
                return attr != null && attr.toLowerCase() !== value && next(elem);
            };
        }

        return function not(elem) {
            return adapter.getAttributeValue(elem, name) !== value && next(elem);
        };
    }
};

module.exports = {
    compile: function(next, data, options) {
        if (options && options.strict && (data.ignoreCase || data.action === "not")) {
            throw new Error("Unsupported attribute selector");
        }
        return attributeRules[data.action](next, data, options);
    },
    rules: attributeRules
};

},{"boolbase":6}],555:[function(require,module,exports){
/*
	compiles a selector to an executable function
*/

module.exports = compile;

var parse = require("css-what");
var BaseFuncs = require("boolbase");
var sortRules = require("./sort.js");
var procedure = require("./procedure.json");
var Rules = require("./general.js");
var Pseudos = require("./pseudos.js");
var trueFunc = BaseFuncs.trueFunc;
var falseFunc = BaseFuncs.falseFunc;

var filters = Pseudos.filters;

function compile(selector, options, context) {
    var next = compileUnsafe(selector, options, context);
    return wrap(next, options);
}

function wrap(next, options) {
    var adapter = options.adapter;

    return function base(elem) {
        return adapter.isTag(elem) && next(elem);
    };
}

function compileUnsafe(selector, options, context) {
    var token = parse(selector, options);
    return compileToken(token, options, context);
}

function includesScopePseudo(t) {
    return (
        t.type === "pseudo" &&
        (t.name === "scope" ||
            (Array.isArray(t.data) &&
                t.data.some(function(data) {
                    return data.some(includesScopePseudo);
                })))
    );
}

var DESCENDANT_TOKEN = { type: "descendant" };
var FLEXIBLE_DESCENDANT_TOKEN = { type: "_flexibleDescendant" };
var SCOPE_TOKEN = { type: "pseudo", name: "scope" };
var PLACEHOLDER_ELEMENT = {};

//CSS 4 Spec (Draft): 3.3.1. Absolutizing a Scope-relative Selector
//http://www.w3.org/TR/selectors4/#absolutizing
function absolutize(token, options, context) {
    var adapter = options.adapter;

    //TODO better check if context is document
    var hasContext =
        !!context &&
        !!context.length &&
        context.every(function(e) {
            return e === PLACEHOLDER_ELEMENT || !!adapter.getParent(e);
        });

    token.forEach(function(t) {
        if (t.length > 0 && isTraversal(t[0]) && t[0].type !== "descendant") {
            //don't return in else branch
        } else if (hasContext && !includesScopePseudo(t)) {
            t.unshift(DESCENDANT_TOKEN);
        } else {
            return;
        }

        t.unshift(SCOPE_TOKEN);
    });
}

function compileToken(token, options, context) {
    token = token.filter(function(t) {
        return t.length > 0;
    });

    token.forEach(sortRules);

    var isArrayContext = Array.isArray(context);

    context = (options && options.context) || context;

    if (context && !isArrayContext) context = [context];

    absolutize(token, options, context);

    var shouldTestNextSiblings = false;

    var query = token
        .map(function(rules) {
            if (rules[0] && rules[1] && rules[0].name === "scope") {
                var ruleType = rules[1].type;
                if (isArrayContext && ruleType === "descendant") {
                    rules[1] = FLEXIBLE_DESCENDANT_TOKEN;
                } else if (ruleType === "adjacent" || ruleType === "sibling") {
                    shouldTestNextSiblings = true;
                }
            }
            return compileRules(rules, options, context);
        })
        .reduce(reduceRules, falseFunc);

    query.shouldTestNextSiblings = shouldTestNextSiblings;

    return query;
}

function isTraversal(t) {
    return procedure[t.type] < 0;
}

function compileRules(rules, options, context) {
    return rules.reduce(function(func, rule) {
        if (func === falseFunc) return func;

        if (!(rule.type in Rules)) {
            throw new Error("Rule type " + rule.type + " is not supported by css-select");
        }

        return Rules[rule.type](func, rule, options, context);
    }, (options && options.rootFunc) || trueFunc);
}

function reduceRules(a, b) {
    if (b === falseFunc || a === trueFunc) {
        return a;
    }
    if (a === falseFunc || b === trueFunc) {
        return b;
    }

    return function combine(elem) {
        return a(elem) || b(elem);
    };
}

function containsTraversal(t) {
    return t.some(isTraversal);
}

//:not, :has and :matches have to compile selectors
//doing this in lib/pseudos.js would lead to circular dependencies,
//so we add them here
filters.not = function(next, token, options, context) {
    var opts = {
        xmlMode: !!(options && options.xmlMode),
        strict: !!(options && options.strict),
        adapter: options.adapter
    };

    if (opts.strict) {
        if (token.length > 1 || token.some(containsTraversal)) {
            throw new Error("complex selectors in :not aren't allowed in strict mode");
        }
    }

    var func = compileToken(token, opts, context);

    if (func === falseFunc) return next;
    if (func === trueFunc) return falseFunc;

    return function not(elem) {
        return !func(elem) && next(elem);
    };
};

filters.has = function(next, token, options) {
    var adapter = options.adapter;
    var opts = {
        xmlMode: !!(options && options.xmlMode),
        strict: !!(options && options.strict),
        adapter: adapter
    };

    //FIXME: Uses an array as a pointer to the current element (side effects)
    var context = token.some(containsTraversal) ? [PLACEHOLDER_ELEMENT] : null;

    var func = compileToken(token, opts, context);

    if (func === falseFunc) return falseFunc;
    if (func === trueFunc) {
        return function hasChild(elem) {
            return adapter.getChildren(elem).some(adapter.isTag) && next(elem);
        };
    }

    func = wrap(func, options);

    if (context) {
        return function has(elem) {
            return next(elem) && ((context[0] = elem), adapter.existsOne(func, adapter.getChildren(elem)));
        };
    }

    return function has(elem) {
        return next(elem) && adapter.existsOne(func, adapter.getChildren(elem));
    };
};

filters.matches = function(next, token, options, context) {
    var opts = {
        xmlMode: !!(options && options.xmlMode),
        strict: !!(options && options.strict),
        rootFunc: next,
        adapter: options.adapter
    };

    return compileToken(token, opts, context);
};

compile.compileToken = compileToken;
compile.compileUnsafe = compileUnsafe;
compile.Pseudos = Pseudos;

},{"./general.js":556,"./procedure.json":557,"./pseudos.js":558,"./sort.js":559,"boolbase":6,"css-what":665}],556:[function(require,module,exports){
var attributes = require("./attributes.js");
var Pseudos = require("./pseudos");

/*
	all available rules
*/
module.exports = {
    __proto__: null,

    attribute: attributes.compile,
    pseudo: Pseudos.compile,

    //tags
    tag: function(next, data, options) {
        var name = data.name;
        var adapter = options.adapter;

        return function tag(elem) {
            return adapter.getName(elem) === name && next(elem);
        };
    },

    //traversal
    descendant: function(next, data, options) {
        // eslint-disable-next-line no-undef
        var isFalseCache = typeof WeakSet !== "undefined" ? new WeakSet() : null;
        var adapter = options.adapter;

        return function descendant(elem) {
            var found = false;

            while (!found && (elem = adapter.getParent(elem))) {
                if (!isFalseCache || !isFalseCache.has(elem)) {
                    found = next(elem);
                    if (!found && isFalseCache) {
                        isFalseCache.add(elem);
                    }
                }
            }

            return found;
        };
    },
    _flexibleDescendant: function(next, data, options) {
        var adapter = options.adapter;

        // Include element itself, only used while querying an array
        return function descendant(elem) {
            var found = next(elem);

            while (!found && (elem = adapter.getParent(elem))) {
                found = next(elem);
            }

            return found;
        };
    },
    parent: function(next, data, options) {
        if (options && options.strict) {
            throw new Error("Parent selector isn't part of CSS3");
        }

        var adapter = options.adapter;

        return function parent(elem) {
            return adapter.getChildren(elem).some(test);
        };

        function test(elem) {
            return adapter.isTag(elem) && next(elem);
        }
    },
    child: function(next, data, options) {
        var adapter = options.adapter;

        return function child(elem) {
            var parent = adapter.getParent(elem);
            return !!parent && next(parent);
        };
    },
    sibling: function(next, data, options) {
        var adapter = options.adapter;

        return function sibling(elem) {
            var siblings = adapter.getSiblings(elem);

            for (var i = 0; i < siblings.length; i++) {
                if (adapter.isTag(siblings[i])) {
                    if (siblings[i] === elem) break;
                    if (next(siblings[i])) return true;
                }
            }

            return false;
        };
    },
    adjacent: function(next, data, options) {
        var adapter = options.adapter;

        return function adjacent(elem) {
            var siblings = adapter.getSiblings(elem),
                lastElement;

            for (var i = 0; i < siblings.length; i++) {
                if (adapter.isTag(siblings[i])) {
                    if (siblings[i] === elem) break;
                    lastElement = siblings[i];
                }
            }

            return !!lastElement && next(lastElement);
        };
    },
    universal: function(next) {
        return next;
    }
};

},{"./attributes.js":554,"./pseudos":558}],557:[function(require,module,exports){
module.exports={
	"universal": 50,
	"tag": 30,
	"attribute": 1,
	"pseudo": 0,
	"descendant": -1,
	"child": -1,
	"parent": -1,
	"sibling": -1,
	"adjacent": -1
}

},{}],558:[function(require,module,exports){
/*
	pseudo selectors

	---

	they are available in two forms:
	* filters called when the selector
	  is compiled and return a function
	  that needs to return next()
	* pseudos get called on execution
	  they need to return a boolean
*/

var getNCheck = require("nth-check");
var BaseFuncs = require("boolbase");
var attributes = require("./attributes.js");
var trueFunc = BaseFuncs.trueFunc;
var falseFunc = BaseFuncs.falseFunc;

var checkAttrib = attributes.rules.equals;

function getAttribFunc(name, value) {
    var data = { name: name, value: value };
    return function attribFunc(next, rule, options) {
        return checkAttrib(next, data, options);
    };
}

function getChildFunc(next, adapter) {
    return function(elem) {
        return !!adapter.getParent(elem) && next(elem);
    };
}

var filters = {
    contains: function(next, text, options) {
        var adapter = options.adapter;

        return function contains(elem) {
            return next(elem) && adapter.getText(elem).indexOf(text) >= 0;
        };
    },
    icontains: function(next, text, options) {
        var itext = text.toLowerCase();
        var adapter = options.adapter;

        return function icontains(elem) {
            return (
                next(elem) &&
                adapter
                    .getText(elem)
                    .toLowerCase()
                    .indexOf(itext) >= 0
            );
        };
    },

    //location specific methods
    "nth-child": function(next, rule, options) {
        var func = getNCheck(rule);
        var adapter = options.adapter;

        if (func === falseFunc) return func;
        if (func === trueFunc) return getChildFunc(next, adapter);

        return function nthChild(elem) {
            var siblings = adapter.getSiblings(elem);

            for (var i = 0, pos = 0; i < siblings.length; i++) {
                if (adapter.isTag(siblings[i])) {
                    if (siblings[i] === elem) break;
                    else pos++;
                }
            }

            return func(pos) && next(elem);
        };
    },
    "nth-last-child": function(next, rule, options) {
        var func = getNCheck(rule);
        var adapter = options.adapter;

        if (func === falseFunc) return func;
        if (func === trueFunc) return getChildFunc(next, adapter);

        return function nthLastChild(elem) {
            var siblings = adapter.getSiblings(elem);

            for (var pos = 0, i = siblings.length - 1; i >= 0; i--) {
                if (adapter.isTag(siblings[i])) {
                    if (siblings[i] === elem) break;
                    else pos++;
                }
            }

            return func(pos) && next(elem);
        };
    },
    "nth-of-type": function(next, rule, options) {
        var func = getNCheck(rule);
        var adapter = options.adapter;

        if (func === falseFunc) return func;
        if (func === trueFunc) return getChildFunc(next, adapter);

        return function nthOfType(elem) {
            var siblings = adapter.getSiblings(elem);

            for (var pos = 0, i = 0; i < siblings.length; i++) {
                if (adapter.isTag(siblings[i])) {
                    if (siblings[i] === elem) break;
                    if (adapter.getName(siblings[i]) === adapter.getName(elem)) pos++;
                }
            }

            return func(pos) && next(elem);
        };
    },
    "nth-last-of-type": function(next, rule, options) {
        var func = getNCheck(rule);
        var adapter = options.adapter;

        if (func === falseFunc) return func;
        if (func === trueFunc) return getChildFunc(next, adapter);

        return function nthLastOfType(elem) {
            var siblings = adapter.getSiblings(elem);

            for (var pos = 0, i = siblings.length - 1; i >= 0; i--) {
                if (adapter.isTag(siblings[i])) {
                    if (siblings[i] === elem) break;
                    if (adapter.getName(siblings[i]) === adapter.getName(elem)) pos++;
                }
            }

            return func(pos) && next(elem);
        };
    },

    //TODO determine the actual root element
    root: function(next, rule, options) {
        var adapter = options.adapter;

        return function(elem) {
            return !adapter.getParent(elem) && next(elem);
        };
    },

    scope: function(next, rule, options, context) {
        var adapter = options.adapter;

        if (!context || context.length === 0) {
            //equivalent to :root
            return filters.root(next, rule, options);
        }

        function equals(a, b) {
            if (typeof adapter.equals === "function") return adapter.equals(a, b);

            return a === b;
        }

        if (context.length === 1) {
            //NOTE: can't be unpacked, as :has uses this for side-effects
            return function(elem) {
                return equals(context[0], elem) && next(elem);
            };
        }

        return function(elem) {
            return context.indexOf(elem) >= 0 && next(elem);
        };
    },

    //jQuery extensions (others follow as pseudos)
    checkbox: getAttribFunc("type", "checkbox"),
    file: getAttribFunc("type", "file"),
    password: getAttribFunc("type", "password"),
    radio: getAttribFunc("type", "radio"),
    reset: getAttribFunc("type", "reset"),
    image: getAttribFunc("type", "image"),
    submit: getAttribFunc("type", "submit")
};

//helper methods
function getFirstElement(elems, adapter) {
    for (var i = 0; elems && i < elems.length; i++) {
        if (adapter.isTag(elems[i])) return elems[i];
    }
}

//while filters are precompiled, pseudos get called when they are needed
var pseudos = {
    empty: function(elem, adapter) {
        return !adapter.getChildren(elem).some(function(elem) {
            return adapter.isTag(elem) || elem.type === "text";
        });
    },

    "first-child": function(elem, adapter) {
        return getFirstElement(adapter.getSiblings(elem), adapter) === elem;
    },
    "last-child": function(elem, adapter) {
        var siblings = adapter.getSiblings(elem);

        for (var i = siblings.length - 1; i >= 0; i--) {
            if (siblings[i] === elem) return true;
            if (adapter.isTag(siblings[i])) break;
        }

        return false;
    },
    "first-of-type": function(elem, adapter) {
        var siblings = adapter.getSiblings(elem);

        for (var i = 0; i < siblings.length; i++) {
            if (adapter.isTag(siblings[i])) {
                if (siblings[i] === elem) return true;
                if (adapter.getName(siblings[i]) === adapter.getName(elem)) break;
            }
        }

        return false;
    },
    "last-of-type": function(elem, adapter) {
        var siblings = adapter.getSiblings(elem);

        for (var i = siblings.length - 1; i >= 0; i--) {
            if (adapter.isTag(siblings[i])) {
                if (siblings[i] === elem) return true;
                if (adapter.getName(siblings[i]) === adapter.getName(elem)) break;
            }
        }

        return false;
    },
    "only-of-type": function(elem, adapter) {
        var siblings = adapter.getSiblings(elem);

        for (var i = 0, j = siblings.length; i < j; i++) {
            if (adapter.isTag(siblings[i])) {
                if (siblings[i] === elem) continue;
                if (adapter.getName(siblings[i]) === adapter.getName(elem)) {
                    return false;
                }
            }
        }

        return true;
    },
    "only-child": function(elem, adapter) {
        var siblings = adapter.getSiblings(elem);

        for (var i = 0; i < siblings.length; i++) {
            if (adapter.isTag(siblings[i]) && siblings[i] !== elem) return false;
        }

        return true;
    },

    //:matches(a, area, link)[href]
    link: function(elem, adapter) {
        return adapter.hasAttrib(elem, "href");
    },
    visited: falseFunc, //Valid implementation
    //TODO: :any-link once the name is finalized (as an alias of :link)

    //forms
    //to consider: :target

    //:matches([selected], select:not([multiple]):not(> option[selected]) > option:first-of-type)
    selected: function(elem, adapter) {
        if (adapter.hasAttrib(elem, "selected")) return true;
        else if (adapter.getName(elem) !== "option") return false;

        //the first <option> in a <select> is also selected
        var parent = adapter.getParent(elem);

        if (!parent || adapter.getName(parent) !== "select" || adapter.hasAttrib(parent, "multiple")) {
            return false;
        }

        var siblings = adapter.getChildren(parent);
        var sawElem = false;

        for (var i = 0; i < siblings.length; i++) {
            if (adapter.isTag(siblings[i])) {
                if (siblings[i] === elem) {
                    sawElem = true;
                } else if (!sawElem) {
                    return false;
                } else if (adapter.hasAttrib(siblings[i], "selected")) {
                    return false;
                }
            }
        }

        return sawElem;
    },
    //https://html.spec.whatwg.org/multipage/scripting.html#disabled-elements
    //:matches(
    //  :matches(button, input, select, textarea, menuitem, optgroup, option)[disabled],
    //  optgroup[disabled] > option),
    // fieldset[disabled] * //TODO not child of first <legend>
    //)
    disabled: function(elem, adapter) {
        return adapter.hasAttrib(elem, "disabled");
    },
    enabled: function(elem, adapter) {
        return !adapter.hasAttrib(elem, "disabled");
    },
    //:matches(:matches(:radio, :checkbox)[checked], :selected) (TODO menuitem)
    checked: function(elem, adapter) {
        return adapter.hasAttrib(elem, "checked") || pseudos.selected(elem, adapter);
    },
    //:matches(input, select, textarea)[required]
    required: function(elem, adapter) {
        return adapter.hasAttrib(elem, "required");
    },
    //:matches(input, select, textarea):not([required])
    optional: function(elem, adapter) {
        return !adapter.hasAttrib(elem, "required");
    },

    //jQuery extensions

    //:not(:empty)
    parent: function(elem, adapter) {
        return !pseudos.empty(elem, adapter);
    },
    //:matches(h1, h2, h3, h4, h5, h6)
    header: namePseudo(["h1", "h2", "h3", "h4", "h5", "h6"]),

    //:matches(button, input[type=button])
    button: function(elem, adapter) {
        var name = adapter.getName(elem);
        return (
            name === "button" || (name === "input" && adapter.getAttributeValue(elem, "type") === "button")
        );
    },
    //:matches(input, textarea, select, button)
    input: namePseudo(["input", "textarea", "select", "button"]),
    //input:matches(:not([type!='']), [type='text' i])
    text: function(elem, adapter) {
        var attr;
        return (
            adapter.getName(elem) === "input" &&
            (!(attr = adapter.getAttributeValue(elem, "type")) || attr.toLowerCase() === "text")
        );
    }
};

function namePseudo(names) {
    if (typeof Set !== "undefined") {
        // eslint-disable-next-line no-undef
        var nameSet = new Set(names);

        return function(elem, adapter) {
            return nameSet.has(adapter.getName(elem));
        };
    }

    return function(elem, adapter) {
        return names.indexOf(adapter.getName(elem)) >= 0;
    };
}

function verifyArgs(func, name, subselect) {
    if (subselect === null) {
        if (func.length > 2 && name !== "scope") {
            throw new Error("pseudo-selector :" + name + " requires an argument");
        }
    } else {
        if (func.length === 2) {
            throw new Error("pseudo-selector :" + name + " doesn't have any arguments");
        }
    }
}

//FIXME this feels hacky
var re_CSS3 = /^(?:(?:nth|last|first|only)-(?:child|of-type)|root|empty|(?:en|dis)abled|checked|not)$/;

module.exports = {
    compile: function(next, data, options, context) {
        var name = data.name;
        var subselect = data.data;
        var adapter = options.adapter;

        if (options && options.strict && !re_CSS3.test(name)) {
            throw new Error(":" + name + " isn't part of CSS3");
        }

        if (typeof filters[name] === "function") {
            return filters[name](next, subselect, options, context);
        } else if (typeof pseudos[name] === "function") {
            var func = pseudos[name];
            verifyArgs(func, name, subselect);

            if (func === falseFunc) {
                return func;
            }

            if (next === trueFunc) {
                return function pseudoRoot(elem) {
                    return func(elem, adapter, subselect);
                };
            }

            return function pseudoArgs(elem) {
                return func(elem, adapter, subselect) && next(elem);
            };
        } else {
            throw new Error("unmatched pseudo-class :" + name);
        }
    },
    filters: filters,
    pseudos: pseudos
};

},{"./attributes.js":554,"boolbase":6,"nth-check":791}],559:[function(require,module,exports){
module.exports = sortByProcedure;

/*
	sort the parts of the passed selector,
	as there is potential for optimization
	(some types of selectors are faster than others)
*/

var procedure = require("./procedure.json");

var attributes = {
    __proto__: null,
    exists: 10,
    equals: 8,
    not: 7,
    start: 6,
    end: 6,
    any: 5,
    hyphen: 4,
    element: 4
};

function sortByProcedure(arr) {
    var procs = arr.map(getProcedure);
    for (var i = 1; i < arr.length; i++) {
        var procNew = procs[i];

        if (procNew < 0) continue;

        for (var j = i - 1; j >= 0 && procNew < procs[j]; j--) {
            var token = arr[j + 1];
            arr[j + 1] = arr[j];
            arr[j] = token;
            procs[j + 1] = procs[j];
            procs[j] = procNew;
        }
    }
}

function getProcedure(token) {
    var proc = procedure[token.type];

    if (proc === procedure.attribute) {
        proc = attributes[token.action];

        if (proc === attributes.equals && token.name === "id") {
            //prefer ID selectors (eg. #ID)
            proc = 9;
        }

        if (token.ignoreCase) {
            //ignoreCase adds some overhead, prefer "normal" token
            //this is a binary operation, to ensure it's still an int
            proc >>= 1;
        }
    } else if (proc === procedure.pseudo) {
        if (!token.data) {
            proc = 3;
        } else if (token.name === "has" || token.name === "contains") {
            proc = 0; //expensive in any case
        } else if (token.name === "matches" || token.name === "not") {
            proc = 0;
            for (var i = 0; i < token.data.length; i++) {
                //TODO better handling of complex selectors
                if (token.data[i].length !== 1) continue;
                var cur = getProcedure(token.data[i][0]);
                //avoid executing :has or :contains
                if (cur === 0) {
                    proc = 0;
                    break;
                }
                if (cur > proc) proc = cur;
            }
            if (token.data.length > 1 && proc > 0) proc -= 1;
        } else {
            proc = 1;
        }
    }
    return proc;
}

},{"./procedure.json":557}],560:[function(require,module,exports){
module.exports={"generic":true,"types":{"absolute-size":"xx-small | x-small | small | medium | large | x-large | xx-large","alpha-value":"<number> | <percentage>","angle-percentage":"<angle> | <percentage>","animateable-feature":"scroll-position | contents | <custom-ident>","attachment":"scroll | fixed | local","auto-repeat":"repeat( [ auto-fill | auto-fit ] , [ <line-names>? <fixed-size> ]+ <line-names>? )","auto-track-list":"[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>? <auto-repeat> [ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>?","basic-shape":"<inset()> | <circle()> | <ellipse()> | <polygon()>","bg-image":"none | <image>","bg-layer":"<bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>","bg-position":"[ center && [ left | right | top | bottom ] <length-percentage>? ] | [ [ left | right ] <length-percentage>? ] && [ [ top | bottom ] <length-percentage>? ] | [ [ left | center | right | <length-percentage> ] || [ top | center | bottom | <length-percentage> ] ]","bg-size":"[ <length-percentage> | auto ]{1,2} | cover | contain","blur()":"blur( <length> )","blend-mode":"normal | multiply | screen | overlay | darken | lighten | color-dodge | color-burn | hard-light | soft-light | difference | exclusion | hue | saturation | color | luminosity","box":"border-box | padding-box | content-box","br-style":"none | hidden | dotted | dashed | solid | double | groove | ridge | inset | outset","br-width":"<length> | thin | medium | thick","brightness()":"brightness( <number-percentage> )","calc()":"calc( <calc-sum> )","calc-sum":"<calc-product> [ [ '+' | '-' ] <calc-product> ]*","calc-product":"<calc-value> [ '*' <calc-value> | '/' <number> ]*","calc-value":"<number> | <dimension> | <percentage> | ( <calc-sum> )","cf-final-image":"<image> | <color>","cf-mixing-image":"<percentage>? && <image>","circle()":"circle( [ <shape-radius> ]? [ at <position> ]? )","clip-source":"<url>","color":"<rgb()> | <rgba()> | <hsl()> | <hsla()> | <hex-color> | <named-color> | currentcolor | <deprecated-system-color>","color-stop":"<color> <length-percentage>?","color-stop-list":"<color-stop>#{2,}","common-lig-values":"[ common-ligatures | no-common-ligatures ]","composite-style":"clear | copy | source-over | source-in | source-out | source-atop | destination-over | destination-in | destination-out | destination-atop | xor","compositing-operator":"add | subtract | intersect | exclude","contextual-alt-values":"[ contextual | no-contextual ]","content-list":"[ <string> | contents | <url> | <quote> | <attr()> | counter( <ident> , <'list-style-type'>? ) ]+","content-replacement":"<image>","contrast()":"contrast( [ <number-percentage> ] )","counter-style":"<counter-style-name> | symbols()","counter-style-name":"<custom-ident>","cross-fade()":"cross-fade( <cf-mixing-image> , <cf-final-image>? )","cubic-bezier-timing-function":"ease | ease-in | ease-out | ease-in-out | cubic-bezier( <number> , <number> , <number> , <number> )","deprecated-system-color":"ActiveBorder | ActiveCaption | AppWorkspace | Background | ButtonFace | ButtonHighlight | ButtonShadow | ButtonText | CaptionText | GrayText | Highlight | HighlightText | InactiveBorder | InactiveCaption | InactiveCaptionText | InfoBackground | InfoText | Menu | MenuText | Scrollbar | ThreeDDarkShadow | ThreeDFace | ThreeDHighlight | ThreeDLightShadow | ThreeDShadow | Window | WindowFrame | WindowText","discretionary-lig-values":"[ discretionary-ligatures | no-discretionary-ligatures ]","display-box":"contents | none","display-inside":"flow | flow-root | table | flex | grid | subgrid | ruby","display-internal":"table-row-group | table-header-group | table-footer-group | table-row | table-cell | table-column-group | table-column | table-caption | ruby-base | ruby-text | ruby-base-container | ruby-text-container","display-legacy":"inline-block | inline-list-item | inline-table | inline-flex | inline-grid","display-listitem":"list-item && <display-outside>? && [ flow | flow-root ]?","display-outside":"block | inline | run-in","drop-shadow()":"drop-shadow( <length>{2,3} <color>? )","east-asian-variant-values":"[ jis78 | jis83 | jis90 | jis04 | simplified | traditional ]","east-asian-width-values":"[ full-width | proportional-width ]","element()":"element( <id-selector> )","ellipse()":"ellipse( [ <shape-radius>{2} ]? [ at <position> ]? )","ending-shape":"circle | ellipse","explicit-track-list":"[ <line-names>? <track-size> ]+ <line-names>?","family-name":"<string> | <custom-ident>+","feature-tag-value":"<string> [ <integer> | on | off ]?","feature-value-name":"<custom-ident>","fill-rule":"nonzero | evenodd","filter-function":"<blur()> | <brightness()> | <contrast()> | <drop-shadow()> | <grayscale()> | <hue-rotate()> | <invert()> | <opacity()> | <saturate()> | <sepia()>","filter-function-list":"[ <filter-function> | <url> ]+","final-bg-layer":"<'background-color'> || <bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>","fit-content()":"fit-content( [ <length> | <percentage> ] )","fixed-breadth":"<length-percentage>","fixed-repeat":"repeat( [ <positive-integer> ] , [ <line-names>? <fixed-size> ]+ <line-names>? )","fixed-size":"<fixed-breadth> | minmax( <fixed-breadth> , <track-breadth> ) | minmax( <inflexible-breadth> , <fixed-breadth> )","font-variant-css21":"[ normal | small-caps ]","frames-timing-function":"frames( <integer> )","frequency-percentage":"<frequency> | <percentage>","generic-family":"serif | sans-serif | cursive | fantasy | monospace | -apple-system","generic-name":"serif | sans-serif | cursive | fantasy | monospace","geometry-box":"<shape-box> | fill-box | stroke-box | view-box","gradient":"<-legacy-gradient()> | <linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()>","grayscale()":"grayscale( <number-percentage> )","grid-line":"auto | <custom-ident> | [ <integer> && <custom-ident>? ] | [ span && [ <integer> || <custom-ident> ] ]","historical-lig-values":"[ historical-ligatures | no-historical-ligatures ]","hsl()":"hsl( [ <hue> <percentage> <percentage> [ / <alpha-value> ]? ] | [ <hue> , <percentage> , <percentage> , <alpha-value>? ] )","hsla()":"hsla( [ <hue> <percentage> <percentage> [ / <alpha-value> ]? ] | [ <hue> , <percentage> , <percentage> , <alpha-value>? ] )","hue":"<number> | <angle>","hue-rotate()":"hue-rotate( <angle> )","image":"<url> | <image()> | <image-set()> | <element()> | <cross-fade()> | <gradient>","image()":"image( [ [ <image> | <string> ]? , <color>? ]! )","image-set()":"image-set( <image-set-option># )","image-set-option":"[ <image> | <string> ] <resolution>","inflexible-breadth":"<length> | <percentage> | min-content | max-content | auto","inset()":"inset( <length-percentage>{1,4} [ round <'border-radius'> ]? )","invert()":"invert( <number-percentage> )","keyframes-name":"<custom-ident> | <string>","keyframe-selector":"from | to | <percentage>","leader()":"leader( <leader-type> )","leader-type":"dotted | solid | space | <string>","length-percentage":"<length> | <percentage>","line-names":"'[' <custom-ident>* ']'","line-name-list":"[ <line-names> | <name-repeat> ]+","linear-gradient()":"linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )","mask-layer":"<mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || <geometry-box> || [ <geometry-box> | no-clip ] || <compositing-operator> || <masking-mode>","mask-position":"[ <length-percentage> | left | center | right ] [ <length-percentage> | top | center | bottom ]?","mask-reference":"none | <image> | <mask-source>","mask-source":"<url>","masking-mode":"alpha | luminance | match-source","matrix()":"matrix( <number> [, <number> ]{5} )","matrix3d()":"matrix3d( <number> [, <number> ]{15} )","media-type":"<ident>","mf-boolean":"<mf-name>","mf-name":"<ident>","minmax()":"minmax( [ <length> | <percentage> | <flex> | min-content | max-content | auto ] , [ <length> | <percentage> | <flex> | min-content | max-content | auto ] )","named-color":"transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen | <-non-standard-color>","namespace-prefix":"<ident>","number-percentage":"<number> | <percentage>","numeric-figure-values":"[ lining-nums | oldstyle-nums ]","numeric-fraction-values":"[ diagonal-fractions | stacked-fractions ]","numeric-spacing-values":"[ proportional-nums | tabular-nums ]","opacity()":"opacity( [ <number-percentage> ] )","perspective()":"perspective( <length> )","polygon()":"polygon( <fill-rule>? , [ <length-percentage> <length-percentage> ]# )","position":"[ [ left | center | right ] || [ top | center | bottom ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]? | [ [ left | right ] <length-percentage> ] && [ [ top | bottom ] <length-percentage> ] ]","quote":"open-quote | close-quote | no-open-quote | no-close-quote","radial-gradient()":"radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )","relative-size":"larger | smaller","repeat-style":"repeat-x | repeat-y | [ repeat | space | round | no-repeat ]{1,2}","repeating-linear-gradient()":"repeating-linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )","repeating-radial-gradient()":"repeating-radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )","rgb()":"rgb( [ [ <percentage>{3} | <number>{3} ] [ / <alpha-value> ]? ] | [ [ <percentage>#{3} | <number>#{3} ] , <alpha-value>? ] )","rgba()":"rgba( [ [ <percentage>{3} | <number>{3} ] [ / <alpha-value> ]? ] | [ [ <percentage>#{3} | <number>#{3} ] , <alpha-value>? ] )","rotate()":"rotate( <angle> )","rotate3d()":"rotate3d( <number> , <number> , <number> , <angle> )","rotateX()":"rotateX( <angle> )","rotateY()":"rotateY( <angle> )","rotateZ()":"rotateZ( <angle> )","saturate()":"saturate( <number-percentage> )","scale()":"scale( <number> [, <number> ]? )","scale3d()":"scale3d( <number> , <number> , <number> )","scaleX()":"scaleX( <number> )","scaleY()":"scaleY( <number> )","scaleZ()":"scaleZ( <number> )","shape-radius":"<length-percentage> | closest-side | farthest-side","skew()":"skew( <angle> [, <angle> ]? )","skewX()":"skewX( <angle> )","skewY()":"skewY( <angle> )","sepia()":"sepia( <number-percentage> )","shadow":"inset? && <length>{2,4} && <color>?","shadow-t":"[ <length>{2,3} && <color>? ]","shape":"rect( [ [ <top> , <right> , <bottom> , <left> ] | [ <top> <right> <bottom> <left> ] ] )","shape-box":"<box> | margin-box","side-or-corner":"[ left | right ] || [ top | bottom ]","single-animation":"<time> || <single-timing-function> || <time> || <single-animation-iteration-count> || <single-animation-direction> || <single-animation-fill-mode> || <single-animation-play-state> || [ none | <keyframes-name> ]","single-animation-direction":"normal | reverse | alternate | alternate-reverse","single-animation-fill-mode":"none | forwards | backwards | both","single-animation-iteration-count":"infinite | <number>","single-animation-play-state":"running | paused","single-timing-function":"linear | <cubic-bezier-timing-function> | <step-timing-function> | <frames-timing-function>","single-transition":"<single-transition-timing-function> || [ none | <single-transition-property> ] || <time> || <time>","single-transition-timing-function":"<single-timing-function>","single-transition-property":"all | <custom-ident>","size":"closest-side | farthest-side | closest-corner | farthest-corner | <length> | <length-percentage>{2}","step-timing-function":"step-start | step-end | steps( <integer> [, [ start | end ] ]? )","symbol":"<string> | <image> | <custom-ident>","target":"<target-counter()> | <target-counters()> | <target-text()>","target-counter()":"target-counter( [ <string> | <url> ] , <custom-ident> , <counter-style>? )","target-counters()":"target-counters( [ <string> | <url> ] , <custom-ident> , <string> , <counter-style>? )","target-text()":"target-text( [ <string> | <url> ] , [ content | before | after | first-letter ]? )","time-percentage":"<time> | <percentage>","track-breadth":"<length-percentage> | <flex> | min-content | max-content | auto","track-list":"[ <line-names>? [ <track-size> | <track-repeat> ] ]+ <line-names>?","track-repeat":"repeat( [ <positive-integer> ] , [ <line-names>? <track-size> ]+ <line-names>? )","track-size":"<track-breadth> | minmax( <inflexible-breadth> , <track-breadth> ) | fit-content( [ <length> | <percentage> ] )","transform-function":"[ <matrix()> || <translate()> || <translateX()> || <translateY()> || <scale()> || <scaleX()> || <scaleY()> || <rotate()> || <skew()> || <skewX()> || <skewY()> || <matrix3d()> || <translate3d()> || <translateZ()> || <scale3d()> || <scaleZ()> || <rotate3d()> || <rotateX()> || <rotateY()> || <rotateZ()> || <perspective()> ]+","transform-list":"<transform-function>+","translate()":"translate( <length-percentage> [, <length-percentage> ]? )","translate3d()":"translate3d( <length-percentage> , <length-percentage> , <length> )","translateX()":"translateX( <length-percentage> )","translateY()":"translateY( <length-percentage> )","translateZ()":"translateZ( <length> )","type-or-unit":"string | integer | color | url | integer | number | length | angle | time | frequency | em | ex | px | rem | vw | vh | vmin | vmax | mm | q | cm | in | pt | pc | deg | grad | rad | ms | s | Hz | kHz | %","viewport-length":"auto | <length-percentage>","-legacy-gradient()":"<-webkit-gradient()> | <-legacy-linear-gradient()> | <-legacy-repeating-linear-gradient()> | <-legacy-radial-gradient()> | <-legacy-repeating-radial-gradient()>","-legacy-linear-gradient()":"-moz-linear-gradient( <-legacy-linear-gradient-arguments> ) | -ms-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-linear-gradient( <-legacy-linear-gradient-arguments> )","-legacy-repeating-linear-gradient()":"-moz-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -ms-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )","-legacy-linear-gradient-arguments":"[ <angle> | <side-or-corner> ]? , <color-stop-list>","-legacy-radial-gradient()":"-moz-radial-gradient( <-legacy-radial-gradient-arguments> ) | -ms-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-radial-gradient( <-legacy-radial-gradient-arguments> )","-legacy-repeating-radial-gradient()":"-moz-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -ms-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )","-legacy-radial-gradient-arguments":"[ <position> , ]? [ [ [ <-legacy-radial-gradient-shape> || <-legacy-radial-gradient-size> ] | [ <length> | <percentage> ]{2} ] , ]? <color-stop-list>","-legacy-radial-gradient-size":"closest-side | closest-corner | farthest-side | farthest-corner | contain | cover","-legacy-radial-gradient-shape":"circle | ellipse","-non-standard-font":"-apple-system-body | -apple-system-headline | -apple-system-subheadline | -apple-system-caption1 | -apple-system-caption2 | -apple-system-footnote | -apple-system-short-body | -apple-system-short-headline | -apple-system-short-subheadline | -apple-system-short-caption1 | -apple-system-short-footnote | -apple-system-tall-body","-non-standard-color":"-moz-ButtonDefault | -moz-ButtonHoverFace | -moz-ButtonHoverText | -moz-CellHighlight | -moz-CellHighlightText | -moz-Combobox | -moz-ComboboxText | -moz-Dialog | -moz-DialogText | -moz-dragtargetzone | -moz-EvenTreeRow | -moz-Field | -moz-FieldText | -moz-html-CellHighlight | -moz-html-CellHighlightText | -moz-mac-accentdarkestshadow | -moz-mac-accentdarkshadow | -moz-mac-accentface | -moz-mac-accentlightesthighlight | -moz-mac-accentlightshadow | -moz-mac-accentregularhighlight | -moz-mac-accentregularshadow | -moz-mac-chrome-active | -moz-mac-chrome-inactive | -moz-mac-focusring | -moz-mac-menuselect | -moz-mac-menushadow | -moz-mac-menutextselect | -moz-MenuHover | -moz-MenuHoverText | -moz-MenuBarText | -moz-MenuBarHoverText | -moz-nativehyperlinktext | -moz-OddTreeRow | -moz-win-communicationstext | -moz-win-mediatext | -moz-activehyperlinktext | -moz-default-background-color | -moz-default-color | -moz-hyperlinktext | -moz-visitedhyperlinktext | -webkit-activelink | -webkit-focus-ring-color | -webkit-link | -webkit-text","-non-standard-image-rendering":"optimize-contrast | -moz-crisp-edges | -o-crisp-edges | -webkit-optimize-contrast","-non-standard-overflow":"-moz-scrollbars-none | -moz-scrollbars-horizontal | -moz-scrollbars-vertical | -moz-hidden-unscrollable","-non-standard-width":"min-intrinsic | intrinsic | -moz-min-content | -moz-max-content | -webkit-min-content | -webkit-max-content","-non-standard-word-break":"break-word","-webkit-image-set()":"<image-set()>","-webkit-gradient()":"-webkit-gradient( <-webkit-gradient-type> , <-webkit-gradient-point> [ , <-webkit-gradient-point> | , <-webkit-gradient-radius> , <-webkit-gradient-point> ] [, <-webkit-gradient-radius> ]? [, <-webkit-gradient-color-stop()> ]* )","-webkit-gradient-color-stop()":"from( <color> ) | color-stop( [ <number-zero-one> | <percentage> ] , <color> ) | to( <color> )","-webkit-gradient-point":"[ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]","-webkit-gradient-radius":"<length> | <percentage>","-webkit-gradient-type":"linear | radial","-webkit-mask-box-repeat":"repeat | stretch | round","-webkit-mask-clip-style":"border | border-box | padding | padding-box | content | content-box | text","-ms-filter":"[ <progid> | FlipH | FlipV ]+","age":"child | young | old","border-radius":"<length-percentage>{1,2}","bottom":"<length> | auto","generic-voice":"[ <age>? <gender> <integer>? ]","gender":"male | female | neutral","left":"<length> | auto","mask-image":"<mask-reference>#","name-repeat":"repeat( [ <positive-integer> | auto-fill ] , <line-names>+ )","outline-radius":"<border-radius>","paint":"none | currentColor | <color> | <url> [ none | currentColor | <color> ]?","path()":"path( <string> )","right":"<length> | auto","svg-length":"<percentage> | <length> | <number>","svg-writing-mode":"lr-tb | rl-tb | tb-rl | lr | rl | tb","top":"<length> | auto","x":"<number>","y":"<number>"},"properties":{"-ms-overflow-style":"auto | none | scrollbar | -ms-autohiding-scrollbar","-moz-appearance":"none | button | button-arrow-down | button-arrow-next | button-arrow-previous | button-arrow-up | button-bevel | button-focus | caret | checkbox | checkbox-container | checkbox-label | checkmenuitem | dualbutton | groupbox | listbox | listitem | menuarrow | menubar | menucheckbox | menuimage | menuitem | menuitemtext | menulist | menulist-button | menulist-text | menulist-textfield | menupopup | menuradio | menuseparator | meterbar | meterchunk | progressbar | progressbar-vertical | progresschunk | progresschunk-vertical | radio | radio-container | radio-label | radiomenuitem | range | range-thumb | resizer | resizerpanel | scale-horizontal | scalethumbend | scalethumb-horizontal | scalethumbstart | scalethumbtick | scalethumb-vertical | scale-vertical | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | separator | sheet | spinner | spinner-downbutton | spinner-textfield | spinner-upbutton | splitter | statusbar | statusbarpanel | tab | tabpanel | tabpanels | tab-scroll-arrow-back | tab-scroll-arrow-forward | textfield | textfield-multiline | toolbar | toolbarbutton | toolbarbutton-dropdown | toolbargripper | toolbox | tooltip | treeheader | treeheadercell | treeheadersortarrow | treeitem | treeline | treetwisty | treetwistyopen | treeview | -moz-mac-unified-toolbar | -moz-win-borderless-glass | -moz-win-browsertabbar-toolbox | -moz-win-communicationstext | -moz-win-communications-toolbox | -moz-win-exclude-glass | -moz-win-glass | -moz-win-mediatext | -moz-win-media-toolbox | -moz-window-button-box | -moz-window-button-box-maximized | -moz-window-button-close | -moz-window-button-maximize | -moz-window-button-minimize | -moz-window-button-restore | -moz-window-frame-bottom | -moz-window-frame-left | -moz-window-frame-right | -moz-window-titlebar | -moz-window-titlebar-maximized","-moz-binding":"<url> | none","-moz-border-bottom-colors":"[ <color> ]* <color> | none","-moz-border-left-colors":"[ <color> ]* <color> | none","-moz-border-right-colors":"[ <color> ]* <color> | none","-moz-border-top-colors":"[ <color> ]* <color> | none","-moz-context-properties":"none | [ fill | fill-opacity | stroke | stroke-opacity ]#","-moz-float-edge":"border-box | content-box | margin-box | padding-box","-moz-force-broken-image-icon":"<integer>","-moz-image-region":"<shape> | auto","-moz-orient":"inline | block | horizontal | vertical","-moz-outline-radius":"<outline-radius>{1,4} [ / <outline-radius>{1,4} ]?","-moz-outline-radius-bottomleft":"<outline-radius>","-moz-outline-radius-bottomright":"<outline-radius>","-moz-outline-radius-topleft":"<outline-radius>","-moz-outline-radius-topright":"<outline-radius>","-moz-stack-sizing":"ignore | stretch-to-fit","-moz-text-blink":"none | blink","-moz-user-focus":"ignore | normal | select-after | select-before | select-menu | select-same | select-all | none","-moz-user-input":"auto | none | enabled | disabled","-moz-user-modify":"read-only | read-write | write-only","-moz-window-dragging":"drag | no-drag","-moz-window-shadow":"default | menu | tooltip | sheet | none","-webkit-border-before":"<'border-width'> || <'border-style'> || <'color'>","-webkit-border-before-color":"<'color'>","-webkit-border-before-style":"<'border-style'>","-webkit-border-before-width":"<'border-width'>","-webkit-box-reflect":"[ above | below | right | left ]? <length>? <image>?","-webkit-mask":"<mask-image> [ <'-webkit-mask-repeat'> || <'-webkit-mask-attachment'> || <'-webkit-mask-position'> || <'-webkit-mask-origin'> || <'-webkit-mask-clip'> ]*","-webkit-mask-attachment":"<attachment> [, <attachment> ]*","-webkit-mask-clip":"<-webkit-mask-clip-style> [, <-webkit-mask-clip-style> ]*","-webkit-mask-composite":"<composite-style> [, <composite-style> ]*","-webkit-mask-image":"<mask-image> [, <mask-image> ]*","-webkit-mask-origin":"[ padding | border | content ] [, [ border | padding | content ] ]*","-webkit-mask-position":"<mask-position>#","-webkit-mask-position-x":"[ <length-percentage> | left | center | right ]#","-webkit-mask-position-y":"[ <length-percentage> | top | center | bottom ]#","-webkit-mask-repeat":"<repeat-style> [, <repeat-style> ]*","-webkit-mask-repeat-x":"repeat | no-repeat | space | round","-webkit-mask-repeat-y":"repeat | no-repeat | space | round","-webkit-overflow-scrolling":"auto | touch","-webkit-tap-highlight-color":"<color>","-webkit-text-fill-color":"<color>","-webkit-text-stroke":"<length> || <color>","-webkit-text-stroke-color":"<color>","-webkit-text-stroke-width":"<length>","-webkit-touch-callout":"default | none","align-content":"flex-start | flex-end | center | space-between | space-around | space-evenly | stretch","align-items":"flex-start | flex-end | center | baseline | stretch","align-self":"auto | flex-start | flex-end | center | baseline | stretch","all":"initial | inherit | unset | revert","animation":"<single-animation>#","animation-delay":"<time>#","animation-direction":"<single-animation-direction>#","animation-duration":"<time>#","animation-fill-mode":"<single-animation-fill-mode>#","animation-iteration-count":"<single-animation-iteration-count>#","animation-name":"[ none | <keyframes-name> ]#","animation-play-state":"<single-animation-play-state>#","animation-timing-function":"<single-timing-function>#","appearance":"auto | none","azimuth":"<angle> | [ [ left-side | far-left | left | center-left | center | center-right | right | far-right | right-side ] || behind ] | leftwards | rightwards","backdrop-filter":"none | <filter-function-list>","backface-visibility":"visible | hidden","background":"[ <bg-layer> , ]* <final-bg-layer>","background-attachment":"<attachment>#","background-blend-mode":"<blend-mode>#","background-clip":"<box>#","background-color":"<color>","background-image":"<bg-image>#","background-origin":"<box>#","background-position":"<bg-position>#","background-position-x":"[ center | [ left | right | x-start | x-end ]? <length-percentage>? ]#","background-position-y":"[ center | [ top | bottom | y-start | y-end ]? <length-percentage>? ]#","background-repeat":"<repeat-style>#","background-size":"<bg-size>#","block-size":"<'width'>","border":"<br-width> || <br-style> || <color>","border-block-end":"<'border-width'> || <'border-style'> || <'color'>","border-block-end-color":"<'color'>","border-block-end-style":"<'border-style'>","border-block-end-width":"<'border-width'>","border-block-start":"<'border-width'> || <'border-style'> || <'color'>","border-block-start-color":"<'color'>","border-block-start-style":"<'border-style'>","border-block-start-width":"<'border-width'>","border-bottom":"<br-width> || <br-style> || <color>","border-bottom-color":"<color>","border-bottom-left-radius":"<length-percentage>{1,2}","border-bottom-right-radius":"<length-percentage>{1,2}","border-bottom-style":"<br-style>","border-bottom-width":"<br-width>","border-collapse":"collapse | separate","border-color":"<color>{1,4}","border-image":"<'border-image-source'> || <'border-image-slice'> [ / <'border-image-width'> | / <'border-image-width'>? / <'border-image-outset'> ]? || <'border-image-repeat'>","border-image-outset":"[ <length> | <number> ]{1,4}","border-image-repeat":"[ stretch | repeat | round | space ]{1,2}","border-image-slice":"<number-percentage>{1,4} && fill?","border-image-source":"none | <image>","border-image-width":"[ <length-percentage> | <number> | auto ]{1,4}","border-inline-end":"<'border-width'> || <'border-style'> || <'color'>","border-inline-end-color":"<'color'>","border-inline-end-style":"<'border-style'>","border-inline-end-width":"<'border-width'>","border-inline-start":"<'border-width'> || <'border-style'> || <'color'>","border-inline-start-color":"<'color'>","border-inline-start-style":"<'border-style'>","border-inline-start-width":"<'border-width'>","border-left":"<br-width> || <br-style> || <color>","border-left-color":"<color>","border-left-style":"<br-style>","border-left-width":"<br-width>","border-radius":"<length-percentage>{1,4} [ / <length-percentage>{1,4} ]?","border-right":"<br-width> || <br-style> || <color>","border-right-color":"<color>","border-right-style":"<br-style>","border-right-width":"<br-width>","border-spacing":"<length> <length>?","border-style":"<br-style>{1,4}","border-top":"<br-width> || <br-style> || <color>","border-top-color":"<color>","border-top-left-radius":"<length-percentage>{1,2}","border-top-right-radius":"<length-percentage>{1,2}","border-top-style":"<br-style>","border-top-width":"<br-width>","border-width":"<br-width>{1,4}","bottom":"<length> | <percentage> | auto","box-align":"start | center | end | baseline | stretch","box-decoration-break":"slice | clone","box-direction":"normal | reverse | inherit","box-flex":"<number>","box-flex-group":"<integer>","box-lines":"single | multiple","box-ordinal-group":"<integer>","box-orient":"horizontal | vertical | inline-axis | block-axis | inherit","box-pack":"start | center | end | justify","box-shadow":"none | <shadow>#","box-sizing":"content-box | border-box","break-after":"auto | avoid | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region","break-before":"auto | avoid | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region","break-inside":"auto | avoid | avoid-page | avoid-column | avoid-region","caption-side":"top | bottom | block-start | block-end | inline-start | inline-end","caret-color":"auto | <color>","clear":"none | left | right | both | inline-start | inline-end","clip":"<shape> | auto","clip-path":"<clip-source> | [ <basic-shape> || <geometry-box> ] | none","color":"<color>","column-count":"<integer> | auto","column-fill":"auto | balance | balance-all","column-gap":"<length-percentage> | normal","column-rule":"<'column-rule-width'> || <'column-rule-style'> || <'column-rule-color'>","column-rule-color":"<color>","column-rule-style":"<'border-style'>","column-rule-width":"<'border-width'>","column-span":"none | all","column-width":"<length> | auto","columns":"<'column-width'> || <'column-count'>","contain":"none | strict | content | [ size || layout || style || paint ]","content":"normal | none | [ <content-replacement> | <content-list> ] [ / <string> ]?","counter-increment":"[ <custom-ident> <integer>? ]+ | none","counter-reset":"[ <custom-ident> <integer>? ]+ | none","cursor":"[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing | hand | -webkit-grab | -webkit-grabbing | -webkit-zoom-in | -webkit-zoom-out | -moz-grab | -moz-grabbing | -moz-zoom-in | -moz-zoom-out ] ]","direction":"ltr | rtl","display":"none | inline | block | list-item | inline-list-item | inline-block | inline-table | table | table-cell | table-column | table-column-group | table-footer-group | table-header-group | table-row | table-row-group | flex | inline-flex | grid | inline-grid | run-in | ruby | ruby-base | ruby-text | ruby-base-container | ruby-text-container | contents | -ms-flexbox | -ms-inline-flexbox | -ms-grid | -ms-inline-grid | -webkit-flex | -webkit-inline-flex | -webkit-box | -webkit-inline-box | -moz-inline-stack | -moz-box | -moz-inline-box","display-inside":"auto | block | table | flex | grid | ruby","display-list":"none | list-item","display-outside":"block-level | inline-level | run-in | contents | none | table-row-group | table-header-group | table-footer-group | table-row | table-cell | table-column-group | table-column | table-caption | ruby-base | ruby-text | ruby-base-container | ruby-text-container","empty-cells":"show | hide","filter":"none | <filter-function-list> | <-ms-filter>","flex":"none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]","flex-basis":"content | <'width'>","flex-direction":"row | row-reverse | column | column-reverse","flex-flow":"<'flex-direction'> || <'flex-wrap'>","flex-grow":"<number>","flex-shrink":"<number>","flex-wrap":"nowrap | wrap | wrap-reverse","float":"left | right | none | inline-start | inline-end","font":"[ [ <'font-style'> || <font-variant-css21> || <'font-weight'> || <'font-stretch'> ]? <'font-size'> [ / <'line-height'> ]? <'font-family'> ] | caption | icon | menu | message-box | small-caption | status-bar | <-non-standard-font>","font-family":"[ <family-name> | <generic-family> ]#","font-feature-settings":"normal | <feature-tag-value>#","font-kerning":"auto | normal | none","font-language-override":"normal | <string>","font-variation-settings":"normal | [ <string> <number> ]#","font-size":"<absolute-size> | <relative-size> | <length-percentage>","font-size-adjust":"none | <number>","font-stretch":"normal | ultra-condensed | extra-condensed | condensed | semi-condensed | semi-expanded | expanded | extra-expanded | ultra-expanded","font-style":"normal | italic | oblique","font-synthesis":"none | [ weight || style ]","font-variant":"normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]","font-variant-alternates":"normal | [ stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) ]","font-variant-caps":"normal | small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps","font-variant-east-asian":"normal | [ <east-asian-variant-values> || <east-asian-width-values> || ruby ]","font-variant-ligatures":"normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> ]","font-variant-numeric":"normal | [ <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero ]","font-variant-position":"normal | sub | super","font-weight":"normal | bold | bolder | lighter | 100 | 200 | 300 | 400 | 500 | 600 | 700 | 800 | 900","grid":"<'grid-template'> | <'grid-template-rows'> / [ auto-flow && dense? ] <'grid-auto-columns'>? | [ auto-flow && dense? ] <'grid-auto-rows'>? / <'grid-template-columns'>","grid-area":"<grid-line> [ / <grid-line> ]{0,3}","grid-auto-columns":"<track-size>+","grid-auto-flow":"[ row | column ] || dense","grid-auto-rows":"<track-size>+","grid-column":"<grid-line> [ / <grid-line> ]?","grid-column-end":"<grid-line>","grid-column-gap":"<length-percentage>","grid-column-start":"<grid-line>","grid-gap":"<'grid-row-gap'> <'grid-column-gap'>?","grid-row":"<grid-line> [ / <grid-line> ]?","grid-row-end":"<grid-line>","grid-row-gap":"<length-percentage>","grid-row-start":"<grid-line>","grid-template":"none | [ <'grid-template-rows'> / <'grid-template-columns'> ] | [ <line-names>? <string> <track-size>? <line-names>? ]+ [ / <explicit-track-list> ]?","grid-template-areas":"none | <string>+","grid-template-columns":"none | <track-list> | <auto-track-list>","grid-template-rows":"none | <track-list> | <auto-track-list>","hanging-punctuation":"none | [ first || [ force-end | allow-end ] || last ]","height":"[ <length> | <percentage> ] && [ border-box | content-box ]? | available | min-content | max-content | fit-content | auto","hyphens":"none | manual | auto","image-orientation":"from-image | <angle> | [ <angle>? flip ]","image-rendering":"auto | crisp-edges | pixelated | optimizeSpeed | optimizeQuality | <-non-standard-image-rendering>","image-resolution":"[ from-image || <resolution> ] && snap?","ime-mode":"auto | normal | active | inactive | disabled","initial-letter":"normal | [ <number> <integer>? ]","initial-letter-align":"[ auto | alphabetic | hanging | ideographic ]","inline-size":"<'width'>","isolation":"auto | isolate","justify-content":"flex-start | flex-end | center | space-between | space-around | space-evenly","left":"<length> | <percentage> | auto","letter-spacing":"normal | <length-percentage>","line-break":"auto | loose | normal | strict","line-height":"normal | <number> | <length> | <percentage>","line-height-step":"none | <length>","list-style":"<'list-style-type'> || <'list-style-position'> || <'list-style-image'>","list-style-image":"<url> | none","list-style-position":"inside | outside","list-style-type":"<counter-style> | <string> | none","margin":"[ <length> | <percentage> | auto ]{1,4}","margin-block-end":"<'margin-left'>","margin-block-start":"<'margin-left'>","margin-bottom":"<length> | <percentage> | auto","margin-inline-end":"<'margin-left'>","margin-inline-start":"<'margin-left'>","margin-left":"<length> | <percentage> | auto","margin-right":"<length> | <percentage> | auto","margin-top":"<length> | <percentage> | auto","mask":"<mask-layer>#","mask-border":"<'mask-border-source'> || <'mask-border-slice'> [ / <'mask-border-width'>? [ / <'mask-border-outset'> ]? ]? || <'mask-border-repeat'> || <'mask-border-mode'>","mask-border-mode":"luminance | alpha","mask-border-outset":"[ <length> | <number> ]{1,4}","mask-border-repeat":"[ stretch | repeat | round | space ]{1,2}","mask-border-slice":"<number-percentage>{1,4} fill?","mask-border-source":"none | <image>","mask-border-width":"[ <length-percentage> | <number> | auto ]{1,4}","mask-clip":"[ <geometry-box> | no-clip ]#","mask-composite":"<compositing-operator>#","mask-image":"<mask-reference>#","mask-mode":"<masking-mode>#","mask-origin":"<geometry-box>#","mask-position":"<position>#","mask-repeat":"<repeat-style>#","mask-size":"<bg-size>#","mask-type":"luminance | alpha","max-block-size":"<'max-width'>","max-height":"<length> | <percentage> | none | max-content | min-content | fit-content | fill-available","max-inline-size":"<'max-width'>","max-width":"<length> | <percentage> | none | max-content | min-content | fit-content | fill-available | <-non-standard-width>","min-block-size":"<'min-width'>","min-height":"<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available","min-inline-size":"<'min-width'>","min-width":"<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available | <-non-standard-width>","mix-blend-mode":"<blend-mode>","object-fit":"fill | contain | cover | none | scale-down","object-position":"<position>","offset":"[ <'offset-position'>? [ <'offset-path'> [ <'offset-distance'> || <'offset-rotate'> ]? ]? ]! [ / <'offset-anchor'> ]?","offset-anchor":"auto | <position>","offset-block-end":"<'left'>","offset-block-start":"<'left'>","offset-inline-end":"<'left'>","offset-inline-start":"<'left'>","offset-distance":"<length-percentage>","offset-path":"none | ray( [ <angle> && <size>? && contain? ] ) | <path()> | <url> | [ <basic-shape> || <geometry-box> ]","offset-position":"auto | <position>","offset-rotate":"[ auto | reverse ] || <angle>","opacity":"<number-zero-one>","order":"<integer>","orphans":"<integer>","outline":"[ <'outline-color'> || <'outline-style'> || <'outline-width'> ]","outline-color":"<color> | invert","outline-offset":"<length>","outline-style":"auto | <br-style>","outline-width":"<br-width>","overflow":"visible | hidden | scroll | auto | <-non-standard-overflow>","overflow-clip-box":"padding-box | content-box","overflow-wrap":"normal | break-word","overflow-x":"visible | hidden | scroll | auto","overflow-y":"visible | hidden | scroll | auto","padding":"[ <length> | <percentage> ]{1,4}","padding-block-end":"<'padding-left'>","padding-block-start":"<'padding-left'>","padding-bottom":"<length> | <percentage>","padding-inline-end":"<'padding-left'>","padding-inline-start":"<'padding-left'>","padding-left":"<length> | <percentage>","padding-right":"<length> | <percentage>","padding-top":"<length> | <percentage>","page-break-after":"auto | always | avoid | left | right","page-break-before":"auto | always | avoid | left | right","page-break-inside":"auto | avoid","perspective":"none | <length>","perspective-origin":"<position>","pointer-events":"auto | none | visiblePainted | visibleFill | visibleStroke | visible | painted | fill | stroke | all | inherit","position":"static | relative | absolute | sticky | fixed | -webkit-sticky","quotes":"none | [ <string> <string> ]+","resize":"none | both | horizontal | vertical","right":"<length> | <percentage> | auto","ruby-align":"start | center | space-between | space-around","ruby-merge":"separate | collapse | auto","ruby-position":"over | under | inter-character","scroll-behavior":"auto | smooth","scroll-snap-coordinate":"none | <position>#","scroll-snap-destination":"<position>","scroll-snap-points-x":"none | repeat( <length-percentage> )","scroll-snap-points-y":"none | repeat( <length-percentage> )","scroll-snap-type":"none | mandatory | proximity","scroll-snap-type-x":"none | mandatory | proximity","scroll-snap-type-y":"none | mandatory | proximity","shape-image-threshold":"<number>","shape-margin":"<length-percentage>","shape-outside":"none | <shape-box> || <basic-shape> | <image>","tab-size":"<integer> | <length>","table-layout":"auto | fixed","text-align":"start | end | left | right | center | justify | match-parent","text-align-last":"auto | start | end | left | right | center | justify","text-combine-upright":"none | all | [ digits <integer>? ]","text-decoration":"<'text-decoration-line'> || <'text-decoration-style'> || <'text-decoration-color'>","text-decoration-color":"<color>","text-decoration-line":"none | [ underline || overline || line-through || blink ]","text-decoration-skip":"none | [ objects || [ spaces | [ leading-spaces || trailing-spaces ] ] || edges || box-decoration ]","text-decoration-skip-ink":"auto | none","text-decoration-style":"solid | double | dotted | dashed | wavy","text-emphasis":"<'text-emphasis-style'> || <'text-emphasis-color'>","text-emphasis-color":"<color>","text-emphasis-position":"[ over | under ] && [ right | left ]","text-emphasis-style":"none | [ [ filled | open ] || [ dot | circle | double-circle | triangle | sesame ] ] | <string>","text-indent":"<length-percentage> && hanging? && each-line?","text-justify":"auto | inter-character | inter-word | none","text-orientation":"mixed | upright | sideways","text-overflow":"[ clip | ellipsis | <string> ]{1,2}","text-rendering":"auto | optimizeSpeed | optimizeLegibility | geometricPrecision","text-shadow":"none | <shadow-t>#","text-size-adjust":"none | auto | <percentage>","text-transform":"none | capitalize | uppercase | lowercase | full-width","text-underline-position":"auto | [ under || [ left | right ] ]","top":"<length> | <percentage> | auto","touch-action":"auto | none | [ [ pan-x | pan-left | pan-right ] || [ pan-y | pan-up | pan-down ] || pinch-zoom ] | manipulation","transform":"none | <transform-list>","transform-box":"border-box | fill-box | view-box","transform-origin":"[ [ <length-percentage> | left | center | right ] && [ <length-percentage> | top | center | bottom ] ] <length>? | [ <length-percentage> | left | center | right | top | bottom ]","transform-style":"flat | preserve-3d","transition":"<single-transition>#","transition-delay":"<time>#","transition-duration":"<time>#","transition-property":"none | <single-transition-property>#","transition-timing-function":"<single-transition-timing-function>#","unicode-bidi":"normal | embed | isolate | bidi-override | isolate-override | plaintext | -moz-isolate | -moz-isolate-override | -moz-plaintext | -webkit-isolate","user-select":"auto | text | none | contain | all","vertical-align":"baseline | sub | super | text-top | text-bottom | middle | top | bottom | <percentage> | <length>","visibility":"visible | hidden | collapse","white-space":"normal | pre | nowrap | pre-wrap | pre-line","widows":"<integer>","width":"[ <length> | <percentage> ] && [ border-box | content-box ]? | available | min-content | max-content | fit-content | auto","will-change":"auto | <animateable-feature>#","word-break":"normal | break-all | keep-all | <-non-standard-word-break>","word-spacing":"normal | <length-percentage>","word-wrap":"normal | break-word","writing-mode":"horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr | <svg-writing-mode>","z-index":"auto | <integer>","-moz-background-clip":"padding | border","-moz-border-radius-bottomleft":"<'border-bottom-left-radius'>","-moz-border-radius-bottomright":"<'border-bottom-right-radius'>","-moz-border-radius-topleft":"<'border-top-left-radius'>","-moz-border-radius-topright":"<'border-bottom-right-radius'>","-moz-osx-font-smoothing":"auto | grayscale","-moz-user-select":"none | text | all | -moz-none","-ms-filter":"<string>","-ms-flex-align":"start | end | center | baseline | stretch","-ms-flex-item-align":"auto | start | end | center | baseline | stretch","-ms-flex-line-pack":"start | end | center | justify | distribute | stretch","-ms-flex-negative":"<'flex-shrink'>","-ms-flex-pack":"start | end | center | justify | distribute","-ms-flex-order":"<integer>","-ms-flex-positive":"<'flex-grow'>","-ms-flex-preferred-size":"<'flex-basis'>","-ms-interpolation-mode":"nearest-neighbor | bicubic","-ms-grid-column-align":"start | end | center | stretch","-ms-grid-row-align":"start | end | center | stretch","-ms-high-contrast-adjust":"auto | none","-ms-user-select":"none | element | text","-webkit-appearance":"none | button | button-bevel | caps-lock-indicator | caret | checkbox | default-button | listbox | listitem | media-fullscreen-button | media-mute-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | push-button | radio | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbargripper-horizontal | scrollbargripper-vertical | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield","-webkit-background-clip":"[ <box> | border | padding | content | text ]#","-webkit-column-break-after":"always | auto | avoid","-webkit-column-break-before":"always | auto | avoid","-webkit-column-break-inside":"always | auto | avoid","-webkit-font-smoothing":"auto | none | antialiased | subpixel-antialiased","-webkit-line-clamp":"<positive-integer>","-webkit-mask-box-image":"[ <url> | <gradient> | none ] [ <length-percentage>{4} <-webkit-mask-box-repeat>{2} ]?","-webkit-print-color-adjust":"economy | exact","-webkit-text-security":"none | circle | disc | square","-webkit-user-drag":"none | element | auto","-webkit-user-select":"auto | none | text | all","alignment-baseline":"auto | baseline | before-edge | text-before-edge | middle | central | after-edge | text-after-edge | ideographic | alphabetic | hanging | mathematical","baseline-shift":"baseline | sub | super | <svg-length>","behavior":"<url>+","clip-rule":"nonzero | evenodd","cue":"<'cue-before'> <'cue-after'>?","cue-after":"<url> <decibel>? | none","cue-before":"<url> <decibel>? | none","dominant-baseline":"auto | use-script | no-change | reset-size | ideographic | alphabetic | hanging | mathematical | central | middle | text-after-edge | text-before-edge","fill":"<paint>","fill-opacity":"<number-zero-one>","fill-rule":"nonzero | evenodd","glyph-orientation-horizontal":"<angle>","glyph-orientation-vertical":"<angle>","kerning":"auto | <svg-length>","marker":"none | <url>","marker-end":"none | <url>","marker-mid":"none | <url>","marker-start":"none | <url>","pause":"<'pause-before'> <'pause-after'>?","pause-after":"<time> | none | x-weak | weak | medium | strong | x-strong","pause-before":"<time> | none | x-weak | weak | medium | strong | x-strong","rest":"<'rest-before'> <'rest-after'>?","rest-after":"<time> | none | x-weak | weak | medium | strong | x-strong","rest-before":"<time> | none | x-weak | weak | medium | strong | x-strong","shape-rendering":"auto | optimizeSpeed | crispEdges | geometricPrecision","src":"[ <url> format( <string># )? | local( <family-name> ) ]#","speak":"auto | none | normal","speak-as":"normal | spell-out || digits || [ literal-punctuation | no-punctuation ]","stroke":"<paint>","stroke-dasharray":"none | [ <svg-length>+ ]#","stroke-dashoffset":"<svg-length>","stroke-linecap":"butt | round | square","stroke-linejoin":"miter | round | bevel","stroke-miterlimit":"<number-one-or-greater>","stroke-opacity":"<number-zero-one>","stroke-width":"<svg-length>","text-anchor":"start | middle | end","unicode-range":"<unicode-range>#","voice-balance":"<number> | left | center | right | leftwards | rightwards","voice-duration":"auto | <time>","voice-family":"[ [ <family-name> | <generic-voice> ] , ]* [ <family-name> | <generic-voice> ] | preserve","voice-pitch":"<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]","voice-range":"<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]","voice-rate":"[ normal | x-slow | slow | medium | fast | x-fast ] || <percentage>","voice-stress":"normal | strong | moderate | none | reduced","voice-volume":"silent | [ [ x-soft | soft | medium | loud | x-loud ] || <decibel> ]","zoom":"normal | reset | <number> | <percentage>"}}
},{}],561:[function(require,module,exports){
var List = require('../utils/list');

module.exports = function createConvertors(walk) {
    return {
        fromPlainObject: function(ast) {
            walk(ast, {
                enter: function(node) {
                    if (node.children && node.children instanceof List === false) {
                        node.children = new List().fromArray(node.children);
                    }
                }
            });

            return ast;
        },
        toPlainObject: function(ast) {
            walk(ast, {
                leave: function(node) {
                    if (node.children && node.children instanceof List) {
                        node.children = node.children.toArray();
                    }
                }
            });

            return ast;
        }
    };
};

},{"../utils/list":661}],562:[function(require,module,exports){
'use strict';

var sourceMap = require('./sourceMap');
var hasOwnProperty = Object.prototype.hasOwnProperty;

function processChildren(node, delimeter) {
    var list = node.children;
    var prev = null;

    if (typeof delimeter !== 'function') {
        list.forEach(this.node, this);
    } else {
        list.forEach(function(node) {
            if (prev !== null) {
                delimeter.call(this, prev);
            }

            this.node(node);
            prev = node;
        }, this);
    }
}

module.exports = function createGenerator(config) {
    function processNode(node) {
        if (hasOwnProperty.call(types, node.type)) {
            types[node.type].call(this, node);
        } else {
            throw new Error('Unknown node type: ' + node.type);
        }
    }

    var types = {};

    if (config.node) {
        for (var name in config.node) {
            types[name] = config.node[name].generate;
        }
    }

    return function(node, options) {
        var buffer = '';
        var handlers = {
            children: processChildren,
            node: processNode,
            chunk: function(chunk) {
                buffer += chunk;
            },
            result: function() {
                return buffer;
            }
        };

        if (options) {
            if (typeof options.decorator === 'function') {
                handlers = options.decorator(handlers);
            }

            if (options.sourceMap) {
                handlers = sourceMap(handlers);
            }
        }

        handlers.node(node);

        return handlers.result();
    };
};

},{"./sourceMap":563}],563:[function(require,module,exports){
'use strict';

var SourceMapGenerator = require('source-map').SourceMapGenerator;
var trackNodes = {
    Atrule: true,
    Selector: true,
    Declaration: true
};

module.exports = function generateSourceMap(handlers) {
    var map = new SourceMapGenerator();
    var line = 1;
    var column = 0;
    var generated = {
        line: 1,
        column: 0
    };
    var original = {
        line: 0, // should be zero to add first mapping
        column: 0
    };
    var sourceMappingActive = false;
    var activatedGenerated = {
        line: 1,
        column: 0
    };
    var activatedMapping = {
        generated: activatedGenerated
    };

    var handlersNode = handlers.node;
    handlers.node = function(node) {
        if (node.loc && node.loc.start && trackNodes.hasOwnProperty(node.type)) {
            var nodeLine = node.loc.start.line;
            var nodeColumn = node.loc.start.column - 1;

            if (original.line !== nodeLine ||
                original.column !== nodeColumn) {
                original.line = nodeLine;
                original.column = nodeColumn;

                generated.line = line;
                generated.column = column;

                if (sourceMappingActive) {
                    sourceMappingActive = false;
                    if (generated.line !== activatedGenerated.line ||
                        generated.column !== activatedGenerated.column) {
                        map.addMapping(activatedMapping);
                    }
                }

                sourceMappingActive = true;
                map.addMapping({
                    source: node.loc.source,
                    original: original,
                    generated: generated
                });
            }
        }

        handlersNode.call(this, node);

        if (sourceMappingActive && trackNodes.hasOwnProperty(node.type)) {
            activatedGenerated.line = line;
            activatedGenerated.column = column;
        }
    };

    var handlersChunk = handlers.chunk;
    handlers.chunk = function(chunk) {
        for (var i = 0; i < chunk.length; i++) {
            if (chunk.charCodeAt(i) === 10) { // \n
                line++;
                column = 0;
            } else {
                column++;
            }
        }

        handlersChunk(chunk);
    };

    var handlersResult = handlers.result;
    handlers.result = function() {
        if (sourceMappingActive) {
            map.addMapping(activatedMapping);
        }

        return {
            css: handlersResult(),
            map: map
        };
    };

    return handlers;
};

},{"source-map":1132}],564:[function(require,module,exports){
'use strict';

module.exports = require('./syntax');

},{"./syntax":593}],565:[function(require,module,exports){
'use strict';

var SyntaxReferenceError = require('./error').SyntaxReferenceError;
var MatchError = require('./error').MatchError;
var names = require('../utils/names');
var generic = require('./generic');
var parse = require('./grammar/parse');
var generate = require('./grammar/generate');
var walk = require('./grammar/walk');
var match = require('./match');
var trace = require('./trace');
var search = require('./search');
var getStructureFromConfig = require('./structure').getStructureFromConfig;
var cssWideKeywords = parse('inherit | initial | unset');
var cssWideKeywordsWithExpression = parse('inherit | initial | unset | <expression>');

function dumpMapSyntax(map, syntaxAsAst) {
    var result = {};

    for (var name in map) {
        if (map[name].syntax) {
            result[name] = syntaxAsAst ? map[name].syntax : generate(map[name].syntax);
        }
    }

    return result;
}

function unwrapNode(item) {
    return item && item.data;
}

function valueHasVar(value) {
    var hasVar = false;

    this.syntax.walk(value, function(node) {
        if (node.type === 'Function' && node.name.toLowerCase() === 'var') {
            hasVar = true;
        }
    });

    return hasVar;
}

// check node is \0 or \9 hack
function isHack(node) {
    return node.type === 'Identifier' && /^\\[09]/.test(node.name);
}

// white spaces, comments and some hacks can to be ignored at the end of value
function isNextMayToBeIgnored(cursor) {
    while (cursor !== null) {
        if (cursor.data.type !== 'WhiteSpace' &&
            cursor.data.type !== 'Comment' &&
            !isHack(cursor.data)) {
            return false;
        }

        cursor = cursor.next;
    }

    return true;
}

function buildMatchResult(match, error) {
    return {
        matched: match,
        error: error,
        getTrace: trace.getTrace,
        isType: trace.isType,
        isProperty: trace.isProperty,
        isKeyword: trace.isKeyword
    };
}

function matchSyntax(lexer, syntax, node, useCommon) {
    var result;

    if (!node || !node.children) {
        return buildMatchResult(null, new Error('Node has no children'));
    }

    if (valueHasVar.call(lexer, node)) {
        return buildMatchResult(null, new Error('Matching for a tree with var() is not supported'));
    }

    if (useCommon) {
        result = match(lexer, lexer.valueCommonSyntax, node.children.head);
    }

    if (!useCommon || !result.match) {
        result = syntax.match(node.children.head);
        if (!result.match) {
            return buildMatchResult(null, new MatchError('Mismatch', lexer, syntax.syntax, node, result.badNode || unwrapNode(result.next) || node));
        }
    }

    // enhance top-level match wrapper
    if (result.match.type === 'ASTNode') {
        result.match = {
            syntax: {
                type: syntax.type,
                name: syntax.name
            },
            match: [result.match]
        };
    } else if (result.match.syntax.type === 'Group') {
        result.match.syntax = {
            type: syntax.type,
            name: syntax.name
        };
    }

    if (result.next && !isNextMayToBeIgnored(result.next)) {
        return buildMatchResult(null, new MatchError('Uncomplete match', lexer, syntax.syntax, node, result.badNode || unwrapNode(result.next) || node));
    }

    return buildMatchResult(result.match, null);
}

var Lexer = function(config, syntax, structure) {
    this.valueCommonSyntax = cssWideKeywords;
    this.syntax = syntax;
    this.generic = false;
    this.properties = {};
    this.types = {};
    this.structure = structure || getStructureFromConfig(config);

    if (config) {
        if (config.generic) {
            this.generic = true;
            for (var name in generic) {
                this.addType_(name, generic[name]);
            }
        }

        if (config.types) {
            for (var name in config.types) {
                this.addType_(name, config.types[name]);
            }
        }

        if (config.properties) {
            for (var name in config.properties) {
                this.addProperty_(name, config.properties[name]);
            }
        }
    }
};

Lexer.prototype = {
    structure: {},
    checkStructure: function(ast) {
        function collectWarning(node, message) {
            warns.push({
                node: node,
                message: message
            });
        }

        var structure = this.structure;
        var warns = [];

        this.syntax.walk(ast, function(node) {
            if (structure.hasOwnProperty(node.type)) {
                structure[node.type].check(node, collectWarning);
            } else {
                collectWarning(node, 'Unknown node type `' + node.type + '`');
            }
        });

        return warns.length ? warns : false;
    },

    createDescriptor: function(syntax, type, name) {
        var self = this;
        var descriptor = {
            type: type,
            name: name,
            syntax: null,
            match: null
        };

        if (typeof syntax === 'function') {
            // convert syntax to pseudo syntax node
            // NOTE: that's not a part of match result tree
            syntax = {
                type: 'ASTNode',
                match: syntax
            };

            descriptor.match = function(item) {
                return match(self, syntax, item);
            };
        } else {
            if (typeof syntax === 'string') {
                // lazy parsing on first access
                Object.defineProperty(descriptor, 'syntax', {
                    get: function() {
                        Object.defineProperty(descriptor, 'syntax', {
                            value: parse(syntax)
                        });

                        return descriptor.syntax;
                    }
                });
            } else {
                descriptor.syntax = syntax;
            }

            descriptor.match = function(item) {
                return match(self, descriptor.syntax, item);
            };
        }

        return descriptor;
    },
    addProperty_: function(name, syntax) {
        this.properties[name] = this.createDescriptor(syntax, 'Property', name);
    },
    addType_: function(name, syntax) {
        this.types[name] = this.createDescriptor(syntax, 'Type', name);

        if (syntax === generic.expression) {
            this.valueCommonSyntax = cssWideKeywordsWithExpression;
        }
    },

    matchDeclaration: function(node) {
        if (node.type !== 'Declaration') {
            return buildMatchResult(null, new Error('Not a Declaration node'));
        }

        return this.matchProperty(node.property, node.value);
    },
    matchProperty: function(propertyName, value) {
        var property = names.property(propertyName);

        // don't match syntax for a custom property
        if (property.custom) {
            return buildMatchResult(null, new Error('Lexer matching doesn\'t applicable for custom properties'));
        }

        var propertySyntax = property.vendor
            ? this.getProperty(property.name) || this.getProperty(property.basename)
            : this.getProperty(property.name);

        if (!propertySyntax) {
            return buildMatchResult(null, new SyntaxReferenceError('Unknown property', propertyName));
        }

        return matchSyntax(this, propertySyntax, value, true);
    },
    matchType: function(typeName, value) {
        var typeSyntax = this.getType(typeName);

        if (!typeSyntax) {
            return buildMatchResult(null, new SyntaxReferenceError('Unknown type', typeName));
        }

        return matchSyntax(this, typeSyntax, value, false);
    },
    match: function(syntax, value) {
        if (!syntax || !syntax.type) {
            return buildMatchResult(null, new SyntaxReferenceError('Bad syntax'));
        }

        if (!syntax.match) {
            syntax = this.createDescriptor(syntax);
        }

        return matchSyntax(this, syntax, value, false);
    },

    findValueFragments: function(propertyName, value, type, name) {
        return search.matchFragments(this, value, this.matchProperty(propertyName, value), type, name);
    },
    findDeclarationValueFragments: function(declaration, type, name) {
        return search.matchFragments(this, declaration.value, this.matchDeclaration(declaration), type, name);
    },
    findAllFragments: function(ast, type, name) {
        var result = [];

        this.syntax.walk(ast, {
            visit: 'Declaration',
            enter: function(declaration) {
                result.push.apply(result, this.findDeclarationValueFragments(declaration, type, name));
            }.bind(this)
        });

        return result;
    },

    getProperty: function(name) {
        return this.properties.hasOwnProperty(name) ? this.properties[name] : null;
    },
    getType: function(name) {
        return this.types.hasOwnProperty(name) ? this.types[name] : null;
    },

    validate: function() {
        function validate(syntax, name, broken, descriptor) {
            if (broken.hasOwnProperty(name)) {
                return broken[name];
            }

            broken[name] = false;
            if (descriptor.syntax !== null) {
                walk(descriptor.syntax, function(node) {
                    if (node.type !== 'Type' && node.type !== 'Property') {
                        return;
                    }

                    var map = node.type === 'Type' ? syntax.types : syntax.properties;
                    var brokenMap = node.type === 'Type' ? brokenTypes : brokenProperties;

                    if (!map.hasOwnProperty(node.name) || validate(syntax, node.name, brokenMap, map[node.name])) {
                        broken[name] = true;
                    }
                }, this);
            }
        }

        var brokenTypes = {};
        var brokenProperties = {};

        for (var key in this.types) {
            validate(this, key, brokenTypes, this.types[key]);
        }

        for (var key in this.properties) {
            validate(this, key, brokenProperties, this.properties[key]);
        }

        brokenTypes = Object.keys(brokenTypes).filter(function(name) {
            return brokenTypes[name];
        });
        brokenProperties = Object.keys(brokenProperties).filter(function(name) {
            return brokenProperties[name];
        });

        if (brokenTypes.length || brokenProperties.length) {
            return {
                types: brokenTypes,
                properties: brokenProperties
            };
        }

        return null;
    },
    dump: function(syntaxAsAst) {
        return {
            generic: this.generic,
            types: dumpMapSyntax(this.types, syntaxAsAst),
            properties: dumpMapSyntax(this.properties, syntaxAsAst)
        };
    },
    toString: function() {
        return JSON.stringify(this.dump());
    }
};

module.exports = Lexer;

},{"../utils/names":662,"./error":566,"./generic":567,"./grammar/generate":569,"./grammar/parse":571,"./grammar/walk":572,"./match":573,"./search":574,"./structure":575,"./trace":576}],566:[function(require,module,exports){
'use strict';

var createCustomError = require('../utils/createCustomError');
var generateGrammar = require('./grammar/generate');

function getLocation(node, point) {
    var loc = node && node.loc && node.loc[point];

    return loc
        ? { offset: loc.offset,
            line: loc.line,
            column: loc.column }
        : null;
}

var SyntaxReferenceError = function(type, referenceName) {
    var error = createCustomError(
        'SyntaxReferenceError',
        type + (referenceName ? ' `' + referenceName + '`' : '')
    );

    error.reference = referenceName;

    return error;
};

var MatchError = function(message, lexer, syntax, value, badNode) {
    var error = createCustomError('SyntaxMatchError', message);
    var errorOffset = -1;
    var start = getLocation(badNode, 'start');
    var end = getLocation(badNode, 'end');
    var css = lexer.syntax.generate(value, {
        decorator: function(handlers) {
            var bufferOffset = 0;

            var handlersChunk = handlers.chunk;
            handlers.chunk = function(chunk) {
                bufferOffset += chunk.length;
                handlersChunk(chunk);
            };

            var handlersNode = handlers.node;
            handlers.node = function(node) {
                if (node === badNode) {
                    errorOffset = bufferOffset;
                }

                handlersNode.call(this, node);
            };

            return handlers;
        }
    });

    if (errorOffset === -1) {
        errorOffset = css.length;
    }

    error.rawMessage = message;
    error.syntax = syntax ? generateGrammar(syntax) : '<generic>';
    error.css = css;
    error.mismatchOffset = errorOffset;
    error.loc = {
        source: badNode && badNode.loc && badNode.loc.source || '<unknown>',
        start: start,
        end: end
    };
    error.line = start ? start.line : undefined;
    error.column = start ? start.column : undefined;
    error.offset = start ? start.offset : undefined;
    error.message = message + '\n' +
        '  syntax: ' + error.syntax + '\n' +
        '   value: ' + (error.css || '<empty string>') + '\n' +
        '  --------' + new Array(error.mismatchOffset + 1).join('-') + '^';

    return error;
};

module.exports = {
    SyntaxReferenceError: SyntaxReferenceError,
    MatchError: MatchError
};

},{"../utils/createCustomError":660,"./grammar/generate":569}],567:[function(require,module,exports){
'use strict';

var names = require('../utils/names.js');

// https://www.w3.org/TR/css-values-3/#lengths
var LENGTH = {
    // absolute length units
    'px': true,
    'mm': true,
    'cm': true,
    'in': true,
    'pt': true,
    'pc': true,
    'q': true,

    // relative length units
    'em': true,
    'ex': true,
    'ch': true,
    'rem': true,

    // viewport-percentage lengths
    'vh': true,
    'vw': true,
    'vmin': true,
    'vmax': true,
    'vm': true
};

var ANGLE = {
    'deg': true,
    'grad': true,
    'rad': true,
    'turn': true
};

var TIME = {
    's': true,
    'ms': true
};

var FREQUENCY = {
    'hz': true,
    'khz': true
};

// https://www.w3.org/TR/css-values-3/#resolution (https://drafts.csswg.org/css-values/#resolution)
var RESOLUTION = {
    'dpi': true,
    'dpcm': true,
    'dppx': true,
    'x': true      // https://github.com/w3c/csswg-drafts/issues/461
};

// https://drafts.csswg.org/css-grid/#fr-unit
var FLEX = {
    'fr': true
};

// https://www.w3.org/TR/css3-speech/#mixing-props-voice-volume
var DECIBEL = {
    'db': true
};

// https://www.w3.org/TR/css3-speech/#voice-props-voice-pitch
var SEMITONES = {
    'st': true
};

// can be used wherever <length>, <frequency>, <angle>, <time>, <percentage>, <number>, or <integer> values are allowed
// https://drafts.csswg.org/css-values/#calc-notation
function isCalc(node) {
    if (node.data.type !== 'Function') {
        return false;
    }

    var keyword = names.keyword(node.data.name);

    // check the function name
    return (
        keyword.name === 'calc' ||
        keyword.name === '-moz-calc' ||
        keyword.name === '-webkit-calc'
    );
}

function astNode(type) {
    return function(node) {
        return node.data.type === type;
    };
}

function dimension(type) {
    return function(node) {
        return isCalc(node) ||
               (node.data.type === 'Dimension' && type.hasOwnProperty(node.data.unit.toLowerCase()));
    };
}

function zeroUnitlessDimension(type) {
    return function(node) {
        return isCalc(node) ||
               (node.data.type === 'Dimension' && type.hasOwnProperty(node.data.unit.toLowerCase())) ||
               (node.data.type === 'Number' && Number(node.data.value) === 0);
    };
}

function attr(node) {
    return node.data.type === 'Function' && node.data.name.toLowerCase() === 'attr';
}

function number(node) {
    return isCalc(node) || node.data.type === 'Number';
}

function numberZeroOne(node) {
    if (isCalc(node) || node.data.type === 'Number') {
        var value = Number(node.data.value);

        return value >= 0 && value <= 1;
    }

    return false;
}

function numberOneOrGreater(node) {
    if (isCalc(node) || node.data.type === 'Number') {
        return Number(node.data.value) >= 1;
    }

    return false;
}

// TODO: fail on 10e-2
function integer(node) {
    return isCalc(node) ||
           (node.data.type === 'Number' && node.data.value.indexOf('.') === -1);
}

// TODO: fail on 10e-2
function positiveInteger(node) {
    return isCalc(node) ||
           (node.data.type === 'Number' && node.data.value.indexOf('.') === -1 && node.data.value.charAt(0) !== '-');
}

function percentage(node) {
    return isCalc(node) ||
           node.data.type === 'Percentage';
}

function hexColor(node) {
    if (node.data.type !== 'HexColor') {
        return false;
    }

    var hex = node.data.value;

    return /^[0-9a-fA-F]{3,8}$/.test(hex) &&
           (hex.length === 3 || hex.length === 4 || hex.length === 6 || hex.length === 8);
}

function expression(node) {
    return node.data.type === 'Function' && node.data.name.toLowerCase() === 'expression';
}

// https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident
// https://drafts.csswg.org/css-values-4/#identifier-value
function customIdent(node) {
    if (node.data.type !== 'Identifier') {
        return false;
    }

    var name = node.data.name.toLowerCase();

    //  3.2. Author-defined Identifiers: the <custom-ident> type
    // The CSS-wide keywords are not valid <custom-ident>s
    if (name === 'unset' || name === 'initial' || name === 'inherit') {
        return false;
    }

    // The default keyword is reserved and is also not a valid <custom-ident>
    if (name === 'default') {
        return false;
    }

    // TODO: ignore property specific keywords (as described https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident)

    return true;
}

module.exports = {
    'angle': zeroUnitlessDimension(ANGLE),
    'attr()': attr,
    'custom-ident': customIdent,
    'decibel': dimension(DECIBEL),
    'dimension': astNode('Dimension'),
    'frequency': dimension(FREQUENCY),
    'flex': dimension(FLEX),
    'hex-color': hexColor,
    'id-selector': astNode('IdSelector'), // element( <id-selector> )
    'ident': astNode('Identifier'),
    'integer': integer,
    'length': zeroUnitlessDimension(LENGTH),
    'number': number,
    'number-zero-one': numberZeroOne,
    'number-one-or-greater': numberOneOrGreater,
    'percentage': percentage,
    'positive-integer': positiveInteger,
    'resolution': dimension(RESOLUTION),
    'semitones': dimension(SEMITONES),
    'string': astNode('String'),
    'time': dimension(TIME),
    'unicode-range': astNode('UnicodeRange'),
    'url': astNode('Url'),

    // old IE stuff
    'progid': astNode('Raw'),
    'expression': expression
};

},{"../utils/names.js":662}],568:[function(require,module,exports){
'use strict';

var createCustomError = require('../../utils/createCustomError');

var SyntaxParseError = function(message, syntaxStr, offset) {
    var error = createCustomError('SyntaxParseError', message);

    error.rawMessage = message;
    error.syntax = syntaxStr;
    error.offset = offset;
    error.message = error.rawMessage + '\n' +
        '  ' + error.syntax + '\n' +
        '--' + new Array((error.offset || error.syntax.length) + 1).join('-') + '^';

    return error;
};

module.exports = {
    SyntaxParseError: SyntaxParseError
};

},{"../../utils/createCustomError":660}],569:[function(require,module,exports){
'use strict';

function isNodeType(node, type) {
    return node && node.type === type;
}

function serializeMultiplier(multiplier) {
    if (multiplier.min === 0 && multiplier.max === 0) {
        return '*';
    }

    if (multiplier.min === 0 && multiplier.max === 1) {
        return '?';
    }

    if (multiplier.min === 1 && multiplier.max === 0) {
        return multiplier.comma ? '#' : '+';
    }

    if (multiplier.min === 1 && multiplier.max === 1) {
        return '';
    }

    return (
        (multiplier.comma ? '#' : '') +
        '{' + multiplier.min + (multiplier.min !== multiplier.max ? ',' + (multiplier.max !== 0 ? multiplier.max : '') : '') + '}'
    );
}

function generateSequence(node, forceBraces, decorate) {
    var result = '';

    if (node.explicit || forceBraces) {
        result += '[' + (!isNodeType(node.terms[0], 'Comma') ? ' ' : '');
    }

    result += node.terms.map(function(term) {
        return generate(term, forceBraces, decorate);
    }).join(node.combinator === ' ' ? ' ' : ' ' + node.combinator + ' ');

    if (node.explicit || forceBraces) {
        result += ' ]';
    }

    return result;
}

function generateParentheses(group, forceBraces, decorate) {
    if (!group.terms.length) {
        return '()';
    }

    return '( ' + generateSequence(group, forceBraces, decorate) + ' )';
}

function generate(node, forceBraces, decorate) {
    var result;

    switch (node.type) {
        case 'Group':
            result =
                generateSequence(node, forceBraces, decorate) +
                (node.disallowEmpty ? '!' : '') +
                serializeMultiplier(node.multiplier);
            break;

        case 'Keyword':
            result = node.name;
            break;

        case 'Function':
            result = node.name + generateParentheses(node.children, forceBraces, decorate);
            break;

        case 'Parentheses': // replace for seq('(' seq(...node.children) ')')
            result = generateParentheses(node.children, forceBraces, decorate);
            break;

        case 'Type':
            result = '<' + node.name + '>';
            break;

        case 'Property':
            result = '<\'' + node.name + '\'>';
            break;

        case 'Combinator': // remove?
        case 'Slash':      // replace for String? '/'
        case 'Percent':    // replace for String? '%'
        case 'String':
        case 'Comma':
            result = node.value;
            break;

        default:
            throw new Error('Unknown node type `' + node.type + '`');
    }

    if (typeof decorate === 'function') {
        result = decorate(result, node);
    }

    return result;
}

module.exports = generate;

},{}],570:[function(require,module,exports){
module.exports = {
    SyntaxParseError: require('./error').SyntaxParseError,
    parse: require('./parse'),
    generate: require('./generate'),
    walk: require('./walk')
};

},{"./error":568,"./generate":569,"./parse":571,"./walk":572}],571:[function(require,module,exports){
'use strict';

var SyntaxParseError = require('./error').SyntaxParseError;

var TAB = 9;
var N = 10;
var F = 12;
var R = 13;
var SPACE = 32;
var EXCLAMATIONMARK = 33;    // !
var NUMBERSIGN = 35;         // #
var PERCENTSIGN = 37;        // %
var AMPERSAND = 38;          // &
var APOSTROPHE = 39;         // '
var LEFTPARENTHESIS = 40;    // (
var RIGHTPARENTHESIS = 41;   // )
var ASTERISK = 42;           // *
var PLUSSIGN = 43;           // +
var COMMA = 44;              // ,
var SOLIDUS = 47;            // /
var LESSTHANSIGN = 60;       // <
var GREATERTHANSIGN = 62;    // >
var QUESTIONMARK = 63;       // ?
var LEFTSQUAREBRACKET = 91;  // [
var RIGHTSQUAREBRACKET = 93; // ]
var LEFTCURLYBRACKET = 123;  // {
var VERTICALLINE = 124;      // |
var RIGHTCURLYBRACKET = 125; // }
var COMBINATOR_PRECEDENCE = {
    ' ': 1,
    '&&': 2,
    '||': 3,
    '|': 4
};
var MULTIPLIER_DEFAULT = {
    comma: false,
    min: 1,
    max: 1
};
var MULTIPLIER_ZERO_OR_MORE = {
    comma: false,
    min: 0,
    max: 0
};
var MULTIPLIER_ONE_OR_MORE = {
    comma: false,
    min: 1,
    max: 0
};
var MULTIPLIER_ONE_OR_MORE_COMMA_SEPARATED = {
    comma: true,
    min: 1,
    max: 0
};
var MULTIPLIER_ZERO_OR_ONE = {
    comma: false,
    min: 0,
    max: 1
};
var NAME_CHAR = (function() {
    var array = typeof Uint32Array === 'function' ? new Uint32Array(128) : new Array(128);
    for (var i = 0; i < 128; i++) {
        array[i] = /[a-zA-Z0-9\-]/.test(String.fromCharCode(i)) ? 1 : 0;
    }
    return array;
})();

var Tokenizer = function(str) {
    this.str = str;
    this.pos = 0;
};
Tokenizer.prototype = {
    charCode: function() {
        return this.pos < this.str.length ? this.str.charCodeAt(this.pos) : 0;
    },
    nextCharCode: function() {
        return this.pos + 1 < this.str.length ? this.str.charCodeAt(this.pos + 1) : 0;
    },
    substringToPos: function(end) {
        return this.str.substring(this.pos, this.pos = end);
    },
    eat: function(code) {
        if (this.charCode() !== code) {
            error(this, this.pos, 'Expect `' + String.fromCharCode(code) + '`');
        }

        this.pos++;
    }
};

function scanSpaces(tokenizer) {
    var end = tokenizer.pos + 1;

    for (; end < tokenizer.str.length; end++) {
        var code = tokenizer.str.charCodeAt(end);
        if (code !== R && code !== N && code !== F && code !== SPACE && code !== TAB) {
            break;
        }
    }

    return tokenizer.substringToPos(end);
}

function scanWord(tokenizer) {
    var end = tokenizer.pos;

    for (; end < tokenizer.str.length; end++) {
        var code = tokenizer.str.charCodeAt(end);
        if (code >= 128 || NAME_CHAR[code] === 0) {
            break;
        }
    }

    if (tokenizer.pos === end) {
        error(tokenizer, tokenizer.pos, 'Expect a keyword');
    }

    return tokenizer.substringToPos(end);
}

function scanNumber(tokenizer) {
    var end = tokenizer.pos;

    for (; end < tokenizer.str.length; end++) {
        var code = tokenizer.str.charCodeAt(end);
        if (code < 48 || code > 57) {
            break;
        }
    }

    if (tokenizer.pos === end) {
        error(tokenizer, tokenizer.pos, 'Expect a number');
    }

    return tokenizer.substringToPos(end);
}

function scanString(tokenizer) {
    var end = tokenizer.str.indexOf('\'', tokenizer.pos + 1);

    if (end === -1) {
        error(tokenizer, tokenizer.str.length, 'Expect a quote');
    }

    return tokenizer.substringToPos(end + 1);
}

function readMultiplierRange(tokenizer, comma) {
    var min = null;
    var max = null;

    tokenizer.eat(LEFTCURLYBRACKET);

    min = scanNumber(tokenizer);

    if (tokenizer.charCode() === COMMA) {
        tokenizer.pos++;
        if (tokenizer.charCode() !== RIGHTCURLYBRACKET) {
            max = scanNumber(tokenizer);
        }
    } else {
        max = min;
    }

    tokenizer.eat(RIGHTCURLYBRACKET);

    return {
        comma: comma,
        min: Number(min),
        max: max ? Number(max) : 0
    };
}

function readMultiplier(tokenizer) {
    switch (tokenizer.charCode()) {
        case ASTERISK:
            tokenizer.pos++;
            return MULTIPLIER_ZERO_OR_MORE;

        case PLUSSIGN:
            tokenizer.pos++;
            return MULTIPLIER_ONE_OR_MORE;

        case QUESTIONMARK:
            tokenizer.pos++;
            return MULTIPLIER_ZERO_OR_ONE;

        case NUMBERSIGN:
            tokenizer.pos++;

            if (tokenizer.charCode() !== LEFTCURLYBRACKET) {
                return MULTIPLIER_ONE_OR_MORE_COMMA_SEPARATED;
            }

            return readMultiplierRange(tokenizer, true);

        case LEFTCURLYBRACKET:
            return readMultiplierRange(tokenizer, false);
    }

    return MULTIPLIER_DEFAULT;
}

function maybeMultiplied(tokenizer, node) {
    var multiplier = readMultiplier(tokenizer);

    if (multiplier !== MULTIPLIER_DEFAULT) {
        return {
            type: 'Group',
            terms: [node],
            combinator: '|',  // `|` combinator is simplest in implementation (and therefore faster)
            disallowEmpty: false,
            multiplier: multiplier,
            explicit: false
        };
    }

    return node;
}

function readProperty(tokenizer) {
    var name;

    tokenizer.eat(LESSTHANSIGN);
    tokenizer.eat(APOSTROPHE);

    name = scanWord(tokenizer);

    tokenizer.eat(APOSTROPHE);
    tokenizer.eat(GREATERTHANSIGN);

    return maybeMultiplied(tokenizer, {
        type: 'Property',
        name: name
    });
}

function readType(tokenizer) {
    var name;

    tokenizer.eat(LESSTHANSIGN);
    name = scanWord(tokenizer);

    if (tokenizer.charCode() === LEFTPARENTHESIS &&
        tokenizer.nextCharCode() === RIGHTPARENTHESIS) {
        tokenizer.pos += 2;
        name += '()';
    }

    tokenizer.eat(GREATERTHANSIGN);

    return maybeMultiplied(tokenizer, {
        type: 'Type',
        name: name
    });
}

function readKeywordOrFunction(tokenizer) {
    var children = null;
    var name;

    name = scanWord(tokenizer);

    if (tokenizer.charCode() === LEFTPARENTHESIS) {
        tokenizer.pos++;
        children = readImplicitGroup(tokenizer);
        tokenizer.eat(RIGHTPARENTHESIS);

        return maybeMultiplied(tokenizer, {
            type: 'Function',
            name: name,
            children: children
        });
    }

    return maybeMultiplied(tokenizer, {
        type: 'Keyword',
        name: name
    });
}

function regroupTerms(terms, combinators) {
    function createGroup(terms, combinator) {
        return {
            type: 'Group',
            terms: terms,
            combinator: combinator,
            disallowEmpty: false,
            multiplier: MULTIPLIER_DEFAULT,
            explicit: false
        };
    }

    combinators = Object.keys(combinators).sort(function(a, b) {
        return COMBINATOR_PRECEDENCE[a] - COMBINATOR_PRECEDENCE[b];
    });

    while (combinators.length > 0) {
        var combinator = combinators.shift();
        for (var i = 0, subgroupStart = 0; i < terms.length; i++) {
            var term = terms[i];
            if (term.type === 'Combinator') {
                if (term.value === combinator) {
                    if (subgroupStart === -1) {
                        subgroupStart = i - 1;
                    }
                    terms.splice(i, 1);
                    i--;
                } else {
                    if (subgroupStart !== -1 && i - subgroupStart > 1) {
                        terms.splice(
                            subgroupStart,
                            i - subgroupStart,
                            createGroup(terms.slice(subgroupStart, i), combinator)
                        );
                        i = subgroupStart + 1;
                    }
                    subgroupStart = -1;
                }
            }
        }

        if (subgroupStart !== -1 && combinators.length) {
            terms.splice(
                subgroupStart,
                i - subgroupStart,
                createGroup(terms.slice(subgroupStart, i), combinator)
            );
        }
    }

    return combinator;
}

function readImplicitGroup(tokenizer) {
    var terms = [];
    var combinators = {};
    var token;
    var prevToken = null;
    var prevTokenPos = tokenizer.pos;

    while (token = peek(tokenizer)) {
        if (token.type !== 'Spaces') {
            if (token.type === 'Combinator') {
                // check for combinator in group beginning and double combinator sequence
                if (prevToken === null || prevToken.type === 'Combinator') {
                    error(tokenizer, prevTokenPos, 'Unexpected combinator');
                }

                combinators[token.value] = true;
            } else if (prevToken !== null && prevToken.type !== 'Combinator') {
                combinators[' '] = true;  // a b
                terms.push({
                    type: 'Combinator',
                    value: ' '
                });
            }

            terms.push(token);
            prevToken = token;
            prevTokenPos = tokenizer.pos;
        }
    }

    // check for combinator in group ending
    if (prevToken !== null && prevToken.type === 'Combinator') {
        error(tokenizer, tokenizer.pos - prevTokenPos, 'Unexpected combinator');
    }

    return {
        type: 'Group',
        terms: terms,
        combinator: regroupTerms(terms, combinators) || ' ',
        disallowEmpty: false,
        multiplier: MULTIPLIER_DEFAULT,
        explicit: false
    };
}

function readGroup(tokenizer) {
    var result;

    tokenizer.eat(LEFTSQUAREBRACKET);
    result = readImplicitGroup(tokenizer);
    tokenizer.eat(RIGHTSQUAREBRACKET);

    result.explicit = true;
    result.multiplier = readMultiplier(tokenizer);

    if (tokenizer.charCode() === EXCLAMATIONMARK) {
        tokenizer.pos++;
        result.disallowEmpty = true;
    }

    return result;
}

function peek(tokenizer) {
    var code = tokenizer.charCode();

    if (code < 128 && NAME_CHAR[code] === 1) {
        return readKeywordOrFunction(tokenizer);
    }

    switch (code) {
        case LEFTSQUAREBRACKET:
            return readGroup(tokenizer);

        case LESSTHANSIGN:
            if (tokenizer.nextCharCode() === APOSTROPHE) {
                return readProperty(tokenizer);
            } else {
                return readType(tokenizer);
            }

        case VERTICALLINE:
            return {
                type: 'Combinator',
                value: tokenizer.substringToPos(tokenizer.nextCharCode() === VERTICALLINE ? tokenizer.pos + 2 : tokenizer.pos + 1)
            };

        case AMPERSAND:
            tokenizer.pos++;
            tokenizer.eat(AMPERSAND);
            return {
                type: 'Combinator',
                value: '&&'
            };

        case COMMA:
            tokenizer.pos++;
            return {
                type: 'Comma',
                value: ','
            };

        case SOLIDUS:
            tokenizer.pos++;
            return {
                type: 'Slash',
                value: '/'
            };

        case PERCENTSIGN:  // looks like exception, needs for attr()'s <type-or-unit>
            tokenizer.pos++;
            return {
                type: 'Percent',
                value: '%'
            };

        case LEFTPARENTHESIS:
            tokenizer.pos++;
            var children = readImplicitGroup(tokenizer);
            tokenizer.eat(RIGHTPARENTHESIS);

            return {
                type: 'Parentheses',
                children: children
            };

        case APOSTROPHE:
            return {
                type: 'String',
                value: scanString(tokenizer)
            };

        case SPACE:
        case TAB:
        case N:
        case R:
        case F:
            return {
                type: 'Spaces',
                value: scanSpaces(tokenizer)
            };
    }
}

function error(tokenizer, pos, msg) {
    throw new SyntaxParseError(msg || 'Unexpected input', tokenizer.str, pos);
}

function parse(str) {
    var tokenizer = new Tokenizer(str);
    var result = readImplicitGroup(tokenizer);

    if (tokenizer.pos !== str.length) {
        error(tokenizer, tokenizer.pos);
    }

    // reduce redundant groups with single group term
    if (result.terms.length === 1 && result.terms[0].type === 'Group') {
        result = result.terms[0];
    }

    return result;
}

// warm up parse to elimitate code branches that never execute
// fix soft deoptimizations (insufficient type feedback)
parse('[a&&<b>#|<\'c\'>*||e(){2,} f{2} /,(% g#{1,2})]!');

module.exports = parse;

},{"./error":568}],572:[function(require,module,exports){
'use strict';

var noop = function() {};

function ensureFunction(value) {
    return typeof value === 'function' ? value : noop;
}

module.exports = function(node, fn, context) {
    function walk(node) {
        enter.call(context, node);

        switch (node.type) {
            case 'Group':
                node.terms.forEach(walk);
                break;

            case 'Function':
            case 'Parentheses':
                walk(node.children);
                break;

            case 'Keyword':
            case 'Type':
            case 'Property':
            case 'Combinator':
            case 'Comma':
            case 'Slash':
            case 'String':
            case 'Percent':
                break;

            default:
                throw new Error('Unknown type: ' + node.type);
        }

        leave.call(context, node);
    }

    var enter = noop;
    var leave = noop;

    if (typeof fn === 'function') {
        enter = fn;
    } else if (fn) {
        enter = ensureFunction(fn.enter);
        leave = ensureFunction(fn.leave);
    }

    if (enter === noop && leave === noop) {
        throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
    }

    walk(node, context);
};

},{}],573:[function(require,module,exports){
'use strict';

var names = require('../utils/names');
var MULTIPLIER_DEFAULT = {
    comma: false,
    min: 1,
    max: 1
};

function skipSpaces(node) {
    while (node !== null && (node.data.type === 'WhiteSpace' || node.data.type === 'Comment')) {
        node = node.next;
    }

    return node;
}

function putResult(buffer, match) {
    var type = match.type || match.syntax.type;

    // ignore groups
    if (type === 'Group') {
        buffer.push.apply(buffer, match.match);
    } else {
        buffer.push(match);
    }
}

function matchToJSON() {
    return {
        type: this.syntax.type,
        name: this.syntax.name,
        match: this.match,
        node: this.node
    };
}

function buildMatchNode(badNode, lastNode, next, match) {
    if (badNode) {
        return {
            badNode: badNode,
            lastNode: null,
            next: null,
            match: null
        };
    }

    return {
        badNode: null,
        lastNode: lastNode,
        next: next,
        match: match
    };
}

function matchGroup(lexer, syntaxNode, node) {
    var result = [];
    var buffer;
    var multiplier = syntaxNode.multiplier || MULTIPLIER_DEFAULT;
    var min = multiplier.min;
    var max = multiplier.max === 0 ? Infinity : multiplier.max;
    var lastCommaTermCount;
    var lastComma;
    var matchCount = 0;
    var lastNode = null;
    var badNode = null;

    mismatch:
    while (matchCount < max) {
        node = skipSpaces(node);
        buffer = [];

        switch (syntaxNode.combinator) {
            case '|':
                for (var i = 0; i < syntaxNode.terms.length; i++) {
                    var term = syntaxNode.terms[i];
                    var res = matchSyntax(lexer, term, node);

                    if (res.match) {
                        putResult(buffer, res.match);
                        node = res.next;
                        break;  // continue matching
                    } else if (res.badNode) {
                        badNode = res.badNode;
                        break mismatch;
                    } else if (res.lastNode) {
                        lastNode = res.lastNode;
                    }
                }

                if (buffer.length === 0) {
                    break mismatch; // nothing found -> stop matching
                }

                break;

            case ' ':
                var beforeMatchNode = node;
                var lastMatchedTerm = null;
                var hasTailMatch = false;
                var commaMissed = false;

                for (var i = 0; i < syntaxNode.terms.length; i++) {
                    var term = syntaxNode.terms[i];
                    var res = matchSyntax(lexer, term, node);

                    if (res.match) {
                        if (term.type === 'Comma' && i !== 0 && !hasTailMatch) {
                            // recover cursor to state before last match and stop matching
                            lastNode = node && node.data;
                            node = beforeMatchNode;
                            break mismatch;
                        }

                        // non-empty match (res.next will refer to another node)
                        if (res.next !== node) {
                            // match should be preceded by a comma
                            if (commaMissed) {
                                lastNode = node && node.data;
                                node = beforeMatchNode;
                                break mismatch;
                            }

                            hasTailMatch = term.type !== 'Comma';
                            lastMatchedTerm = term;
                        }

                        putResult(buffer, res.match);
                        node = skipSpaces(res.next);
                    } else if (res.badNode) {
                        badNode = res.badNode;
                        break mismatch;
                    } else {
                        if (res.lastNode) {
                            lastNode = res.lastNode;
                        }

                        // it's ok when comma doesn't match when no matches yet
                        // but only if comma is not first or last term
                        if (term.type === 'Comma' && i !== 0 && i !== syntaxNode.terms.length - 1) {
                            if (hasTailMatch) {
                                commaMissed = true;
                            }
                            continue;
                        }

                        // recover cursor to state before last match and stop matching
                        lastNode = res.lastNode || (node && node.data);
                        node = beforeMatchNode;
                        break mismatch;
                    }
                }

                // don't allow empty match when [ ]!
                if (!lastMatchedTerm && syntaxNode.disallowEmpty) {
                    // empty match but shouldn't
                    // recover cursor to state before last match and stop matching
                    lastNode = node && node.data;
                    node = beforeMatchNode;
                    break mismatch;
                }

                // don't allow comma at the end but only if last term isn't a comma
                if (lastMatchedTerm && lastMatchedTerm.type === 'Comma' && term.type !== 'Comma') {
                    lastNode = node && node.data;
                    node = beforeMatchNode;
                    break mismatch;
                }

                break;

            case '&&':
                var beforeMatchNode = node;
                var lastMatchedTerm = null;
                var terms = syntaxNode.terms.slice();

                while (terms.length) {
                    var wasMatch = false;
                    var emptyMatched = 0;

                    for (var i = 0; i < terms.length; i++) {
                        var term = terms[i];
                        var res = matchSyntax(lexer, term, node);

                        if (res.match) {
                            // non-empty match (res.next will refer to another node)
                            if (res.next !== node) {
                                lastMatchedTerm = term;
                            } else {
                                emptyMatched++;
                                continue;
                            }

                            wasMatch = true;
                            terms.splice(i--, 1);
                            putResult(buffer, res.match);
                            node = skipSpaces(res.next);
                            break;
                        } else if (res.badNode) {
                            badNode = res.badNode;
                            break mismatch;
                        } else if (res.lastNode) {
                            lastNode = res.lastNode;
                        }
                    }

                    if (!wasMatch) {
                        // terms left, but they all are optional
                        if (emptyMatched === terms.length) {
                            break;
                        }

                        // not ok
                        lastNode = node && node.data;
                        node = beforeMatchNode;
                        break mismatch;
                    }
                }

                if (!lastMatchedTerm && syntaxNode.disallowEmpty) { // don't allow empty match when [ ]!
                    // empty match but shouldn't
                    // recover cursor to state before last match and stop matching
                    lastNode = node && node.data;
                    node = beforeMatchNode;
                    break mismatch;
                }

                break;

            case '||':
                var beforeMatchNode = node;
                var lastMatchedTerm = null;
                var terms = syntaxNode.terms.slice();

                while (terms.length) {
                    var wasMatch = false;
                    var emptyMatched = 0;

                    for (var i = 0; i < terms.length; i++) {
                        var term = terms[i];
                        var res = matchSyntax(lexer, term, node);

                        if (res.match) {
                            // non-empty match (res.next will refer to another node)
                            if (res.next !== node) {
                                lastMatchedTerm = term;
                            } else {
                                emptyMatched++;
                                continue;
                            }

                            wasMatch = true;
                            terms.splice(i--, 1);
                            putResult(buffer, res.match);
                            node = skipSpaces(res.next);
                            break;
                        } else if (res.badNode) {
                            badNode = res.badNode;
                            break mismatch;
                        } else if (res.lastNode) {
                            lastNode = res.lastNode;
                        }
                    }

                    if (!wasMatch) {
                        break;
                    }
                }

                // don't allow empty match
                if (!lastMatchedTerm && (emptyMatched !== terms.length || syntaxNode.disallowEmpty)) {
                    // empty match but shouldn't
                    // recover cursor to state before last match and stop matching
                    lastNode = node && node.data;
                    node = beforeMatchNode;
                    break mismatch;
                }

                break;
        }

        // flush buffer
        result.push.apply(result, buffer);
        matchCount++;

        if (!node) {
            break;
        }

        if (multiplier.comma) {
            if (lastComma && lastCommaTermCount === result.length) {
                // nothing match after comma
                break mismatch;
            }

            node = skipSpaces(node);
            if (node !== null && node.data.type === 'Operator' && node.data.value === ',') {
                result.push({
                    syntax: syntaxNode,
                    match: [{
                        type: 'ASTNode',
                        node: node.data,
                        childrenMatch: null
                    }]
                });
                lastCommaTermCount = result.length;
                lastComma = node;
                node = node.next;
            } else {
                lastNode = node !== null ? node.data : null;
                break mismatch;
            }
        }
    }

    // console.log(syntaxNode.type, badNode, lastNode);

    if (lastComma && lastCommaTermCount === result.length) {
        // nothing match after comma
        node = lastComma;
        result.pop();
    }

    return buildMatchNode(badNode, lastNode, node, matchCount < min ? null : {
        syntax: syntaxNode,
        match: result,
        toJSON: matchToJSON
    });
}

function matchSyntax(lexer, syntaxNode, node) {
    var badNode = null;
    var lastNode = null;
    var match = null;

    switch (syntaxNode.type) {
        case 'Group':
            return matchGroup(lexer, syntaxNode, node);

        case 'Function':
            // expect a function node
            if (!node || node.data.type !== 'Function') {
                break;
            }

            var keyword = names.keyword(node.data.name);
            var name = syntaxNode.name.toLowerCase();

            // check function name with vendor consideration
            if (name !== keyword.name) {
                break;
            }

            var res = matchSyntax(lexer, syntaxNode.children, node.data.children.head);
            if (!res.match || res.next) {
                badNode = res.badNode || res.lastNode || (res.next ? res.next.data : null) || node.data;
                break;
            }

            match = [{
                type: 'ASTNode',
                node: node.data,
                childrenMatch: res.match.match
            }];

            // Use node.next instead of res.next here since syntax is matching
            // for internal list and it should be completelly matched (res.next is null at this point).
            // Therefore function is matched and we are going to next node
            node = node.next;
            break;

        case 'Parentheses':
            if (!node || node.data.type !== 'Parentheses') {
                break;
            }

            var res = matchSyntax(lexer, syntaxNode.children, node.data.children.head);
            if (!res.match || res.next) {
                badNode = res.badNode || res.lastNode || (res.next ? res.next.data : null) || node.data;  // TODO: case when res.next === null
                break;
            }

            match = [{
                type: 'ASTNode',
                node: node.data,
                childrenMatch: res.match.match
            }];

            node = res.next;
            break;

        case 'Type':
            var typeSyntax = lexer.getType(syntaxNode.name);
            if (!typeSyntax) {
                throw new Error('Unknown syntax type `' + syntaxNode.name + '`');
            }

            var res = typeSyntax.match(node);
            if (!res.match) {
                badNode = res && res.badNode; // TODO: case when res.next === null
                lastNode = (res && res.lastNode) || (node && node.data);
                break;
            }

            node = res.next;
            putResult(match = [], res.match);
            if (match.length === 0) {
                match = null;
            }
            break;

        case 'Property':
            var propertySyntax = lexer.getProperty(syntaxNode.name);
            if (!propertySyntax) {
                throw new Error('Unknown property `' + syntaxNode.name + '`');
            }

            var res = propertySyntax.match(node);
            if (!res.match) {
                badNode = res && res.badNode; // TODO: case when res.next === null
                lastNode = (res && res.lastNode) || (node && node.data);
                break;
            }

            node = res.next;
            putResult(match = [], res.match);
            if (match.length === 0) {
                match = null;
            }
            break;

        case 'Keyword':
            if (!node) {
                break;
            }

            if (node.data.type === 'Identifier') {
                var keyword = names.keyword(node.data.name);
                var keywordName = keyword.name;
                var name = syntaxNode.name.toLowerCase();

                // drop \0 and \9 hack from keyword name
                if (keywordName.indexOf('\\') !== -1) {
                    keywordName = keywordName.replace(/\\[09].*$/, '');
                }

                if (name !== keywordName) {
                    break;
                }
            } else {
                // keyword may to be a number (e.g. font-weight: 400 )
                if (node.data.type !== 'Number' || node.data.value !== syntaxNode.name) {
                    break;
                }
            }

            match = [{
                type: 'ASTNode',
                node: node.data,
                childrenMatch: null
            }];
            node = node.next;
            break;

        case 'Slash':
        case 'Comma':
            if (!node || node.data.type !== 'Operator' || node.data.value !== syntaxNode.value) {
                break;
            }

            match = [{
                type: 'ASTNode',
                node: node.data,
                childrenMatch: null
            }];
            node = node.next;
            break;

        case 'String':
            if (!node || node.data.type !== 'String') {
                break;
            }

            match = [{
                type: 'ASTNode',
                node: node.data,
                childrenMatch: null
            }];
            node = node.next;
            break;

        case 'ASTNode':
            if (node && syntaxNode.match(node)) {
                match = {
                    type: 'ASTNode',
                    node: node.data,
                    childrenMatch: null
                };
                node = node.next;
            }
            return buildMatchNode(badNode, lastNode, node, match);

        default:
            throw new Error('Not implemented yet node type: ' + syntaxNode.type);
    }

    return buildMatchNode(badNode, lastNode, node, match === null ? null : {
        syntax: syntaxNode,
        match: match,
        toJSON: matchToJSON
    });

};

module.exports = matchSyntax;

},{"../utils/names":662}],574:[function(require,module,exports){
var List = require('../utils/list');

function getFirstMatchNode(matchNode) {
    if (matchNode.type === 'ASTNode') {
        return matchNode.node;
    }

    return getFirstMatchNode(matchNode.match[0]);
}

function getLastMatchNode(matchNode) {
    if (matchNode.type === 'ASTNode') {
        return matchNode.node;
    }

    return getLastMatchNode(matchNode.match[matchNode.match.length - 1]);
}

function matchFragments(lexer, ast, match, type, name) {
    function findFragments(matchNode) {
        if (matchNode.type === 'ASTNode') {
            return;
        }

        if (matchNode.syntax.type === type &&
            matchNode.syntax.name === name) {
            var start = getFirstMatchNode(matchNode);
            var end = getLastMatchNode(matchNode);

            lexer.syntax.walk(ast, function(node, item, list) {
                if (node === start) {
                    var nodes = new List();

                    do {
                        nodes.appendData(item.data);

                        if (item.data === end) {
                            break;
                        }

                        item = item.next;
                    } while (item !== null);

                    fragments.push({
                        parent: list,
                        nodes: nodes
                    });
                }
            });
        }

        matchNode.match.forEach(findFragments);
    }

    var fragments = [];

    if (match.matched !== null) {
        findFragments(match.matched);
    }

    return fragments;
}

module.exports = {
    matchFragments: matchFragments
};

},{"../utils/list":661}],575:[function(require,module,exports){
var List = require('../utils/list');
var hasOwnProperty = Object.prototype.hasOwnProperty;

function isValidNumber(value) {
    // Number.isInteger(value) && value >= 0
    return (
        typeof value === 'number' &&
        isFinite(value) &&
        Math.floor(value) === value &&
        value >= 0
    );
}

function isValidLocation(loc) {
    return (
        Boolean(loc) &&
        isValidNumber(loc.offset) &&
        isValidNumber(loc.line) &&
        isValidNumber(loc.column)
    );
}

function createNodeStructureChecker(type, fields) {
    return function checkNode(node, warn) {
        if (!node || node.constructor !== Object) {
            return warn(node, 'Type of node should be an Object');
        }

        for (var key in node) {
            var valid = true;

            if (hasOwnProperty.call(node, key) === false) {
                continue;
            }

            if (key === 'type') {
                if (node.type !== type) {
                    warn(node, 'Wrong node type `' + node.type + '`, expected `' + type + '`');
                }
            } else if (key === 'loc') {
                if (node.loc === null) {
                    continue;
                } else if (node.loc && node.loc.constructor === Object) {
                    if (typeof node.loc.source !== 'string') {
                        key += '.source';
                    } else if (!isValidLocation(node.loc.start)) {
                        key += '.start';
                    } else if (!isValidLocation(node.loc.end)) {
                        key += '.end';
                    } else {
                        continue;
                    }
                }

                valid = false;
            } else if (fields.hasOwnProperty(key)) {
                for (var i = 0, valid = false; !valid && i < fields[key].length; i++) {
                    var fieldType = fields[key][i];

                    switch (fieldType) {
                        case String:
                            valid = typeof node[key] === 'string';
                            break;

                        case Boolean:
                            valid = typeof node[key] === 'boolean';
                            break;

                        case null:
                            valid = node[key] === null;
                            break;

                        default:
                            if (typeof fieldType === 'string') {
                                valid = node[key] && node[key].type === fieldType;
                            } else if (Array.isArray(fieldType)) {
                                valid = node[key] instanceof List;
                            }
                    }
                }
            } else {
                warn(node, 'Unknown field `' + key + '` for ' + type + ' node type');
            }

            if (!valid) {
                warn(node, 'Bad value for `' + type + '.' + key + '`');
            }
        }

        for (var key in fields) {
            if (hasOwnProperty.call(fields, key) &&
                hasOwnProperty.call(node, key) === false) {
                warn(node, 'Field `' + type + '.' + key + '` is missed');
            }
        }
    };
}

function processStructure(name, nodeType) {
    var structure = nodeType.structure;
    var fields = {
        type: String,
        loc: true
    };
    var docs = {
        type: '"' + name + '"'
    };

    for (var key in structure) {
        if (hasOwnProperty.call(structure, key) === false) {
            continue;
        }

        var docsTypes = [];
        var fieldTypes = fields[key] = Array.isArray(structure[key])
            ? structure[key].slice()
            : [structure[key]];

        for (var i = 0; i < fieldTypes.length; i++) {
            var fieldType = fieldTypes[i];
            if (fieldType === String || fieldType === Boolean) {
                docsTypes.push(fieldType.name);
            } else if (fieldType === null) {
                docsTypes.push('null');
            } else if (typeof fieldType === 'string') {
                docsTypes.push('<' + fieldType + '>');
            } else if (Array.isArray(fieldType)) {
                docsTypes.push('List'); // TODO: use type enum
            } else {
                throw new Error('Wrong value `' + fieldType + '` in `' + name + '.' + key + '` structure definition');
            }
        }

        docs[key] = docsTypes.join(' | ');
    }

    return {
        docs: docs,
        check: createNodeStructureChecker(name, fields)
    };
}

module.exports = {
    getStructureFromConfig: function(config) {
        var structure = {};

        if (config.node) {
            for (var name in config.node) {
                if (hasOwnProperty.call(config.node, name)) {
                    var nodeType = config.node[name];

                    if (nodeType.structure) {
                        structure[name] = processStructure(name, nodeType);
                    } else {
                        throw new Error('Missed `structure` field in `' + name + '` node type definition');
                    }
                }
            }
        }

        return structure;
    }
};

},{"../utils/list":661}],576:[function(require,module,exports){
function getTrace(node) {
    function hasMatch(matchNode) {
        if (matchNode.type === 'ASTNode') {
            if (matchNode.node === node) {
                result = [];
                return true;
            }

            if (matchNode.childrenMatch) {
                // use for-loop for better perfomance
                for (var i = 0; i < matchNode.childrenMatch.length; i++) {
                    if (hasMatch(matchNode.childrenMatch[i])) {
                        return true;
                    }
                }
            }
        } else {
            // use for-loop for better perfomance
            for (var i = 0; i < matchNode.match.length; i++) {
                if (hasMatch(matchNode.match[i])) {
                    if (matchNode.syntax.type === 'Type' ||
                        matchNode.syntax.type === 'Property' ||
                        matchNode.syntax.type === 'Keyword') {
                        result.unshift(matchNode.syntax);
                    }
                    return true;
                }
            }
        }

        return false;
    }

    var result = null;

    if (this.matched !== null) {
        hasMatch(this.matched);
    }

    return result;
}

function testNode(match, node, fn) {
    var trace = getTrace.call(match, node);

    if (trace === null) {
        return false;
    }

    return trace.some(fn);
}

function isType(node, type) {
    return testNode(this, node, function(matchNode) {
        return matchNode.type === 'Type' && matchNode.name === type;
    });
}

function isProperty(node, property) {
    return testNode(this, node, function(matchNode) {
        return matchNode.type === 'Property' && matchNode.name === property;
    });
}

function isKeyword(node) {
    return testNode(this, node, function(matchNode) {
        return matchNode.type === 'Keyword';
    });
}

module.exports = {
    getTrace: getTrace,
    isType: isType,
    isProperty: isProperty,
    isKeyword: isKeyword
};

},{}],577:[function(require,module,exports){
'use strict';

var Tokenizer = require('../tokenizer');
var List = require('../utils/list');
var sequence = require('./sequence');
var noop = function() {};

function createParseContext(name) {
    return function() {
        return this[name]();
    };
}

function processConfig(config) {
    var parserConfig = {
        context: {},
        scope: {},
        atrule: {},
        pseudo: {}
    };

    if (config.parseContext) {
        for (var name in config.parseContext) {
            switch (typeof config.parseContext[name]) {
                case 'function':
                    parserConfig.context[name] = config.parseContext[name];
                    break;

                case 'string':
                    parserConfig.context[name] = createParseContext(config.parseContext[name]);
                    break;
            }
        }
    }

    if (config.scope) {
        for (var name in config.scope) {
            parserConfig.scope[name] = config.scope[name];
        }
    }

    if (config.atrule) {
        for (var name in config.atrule) {
            var atrule = config.atrule[name];

            if (atrule.parse) {
                parserConfig.atrule[name] = atrule.parse;
            }
        }
    }

    if (config.pseudo) {
        for (var name in config.pseudo) {
            var pseudo = config.pseudo[name];

            if (pseudo.parse) {
                parserConfig.pseudo[name] = pseudo.parse;
            }
        }
    }

    if (config.node) {
        for (var name in config.node) {
            parserConfig[name] = config.node[name].parse;
        }
    }

    return parserConfig;
}

module.exports = function createParser(config) {
    var parser = {
        scanner: new Tokenizer(),
        filename: '<unknown>',
        needPositions: false,
        onParseError: noop,
        onParseErrorThrow: false,
        parseAtrulePrelude: true,
        parseRulePrelude: true,
        parseValue: true,
        parseCustomProperty: false,

        readSequence: sequence,

        createList: function() {
            return new List();
        },
        createSingleNodeList: function(node) {
            return new List().appendData(node);
        },
        getFirstListNode: function(list) {
            return list && list.first();
        },
        getLastListNode: function(list) {
            return list.last();
        },

        parseWithFallback: function(consumer, fallback) {
            var startToken = this.scanner.currentToken;

            try {
                return consumer.call(this);
            } catch (e) {
                if (this.onParseErrorThrow) {
                    throw e;
                }

                var fallbackNode = fallback.call(this, startToken);

                this.onParseErrorThrow = true;
                this.onParseError(e, fallbackNode);
                this.onParseErrorThrow = false;

                return fallbackNode;
            }
        },

        getLocation: function(start, end) {
            if (this.needPositions) {
                return this.scanner.getLocationRange(
                    start,
                    end,
                    this.filename
                );
            }

            return null;
        },
        getLocationFromList: function(list) {
            if (this.needPositions) {
                var head = this.getFirstListNode(list);
                var tail = this.getLastListNode(list);
                return this.scanner.getLocationRange(
                    head !== null ? head.loc.start.offset - this.scanner.startOffset : this.scanner.tokenStart,
                    tail !== null ? tail.loc.end.offset - this.scanner.startOffset : this.scanner.tokenStart,
                    this.filename
                );
            }

            return null;
        }
    };

    config = processConfig(config || {});
    for (var key in config) {
        parser[key] = config[key];
    }

    return function(source, options) {
        options = options || {};

        var context = options.context || 'default';
        var ast;

        parser.scanner.setSource(source, options.offset, options.line, options.column);
        parser.filename = options.filename || '<unknown>';
        parser.needPositions = Boolean(options.positions);
        parser.onParseError = typeof options.onParseError === 'function' ? options.onParseError : noop;
        parser.onParseErrorThrow = false;
        parser.parseAtrulePrelude = 'parseAtrulePrelude' in options ? Boolean(options.parseAtrulePrelude) : true;
        parser.parseRulePrelude = 'parseRulePrelude' in options ? Boolean(options.parseRulePrelude) : true;
        parser.parseValue = 'parseValue' in options ? Boolean(options.parseValue) : true;
        parser.parseCustomProperty = 'parseCustomProperty' in options ? Boolean(options.parseCustomProperty) : false;

        if (!parser.context.hasOwnProperty(context)) {
            throw new Error('Unknown context `' + context + '`');
        }

        ast = parser.context[context].call(parser, options);

        if (!parser.scanner.eof) {
            parser.scanner.error();
        }

        return ast;
    };
};

},{"../tokenizer":657,"../utils/list":661,"./sequence":578}],578:[function(require,module,exports){
var TYPE = require('../tokenizer').TYPE;
var WHITESPACE = TYPE.WhiteSpace;
var COMMENT = TYPE.Comment;

module.exports = function readSequence(recognizer) {
    var children = this.createList();
    var child = null;
    var context = {
        recognizer: recognizer,
        space: null,
        ignoreWS: false,
        ignoreWSAfter: false
    };

    this.scanner.skipSC();

    while (!this.scanner.eof) {
        switch (this.scanner.tokenType) {
            case COMMENT:
                this.scanner.next();
                continue;

            case WHITESPACE:
                if (context.ignoreWS) {
                    this.scanner.next();
                } else {
                    context.space = this.WhiteSpace();
                }
                continue;
        }

        child = recognizer.getNode.call(this, context);

        if (child === undefined) {
            break;
        }

        if (context.space !== null) {
            children.push(context.space);
            context.space = null;
        }

        children.push(child);

        if (context.ignoreWSAfter) {
            context.ignoreWSAfter = false;
            context.ignoreWS = true;
        } else {
            context.ignoreWS = false;
        }
    }

    return children;
};

},{"../tokenizer":657}],579:[function(require,module,exports){
module.exports = {
    parse: {
        prelude: null,
        block: function() {
            return this.Block(true);
        }
    }
};

},{}],580:[function(require,module,exports){
var TYPE = require('../../tokenizer').TYPE;

var STRING = TYPE.String;
var IDENTIFIER = TYPE.Identifier;
var URL = TYPE.Url;
var LEFTPARENTHESIS = TYPE.LeftParenthesis;

module.exports = {
    parse: {
        prelude: function() {
            var children = this.createList();

            this.scanner.skipSC();

            switch (this.scanner.tokenType) {
                case STRING:
                    children.push(this.String());
                    break;

                case URL:
                    children.push(this.Url());
                    break;

                default:
                    this.scanner.error('String or url() is expected');
            }

            if (this.scanner.lookupNonWSType(0) === IDENTIFIER ||
                this.scanner.lookupNonWSType(0) === LEFTPARENTHESIS) {
                children.push(this.WhiteSpace());
                children.push(this.MediaQueryList());
            }

            return children;
        },
        block: null
    }
};

},{"../../tokenizer":657}],581:[function(require,module,exports){
module.exports = {
    'font-face': require('./font-face'),
    'import': require('./import'),
    'media': require('./media'),
    'page': require('./page'),
    'supports': require('./supports')
};

},{"./font-face":579,"./import":580,"./media":582,"./page":583,"./supports":584}],582:[function(require,module,exports){
module.exports = {
    parse: {
        prelude: function() {
            return this.createSingleNodeList(
                this.MediaQueryList()
            );
        },
        block: function() {
            return this.Block(false);
        }
    }
};

},{}],583:[function(require,module,exports){
module.exports = {
    parse: {
        prelude: function() {
            return this.createSingleNodeList(
                this.SelectorList()
            );
        },
        block: function() {
            return this.Block(true);
        }
    }
};

},{}],584:[function(require,module,exports){
var TYPE = require('../../tokenizer').TYPE;

var WHITESPACE = TYPE.WhiteSpace;
var COMMENT = TYPE.Comment;
var IDENTIFIER = TYPE.Identifier;
var FUNCTION = TYPE.Function;
var LEFTPARENTHESIS = TYPE.LeftParenthesis;
var HYPHENMINUS = TYPE.HyphenMinus;
var COLON = TYPE.Colon;

function consumeRaw() {
    return this.createSingleNodeList(
        this.Raw(this.scanner.currentToken, 0, 0, false, false)
    );
}

function parentheses() {
    var index = 0;

    this.scanner.skipSC();

    // TODO: make it simplier
    if (this.scanner.tokenType === IDENTIFIER) {
        index = 1;
    } else if (this.scanner.tokenType === HYPHENMINUS &&
               this.scanner.lookupType(1) === IDENTIFIER) {
        index = 2;
    }

    if (index !== 0 && this.scanner.lookupNonWSType(index) === COLON) {
        return this.createSingleNodeList(
            this.Declaration()
        );
    }

    return readSequence.call(this);
}

function readSequence() {
    var children = this.createList();
    var space = null;
    var child;

    this.scanner.skipSC();

    scan:
    while (!this.scanner.eof) {
        switch (this.scanner.tokenType) {
            case WHITESPACE:
                space = this.WhiteSpace();
                continue;

            case COMMENT:
                this.scanner.next();
                continue;

            case FUNCTION:
                child = this.Function(consumeRaw, this.scope.AtrulePrelude);
                break;

            case IDENTIFIER:
                child = this.Identifier();
                break;

            case LEFTPARENTHESIS:
                child = this.Parentheses(parentheses, this.scope.AtrulePrelude);
                break;

            default:
                break scan;
        }

        if (space !== null) {
            children.push(space);
            space = null;
        }

        children.push(child);
    }

    return children;
}

module.exports = {
    parse: {
        prelude: function() {
            var children = readSequence.call(this);

            if (this.getFirstListNode(children) === null) {
                this.scanner.error('Condition is expected');
            }

            return children;
        },
        block: function() {
            return this.Block(false);
        }
    }
};

},{"../../tokenizer":657}],585:[function(require,module,exports){
var data = require('../../../data');

module.exports = {
    generic: true,
    types: data.types,
    properties: data.properties,
    node: require('../node')
};

},{"../../../data":560,"../node":634}],586:[function(require,module,exports){
var hasOwnProperty = Object.prototype.hasOwnProperty;
var shape = {
    generic: true,
    types: {},
    properties: {},
    parseContext: {},
    scope: {},
    atrule: ['parse'],
    pseudo: ['parse'],
    node: ['name', 'structure', 'parse', 'generate', 'walkContext']
};

function isObject(value) {
    return value && value.constructor === Object;
}

function copy(value) {
    if (isObject(value)) {
        var res = {};
        for (var key in value) {
            if (hasOwnProperty.call(value, key)) {
                res[key] = value[key];
            }
        }
        return res;
    } else {
        return value;
    }
}

function extend(dest, src) {
    for (var key in src) {
        if (hasOwnProperty.call(src, key)) {
            if (isObject(dest[key])) {
                extend(dest[key], copy(src[key]));
            } else {
                dest[key] = copy(src[key]);
            }
        }
    }
}

function mix(dest, src, shape) {
    for (var key in shape) {
        if (hasOwnProperty.call(shape, key) === false) {
            continue;
        }

        if (shape[key] === true) {
            if (key in src) {
                if (hasOwnProperty.call(src, key)) {
                    dest[key] = copy(src[key]);
                }
            }
        } else if (shape[key]) {
            if (isObject(shape[key])) {
                var res = {};
                extend(res, dest[key]);
                extend(res, src[key]);
                dest[key] = res;
            } else if (Array.isArray(shape[key])) {
                var res = {};
                var innerShape = shape[key].reduce(function(s, k) {
                    s[k] = true;
                    return s;
                }, {});
                for (var name in dest[key]) {
                    if (hasOwnProperty.call(dest[key], name)) {
                        res[name] = {};
                        if (dest[key] && dest[key][name]) {
                            mix(res[name], dest[key][name], innerShape);
                        }
                    }
                }
                for (var name in src[key]) {
                    if (hasOwnProperty.call(src[key], name)) {
                        if (!res[name]) {
                            res[name] = {};
                        }
                        if (src[key] && src[key][name]) {
                            mix(res[name], src[key][name], innerShape);
                        }
                    }
                }
                dest[key] = res;
            }
        }
    }
    return dest;
}

module.exports = function(dest, src) {
    return mix(dest, src, shape);
};

},{}],587:[function(require,module,exports){
module.exports = {
    parseContext: {
        default: 'StyleSheet',
        stylesheet: 'StyleSheet',
        atrule: 'Atrule',
        atrulePrelude: function(options) {
            return this.AtrulePrelude(options.atrule ? String(options.atrule) : null);
        },
        mediaQueryList: 'MediaQueryList',
        mediaQuery: 'MediaQuery',
        rule: 'Rule',
        selectorList: 'SelectorList',
        selector: 'Selector',
        block: function() {
            return this.Block(true);
        },
        declarationList: 'DeclarationList',
        declaration: 'Declaration',
        value: 'Value'
    },
    scope: require('../scope'),
    atrule: require('../atrule'),
    pseudo: require('../pseudo'),
    node: require('../node')
};

},{"../atrule":581,"../node":634,"../pseudo":640,"../scope":651}],588:[function(require,module,exports){
module.exports = {
    node: require('../node')
};

},{"../node":634}],589:[function(require,module,exports){
var List = require('../utils/list');
var Tokenizer = require('../tokenizer');
var Lexer = require('../lexer/Lexer');
var grammar = require('../lexer/grammar');
var createParser = require('../parser/create');
var createGenerator = require('../generator/create');
var createConvertor = require('../convertor/create');
var createWalker = require('../walker/create');
var clone = require('../utils/clone');
var names = require('../utils/names');
var mix = require('./config/mix');

function assign(dest, src) {
    for (var key in src) {
        dest[key] = src[key];
    }

    return dest;
}

function createSyntax(config) {
    var parse = createParser(config);
    var walk = createWalker(config);
    var generate = createGenerator(config);
    var convert = createConvertor(walk);

    var syntax = {
        List: List,
        Tokenizer: Tokenizer,
        Lexer: Lexer,

        vendorPrefix: names.vendorPrefix,
        keyword: names.keyword,
        property: names.property,
        isCustomProperty: names.isCustomProperty,

        grammar: grammar,
        lexer: null,
        createLexer: function(config) {
            return new Lexer(config, syntax, syntax.lexer.structure);
        },

        parse: parse,
        walk: walk,
        generate: generate,

        clone: clone,
        fromPlainObject: convert.fromPlainObject,
        toPlainObject: convert.toPlainObject,

        createSyntax: function(config) {
            return createSyntax(mix({}, config));
        },
        fork: function(extension) {
            var base = mix({}, config); // copy of config
            return createSyntax(
                typeof extension === 'function'
                    ? extension(base, assign)
                    : mix(base, extension)
            );
        }
    };

    syntax.lexer = new Lexer({
        generic: true,
        types: config.types,
        properties: config.properties,
        node: config.node
    }, syntax);

    return syntax;
};

exports.create = function(config) {
    return createSyntax(mix({}, config));
};

},{"../convertor/create":561,"../generator/create":562,"../lexer/Lexer":565,"../lexer/grammar":570,"../parser/create":577,"../tokenizer":657,"../utils/clone":659,"../utils/list":661,"../utils/names":662,"../walker/create":663,"./config/mix":586}],590:[function(require,module,exports){
// https://drafts.csswg.org/css-images-4/#element-notation
// https://developer.mozilla.org/en-US/docs/Web/CSS/element
module.exports = function() {
    this.scanner.skipSC();

    var children = this.createSingleNodeList(
        this.IdSelector()
    );

    this.scanner.skipSC();

    return children;
};

},{}],591:[function(require,module,exports){
// legacy IE function
// expression '(' raw ')'
module.exports = function() {
    return this.createSingleNodeList(
        this.Raw(this.scanner.currentToken, 0, 0, false, false)
    );
};

},{}],592:[function(require,module,exports){
var TYPE = require('../../tokenizer').TYPE;

var IDENTIFIER = TYPE.Identifier;
var COMMA = TYPE.Comma;
var SEMICOLON = TYPE.Semicolon;
var HYPHENMINUS = TYPE.HyphenMinus;
var EXCLAMATIONMARK = TYPE.ExclamationMark;

// var '(' ident (',' <value>? )? ')'
module.exports = function() {
    var children = this.createList();

    this.scanner.skipSC();

    var identStart = this.scanner.tokenStart;

    this.scanner.eat(HYPHENMINUS);
    if (this.scanner.source.charCodeAt(this.scanner.tokenStart) !== HYPHENMINUS) {
        this.scanner.error('HyphenMinus is expected');
    }
    this.scanner.eat(IDENTIFIER);

    children.push({
        type: 'Identifier',
        loc: this.getLocation(identStart, this.scanner.tokenStart),
        name: this.scanner.substrToCursor(identStart)
    });

    this.scanner.skipSC();

    if (this.scanner.tokenType === COMMA) {
        children.push(this.Operator());
        children.push(this.parseCustomProperty
            ? this.Value(null)
            : this.Raw(this.scanner.currentToken, EXCLAMATIONMARK, SEMICOLON, false, false)
        );
    }

    return children;
};

},{"../../tokenizer":657}],593:[function(require,module,exports){
function merge() {
    var dest = {};

    for (var i = 0; i < arguments.length; i++) {
        var src = arguments[i];
        for (var key in src) {
            dest[key] = src[key];
        }
    }

    return dest;
}

module.exports = require('./create').create(
    merge(
        require('./config/lexer'),
        require('./config/parser'),
        require('./config/walker')
    )
);

},{"./config/lexer":585,"./config/parser":587,"./config/walker":588,"./create":589}],594:[function(require,module,exports){
var cmpChar = require('../../tokenizer').cmpChar;
var isNumber = require('../../tokenizer').isNumber;
var TYPE = require('../../tokenizer').TYPE;

var IDENTIFIER = TYPE.Identifier;
var NUMBER = TYPE.Number;
var PLUSSIGN = TYPE.PlusSign;
var HYPHENMINUS = TYPE.HyphenMinus;
var N = 110; // 'n'.charCodeAt(0)
var DISALLOW_SIGN = true;
var ALLOW_SIGN = false;

function checkTokenIsInteger(scanner, disallowSign) {
    var pos = scanner.tokenStart;

    if (scanner.source.charCodeAt(pos) === PLUSSIGN ||
        scanner.source.charCodeAt(pos) === HYPHENMINUS) {
        if (disallowSign) {
            scanner.error();
        }
        pos++;
    }

    for (; pos < scanner.tokenEnd; pos++) {
        if (!isNumber(scanner.source.charCodeAt(pos))) {
            scanner.error('Unexpected input', pos);
        }
    }
}

// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
module.exports = {
    name: 'AnPlusB',
    structure: {
        a: [String, null],
        b: [String, null]
    },
    parse: function() {
        var start = this.scanner.tokenStart;
        var end = start;
        var prefix = '';
        var a = null;
        var b = null;

        if (this.scanner.tokenType === NUMBER ||
            this.scanner.tokenType === PLUSSIGN) {
            checkTokenIsInteger(this.scanner, ALLOW_SIGN);
            prefix = this.scanner.getTokenValue();
            this.scanner.next();
            end = this.scanner.tokenStart;
        }

        if (this.scanner.tokenType === IDENTIFIER) {
            var bStart = this.scanner.tokenStart;

            if (cmpChar(this.scanner.source, bStart, HYPHENMINUS)) {
                if (prefix === '') {
                    prefix = '-';
                    bStart++;
                } else {
                    this.scanner.error('Unexpected hyphen minus');
                }
            }

            if (!cmpChar(this.scanner.source, bStart, N)) {
                this.scanner.error();
            }

            a = prefix === ''  ? '1'  :
                prefix === '+' ? '+1' :
                prefix === '-' ? '-1' :
                prefix;

            var len = this.scanner.tokenEnd - bStart;
            if (len > 1) {
                // ..n-..
                if (this.scanner.source.charCodeAt(bStart + 1) !== HYPHENMINUS) {
                    this.scanner.error('Unexpected input', bStart + 1);
                }

                if (len > 2) {
                    // ..n-{number}..
                    this.scanner.tokenStart = bStart + 2;
                } else {
                    // ..n- {number}
                    this.scanner.next();
                    this.scanner.skipSC();
                }

                checkTokenIsInteger(this.scanner, DISALLOW_SIGN);
                b = '-' + this.scanner.getTokenValue();
                this.scanner.next();
                end = this.scanner.tokenStart;
            } else {
                prefix = '';
                this.scanner.next();
                end = this.scanner.tokenStart;
                this.scanner.skipSC();

                if (this.scanner.tokenType === HYPHENMINUS ||
                    this.scanner.tokenType === PLUSSIGN) {
                    prefix = this.scanner.getTokenValue();
                    this.scanner.next();
                    this.scanner.skipSC();
                }

                if (this.scanner.tokenType === NUMBER) {
                    checkTokenIsInteger(this.scanner, prefix !== '');

                    if (!isNumber(this.scanner.source.charCodeAt(this.scanner.tokenStart))) {
                        prefix = this.scanner.source.charAt(this.scanner.tokenStart);
                        this.scanner.tokenStart++;
                    }

                    if (prefix === '') {
                        // should be an operator before number
                        this.scanner.error();
                    } else if (prefix === '+') {
                        // plus is using by default
                        prefix = '';
                    }

                    b = prefix + this.scanner.getTokenValue();

                    this.scanner.next();
                    end = this.scanner.tokenStart;
                } else {
                    if (prefix) {
                        this.scanner.eat(NUMBER);
                    }
                }
            }
        } else {
            if (prefix === '' || prefix === '+') { // no number
                this.scanner.error(
                    'Number or identifier is expected',
                    this.scanner.tokenStart + (
                        this.scanner.tokenType === PLUSSIGN ||
                        this.scanner.tokenType === HYPHENMINUS
                    )
                );
            }

            b = prefix;
        }

        return {
            type: 'AnPlusB',
            loc: this.getLocation(start, end),
            a: a,
            b: b
        };
    },
    generate: function(node) {
        var a = node.a !== null && node.a !== undefined;
        var b = node.b !== null && node.b !== undefined;

        if (a) {
            this.chunk(
                node.a === '+1' ? '+n' :
                node.a ===  '1' ?  'n' :
                node.a === '-1' ? '-n' :
                node.a + 'n'
            );

            if (b) {
                b = String(node.b);
                if (b.charAt(0) === '-' || b.charAt(0) === '+') {
                    this.chunk(b.charAt(0));
                    this.chunk(b.substr(1));
                } else {
                    this.chunk('+');
                    this.chunk(b);
                }
            }
        } else {
            this.chunk(String(node.b));
        }
    }
};

},{"../../tokenizer":657}],595:[function(require,module,exports){
var TYPE = require('../../tokenizer').TYPE;

var ATRULE = TYPE.Atrule;
var SEMICOLON = TYPE.Semicolon;
var LEFTCURLYBRACKET = TYPE.LeftCurlyBracket;
var RIGHTCURLYBRACKET = TYPE.RightCurlyBracket;

function consumeRaw(startToken) {
    return this.Raw(startToken, SEMICOLON, LEFTCURLYBRACKET, false, true);
}

function isDeclarationBlockAtrule() {
    for (var offset = 1, type; type = this.scanner.lookupType(offset); offset++) {
        if (type === RIGHTCURLYBRACKET) {
            return true;
        }

        if (type === LEFTCURLYBRACKET ||
            type === ATRULE) {
            return false;
        }
    }

    return false;
}

module.exports = {
    name: 'Atrule',
    structure: {
        name: String,
        prelude: ['AtrulePrelude', 'Raw', null],
        block: ['Block', null]
    },
    parse: function() {
        var start = this.scanner.tokenStart;
        var name;
        var nameLowerCase;
        var prelude = null;
        var block = null;

        this.scanner.eat(ATRULE);

        name = this.scanner.substrToCursor(start + 1);
        nameLowerCase = name.toLowerCase();
        this.scanner.skipSC();

        // parse prelude
        if (this.scanner.eof === false &&
            this.scanner.tokenType !== LEFTCURLYBRACKET &&
            this.scanner.tokenType !== SEMICOLON) {
            if (this.parseAtrulePrelude) {
                prelude = this.parseWithFallback(this.AtrulePrelude.bind(this, name), consumeRaw);

                // turn empty AtrulePrelude into null
                if (prelude.type === 'AtrulePrelude' && prelude.children.head === null) {
                    prelude = null;
                }
            } else {
                prelude = consumeRaw.call(this, this.scanner.currentToken);
            }

            this.scanner.skipSC();
        }

        switch (this.scanner.tokenType) {
            case SEMICOLON:
                this.scanner.next();
                break;

            case LEFTCURLYBRACKET:
                if (this.atrule.hasOwnProperty(nameLowerCase) &&
                    typeof this.atrule[nameLowerCase].block === 'function') {
                    block = this.atrule[nameLowerCase].block.call(this);
                } else {
                    // TODO: should consume block content as Raw?
                    block = this.Block(isDeclarationBlockAtrule.call(this));
                }

                break;
        }

        return {
            type: 'Atrule',
            loc: this.getLocation(start, this.scanner.tokenStart),
            name: name,
            prelude: prelude,
            block: block
        };
    },
    generate: function(node) {
        this.chunk('@');
        this.chunk(node.name);

        if (node.prelude !== null) {
            this.chunk(' ');
            this.node(node.prelude);
        }

        if (node.block) {
            this.node(node.block);
        } else {
            this.chunk(';');
        }
    },
    walkContext: 'atrule'
};

},{"../../tokenizer":657}],596:[function(require,module,exports){
var TYPE = require('../../tokenizer').TYPE;

var SEMICOLON = TYPE.Semicolon;
var LEFTCURLYBRACKET = TYPE.LeftCurlyBracket;

module.exports = {
    name: 'AtrulePrelude',
    structure: {
        children: [[]]
    },
    parse: function(name) {
        var children = null;

        if (name !== null) {
            name = name.toLowerCase();
        }

        this.scanner.skipSC();

        if (this.atrule.hasOwnProperty(name) &&
            typeof this.atrule[name].prelude === 'function') {
            // custom consumer
            children = this.atrule[name].prelude.call(this);
        } else {
            // default consumer
            children = this.readSequence(this.scope.AtrulePrelude);
        }

        this.scanner.skipSC();

        if (this.scanner.eof !== true &&
            this.scanner.tokenType !== LEFTCURLYBRACKET &&
            this.scanner.tokenType !== SEMICOLON) {
            this.scanner.error('Semicolon or block is expected');
        }

        if (children === null) {
            children = this.createList();
        }

        return {
            type: 'AtrulePrelude',
            loc: this.getLocationFromList(children),
            children: children
        };
    },
    generate: function(node) {
        this.children(node);
    },
    walkContext: 'atrulePrelude'
};

},{"../../tokenizer":657}],597:[function(require,module,exports){
var TYPE = require('../../tokenizer').TYPE;

var IDENTIFIER = TYPE.Identifier;
var STRING = TYPE.String;
var DOLLARSIGN = TYPE.DollarSign;
var ASTERISK = TYPE.Asterisk;
var COLON = TYPE.Colon;
var EQUALSSIGN = TYPE.EqualsSign;
var LEFTSQUAREBRACKET = TYPE.LeftSquareBracket;
var RIGHTSQUAREBRACKET = TYPE.RightSquareBracket;
var CIRCUMFLEXACCENT = TYPE.CircumflexAccent;
var VERTICALLINE = TYPE.VerticalLine;
var TILDE = TYPE.Tilde;

function getAttributeName() {
    if (this.scanner.eof) {
        this.scanner.error('Unexpected end of input');
    }

    var start = this.scanner.tokenStart;
    var expectIdentifier = false;
    var checkColon = true;

    if (this.scanner.tokenType === ASTERISK) {
        expectIdentifier = true;
        checkColon = false;
        this.scanner.next();
    } else if (this.scanner.tokenType !== VERTICALLINE) {
        this.scanner.eat(IDENTIFIER);
    }

    if (this.scanner.tokenType === VERTICALLINE) {
        if (this.scanner.lookupType(1) !== EQUALSSIGN) {
            this.scanner.next();
            this.scanner.eat(IDENTIFIER);
        } else if (expectIdentifier) {
            this.scanner.error('Identifier is expected', this.scanner.tokenEnd);
        }
    } else if (expectIdentifier) {
        this.scanner.error('Vertical line is expected');
    }

    if (checkColon && this.scanner.tokenType === COLON) {
        this.scanner.next();
        this.scanner.eat(IDENTIFIER);
    }

    return {
        type: 'Identifier',
        loc: this.getLocation(start, this.scanner.tokenStart),
        name: this.scanner.substrToCursor(start)
    };
}

function getOperator() {
    var start = this.scanner.tokenStart;
    var tokenType = this.scanner.tokenType;

    if (tokenType !== EQUALSSIGN &&        // =
        tokenType !== TILDE &&             // ~=
        tokenType !== CIRCUMFLEXACCENT &&  // ^=
        tokenType !== DOLLARSIGN &&        // $=
        tokenType !== ASTERISK &&          // *=
        tokenType !== VERTICALLINE         // |=
    ) {
        this.scanner.error('Attribute selector (=, ~=, ^=, $=, *=, |=) is expected');
    }

    if (tokenType === EQUALSSIGN) {
        this.scanner.next();
    } else {
        this.scanner.next();
        this.scanner.eat(EQUALSSIGN);
    }

    return this.scanner.substrToCursor(start);
}

// '[' S* attrib_name ']'
// '[' S* attrib_name S* attrib_matcher S* [ IDENT | STRING ] S* attrib_flags? S* ']'
module.exports = {
    name: 'AttributeSelector',
    structure: {
        name: 'Identifier',
        matcher: [String, null],
        value: ['String', 'Identifier', null],
        flags: [String, null]
    },
    parse: function() {
        var start = this.scanner.tokenStart;
        var name;
        var matcher = null;
        var value = null;
        var flags = null;

        this.scanner.eat(LEFTSQUAREBRACKET);
        this.scanner.skipSC();

        name = getAttributeName.call(this);
        this.scanner.skipSC();

        if (this.scanner.tokenType !== RIGHTSQUAREBRACKET) {
            // avoid case `[name i]`
            if (this.scanner.tokenType !== IDENTIFIER) {
                matcher = getOperator.call(this);

                this.scanner.skipSC();

                value = this.scanner.tokenType === STRING
                    ? this.String()
                    : this.Identifier();

                this.scanner.skipSC();
            }

            // attribute flags
            if (this.scanner.tokenType === IDENTIFIER) {
                flags = this.scanner.getTokenValue();
                this.scanner.next();

                this.scanner.skipSC();
            }
        }

        this.scanner.eat(RIGHTSQUAREBRACKET);

        return {
            type: 'AttributeSelector',
            loc: this.getLocation(start, this.scanner.tokenStart),
            name: name,
            matcher: matcher,
            value: value,
            flags: flags
        };
    },
    generate: function(node) {
        var flagsPrefix = ' ';

        this.chunk('[');
        this.node(node.name);

        if (node.matcher !== null) {
            this.chunk(node.matcher);

            if (node.value !== null) {
                this.node(node.value);

                // space between string and flags is not required
                if (node.value.type === 'String') {
                    flagsPrefix = '';
                }
            }
        }

        if (node.flags !== null) {
            this.chunk(flagsPrefix);
            this.chunk(node.flags);
        }

        this.chunk(']');
    }
};

},{"../../tokenizer":657}],598:[function(require,module,exports){
var TYPE = require('../../tokenizer').TYPE;

var WHITESPACE = TYPE.WhiteSpace;
var COMMENT = TYPE.Comment;
var SEMICOLON = TYPE.Semicolon;
var ATRULE = TYPE.Atrule;
var LEFTCURLYBRACKET = TYPE.LeftCurlyBracket;
var RIGHTCURLYBRACKET = TYPE.RightCurlyBracket;

function consumeRaw(startToken) {
    return this.Raw(startToken, 0, 0, false, true);
}
function consumeRule() {
    return this.parseWithFallback(this.Rule, consumeRaw);
}
function consumeRawDeclaration(startToken) {
    return this.Raw(startToken, 0, SEMICOLON, true, true);
}
function consumeDeclaration() {
    if (this.scanner.tokenType === SEMICOLON) {
        return consumeRawDeclaration.call(this, this.scanner.currentToken);
    }

    var node = this.parseWithFallback(this.Declaration, consumeRawDeclaration);

    if (this.scanner.tokenType === SEMICOLON) {
        this.scanner.next();
    }

    return node;
}

module.exports = {
    name: 'Block',
    structure: {
        children: [[
            'Atrule',
            'Rule',
            'Declaration'
        ]]
    },
    parse: function(isDeclaration) {
        var consumer = isDeclaration ? consumeDeclaration : consumeRule;

        var start = this.scanner.tokenStart;
        var children = this.createList();

        this.scanner.eat(LEFTCURLYBRACKET);

        scan:
        while (!this.scanner.eof) {
            switch (this.scanner.tokenType) {
                case RIGHTCURLYBRACKET:
                    break scan;

                case WHITESPACE:
                case COMMENT:
                    this.scanner.next();
                    break;

                case ATRULE:
                    children.push(this.parseWithFallback(this.Atrule, consumeRaw));
                    break;

                default:
                    children.push(consumer.call(this));
            }
        }

        if (!this.scanner.eof) {
            this.scanner.eat(RIGHTCURLYBRACKET);
        }

        return {
            type: 'Block',
            loc: this.getLocation(start, this.scanner.tokenStart),
            children: children
        };
    },
    generate: function(node) {
        this.chunk('{');
        this.children(node, function(prev) {
            if (prev.type === 'Declaration') {
                this.chunk(';');
            }
        });
        this.chunk('}');
    },
    walkContext: 'block'
};

},{"../../tokenizer":657}],599:[function(require,module,exports){
var TYPE = require('../../tokenizer').TYPE;
var LEFTSQUAREBRACKET = TYPE.LeftSquareBracket;
var RIGHTSQUAREBRACKET = TYPE.RightSquareBracket;

module.exports = {
    name: 'Brackets',
    structure: {
        children: [[]]
    },
    parse: function(readSequence, recognizer) {
        var start = this.scanner.tokenStart;
        var children = null;

        this.scanner.eat(LEFTSQUAREBRACKET);

        children = readSequence.call(this, recognizer);

        if (!this.scanner.eof) {
            this.scanner.eat(RIGHTSQUAREBRACKET);
        }

        return {
            type: 'Brackets',
            loc: this.getLocation(start, this.scanner.tokenStart),
            children: children
        };
    },
    generate: function(node) {
        this.chunk('[');
        this.children(node);
        this.chunk(']');
    }
};

},{"../../tokenizer":657}],600:[function(require,module,exports){
var CDC = require('../../tokenizer').TYPE.CDC;

module.exports = {
    name: 'CDC',
    structure: [],
    parse: function() {
        var start = this.scanner.tokenStart;

        this.scanner.eat(CDC); // -->

        return {
            type: 'CDC',
            loc: this.getLocation(start, this.scanner.tokenStart)
        };
    },
    generate: function() {
        this.chunk('-->');
    }
};

},{"../../tokenizer":657}],601:[function(require,module,exports){
var CDO = require('../../tokenizer').TYPE.CDO;

module.exports = {
    name: 'CDO',
    structure: [],
    parse: function() {
        var start = this.scanner.tokenStart;

        this.scanner.eat(CDO); // <!--

        return {
            type: 'CDO',
            loc: this.getLocation(start, this.scanner.tokenStart)
        };
    },
    generate: function() {
        this.chunk('<!--');
    }
};

},{"../../tokenizer":657}],602:[function(require,module,exports){
var TYPE = require('../../tokenizer').TYPE;
var IDENTIFIER = TYPE.Identifier;
var FULLSTOP = TYPE.FullStop;

// '.' ident
module.exports = {
    name: 'ClassSelector',
    structure: {
        name: String
    },
    parse: function() {
        this.scanner.eat(FULLSTOP);

        return {
            type: 'ClassSelector',
            loc: this.getLocation(this.scanner.tokenStart - 1, this.scanner.tokenEnd),
            name: this.scanner.consume(IDENTIFIER)
        };
    },
    generate: function(node) {
        this.chunk('.');
        this.chunk(node.name);
    }
};

},{"../../tokenizer":657}],603:[function(require,module,exports){
var TYPE = require('../../tokenizer').TYPE;

var PLUSSIGN = TYPE.PlusSign;
var SOLIDUS = TYPE.Solidus;
var GREATERTHANSIGN = TYPE.GreaterThanSign;
var TILDE = TYPE.Tilde;

// + | > | ~ | /deep/
module.exports = {
    name: 'Combinator',
    structure: {
        name: String
    },
    parse: function() {
        var start = this.scanner.tokenStart;

        switch (this.scanner.tokenType) {
            case GREATERTHANSIGN:
            case PLUSSIGN:
            case TILDE:
                this.scanner.next();
                break;

            case SOLIDUS:
                this.scanner.next();
                this.scanner.expectIdentifier('deep');
                this.scanner.eat(SOLIDUS);
                break;

            default:
                this.scanner.error('Combinator is expected');
        }

        return {
            type: 'Combinator',
            loc: this.getLocation(start, this.scanner.tokenStart),
            name: this.scanner.substrToCursor(start)
        };
    },
    generate: function(node) {
        this.chunk(node.name);
    }
};

},{"../../tokenizer":657}],604:[function(require,module,exports){
var TYPE = require('../../tokenizer').TYPE;

var ASTERISK = TYPE.Asterisk;
var SOLIDUS = TYPE.Solidus;

// '/*' .* '*/'
module.exports = {
    name: 'Comment',
    structure: {
        value: String
    },
    parse: function() {
        var start = this.scanner.tokenStart;
        var end = this.scanner.tokenEnd;

        if ((end - start + 2) >= 2 &&
            this.scanner.source.charCodeAt(end - 2) === ASTERISK &&
            this.scanner.source.charCodeAt(end - 1) === SOLIDUS) {
            end -= 2;
        }

        this.scanner.next();

        return {
            type: 'Comment',
            loc: this.getLocation(start, this.scanner.tokenStart),
            value: this.scanner.source.substring(start + 2, end)
        };
    },
    generate: function(node) {
        this.chunk('/*');
        this.chunk(node.value);
        this.chunk('*/');
    }
};

},{"../../tokenizer":657}],605:[function(require,module,exports){
var isCustomProperty = require('../../utils/names').isCustomProperty;
var TYPE = require('../../tokenizer').TYPE;

var IDENTIFIER = TYPE.Identifier;
var COLON = TYPE.Colon;
var EXCLAMATIONMARK = TYPE.ExclamationMark;
var SOLIDUS = TYPE.Solidus;
var ASTERISK = TYPE.Asterisk;
var DOLLARSIGN = TYPE.DollarSign;
var HYPHENMINUS = TYPE.HyphenMinus;
var SEMICOLON = TYPE.Semicolon;
var PLUSSIGN = TYPE.PlusSign;
var NUMBERSIGN = TYPE.NumberSign;

function consumeValueRaw(startToken) {
    return this.Raw(startToken, EXCLAMATIONMARK, SEMICOLON, false, true);
}

function consumeCustomPropertyRaw(startToken) {
    return this.Raw(startToken, EXCLAMATIONMARK, SEMICOLON, false, false);
}

function consumeValue() {
    var startValueToken = this.scanner.currentToken;
    var value = this.Value();

    if (value.type !== 'Raw' &&
        this.scanner.eof === false &&
        this.scanner.tokenType !== SEMICOLON &&
        this.scanner.tokenType !== EXCLAMATIONMARK &&
        this.scanner.isBalanceEdge(startValueToken) === false) {
        this.scanner.error();
    }

    return value;
}

module.exports = {
    name: 'Declaration',
    structure: {
        important: [Boolean, String],
        property: String,
        value: ['Value', 'Raw']
    },
    parse: function() {
        var start = this.scanner.tokenStart;
        var startToken = this.scanner.currentToken;
        var property = readProperty.call(this);
        var customProperty = isCustomProperty(property);
        var parseValue = customProperty ? this.parseCustomProperty : this.parseValue;
        var consumeRaw = customProperty ? consumeCustomPropertyRaw : consumeValueRaw;
        var important = false;
        var value;

        this.scanner.skipSC();
        this.scanner.eat(COLON);

        if (!customProperty) {
            this.scanner.skipSC();
        }

        if (parseValue) {
            value = this.parseWithFallback(consumeValue, consumeRaw);
        } else {
            value = consumeRaw.call(this, this.scanner.currentToken);
        }

        if (this.scanner.tokenType === EXCLAMATIONMARK) {
            important = getImportant(this.scanner);
            this.scanner.skipSC();
        }

        // Do not include semicolon to range per spec
        // https://drafts.csswg.org/css-syntax/#declaration-diagram

        if (this.scanner.eof === false &&
            this.scanner.tokenType !== SEMICOLON &&
            this.scanner.isBalanceEdge(startToken) === false) {
            this.scanner.error();
        }

        return {
            type: 'Declaration',
            loc: this.getLocation(start, this.scanner.tokenStart),
            important: important,
            property: property,
            value: value
        };
    },
    generate: function(node) {
        this.chunk(node.property);
        this.chunk(':');
        this.node(node.value);

        if (node.important) {
            this.chunk(node.important === true ? '!important' : '!' + node.important);
        }
    },
    walkContext: 'declaration'
};

function readProperty() {
    var start = this.scanner.tokenStart;
    var prefix = 0;

    // hacks
    switch (this.scanner.tokenType) {
        case ASTERISK:
        case DOLLARSIGN:
        case PLUSSIGN:
        case NUMBERSIGN:
            prefix = 1;
            break;

        // TODO: not sure we should support this hack
        case SOLIDUS:
            prefix = this.scanner.lookupType(1) === SOLIDUS ? 2 : 1;
            break;
    }

    if (this.scanner.lookupType(prefix) === HYPHENMINUS) {
        prefix++;
    }

    if (prefix) {
        this.scanner.skip(prefix);
    }

    this.scanner.eat(IDENTIFIER);

    return this.scanner.substrToCursor(start);
}

// ! ws* important
function getImportant(scanner) {
    scanner.eat(EXCLAMATIONMARK);
    scanner.skipSC();

    var important = scanner.consume(IDENTIFIER);

    // store original value in case it differ from `important`
    // for better original source restoring and hacks like `!ie` support
    return important === 'important' ? true : important;
}

},{"../../tokenizer":657,"../../utils/names":662}],606:[function(require,module,exports){
var TYPE = require('../../tokenizer').TYPE;

var WHITESPACE = TYPE.WhiteSpace;
var COMMENT = TYPE.Comment;
var SEMICOLON = TYPE.Semicolon;

function consumeRaw(startToken) {
    return this.Raw(startToken, 0, SEMICOLON, true, true);
}

module.exports = {
    name: 'DeclarationList',
    structure: {
        children: [[
            'Declaration'
        ]]
    },
    parse: function() {
        var children = this.createList();

        scan:
        while (!this.scanner.eof) {
            switch (this.scanner.tokenType) {
                case WHITESPACE:
                case COMMENT:
                case SEMICOLON:
                    this.scanner.next();
                    break;

                default:
                    children.push(this.parseWithFallback(this.Declaration, consumeRaw));
            }
        }

        return {
            type: 'DeclarationList',
            loc: this.getLocationFromList(children),
            children: children
        };
    },
    generate: function(node) {
        this.children(node, function(prev) {
            if (prev.type === 'Declaration') {
                this.chunk(';');
            }
        });
    }
};

},{"../../tokenizer":657}],607:[function(require,module,exports){
var NUMBER = require('../../tokenizer').TYPE.Number;

// special reader for units to avoid adjoined IE hacks (i.e. '1px\9')
function readUnit(scanner) {
    var unit = scanner.getTokenValue();
    var backSlashPos = unit.indexOf('\\');

    if (backSlashPos > 0) {
        // patch token offset
        scanner.tokenStart += backSlashPos;

        // return part before backslash
        return unit.substring(0, backSlashPos);
    }

    // no backslash in unit name
    scanner.next();

    return unit;
}

// number ident
module.exports = {
    name: 'Dimension',
    structure: {
        value: String,
        unit: String
    },
    parse: function() {
        var start = this.scanner.tokenStart;
        var value = this.scanner.consume(NUMBER);
        var unit = readUnit(this.scanner);

        return {
            type: 'Dimension',
            loc: this.getLocation(start, this.scanner.tokenStart),
            value: value,
            unit: unit
        };
    },
    generate: function(node) {
        this.chunk(node.value);
        this.chunk(node.unit);
    }
};

},{"../../tokenizer":657}],608:[function(require,module,exports){
var TYPE = require('../../tokenizer').TYPE;
var RIGHTPARENTHESIS = TYPE.RightParenthesis;

// <function-token> <sequence> ')'
module.exports = {
    name: 'Function',
    structure: {
        name: String,
        children: [[]]
    },
    parse: function(readSequence, recognizer) {
        var start = this.scanner.tokenStart;
        var name = this.scanner.consumeFunctionName();
        var nameLowerCase = name.toLowerCase();
        var children;

        children = recognizer.hasOwnProperty(nameLowerCase)
            ? recognizer[nameLowerCase].call(this, recognizer)
            : readSequence.call(this, recognizer);

        if (!this.scanner.eof) {
            this.scanner.eat(RIGHTPARENTHESIS);
        }

        return {
            type: 'Function',
            loc: this.getLocation(start, this.scanner.tokenStart),
            name: name,
            children: children
        };
    },
    generate: function(node) {
        this.chunk(node.name);
        this.chunk('(');
        this.children(node);
        this.chunk(')');
    },
    walkContext: 'function'
};

},{"../../tokenizer":657}],609:[function(require,module,exports){
var isHex = require('../../tokenizer').isHex;
var TYPE = require('../../tokenizer').TYPE;

var IDENTIFIER = TYPE.Identifier;
var NUMBER = TYPE.Number;
var NUMBERSIGN = TYPE.NumberSign;

function consumeHexSequence(scanner, required) {
    if (!isHex(scanner.source.charCodeAt(scanner.tokenStart))) {
        if (required) {
            scanner.error('Unexpected input', scanner.tokenStart);
        } else {
            return;
        }
    }

    for (var pos = scanner.tokenStart + 1; pos < scanner.tokenEnd; pos++) {
        var code = scanner.source.charCodeAt(pos);

        // break on non-hex char
        if (!isHex(code)) {
            // break token, exclude symbol
            scanner.tokenStart = pos;
            return;
        }
    }

    // token is full hex sequence, go to next token
    scanner.next();
}

// # ident
module.exports = {
    name: 'HexColor',
    structure: {
        value: String
    },
    parse: function() {
        var start = this.scanner.tokenStart;

        this.scanner.eat(NUMBERSIGN);

        scan:
        switch (this.scanner.tokenType) {
            case NUMBER:
                consumeHexSequence(this.scanner, true);

                // if token is identifier then number consists of hex only,
                // try to add identifier to result
                if (this.scanner.tokenType === IDENTIFIER) {
                    consumeHexSequence(this.scanner, false);
                }

                break;

            case IDENTIFIER:
                consumeHexSequence(this.scanner, true);
                break;

            default:
                this.scanner.error('Number or identifier is expected');
        }

        return {
            type: 'HexColor',
            loc: this.getLocation(start, this.scanner.tokenStart),
            value: this.scanner.substrToCursor(start + 1) // skip #
        };
    },
    generate: function(node) {
        this.chunk('#');
        this.chunk(node.value);
    }
};

},{"../../tokenizer":657}],610:[function(require,module,exports){
var TYPE = require('../../tokenizer').TYPE;
var IDENTIFIER = TYPE.Identifier;
var NUMBERSIGN = TYPE.NumberSign;

// '#' ident
module.exports = {
    name: 'IdSelector',
    structure: {
        name: String
    },
    parse: function() {
        this.scanner.eat(NUMBERSIGN);

        return {
            type: 'IdSelector',
            loc: this.getLocation(this.scanner.tokenStart - 1, this.scanner.tokenEnd),
            name: this.scanner.consume(IDENTIFIER)
        };
    },
    generate: function(node) {
        this.chunk('#');
        this.chunk(node.name);
    }
};

},{"../../tokenizer":657}],611:[function(require,module,exports){
var TYPE = require('../../tokenizer').TYPE;
var IDENTIFIER = TYPE.Identifier;

module.exports = {
    name: 'Identifier',
    structure: {
        name: String
    },
    parse: function() {
        return {
            type: 'Identifier',
            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
            name: this.scanner.consume(IDENTIFIER)
        };
    },
    generate: function(node) {
        this.chunk(node.name);
    }
};

},{"../../tokenizer":657}],612:[function(require,module,exports){
var TYPE = require('../../tokenizer').TYPE;

var IDENTIFIER = TYPE.Identifier;
var NUMBER = TYPE.Number;
var LEFTPARENTHESIS = TYPE.LeftParenthesis;
var RIGHTPARENTHESIS = TYPE.RightParenthesis;
var COLON = TYPE.Colon;
var SOLIDUS = TYPE.Solidus;

module.exports = {
    name: 'MediaFeature',
    structure: {
        name: String,
        value: ['Identifier', 'Number', 'Dimension', 'Ratio', null]
    },
    parse: function() {
        var start = this.scanner.tokenStart;
        var name;
        var value = null;

        this.scanner.eat(LEFTPARENTHESIS);
        this.scanner.skipSC();

        name = this.scanner.consume(IDENTIFIER);
        this.scanner.skipSC();

        if (this.scanner.tokenType !== RIGHTPARENTHESIS) {
            this.scanner.eat(COLON);
            this.scanner.skipSC();

            switch (this.scanner.tokenType) {
                case NUMBER:
                    if (this.scanner.lookupType(1) === IDENTIFIER) {
                        value = this.Dimension();
                    } else if (this.scanner.lookupNonWSType(1) === SOLIDUS) {
                        value = this.Ratio();
                    } else {
                        value = this.Number();
                    }

                    break;

                case IDENTIFIER:
                    value = this.Identifier();

                    break;

                default:
                    this.scanner.error('Number, dimension, ratio or identifier is expected');
            }

            this.scanner.skipSC();
        }

        this.scanner.eat(RIGHTPARENTHESIS);

        return {
            type: 'MediaFeature',
            loc: this.getLocation(start, this.scanner.tokenStart),
            name: name,
            value: value
        };
    },
    generate: function(node) {
        this.chunk('(');
        this.chunk(node.name);
        if (node.value !== null) {
            this.chunk(':');
            this.node(node.value);
        }
        this.chunk(')');
    }
};

},{"../../tokenizer":657}],613:[function(require,module,exports){
var TYPE = require('../../tokenizer').TYPE;

var WHITESPACE = TYPE.WhiteSpace;
var COMMENT = TYPE.Comment;
var IDENTIFIER = TYPE.Identifier;
var LEFTPARENTHESIS = TYPE.LeftParenthesis;

module.exports = {
    name: 'MediaQuery',
    structure: {
        children: [[
            'Identifier',
            'MediaFeature',
            'WhiteSpace'
        ]]
    },
    parse: function() {
        this.scanner.skipSC();

        var children = this.createList();
        var child = null;
        var space = null;

        scan:
        while (!this.scanner.eof) {
            switch (this.scanner.tokenType) {
                case COMMENT:
                    this.scanner.next();
                    continue;

                case WHITESPACE:
                    space = this.WhiteSpace();
                    continue;

                case IDENTIFIER:
                    child = this.Identifier();
                    break;

                case LEFTPARENTHESIS:
                    child = this.MediaFeature();
                    break;

                default:
                    break scan;
            }

            if (space !== null) {
                children.push(space);
                space = null;
            }

            children.push(child);
        }

        if (child === null) {
            this.scanner.error('Identifier or parenthesis is expected');
        }

        return {
            type: 'MediaQuery',
            loc: this.getLocationFromList(children),
            children: children
        };
    },
    generate: function(node) {
        this.children(node);
    }
};

},{"../../tokenizer":657}],614:[function(require,module,exports){
var COMMA = require('../../tokenizer').TYPE.Comma;

module.exports = {
    name: 'MediaQueryList',
    structure: {
        children: [[
            'MediaQuery'
        ]]
    },
    parse: function(relative) {
        var children = this.createList();

        this.scanner.skipSC();

        while (!this.scanner.eof) {
            children.push(this.MediaQuery(relative));

            if (this.scanner.tokenType !== COMMA) {
                break;
            }

            this.scanner.next();
        }

        return {
            type: 'MediaQueryList',
            loc: this.getLocationFromList(children),
            children: children
        };
    },
    generate: function(node) {
        this.children(node, function() {
            this.chunk(',');
        });
    }
};

},{"../../tokenizer":657}],615:[function(require,module,exports){
// https://drafts.csswg.org/css-syntax-3/#the-anb-type
module.exports = {
    name: 'Nth',
    structure: {
        nth: ['AnPlusB', 'Identifier'],
        selector: ['SelectorList', null]
    },
    parse: function(allowOfClause) {
        this.scanner.skipSC();

        var start = this.scanner.tokenStart;
        var end = start;
        var selector = null;
        var query;

        if (this.scanner.lookupValue(0, 'odd') || this.scanner.lookupValue(0, 'even')) {
            query = this.Identifier();
        } else {
            query = this.AnPlusB();
        }

        this.scanner.skipSC();

        if (allowOfClause && this.scanner.lookupValue(0, 'of')) {
            this.scanner.next();

            selector = this.SelectorList();

            if (this.needPositions) {
                end = this.getLastListNode(selector.children).loc.end.offset;
            }
        } else {
            if (this.needPositions) {
                end = query.loc.end.offset;
            }
        }

        return {
            type: 'Nth',
            loc: this.getLocation(start, end),
            nth: query,
            selector: selector
        };
    },
    generate: function(node) {
        this.node(node.nth);
        if (node.selector !== null) {
            this.chunk(' of ');
            this.node(node.selector);
        }
    }
};

},{}],616:[function(require,module,exports){
var NUMBER = require('../../tokenizer').TYPE.Number;

module.exports = {
    name: 'Number',
    structure: {
        value: String
    },
    parse: function() {
        return {
            type: 'Number',
            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
            value: this.scanner.consume(NUMBER)
        };
    },
    generate: function(node) {
        this.chunk(node.value);
    }
};

},{"../../tokenizer":657}],617:[function(require,module,exports){
// '/' | '*' | ',' | ':' | '+' | '-'
module.exports = {
    name: 'Operator',
    structure: {
        value: String
    },
    parse: function() {
        var start = this.scanner.tokenStart;

        this.scanner.next();

        return {
            type: 'Operator',
            loc: this.getLocation(start, this.scanner.tokenStart),
            value: this.scanner.substrToCursor(start)
        };
    },
    generate: function(node) {
        this.chunk(node.value);
    }
};

},{}],618:[function(require,module,exports){
var TYPE = require('../../tokenizer').TYPE;
var LEFTPARENTHESIS = TYPE.LeftParenthesis;
var RIGHTPARENTHESIS = TYPE.RightParenthesis;

module.exports = {
    name: 'Parentheses',
    structure: {
        children: [[]]
    },
    parse: function(readSequence, recognizer) {
        var start = this.scanner.tokenStart;
        var children = null;

        this.scanner.eat(LEFTPARENTHESIS);

        children = readSequence.call(this, recognizer);

        if (!this.scanner.eof) {
            this.scanner.eat(RIGHTPARENTHESIS);
        }

        return {
            type: 'Parentheses',
            loc: this.getLocation(start, this.scanner.tokenStart),
            children: children
        };
    },
    generate: function(node) {
        this.chunk('(');
        this.children(node);
        this.chunk(')');
    }
};

},{"../../tokenizer":657}],619:[function(require,module,exports){
var TYPE = require('../../tokenizer').TYPE;

var NUMBER = TYPE.Number;
var PERCENTSIGN = TYPE.PercentSign;

module.exports = {
    name: 'Percentage',
    structure: {
        value: String
    },
    parse: function() {
        var start = this.scanner.tokenStart;
        var number = this.scanner.consume(NUMBER);

        this.scanner.eat(PERCENTSIGN);

        return {
            type: 'Percentage',
            loc: this.getLocation(start, this.scanner.tokenStart),
            value: number
        };
    },
    generate: function(node) {
        this.chunk(node.value);
        this.chunk('%');
    }
};

},{"../../tokenizer":657}],620:[function(require,module,exports){
var TYPE = require('../../tokenizer').TYPE;

var IDENTIFIER = TYPE.Identifier;
var FUNCTION = TYPE.Function;
var COLON = TYPE.Colon;
var RIGHTPARENTHESIS = TYPE.RightParenthesis;

// : ident [ '(' .. ')' ]?
module.exports = {
    name: 'PseudoClassSelector',
    structure: {
        name: String,
        children: [['Raw'], null]
    },
    parse: function() {
        var start = this.scanner.tokenStart;
        var children = null;
        var name;
        var nameLowerCase;

        this.scanner.eat(COLON);

        if (this.scanner.tokenType === FUNCTION) {
            name = this.scanner.consumeFunctionName();
            nameLowerCase = name.toLowerCase();

            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
                this.scanner.skipSC();
                children = this.pseudo[nameLowerCase].call(this);
                this.scanner.skipSC();
            } else {
                children = this.createList();
                children.push(
                    this.Raw(this.scanner.currentToken, 0, 0, false, false)
                );
            }

            this.scanner.eat(RIGHTPARENTHESIS);
        } else {
            name = this.scanner.consume(IDENTIFIER);
        }

        return {
            type: 'PseudoClassSelector',
            loc: this.getLocation(start, this.scanner.tokenStart),
            name: name,
            children: children
        };
    },
    generate: function(node) {
        this.chunk(':');
        this.chunk(node.name);

        if (node.children !== null) {
            this.chunk('(');
            this.children(node);
            this.chunk(')');
        }
    },
    walkContext: 'function'
};

},{"../../tokenizer":657}],621:[function(require,module,exports){
var TYPE = require('../../tokenizer').TYPE;

var IDENTIFIER = TYPE.Identifier;
var FUNCTION = TYPE.Function;
var COLON = TYPE.Colon;
var RIGHTPARENTHESIS = TYPE.RightParenthesis;

// :: ident [ '(' .. ')' ]?
module.exports = {
    name: 'PseudoElementSelector',
    structure: {
        name: String,
        children: [['Raw'], null]
    },
    parse: function() {
        var start = this.scanner.tokenStart;
        var children = null;
        var name;
        var nameLowerCase;

        this.scanner.eat(COLON);
        this.scanner.eat(COLON);

        if (this.scanner.tokenType === FUNCTION) {
            name = this.scanner.consumeFunctionName();
            nameLowerCase = name.toLowerCase();

            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
                this.scanner.skipSC();
                children = this.pseudo[nameLowerCase].call(this);
                this.scanner.skipSC();
            } else {
                children = this.createList();
                children.push(
                    this.Raw(this.scanner.currentToken, 0, 0, false, false)
                );
            }

            this.scanner.eat(RIGHTPARENTHESIS);
        } else {
            name = this.scanner.consume(IDENTIFIER);
        }

        return {
            type: 'PseudoElementSelector',
            loc: this.getLocation(start, this.scanner.tokenStart),
            name: name,
            children: children
        };
    },
    generate: function(node) {
        this.chunk('::');
        this.chunk(node.name);

        if (node.children !== null) {
            this.chunk('(');
            this.children(node);
            this.chunk(')');
        }
    },
    walkContext: 'function'
};

},{"../../tokenizer":657}],622:[function(require,module,exports){
var isNumber = require('../../tokenizer').isNumber;
var TYPE = require('../../tokenizer').TYPE;
var NUMBER = TYPE.Number;
var SOLIDUS = TYPE.Solidus;
var FULLSTOP = TYPE.FullStop;

// Terms of <ratio> should to be a positive number (not zero or negative)
// (see https://drafts.csswg.org/mediaqueries-3/#values)
// However, -o-min-device-pixel-ratio takes fractional values as a ratio's term
// and this is using by various sites. Therefore we relax checking on parse
// to test a term is unsigned number without exponent part.
// Additional checks may to be applied on lexer validation.
function consumeNumber(scanner) {
    var value = scanner.consumeNonWS(NUMBER);

    for (var i = 0; i < value.length; i++) {
        var code = value.charCodeAt(i);
        if (!isNumber(code) && code !== FULLSTOP) {
            scanner.error('Unsigned number is expected', scanner.tokenStart - value.length + i);
        }
    }

    if (Number(value) === 0) {
        scanner.error('Zero number is not allowed', scanner.tokenStart - value.length);
    }

    return value;
}

// <positive-integer> S* '/' S* <positive-integer>
module.exports = {
    name: 'Ratio',
    structure: {
        left: String,
        right: String
    },
    parse: function() {
        var start = this.scanner.tokenStart;
        var left = consumeNumber(this.scanner);
        var right;

        this.scanner.eatNonWS(SOLIDUS);
        right = consumeNumber(this.scanner);

        return {
            type: 'Ratio',
            loc: this.getLocation(start, this.scanner.tokenStart),
            left: left,
            right: right
        };
    },
    generate: function(node) {
        this.chunk(node.left);
        this.chunk('/');
        this.chunk(node.right);
    }
};

},{"../../tokenizer":657}],623:[function(require,module,exports){
module.exports = {
    name: 'Raw',
    structure: {
        value: String
    },
    parse: function(startToken, endTokenType1, endTokenType2, includeTokenType2, excludeWhiteSpace) {
        var startOffset = this.scanner.getTokenStart(startToken);
        var endOffset;

        this.scanner.skip(
            this.scanner.getRawLength(
                startToken,
                endTokenType1,
                endTokenType2,
                includeTokenType2
            )
        );

        if (excludeWhiteSpace && this.scanner.tokenStart > startOffset) {
            endOffset = this.scanner.getOffsetExcludeWS();
        } else {
            endOffset = this.scanner.tokenStart;
        }

        return {
            type: 'Raw',
            loc: this.getLocation(startOffset, endOffset),
            value: this.scanner.source.substring(startOffset, endOffset)
        };
    },
    generate: function(node) {
        this.chunk(node.value);
    }
};

},{}],624:[function(require,module,exports){
var TYPE = require('../../tokenizer').TYPE;

var LEFTCURLYBRACKET = TYPE.LeftCurlyBracket;

function consumeRaw(startToken) {
    return this.Raw(startToken, LEFTCURLYBRACKET, 0, false, true);
}

function consumePrelude() {
    var prelude = this.SelectorList();

    if (prelude.type !== 'Raw' &&
        this.scanner.eof === false &&
        this.scanner.tokenType !== LEFTCURLYBRACKET) {
        this.scanner.error();
    }

    return prelude;
}

module.exports = {
    name: 'Rule',
    structure: {
        prelude: ['SelectorList', 'Raw'],
        block: ['Block']
    },
    parse: function() {
        var startToken = this.scanner.currentToken;
        var startOffset = this.scanner.tokenStart;
        var prelude;
        var block;

        if (this.parseRulePrelude) {
            prelude = this.parseWithFallback(consumePrelude, consumeRaw);
        } else {
            prelude = consumeRaw.call(this, startToken);
        }

        block = this.Block(true);

        return {
            type: 'Rule',
            loc: this.getLocation(startOffset, this.scanner.tokenStart),
            prelude: prelude,
            block: block
        };
    },
    generate: function(node) {
        this.node(node.prelude);
        this.node(node.block);
    },
    walkContext: 'rule'
};

},{"../../tokenizer":657}],625:[function(require,module,exports){
module.exports = {
    name: 'Selector',
    structure: {
        children: [[
            'TypeSelector',
            'IdSelector',
            'ClassSelector',
            'AttributeSelector',
            'PseudoClassSelector',
            'PseudoElementSelector',
            'Combinator',
            'WhiteSpace'
        ]]
    },
    parse: function() {
        var children = this.readSequence(this.scope.Selector);

        // nothing were consumed
        if (this.getFirstListNode(children) === null) {
            this.scanner.error('Selector is expected');
        }

        return {
            type: 'Selector',
            loc: this.getLocationFromList(children),
            children: children
        };
    },
    generate: function(node) {
        this.children(node);
    }
};

},{}],626:[function(require,module,exports){
var TYPE = require('../../tokenizer').TYPE;

var COMMA = TYPE.Comma;

module.exports = {
    name: 'SelectorList',
    structure: {
        children: [[
            'Selector',
            'Raw'
        ]]
    },
    parse: function() {
        var children = this.createList();

        while (!this.scanner.eof) {
            children.push(this.Selector());

            if (this.scanner.tokenType === COMMA) {
                this.scanner.next();
                continue;
            }

            break;
        }

        return {
            type: 'SelectorList',
            loc: this.getLocationFromList(children),
            children: children
        };
    },
    generate: function(node) {
        this.children(node, function() {
            this.chunk(',');
        });
    },
    walkContext: 'selector'
};

},{"../../tokenizer":657}],627:[function(require,module,exports){
var STRING = require('../../tokenizer').TYPE.String;

module.exports = {
    name: 'String',
    structure: {
        value: String
    },
    parse: function() {
        return {
            type: 'String',
            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
            value: this.scanner.consume(STRING)
        };
    },
    generate: function(node) {
        this.chunk(node.value);
    }
};

},{"../../tokenizer":657}],628:[function(require,module,exports){
var TYPE = require('../../tokenizer').TYPE;

var WHITESPACE = TYPE.WhiteSpace;
var COMMENT = TYPE.Comment;
var EXCLAMATIONMARK = TYPE.ExclamationMark;
var ATRULE = TYPE.Atrule;
var CDO = TYPE.CDO;
var CDC = TYPE.CDC;

function consumeRaw(startToken) {
    return this.Raw(startToken, 0, 0, false, false);
}

module.exports = {
    name: 'StyleSheet',
    structure: {
        children: [[
            'Comment',
            'CDO',
            'CDC',
            'Atrule',
            'Rule',
            'Raw'
        ]]
    },
    parse: function() {
        var start = this.scanner.tokenStart;
        var children = this.createList();
        var child;

        scan:
        while (!this.scanner.eof) {
            switch (this.scanner.tokenType) {
                case WHITESPACE:
                    this.scanner.next();
                    continue;

                case COMMENT:
                    // ignore comments except exclamation comments (i.e. /*! .. */) on top level
                    if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 2) !== EXCLAMATIONMARK) {
                        this.scanner.next();
                        continue;
                    }

                    child = this.Comment();
                    break;

                case CDO: // <!--
                    child = this.CDO();
                    break;

                case CDC: // -->
                    child = this.CDC();
                    break;

                // CSS Syntax Module Level 3
                // 2.2 Error handling
                // At the "top level" of a stylesheet, an <at-keyword-token> starts an at-rule.
                case ATRULE:
                    child = this.parseWithFallback(this.Atrule, consumeRaw);
                    break;

                // Anything else starts a qualified rule ...
                default:
                    child = this.parseWithFallback(this.Rule, consumeRaw);
            }

            children.push(child);
        }

        return {
            type: 'StyleSheet',
            loc: this.getLocation(start, this.scanner.tokenStart),
            children: children
        };
    },
    generate: function(node) {
        this.children(node);
    },
    walkContext: 'stylesheet'
};

},{"../../tokenizer":657}],629:[function(require,module,exports){
var TYPE = require('../../tokenizer').TYPE;

var IDENTIFIER = TYPE.Identifier;
var ASTERISK = TYPE.Asterisk;
var VERTICALLINE = TYPE.VerticalLine;

function eatIdentifierOrAsterisk() {
    if (this.scanner.tokenType !== IDENTIFIER &&
        this.scanner.tokenType !== ASTERISK) {
        this.scanner.error('Identifier or asterisk is expected');
    }

    this.scanner.next();
}

// ident
// ident|ident
// ident|*
// *
// *|ident
// *|*
// |ident
// |*
module.exports = {
    name: 'TypeSelector',
    structure: {
        name: String
    },
    parse: function() {
        var start = this.scanner.tokenStart;

        if (this.scanner.tokenType === VERTICALLINE) {
            this.scanner.next();
            eatIdentifierOrAsterisk.call(this);
        } else {
            eatIdentifierOrAsterisk.call(this);

            if (this.scanner.tokenType === VERTICALLINE) {
                this.scanner.next();
                eatIdentifierOrAsterisk.call(this);
            }
        }

        return {
            type: 'TypeSelector',
            loc: this.getLocation(start, this.scanner.tokenStart),
            name: this.scanner.substrToCursor(start)
        };
    },
    generate: function(node) {
        this.chunk(node.name);
    }
};

},{"../../tokenizer":657}],630:[function(require,module,exports){
var isHex = require('../../tokenizer').isHex;
var TYPE = require('../../tokenizer').TYPE;

var IDENTIFIER = TYPE.Identifier;
var NUMBER = TYPE.Number;
var PLUSSIGN = TYPE.PlusSign;
var HYPHENMINUS = TYPE.HyphenMinus;
var FULLSTOP = TYPE.FullStop;
var QUESTIONMARK = TYPE.QuestionMark;

function scanUnicodeNumber(scanner) {
    for (var pos = scanner.tokenStart + 1; pos < scanner.tokenEnd; pos++) {
        var code = scanner.source.charCodeAt(pos);

        // break on fullstop or hyperminus/plussign after exponent
        if (code === FULLSTOP || code === PLUSSIGN) {
            // break token, exclude symbol
            scanner.tokenStart = pos;
            return false;
        }
    }

    return true;
}

// https://drafts.csswg.org/css-syntax-3/#urange
function scanUnicodeRange(scanner) {
    var hexStart = scanner.tokenStart + 1; // skip +
    var hexLength = 0;

    scan: {
        if (scanner.tokenType === NUMBER) {
            if (scanner.source.charCodeAt(scanner.tokenStart) !== FULLSTOP && scanUnicodeNumber(scanner)) {
                scanner.next();
            } else if (scanner.source.charCodeAt(scanner.tokenStart) !== HYPHENMINUS) {
                break scan;
            }
        } else {
            scanner.next(); // PLUSSIGN
        }

        if (scanner.tokenType === HYPHENMINUS) {
            scanner.next();
        }

        if (scanner.tokenType === NUMBER) {
            scanner.next();
        }

        if (scanner.tokenType === IDENTIFIER) {
            scanner.next();
        }

        if (scanner.tokenStart === hexStart) {
            scanner.error('Unexpected input', hexStart);
        }
    }

    // validate for U+x{1,6} or U+x{1,6}-x{1,6}
    // where x is [0-9a-fA-F]
    for (var i = hexStart, wasHyphenMinus = false; i < scanner.tokenStart; i++) {
        var code = scanner.source.charCodeAt(i);

        if (isHex(code) === false && (code !== HYPHENMINUS || wasHyphenMinus)) {
            scanner.error('Unexpected input', i);
        }

        if (code === HYPHENMINUS) {
            // hex sequence shouldn't be an empty
            if (hexLength === 0) {
                scanner.error('Unexpected input', i);
            }

            wasHyphenMinus = true;
            hexLength = 0;
        } else {
            hexLength++;

            // too long hex sequence
            if (hexLength > 6) {
                scanner.error('Too long hex sequence', i);
            }
        }

    }

    // check we have a non-zero sequence
    if (hexLength === 0) {
        scanner.error('Unexpected input', i - 1);
    }

    // U+abc???
    if (!wasHyphenMinus) {
        // consume as many U+003F QUESTION MARK (?) code points as possible
        for (; hexLength < 6 && !scanner.eof; scanner.next()) {
            if (scanner.tokenType !== QUESTIONMARK) {
                break;
            }

            hexLength++;
        }
    }
}

module.exports = {
    name: 'UnicodeRange',
    structure: {
        value: String
    },
    parse: function() {
        var start = this.scanner.tokenStart;

        this.scanner.next(); // U or u
        scanUnicodeRange(this.scanner);

        return {
            type: 'UnicodeRange',
            loc: this.getLocation(start, this.scanner.tokenStart),
            value: this.scanner.substrToCursor(start)
        };
    },
    generate: function(node) {
        this.chunk(node.value);
    }
};

},{"../../tokenizer":657}],631:[function(require,module,exports){
var TYPE = require('../../tokenizer').TYPE;

var STRING = TYPE.String;
var URL = TYPE.Url;
var RAW = TYPE.Raw;
var RIGHTPARENTHESIS = TYPE.RightParenthesis;

// url '(' S* (string | raw) S* ')'
module.exports = {
    name: 'Url',
    structure: {
        value: ['String', 'Raw']
    },
    parse: function() {
        var start = this.scanner.tokenStart;
        var value;

        this.scanner.eat(URL);
        this.scanner.skipSC();

        switch (this.scanner.tokenType) {
            case STRING:
                value = this.String();
                break;

            case RAW:
                value = this.Raw(this.scanner.currentToken, 0, RAW, true, false);
                break;

            default:
                this.scanner.error('String or Raw is expected');
        }

        this.scanner.skipSC();
        this.scanner.eat(RIGHTPARENTHESIS);

        return {
            type: 'Url',
            loc: this.getLocation(start, this.scanner.tokenStart),
            value: value
        };
    },
    generate: function(node) {
        this.chunk('url');
        this.chunk('(');
        this.node(node.value);
        this.chunk(')');
    }
};

},{"../../tokenizer":657}],632:[function(require,module,exports){
module.exports = {
    name: 'Value',
    structure: {
        children: [[]]
    },
    parse: function() {
        var start = this.scanner.tokenStart;
        var children = this.readSequence(this.scope.Value);

        return {
            type: 'Value',
            loc: this.getLocation(start, this.scanner.tokenStart),
            children: children
        };
    },
    generate: function(node) {
        this.children(node);
    }
};

},{}],633:[function(require,module,exports){
var WHITESPACE = require('../../tokenizer').TYPE.WhiteSpace;
var SPACE = Object.freeze({
    type: 'WhiteSpace',
    loc: null,
    value: ' '
});

module.exports = {
    name: 'WhiteSpace',
    structure: {
        value: String
    },
    parse: function() {
        this.scanner.eat(WHITESPACE);
        return SPACE;

        // return {
        //     type: 'WhiteSpace',
        //     loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
        //     value: this.scanner.consume(WHITESPACE)
        // };
    },
    generate: function(node) {
        this.chunk(node.value);
    }
};

},{"../../tokenizer":657}],634:[function(require,module,exports){
module.exports = {
    AnPlusB: require('./AnPlusB'),
    Atrule: require('./Atrule'),
    AtrulePrelude: require('./AtrulePrelude'),
    AttributeSelector: require('./AttributeSelector'),
    Block: require('./Block'),
    Brackets: require('./Brackets'),
    CDC: require('./CDC'),
    CDO: require('./CDO'),
    ClassSelector: require('./ClassSelector'),
    Combinator: require('./Combinator'),
    Comment: require('./Comment'),
    Declaration: require('./Declaration'),
    DeclarationList: require('./DeclarationList'),
    Dimension: require('./Dimension'),
    Function: require('./Function'),
    HexColor: require('./HexColor'),
    Identifier: require('./Identifier'),
    IdSelector: require('./IdSelector'),
    MediaFeature: require('./MediaFeature'),
    MediaQuery: require('./MediaQuery'),
    MediaQueryList: require('./MediaQueryList'),
    Nth: require('./Nth'),
    Number: require('./Number'),
    Operator: require('./Operator'),
    Parentheses: require('./Parentheses'),
    Percentage: require('./Percentage'),
    PseudoClassSelector: require('./PseudoClassSelector'),
    PseudoElementSelector: require('./PseudoElementSelector'),
    Ratio: require('./Ratio'),
    Raw: require('./Raw'),
    Rule: require('./Rule'),
    Selector: require('./Selector'),
    SelectorList: require('./SelectorList'),
    String: require('./String'),
    StyleSheet: require('./StyleSheet'),
    TypeSelector: require('./TypeSelector'),
    UnicodeRange: require('./UnicodeRange'),
    Url: require('./Url'),
    Value: require('./Value'),
    WhiteSpace: require('./WhiteSpace')
};

},{"./AnPlusB":594,"./Atrule":595,"./AtrulePrelude":596,"./AttributeSelector":597,"./Block":598,"./Brackets":599,"./CDC":600,"./CDO":601,"./ClassSelector":602,"./Combinator":603,"./Comment":604,"./Declaration":605,"./DeclarationList":606,"./Dimension":607,"./Function":608,"./HexColor":609,"./IdSelector":610,"./Identifier":611,"./MediaFeature":612,"./MediaQuery":613,"./MediaQueryList":614,"./Nth":615,"./Number":616,"./Operator":617,"./Parentheses":618,"./Percentage":619,"./PseudoClassSelector":620,"./PseudoElementSelector":621,"./Ratio":622,"./Raw":623,"./Rule":624,"./Selector":625,"./SelectorList":626,"./String":627,"./StyleSheet":628,"./TypeSelector":629,"./UnicodeRange":630,"./Url":631,"./Value":632,"./WhiteSpace":633}],635:[function(require,module,exports){
var DISALLOW_OF_CLAUSE = false;

module.exports = {
    parse: function nth() {
        return this.createSingleNodeList(
            this.Nth(DISALLOW_OF_CLAUSE)
        );
    }
};

},{}],636:[function(require,module,exports){
var ALLOW_OF_CLAUSE = true;

module.exports = {
    parse: function nthWithOfClause() {
        return this.createSingleNodeList(
            this.Nth(ALLOW_OF_CLAUSE)
        );
    }
};

},{}],637:[function(require,module,exports){
module.exports = {
    parse: function selectorList() {
        return this.createSingleNodeList(
            this.SelectorList()
        );
    }
};

},{}],638:[function(require,module,exports){
module.exports = {
    parse: function() {
        return this.createSingleNodeList(
            this.Identifier()
        );
    }
};

},{}],639:[function(require,module,exports){
module.exports = {
    parse: function() {
        return this.createSingleNodeList(
            this.SelectorList()
        );
    }
};

},{}],640:[function(require,module,exports){
module.exports = {
    'dir': require('./dir'),
    'has': require('./has'),
    'lang': require('./lang'),
    'matches': require('./matches'),
    'not': require('./not'),
    'nth-child': require('./nth-child'),
    'nth-last-child': require('./nth-last-child'),
    'nth-last-of-type': require('./nth-last-of-type'),
    'nth-of-type': require('./nth-of-type'),
    'slotted': require('./slotted')
};

},{"./dir":638,"./has":639,"./lang":641,"./matches":642,"./not":643,"./nth-child":644,"./nth-last-child":645,"./nth-last-of-type":646,"./nth-of-type":647,"./slotted":648}],641:[function(require,module,exports){
arguments[4][638][0].apply(exports,arguments)
},{"dup":638}],642:[function(require,module,exports){
module.exports = require('./common/selectorList');

},{"./common/selectorList":637}],643:[function(require,module,exports){
arguments[4][642][0].apply(exports,arguments)
},{"./common/selectorList":637,"dup":642}],644:[function(require,module,exports){
module.exports = require('./common/nthWithOfClause');

},{"./common/nthWithOfClause":636}],645:[function(require,module,exports){
arguments[4][644][0].apply(exports,arguments)
},{"./common/nthWithOfClause":636,"dup":644}],646:[function(require,module,exports){
module.exports = require('./common/nth');

},{"./common/nth":635}],647:[function(require,module,exports){
arguments[4][646][0].apply(exports,arguments)
},{"./common/nth":635,"dup":646}],648:[function(require,module,exports){
module.exports = {
    parse: function compoundSelector() {
        return this.createSingleNodeList(
            this.Selector()
        );
    }
};

},{}],649:[function(require,module,exports){
module.exports = {
    getNode: require('./default')
};

},{"./default":650}],650:[function(require,module,exports){
var cmpChar = require('../../tokenizer').cmpChar;
var TYPE = require('../../tokenizer').TYPE;

var IDENTIFIER = TYPE.Identifier;
var STRING = TYPE.String;
var NUMBER = TYPE.Number;
var FUNCTION = TYPE.Function;
var URL = TYPE.Url;
var NUMBERSIGN = TYPE.NumberSign;
var LEFTPARENTHESIS = TYPE.LeftParenthesis;
var LEFTSQUAREBRACKET = TYPE.LeftSquareBracket;
var PLUSSIGN = TYPE.PlusSign;
var HYPHENMINUS = TYPE.HyphenMinus;
var COMMA = TYPE.Comma;
var SOLIDUS = TYPE.Solidus;
var ASTERISK = TYPE.Asterisk;
var PERCENTSIGN = TYPE.PercentSign;
var BACKSLASH = TYPE.Backslash;
var U = 117; // 'u'.charCodeAt(0)

module.exports = function defaultRecognizer(context) {
    switch (this.scanner.tokenType) {
        case NUMBERSIGN:
            return this.HexColor();

        case COMMA:
            context.space = null;
            context.ignoreWSAfter = true;
            return this.Operator();

        case SOLIDUS:
        case ASTERISK:
        case PLUSSIGN:
        case HYPHENMINUS:
            return this.Operator();

        case LEFTPARENTHESIS:
            return this.Parentheses(this.readSequence, context.recognizer);

        case LEFTSQUAREBRACKET:
            return this.Brackets(this.readSequence, context.recognizer);

        case STRING:
            return this.String();

        case NUMBER:
            switch (this.scanner.lookupType(1)) {
                case PERCENTSIGN:
                    return this.Percentage();

                case IDENTIFIER:
                    // edge case: number with folowing \0 and \9 hack shouldn't to be a Dimension
                    if (cmpChar(this.scanner.source, this.scanner.tokenEnd, BACKSLASH)) {
                        return this.Number();
                    } else {
                        return this.Dimension();
                    }

                default:
                    return this.Number();
            }

        case FUNCTION:
            return this.Function(this.readSequence, context.recognizer);

        case URL:
            return this.Url();

        case IDENTIFIER:
            // check for unicode range, it should start with u+ or U+
            if (cmpChar(this.scanner.source, this.scanner.tokenStart, U) &&
                cmpChar(this.scanner.source, this.scanner.tokenStart + 1, PLUSSIGN)) {
                return this.UnicodeRange();
            } else {
                return this.Identifier();
            }
    }
};

},{"../../tokenizer":657}],651:[function(require,module,exports){
module.exports = {
    AtrulePrelude: require('./atrulePrelude'),
    Selector: require('./selector'),
    Value: require('./value')
};

},{"./atrulePrelude":649,"./selector":652,"./value":653}],652:[function(require,module,exports){
var TYPE = require('../../tokenizer').TYPE;

var IDENTIFIER = TYPE.Identifier;
var NUMBER = TYPE.Number;
var NUMBERSIGN = TYPE.NumberSign;
var LEFTSQUAREBRACKET = TYPE.LeftSquareBracket;
var PLUSSIGN = TYPE.PlusSign;
var SOLIDUS = TYPE.Solidus;
var ASTERISK = TYPE.Asterisk;
var FULLSTOP = TYPE.FullStop;
var COLON = TYPE.Colon;
var GREATERTHANSIGN = TYPE.GreaterThanSign;
var VERTICALLINE = TYPE.VerticalLine;
var TILDE = TYPE.Tilde;

function getNode(context) {
    switch (this.scanner.tokenType) {
        case PLUSSIGN:
        case GREATERTHANSIGN:
        case TILDE:
            context.space = null;
            context.ignoreWSAfter = true;
            return this.Combinator();

        case SOLIDUS:  // /deep/
            return this.Combinator();

        case FULLSTOP:
            return this.ClassSelector();

        case LEFTSQUAREBRACKET:
            return this.AttributeSelector();

        case NUMBERSIGN:
            return this.IdSelector();

        case COLON:
            if (this.scanner.lookupType(1) === COLON) {
                return this.PseudoElementSelector();
            } else {
                return this.PseudoClassSelector();
            }

        case IDENTIFIER:
        case ASTERISK:
        case VERTICALLINE:
            return this.TypeSelector();

        case NUMBER:
            return this.Percentage();
    }
};

module.exports = {
    getNode: getNode
};

},{"../../tokenizer":657}],653:[function(require,module,exports){
module.exports = {
    getNode: require('./default'),
    '-moz-element': require('../function/element'),
    'element': require('../function/element'),
    'expression': require('../function/expression'),
    'var': require('../function/var')
};

},{"../function/element":590,"../function/expression":591,"../function/var":592,"./default":650}],654:[function(require,module,exports){
'use strict';

var CssSyntaxError = require('./error');

var constants = require('./const');
var TYPE = constants.TYPE;
var NAME = constants.NAME;
var SYMBOL_TYPE = constants.SYMBOL_TYPE;

var utils = require('./utils');
var firstCharOffset = utils.firstCharOffset;
var cmpStr = utils.cmpStr;
var isNumber = utils.isNumber;
var findWhiteSpaceStart = utils.findWhiteSpaceStart;
var findWhiteSpaceEnd = utils.findWhiteSpaceEnd;
var findCommentEnd = utils.findCommentEnd;
var findStringEnd = utils.findStringEnd;
var findNumberEnd = utils.findNumberEnd;
var findIdentifierEnd = utils.findIdentifierEnd;
var findUrlRawEnd = utils.findUrlRawEnd;

var NULL = 0;
var WHITESPACE = TYPE.WhiteSpace;
var IDENTIFIER = TYPE.Identifier;
var NUMBER = TYPE.Number;
var STRING = TYPE.String;
var COMMENT = TYPE.Comment;
var PUNCTUATOR = TYPE.Punctuator;
var CDO = TYPE.CDO;
var CDC = TYPE.CDC;
var ATRULE = TYPE.Atrule;
var FUNCTION = TYPE.Function;
var URL = TYPE.Url;
var RAW = TYPE.Raw;

var N = 10;
var F = 12;
var R = 13;
var STAR = TYPE.Asterisk;
var SLASH = TYPE.Solidus;
var FULLSTOP = TYPE.FullStop;
var PLUSSIGN = TYPE.PlusSign;
var HYPHENMINUS = TYPE.HyphenMinus;
var GREATERTHANSIGN = TYPE.GreaterThanSign;
var LESSTHANSIGN = TYPE.LessThanSign;
var EXCLAMATIONMARK = TYPE.ExclamationMark;
var COMMERCIALAT = TYPE.CommercialAt;
var QUOTATIONMARK = TYPE.QuotationMark;
var APOSTROPHE = TYPE.Apostrophe;
var LEFTPARENTHESIS = TYPE.LeftParenthesis;
var RIGHTPARENTHESIS = TYPE.RightParenthesis;
var LEFTCURLYBRACKET = TYPE.LeftCurlyBracket;
var RIGHTCURLYBRACKET = TYPE.RightCurlyBracket;
var LEFTSQUAREBRACKET = TYPE.LeftSquareBracket;
var RIGHTSQUAREBRACKET = TYPE.RightSquareBracket;

var MIN_BUFFER_SIZE = 16 * 1024;
var OFFSET_MASK = 0x00FFFFFF;
var TYPE_SHIFT = 24;
var SafeUint32Array = typeof Uint32Array !== 'undefined' ? Uint32Array : Array; // fallback on Array when TypedArray is not supported

function computeLinesAndColumns(tokenizer, source) {
    var sourceLength = source.length;
    var start = firstCharOffset(source);
    var lines = tokenizer.lines;
    var line = tokenizer.startLine;
    var columns = tokenizer.columns;
    var column = tokenizer.startColumn;

    if (lines === null || lines.length < sourceLength + 1) {
        lines = new SafeUint32Array(Math.max(sourceLength + 1024, MIN_BUFFER_SIZE));
        columns = new SafeUint32Array(lines.length);
    }

    for (var i = start; i < sourceLength; i++) {
        var code = source.charCodeAt(i);

        lines[i] = line;
        columns[i] = column++;

        if (code === N || code === R || code === F) {
            if (code === R && i + 1 < sourceLength && source.charCodeAt(i + 1) === N) {
                i++;
                lines[i] = line;
                columns[i] = column;
            }

            line++;
            column = 1;
        }
    }

    lines[i] = line;
    columns[i] = column;

    tokenizer.linesAnsColumnsComputed = true;
    tokenizer.lines = lines;
    tokenizer.columns = columns;
}

function tokenLayout(tokenizer, source, startPos) {
    var sourceLength = source.length;
    var offsetAndType = tokenizer.offsetAndType;
    var balance = tokenizer.balance;
    var tokenCount = 0;
    var prevType = 0;
    var offset = startPos;
    var anchor = 0;
    var balanceCloseCode = 0;
    var balanceStart = 0;
    var balancePrev = 0;

    if (offsetAndType === null || offsetAndType.length < sourceLength + 1) {
        offsetAndType = new SafeUint32Array(sourceLength + 1024);
        balance = new SafeUint32Array(sourceLength + 1024);
    }

    while (offset < sourceLength) {
        var code = source.charCodeAt(offset);
        var type = code < 0x80 ? SYMBOL_TYPE[code] : IDENTIFIER;

        balance[tokenCount] = sourceLength;

        switch (type) {
            case WHITESPACE:
                offset = findWhiteSpaceEnd(source, offset + 1);
                break;

            case PUNCTUATOR:
                switch (code) {
                    case balanceCloseCode:
                        balancePrev = balanceStart & OFFSET_MASK;
                        balanceStart = balance[balancePrev];
                        balanceCloseCode = balanceStart >> TYPE_SHIFT;
                        balance[tokenCount] = balancePrev;
                        balance[balancePrev++] = tokenCount;
                        for (; balancePrev < tokenCount; balancePrev++) {
                            if (balance[balancePrev] === sourceLength) {
                                balance[balancePrev] = tokenCount;
                            }
                        }
                        break;

                    case LEFTSQUAREBRACKET:
                        balance[tokenCount] = balanceStart;
                        balanceCloseCode = RIGHTSQUAREBRACKET;
                        balanceStart = (balanceCloseCode << TYPE_SHIFT) | tokenCount;
                        break;

                    case LEFTCURLYBRACKET:
                        balance[tokenCount] = balanceStart;
                        balanceCloseCode = RIGHTCURLYBRACKET;
                        balanceStart = (balanceCloseCode << TYPE_SHIFT) | tokenCount;
                        break;

                    case LEFTPARENTHESIS:
                        balance[tokenCount] = balanceStart;
                        balanceCloseCode = RIGHTPARENTHESIS;
                        balanceStart = (balanceCloseCode << TYPE_SHIFT) | tokenCount;
                        break;
                }

                // /*
                if (code === STAR && prevType === SLASH) {
                    type = COMMENT;
                    offset = findCommentEnd(source, offset + 1);
                    tokenCount--; // rewrite prev token
                    break;
                }

                // edge case for -.123 and +.123
                if (code === FULLSTOP && (prevType === PLUSSIGN || prevType === HYPHENMINUS)) {
                    if (offset + 1 < sourceLength && isNumber(source.charCodeAt(offset + 1))) {
                        type = NUMBER;
                        offset = findNumberEnd(source, offset + 2, false);
                        tokenCount--; // rewrite prev token
                        break;
                    }
                }

                // <!--
                if (code === EXCLAMATIONMARK && prevType === LESSTHANSIGN) {
                    if (offset + 2 < sourceLength &&
                        source.charCodeAt(offset + 1) === HYPHENMINUS &&
                        source.charCodeAt(offset + 2) === HYPHENMINUS) {
                        type = CDO;
                        offset = offset + 3;
                        tokenCount--; // rewrite prev token
                        break;
                    }
                }

                // -->
                if (code === HYPHENMINUS && prevType === HYPHENMINUS) {
                    if (offset + 1 < sourceLength && source.charCodeAt(offset + 1) === GREATERTHANSIGN) {
                        type = CDC;
                        offset = offset + 2;
                        tokenCount--; // rewrite prev token
                        break;
                    }
                }

                // ident(
                if (code === LEFTPARENTHESIS && prevType === IDENTIFIER) {
                    offset = offset + 1;
                    tokenCount--; // rewrite prev token
                    balance[tokenCount] = balance[tokenCount + 1];
                    balanceStart--;

                    // 4 char length identifier and equal to `url(` (case insensitive)
                    if (offset - anchor === 4 && cmpStr(source, anchor, offset, 'url(')) {
                        // special case for url() because it can contain any symbols sequence with few exceptions
                        anchor = findWhiteSpaceEnd(source, offset);
                        code = source.charCodeAt(anchor);
                        if (code !== LEFTPARENTHESIS &&
                            code !== RIGHTPARENTHESIS &&
                            code !== QUOTATIONMARK &&
                            code !== APOSTROPHE) {
                            // url(
                            offsetAndType[tokenCount++] = (URL << TYPE_SHIFT) | offset;
                            balance[tokenCount] = sourceLength;

                            // ws*
                            if (anchor !== offset) {
                                offsetAndType[tokenCount++] = (WHITESPACE << TYPE_SHIFT) | anchor;
                                balance[tokenCount] = sourceLength;
                            }

                            // raw
                            type = RAW;
                            offset = findUrlRawEnd(source, anchor);
                        } else {
                            type = URL;
                        }
                    } else {
                        type = FUNCTION;
                    }
                    break;
                }

                type = code;
                offset = offset + 1;
                break;

            case NUMBER:
                offset = findNumberEnd(source, offset + 1, prevType !== FULLSTOP);

                // merge number with a preceding dot, dash or plus
                if (prevType === FULLSTOP ||
                    prevType === HYPHENMINUS ||
                    prevType === PLUSSIGN) {
                    tokenCount--; // rewrite prev token
                }

                break;

            case STRING:
                offset = findStringEnd(source, offset + 1, code);
                break;

            default:
                anchor = offset;
                offset = findIdentifierEnd(source, offset);

                // merge identifier with a preceding dash
                if (prevType === HYPHENMINUS) {
                    // rewrite prev token
                    tokenCount--;
                    // restore prev prev token type
                    // for case @-prefix-ident
                    prevType = tokenCount === 0 ? 0 : offsetAndType[tokenCount - 1] >> TYPE_SHIFT;
                }

                if (prevType === COMMERCIALAT) {
                    // rewrite prev token and change type to <at-keyword-token>
                    tokenCount--;
                    type = ATRULE;
                }
        }

        offsetAndType[tokenCount++] = (type << TYPE_SHIFT) | offset;
        prevType = type;
    }

    // finalize arrays
    offsetAndType[tokenCount] = offset;
    balance[tokenCount] = sourceLength;
    balance[sourceLength] = sourceLength; // prevents false positive balance match with any token
    while (balanceStart !== 0) {
        balancePrev = balanceStart & OFFSET_MASK;
        balanceStart = balance[balancePrev];
        balance[balancePrev] = sourceLength;
    }

    tokenizer.offsetAndType = offsetAndType;
    tokenizer.tokenCount = tokenCount;
    tokenizer.balance = balance;
}

//
// tokenizer
//

var Tokenizer = function(source, startOffset, startLine, startColumn) {
    this.offsetAndType = null;
    this.balance = null;
    this.lines = null;
    this.columns = null;

    this.setSource(source, startOffset, startLine, startColumn);
};

Tokenizer.prototype = {
    setSource: function(source, startOffset, startLine, startColumn) {
        var safeSource = String(source || '');
        var start = firstCharOffset(safeSource);

        this.source = safeSource;
        this.firstCharOffset = start;
        this.startOffset = typeof startOffset === 'undefined' ? 0 : startOffset;
        this.startLine = typeof startLine === 'undefined' ? 1 : startLine;
        this.startColumn = typeof startColumn === 'undefined' ? 1 : startColumn;
        this.linesAnsColumnsComputed = false;

        this.eof = false;
        this.currentToken = -1;
        this.tokenType = 0;
        this.tokenStart = start;
        this.tokenEnd = start;

        tokenLayout(this, safeSource, start);
        this.next();
    },

    lookupType: function(offset) {
        offset += this.currentToken;

        if (offset < this.tokenCount) {
            return this.offsetAndType[offset] >> TYPE_SHIFT;
        }

        return NULL;
    },
    lookupNonWSType: function(offset) {
        offset += this.currentToken;

        for (var type; offset < this.tokenCount; offset++) {
            type = this.offsetAndType[offset] >> TYPE_SHIFT;

            if (type !== WHITESPACE) {
                return type;
            }
        }

        return NULL;
    },
    lookupValue: function(offset, referenceStr) {
        offset += this.currentToken;

        if (offset < this.tokenCount) {
            return cmpStr(
                this.source,
                this.offsetAndType[offset - 1] & OFFSET_MASK,
                this.offsetAndType[offset] & OFFSET_MASK,
                referenceStr
            );
        }

        return false;
    },
    getTokenStart: function(tokenNum) {
        if (tokenNum === this.currentToken) {
            return this.tokenStart;
        }

        if (tokenNum > 0) {
            return tokenNum < this.tokenCount
                ? this.offsetAndType[tokenNum - 1] & OFFSET_MASK
                : this.offsetAndType[this.tokenCount] & OFFSET_MASK;
        }

        return this.firstCharOffset;
    },
    getOffsetExcludeWS: function() {
        if (this.currentToken > 0) {
            if ((this.offsetAndType[this.currentToken - 1] >> TYPE_SHIFT) === WHITESPACE) {
                return this.currentToken > 1
                    ? this.offsetAndType[this.currentToken - 2] & OFFSET_MASK
                    : this.firstCharOffset;
            }
        }
        return this.tokenStart;
    },
    getRawLength: function(startToken, endTokenType1, endTokenType2, includeTokenType2) {
        var cursor = startToken;
        var balanceEnd;

        loop:
        for (; cursor < this.tokenCount; cursor++) {
            balanceEnd = this.balance[cursor];

            // belance end points to offset before start
            if (balanceEnd < startToken) {
                break loop;
            }

            // check token is stop type
            switch (this.offsetAndType[cursor] >> TYPE_SHIFT) {
                case endTokenType1:
                    break loop;

                case endTokenType2:
                    if (includeTokenType2) {
                        cursor++;
                    }
                    break loop;

                default:
                    // fast forward to the end of balanced block
                    if (this.balance[balanceEnd] === cursor) {
                        cursor = balanceEnd;
                    }
            }

        }

        return cursor - this.currentToken;
    },
    isBalanceEdge: function(pos) {
        var balanceStart = this.balance[this.currentToken];
        return balanceStart < pos;
    },

    getTokenValue: function() {
        return this.source.substring(this.tokenStart, this.tokenEnd);
    },
    substrToCursor: function(start) {
        return this.source.substring(start, this.tokenStart);
    },

    skipWS: function() {
        for (var i = this.currentToken, skipTokenCount = 0; i < this.tokenCount; i++, skipTokenCount++) {
            if ((this.offsetAndType[i] >> TYPE_SHIFT) !== WHITESPACE) {
                break;
            }
        }

        if (skipTokenCount > 0) {
            this.skip(skipTokenCount);
        }
    },
    skipSC: function() {
        while (this.tokenType === WHITESPACE || this.tokenType === COMMENT) {
            this.next();
        }
    },
    skip: function(tokenCount) {
        var next = this.currentToken + tokenCount;

        if (next < this.tokenCount) {
            this.currentToken = next;
            this.tokenStart = this.offsetAndType[next - 1] & OFFSET_MASK;
            next = this.offsetAndType[next];
            this.tokenType = next >> TYPE_SHIFT;
            this.tokenEnd = next & OFFSET_MASK;
        } else {
            this.currentToken = this.tokenCount;
            this.next();
        }
    },
    next: function() {
        var next = this.currentToken + 1;

        if (next < this.tokenCount) {
            this.currentToken = next;
            this.tokenStart = this.tokenEnd;
            next = this.offsetAndType[next];
            this.tokenType = next >> TYPE_SHIFT;
            this.tokenEnd = next & OFFSET_MASK;
        } else {
            this.currentToken = this.tokenCount;
            this.eof = true;
            this.tokenType = NULL;
            this.tokenStart = this.tokenEnd = this.source.length;
        }
    },

    eat: function(tokenType) {
        if (this.tokenType !== tokenType) {
            var offset = this.tokenStart;
            var message = NAME[tokenType] + ' is expected';

            // tweak message and offset
            if (tokenType === IDENTIFIER) {
                // when identifier is expected but there is a function or url
                if (this.tokenType === FUNCTION || this.tokenType === URL) {
                    offset = this.tokenEnd - 1;
                    message += ' but function found';
                }
            } else {
                // when test type is part of another token show error for current position + 1
                // e.g. eat(HYPHENMINUS) will fail on "-foo", but pointing on "-" is odd
                if (this.source.charCodeAt(this.tokenStart) === tokenType) {
                    offset = offset + 1;
                }
            }

            this.error(message, offset);
        }

        this.next();
    },
    eatNonWS: function(tokenType) {
        this.skipWS();
        this.eat(tokenType);
    },

    consume: function(tokenType) {
        var value = this.getTokenValue();

        this.eat(tokenType);

        return value;
    },
    consumeFunctionName: function() {
        var name = this.source.substring(this.tokenStart, this.tokenEnd - 1);

        this.eat(FUNCTION);

        return name;
    },
    consumeNonWS: function(tokenType) {
        this.skipWS();

        return this.consume(tokenType);
    },

    expectIdentifier: function(name) {
        if (this.tokenType !== IDENTIFIER || cmpStr(this.source, this.tokenStart, this.tokenEnd, name) === false) {
            this.error('Identifier `' + name + '` is expected');
        }

        this.next();
    },

    getLocation: function(offset, filename) {
        if (!this.linesAnsColumnsComputed) {
            computeLinesAndColumns(this, this.source);
        }

        return {
            source: filename,
            offset: this.startOffset + offset,
            line: this.lines[offset],
            column: this.columns[offset]
        };
    },

    getLocationRange: function(start, end, filename) {
        if (!this.linesAnsColumnsComputed) {
            computeLinesAndColumns(this, this.source);
        }

        return {
            source: filename,
            start: {
                offset: this.startOffset + start,
                line: this.lines[start],
                column: this.columns[start]
            },
            end: {
                offset: this.startOffset + end,
                line: this.lines[end],
                column: this.columns[end]
            }
        };
    },

    error: function(message, offset) {
        var location = typeof offset !== 'undefined' && offset < this.source.length
            ? this.getLocation(offset)
            : this.eof
                ? this.getLocation(findWhiteSpaceStart(this.source, this.source.length - 1))
                : this.getLocation(this.tokenStart);

        throw new CssSyntaxError(
            message || 'Unexpected input',
            this.source,
            location.offset,
            location.line,
            location.column
        );
    },

    dump: function() {
        var offset = 0;

        return Array.prototype.slice.call(this.offsetAndType, 0, this.tokenCount).map(function(item, idx) {
            var start = offset;
            var end = item & OFFSET_MASK;

            offset = end;

            return {
                idx: idx,
                type: NAME[item >> TYPE_SHIFT],
                chunk: this.source.substring(start, end),
                balance: this.balance[idx]
            };
        }, this);
    }
};

// extend with error class
Tokenizer.CssSyntaxError = CssSyntaxError;

// extend tokenizer with constants
Object.keys(constants).forEach(function(key) {
    Tokenizer[key] = constants[key];
});

// extend tokenizer with static methods from utils
Object.keys(utils).forEach(function(key) {
    Tokenizer[key] = utils[key];
});

// warm up tokenizer to elimitate code branches that never execute
// fix soft deoptimizations (insufficient type feedback)
new Tokenizer('\n\r\r\n\f<!---->//""\'\'/*\r\n\f*/1a;.\\31\t\+2{url(a);func();+1.2e3 -.4e-5 .6e+7}').getLocation();

module.exports = Tokenizer;

},{"./const":655,"./error":656,"./utils":658}],655:[function(require,module,exports){
'use strict';

// token types (note: value shouldn't intersect with used char codes)
var WHITESPACE = 1;
var IDENTIFIER = 2;
var NUMBER = 3;
var STRING = 4;
var COMMENT = 5;
var PUNCTUATOR = 6;
var CDO = 7;
var CDC = 8;
var ATRULE = 14;
var FUNCTION = 15;
var URL = 16;
var RAW = 17;

var TAB = 9;
var N = 10;
var F = 12;
var R = 13;
var SPACE = 32;

var TYPE = {
    WhiteSpace:   WHITESPACE,
    Identifier:   IDENTIFIER,
    Number:           NUMBER,
    String:           STRING,
    Comment:         COMMENT,
    Punctuator:   PUNCTUATOR,
    CDO:                 CDO,
    CDC:                 CDC,
    Atrule:           ATRULE,
    Function:       FUNCTION,
    Url:                 URL,
    Raw:                 RAW,

    ExclamationMark:      33,  // !
    QuotationMark:        34,  // "
    NumberSign:           35,  // #
    DollarSign:           36,  // $
    PercentSign:          37,  // %
    Ampersand:            38,  // &
    Apostrophe:           39,  // '
    LeftParenthesis:      40,  // (
    RightParenthesis:     41,  // )
    Asterisk:             42,  // *
    PlusSign:             43,  // +
    Comma:                44,  // ,
    HyphenMinus:          45,  // -
    FullStop:             46,  // .
    Solidus:              47,  // /
    Colon:                58,  // :
    Semicolon:            59,  // ;
    LessThanSign:         60,  // <
    EqualsSign:           61,  // =
    GreaterThanSign:      62,  // >
    QuestionMark:         63,  // ?
    CommercialAt:         64,  // @
    LeftSquareBracket:    91,  // [
    Backslash:            92,  // \
    RightSquareBracket:   93,  // ]
    CircumflexAccent:     94,  // ^
    LowLine:              95,  // _
    GraveAccent:          96,  // `
    LeftCurlyBracket:    123,  // {
    VerticalLine:        124,  // |
    RightCurlyBracket:   125,  // }
    Tilde:               126   // ~
};

var NAME = Object.keys(TYPE).reduce(function(result, key) {
    result[TYPE[key]] = key;
    return result;
}, {});

// https://drafts.csswg.org/css-syntax/#tokenizer-definitions
// > non-ASCII code point
// >   A code point with a value equal to or greater than U+0080 <control>
// > name-start code point
// >   A letter, a non-ASCII code point, or U+005F LOW LINE (_).
// > name code point
// >   A name-start code point, a digit, or U+002D HYPHEN-MINUS (-)
// That means only ASCII code points has a special meaning and we a maps for 0..127 codes only
var SafeUint32Array = typeof Uint32Array !== 'undefined' ? Uint32Array : Array; // fallback on Array when TypedArray is not supported
var SYMBOL_TYPE = new SafeUint32Array(0x80);
var PUNCTUATION = new SafeUint32Array(0x80);
var STOP_URL_RAW = new SafeUint32Array(0x80);

for (var i = 0; i < SYMBOL_TYPE.length; i++) {
    SYMBOL_TYPE[i] = IDENTIFIER;
}

// fill categories
[
    TYPE.ExclamationMark,    // !
    TYPE.QuotationMark,      // "
    TYPE.NumberSign,         // #
    TYPE.DollarSign,         // $
    TYPE.PercentSign,        // %
    TYPE.Ampersand,          // &
    TYPE.Apostrophe,         // '
    TYPE.LeftParenthesis,    // (
    TYPE.RightParenthesis,   // )
    TYPE.Asterisk,           // *
    TYPE.PlusSign,           // +
    TYPE.Comma,              // ,
    TYPE.HyphenMinus,        // -
    TYPE.FullStop,           // .
    TYPE.Solidus,            // /
    TYPE.Colon,              // :
    TYPE.Semicolon,          // ;
    TYPE.LessThanSign,       // <
    TYPE.EqualsSign,         // =
    TYPE.GreaterThanSign,    // >
    TYPE.QuestionMark,       // ?
    TYPE.CommercialAt,       // @
    TYPE.LeftSquareBracket,  // [
    // TYPE.Backslash,          // \
    TYPE.RightSquareBracket, // ]
    TYPE.CircumflexAccent,   // ^
    // TYPE.LowLine,            // _
    TYPE.GraveAccent,        // `
    TYPE.LeftCurlyBracket,   // {
    TYPE.VerticalLine,       // |
    TYPE.RightCurlyBracket,  // }
    TYPE.Tilde               // ~
].forEach(function(key) {
    SYMBOL_TYPE[Number(key)] = PUNCTUATOR;
    PUNCTUATION[Number(key)] = PUNCTUATOR;
});

for (var i = 48; i <= 57; i++) {
    SYMBOL_TYPE[i] = NUMBER;
}

SYMBOL_TYPE[SPACE] = WHITESPACE;
SYMBOL_TYPE[TAB] = WHITESPACE;
SYMBOL_TYPE[N] = WHITESPACE;
SYMBOL_TYPE[R] = WHITESPACE;
SYMBOL_TYPE[F] = WHITESPACE;

SYMBOL_TYPE[TYPE.Apostrophe] = STRING;
SYMBOL_TYPE[TYPE.QuotationMark] = STRING;

STOP_URL_RAW[SPACE] = 1;
STOP_URL_RAW[TAB] = 1;
STOP_URL_RAW[N] = 1;
STOP_URL_RAW[R] = 1;
STOP_URL_RAW[F] = 1;
STOP_URL_RAW[TYPE.Apostrophe] = 1;
STOP_URL_RAW[TYPE.QuotationMark] = 1;
STOP_URL_RAW[TYPE.LeftParenthesis] = 1;
STOP_URL_RAW[TYPE.RightParenthesis] = 1;

// whitespace is punctuation ...
PUNCTUATION[SPACE] = PUNCTUATOR;
PUNCTUATION[TAB] = PUNCTUATOR;
PUNCTUATION[N] = PUNCTUATOR;
PUNCTUATION[R] = PUNCTUATOR;
PUNCTUATION[F] = PUNCTUATOR;
// ... hyper minus is not
PUNCTUATION[TYPE.HyphenMinus] = 0;

module.exports = {
    TYPE: TYPE,
    NAME: NAME,

    SYMBOL_TYPE: SYMBOL_TYPE,
    PUNCTUATION: PUNCTUATION,
    STOP_URL_RAW: STOP_URL_RAW
};

},{}],656:[function(require,module,exports){
'use strict';

var createCustomError = require('../utils/createCustomError');
var MAX_LINE_LENGTH = 100;
var OFFSET_CORRECTION = 60;
var TAB_REPLACEMENT = '    ';

function sourceFragment(error, extraLines) {
    function processLines(start, end) {
        return lines.slice(start, end).map(function(line, idx) {
            var num = String(start + idx + 1);

            while (num.length < maxNumLength) {
                num = ' ' + num;
            }

            return num + ' |' + line;
        }).join('\n');
    }

    var lines = error.source.split(/\r\n?|\n|\f/);
    var line = error.line;
    var column = error.column;
    var startLine = Math.max(1, line - extraLines) - 1;
    var endLine = Math.min(line + extraLines, lines.length + 1);
    var maxNumLength = Math.max(4, String(endLine).length) + 1;
    var cutLeft = 0;

    // column correction according to replaced tab before column
    column += (TAB_REPLACEMENT.length - 1) * (lines[line - 1].substr(0, column - 1).match(/\t/g) || []).length;

    if (column > MAX_LINE_LENGTH) {
        cutLeft = column - OFFSET_CORRECTION + 3;
        column = OFFSET_CORRECTION - 2;
    }

    for (var i = startLine; i <= endLine; i++) {
        if (i >= 0 && i < lines.length) {
            lines[i] = lines[i].replace(/\t/g, TAB_REPLACEMENT);
            lines[i] =
                (cutLeft > 0 && lines[i].length > cutLeft ? '\u2026' : '') +
                lines[i].substr(cutLeft, MAX_LINE_LENGTH - 2) +
                (lines[i].length > cutLeft + MAX_LINE_LENGTH - 1 ? '\u2026' : '');
        }
    }

    return [
        processLines(startLine, line),
        new Array(column + maxNumLength + 2).join('-') + '^',
        processLines(line, endLine)
    ].filter(Boolean).join('\n');
}

var CssSyntaxError = function(message, source, offset, line, column) {
    var error = createCustomError('CssSyntaxError', message);

    error.source = source;
    error.offset = offset;
    error.line = line;
    error.column = column;

    error.sourceFragment = function(extraLines) {
        return sourceFragment(error, isNaN(extraLines) ? 0 : extraLines);
    };
    Object.defineProperty(error, 'formattedMessage', {
        get: function() {
            return (
                'Parse error: ' + error.message + '\n' +
                sourceFragment(error, 2)
            );
        }
    });

    // for backward capability
    error.parseError = {
        offset: offset,
        line: line,
        column: column
    };

    return error;
};

module.exports = CssSyntaxError;

},{"../utils/createCustomError":660}],657:[function(require,module,exports){
module.exports = require('./Tokenizer');

},{"./Tokenizer":654}],658:[function(require,module,exports){
'use strict';

var constants = require('./const');
var PUNCTUATION = constants.PUNCTUATION;
var STOP_URL_RAW = constants.STOP_URL_RAW;
var TYPE = constants.TYPE;
var FULLSTOP = TYPE.FullStop;
var PLUSSIGN = TYPE.PlusSign;
var HYPHENMINUS = TYPE.HyphenMinus;
var PUNCTUATOR = TYPE.Punctuator;
var TAB = 9;
var N = 10;
var F = 12;
var R = 13;
var SPACE = 32;
var BACK_SLASH = 92;
var E = 101; // 'e'.charCodeAt(0)

function firstCharOffset(source) {
    // detect BOM (https://en.wikipedia.org/wiki/Byte_order_mark)
    if (source.charCodeAt(0) === 0xFEFF ||  // UTF-16BE
        source.charCodeAt(0) === 0xFFFE) {  // UTF-16LE
        return 1;
    }

    return 0;
}

function isHex(code) {
    return (code >= 48 && code <= 57) || // 0 .. 9
           (code >= 65 && code <= 70) || // A .. F
           (code >= 97 && code <= 102);  // a .. f
}

function isNumber(code) {
    return code >= 48 && code <= 57;
}

function isWhiteSpace(code) {
    return code === SPACE || code === TAB || isNewline(code);
}

function isNewline(code) {
    return code === R || code === N || code === F;
}

function getNewlineLength(source, offset, code) {
    if (isNewline(code)) {
        if (code === R && offset + 1 < source.length && source.charCodeAt(offset + 1) === N) {
            return 2;
        }

        return 1;
    }

    return 0;
}

function cmpChar(testStr, offset, referenceCode) {
    var code = testStr.charCodeAt(offset);

    // code.toLowerCase() for A..Z
    if (code >= 65 && code <= 90) {
        code = code | 32;
    }

    return code === referenceCode;
}

function cmpStr(testStr, start, end, referenceStr) {
    if (end - start !== referenceStr.length) {
        return false;
    }

    if (start < 0 || end > testStr.length) {
        return false;
    }

    for (var i = start; i < end; i++) {
        var testCode = testStr.charCodeAt(i);
        var refCode = referenceStr.charCodeAt(i - start);

        // testCode.toLowerCase() for A..Z
        if (testCode >= 65 && testCode <= 90) {
            testCode = testCode | 32;
        }

        if (testCode !== refCode) {
            return false;
        }
    }

    return true;
}

function findWhiteSpaceStart(source, offset) {
    while (offset >= 0 && isWhiteSpace(source.charCodeAt(offset))) {
        offset--;
    }

    return offset + 1;
}

function findWhiteSpaceEnd(source, offset) {
    while (offset < source.length && isWhiteSpace(source.charCodeAt(offset))) {
        offset++;
    }

    return offset;
}

function findCommentEnd(source, offset) {
    var commentEnd = source.indexOf('*/', offset);

    if (commentEnd === -1) {
        return source.length;
    }

    return commentEnd + 2;
}

function findStringEnd(source, offset, quote) {
    for (; offset < source.length; offset++) {
        var code = source.charCodeAt(offset);

        // TODO: bad string
        if (code === BACK_SLASH) {
            offset++;
        } else if (code === quote) {
            offset++;
            break;
        }
    }

    return offset;
}

function findDecimalNumberEnd(source, offset) {
    while (offset < source.length && isNumber(source.charCodeAt(offset))) {
        offset++;
    }

    return offset;
}

function findNumberEnd(source, offset, allowFraction) {
    var code;

    offset = findDecimalNumberEnd(source, offset);

    // fraction: .\d+
    if (allowFraction && offset + 1 < source.length && source.charCodeAt(offset) === FULLSTOP) {
        code = source.charCodeAt(offset + 1);

        if (isNumber(code)) {
            offset = findDecimalNumberEnd(source, offset + 1);
        }
    }

    // exponent: e[+-]\d+
    if (offset + 1 < source.length) {
        if ((source.charCodeAt(offset) | 32) === E) { // case insensitive check for `e`
            code = source.charCodeAt(offset + 1);

            if (code === PLUSSIGN || code === HYPHENMINUS) {
                if (offset + 2 < source.length) {
                    code = source.charCodeAt(offset + 2);
                }
            }

            if (isNumber(code)) {
                offset = findDecimalNumberEnd(source, offset + 2);
            }
        }
    }

    return offset;
}

// skip escaped unicode sequence that can ends with space
// [0-9a-f]{1,6}(\r\n|[ \n\r\t\f])?
function findEscapeEnd(source, offset) {
    for (var i = 0; i < 7 && offset + i < source.length; i++) {
        var code = source.charCodeAt(offset + i);

        if (i !== 6 && isHex(code)) {
            continue;
        }

        if (i > 0) {
            offset += i - 1 + getNewlineLength(source, offset + i, code);
            if (code === SPACE || code === TAB) {
                offset++;
            }
        }

        break;
    }

    return offset;
}

function findIdentifierEnd(source, offset) {
    for (; offset < source.length; offset++) {
        var code = source.charCodeAt(offset);

        if (code === BACK_SLASH) {
            offset = findEscapeEnd(source, offset + 1);
        } else if (code < 0x80 && PUNCTUATION[code] === PUNCTUATOR) {
            break;
        }
    }

    return offset;
}

function findUrlRawEnd(source, offset) {
    for (; offset < source.length; offset++) {
        var code = source.charCodeAt(offset);

        if (code === BACK_SLASH) {
            offset = findEscapeEnd(source, offset + 1);
        } else if (code < 0x80 && STOP_URL_RAW[code] === 1) {
            break;
        }
    }

    return offset;
}

module.exports = {
    firstCharOffset: firstCharOffset,

    isHex: isHex,
    isNumber: isNumber,
    isWhiteSpace: isWhiteSpace,
    isNewline: isNewline,
    getNewlineLength: getNewlineLength,

    cmpChar: cmpChar,
    cmpStr: cmpStr,

    findWhiteSpaceStart: findWhiteSpaceStart,
    findWhiteSpaceEnd: findWhiteSpaceEnd,
    findCommentEnd: findCommentEnd,
    findStringEnd: findStringEnd,
    findDecimalNumberEnd: findDecimalNumberEnd,
    findNumberEnd: findNumberEnd,
    findEscapeEnd: findEscapeEnd,
    findIdentifierEnd: findIdentifierEnd,
    findUrlRawEnd: findUrlRawEnd
};

},{"./const":655}],659:[function(require,module,exports){
'use strict';

var List = require('./list');

module.exports = function clone(node) {
    var result = {};

    for (var key in node) {
        var value = node[key];

        if (value) {
            if (Array.isArray(value) || value instanceof List) {
                value = value.map(clone);
            } else if (value.constructor === Object) {
                value = clone(value);
            }
        }

        result[key] = value;
    }

    return result;
};

},{"./list":661}],660:[function(require,module,exports){
module.exports = function createCustomError(name, message) {
    // use Object.create(), because some VMs prevent setting line/column otherwise
    // (iOS Safari 10 even throws an exception)
    var error = Object.create(SyntaxError.prototype);
    var errorStack = new Error();

    error.name = name;
    error.message = message;

    Object.defineProperty(error, 'stack', {
        get: function() {
            return (errorStack.stack || '').replace(/^(.+\n){1,3}/, name + ': ' + message + '\n');
        }
    });

    return error;
};

},{}],661:[function(require,module,exports){
'use strict';

//
//            item        item        item        item
//          /------\    /------\    /------\    /------\
//          | data |    | data |    | data |    | data |
//  null <--+-prev |<---+-prev |<---+-prev |<---+-prev |
//          | next-+--->| next-+--->| next-+--->| next-+--> null
//          \------/    \------/    \------/    \------/
//             ^                                    ^
//             |                list                |
//             |              /------\              |
//             \--------------+-head |              |
//                            | tail-+--------------/
//                            \------/
//

function createItem(data) {
    return {
        prev: null,
        next: null,
        data: data
    };
}

function allocateCursor(node, prev, next) {
    var cursor;

    if (cursors !== null) {
        cursor = cursors;
        cursors = cursors.cursor;
        cursor.prev = prev;
        cursor.next = next;
        cursor.cursor = node.cursor;
    } else {
        cursor = {
            prev: prev,
            next: next,
            cursor: node.cursor
        };
    }

    node.cursor = cursor;

    return cursor;
}

function releaseCursor(node) {
    var cursor = node.cursor;

    node.cursor = cursor.cursor;
    cursor.prev = null;
    cursor.next = null;
    cursor.cursor = cursors;
    cursors = cursor;
}

var cursors = null;
var List = function() {
    this.cursor = null;
    this.head = null;
    this.tail = null;
};

List.createItem = createItem;
List.prototype.createItem = createItem;

List.prototype.updateCursors = function(prevOld, prevNew, nextOld, nextNew) {
    var cursor = this.cursor;

    while (cursor !== null) {
        if (cursor.prev === prevOld) {
            cursor.prev = prevNew;
        }

        if (cursor.next === nextOld) {
            cursor.next = nextNew;
        }

        cursor = cursor.cursor;
    }
};

List.prototype.getSize = function() {
    var size = 0;
    var cursor = this.head;

    while (cursor) {
        size++;
        cursor = cursor.next;
    }

    return size;
};

List.prototype.fromArray = function(array) {
    var cursor = null;

    this.head = null;

    for (var i = 0; i < array.length; i++) {
        var item = createItem(array[i]);

        if (cursor !== null) {
            cursor.next = item;
        } else {
            this.head = item;
        }

        item.prev = cursor;
        cursor = item;
    }

    this.tail = cursor;

    return this;
};

List.prototype.toArray = function() {
    var cursor = this.head;
    var result = [];

    while (cursor) {
        result.push(cursor.data);
        cursor = cursor.next;
    }

    return result;
};

List.prototype.toJSON = List.prototype.toArray;

List.prototype.isEmpty = function() {
    return this.head === null;
};

List.prototype.first = function() {
    return this.head && this.head.data;
};

List.prototype.last = function() {
    return this.tail && this.tail.data;
};

List.prototype.each = function(fn, context) {
    var item;

    if (context === undefined) {
        context = this;
    }

    // push cursor
    var cursor = allocateCursor(this, null, this.head);

    while (cursor.next !== null) {
        item = cursor.next;
        cursor.next = item.next;

        fn.call(context, item.data, item, this);
    }

    // pop cursor
    releaseCursor(this);
};

List.prototype.forEach = List.prototype.each;

List.prototype.eachRight = function(fn, context) {
    var item;

    if (context === undefined) {
        context = this;
    }

    // push cursor
    var cursor = allocateCursor(this, this.tail, null);

    while (cursor.prev !== null) {
        item = cursor.prev;
        cursor.prev = item.prev;

        fn.call(context, item.data, item, this);
    }

    // pop cursor
    releaseCursor(this);
};

List.prototype.forEachRight = List.prototype.eachRight;

List.prototype.nextUntil = function(start, fn, context) {
    if (start === null) {
        return;
    }

    var item;

    if (context === undefined) {
        context = this;
    }

    // push cursor
    var cursor = allocateCursor(this, null, start);

    while (cursor.next !== null) {
        item = cursor.next;
        cursor.next = item.next;

        if (fn.call(context, item.data, item, this)) {
            break;
        }
    }

    // pop cursor
    releaseCursor(this);
};

List.prototype.prevUntil = function(start, fn, context) {
    if (start === null) {
        return;
    }

    var item;

    if (context === undefined) {
        context = this;
    }

    // push cursor
    var cursor = allocateCursor(this, start, null);

    while (cursor.prev !== null) {
        item = cursor.prev;
        cursor.prev = item.prev;

        if (fn.call(context, item.data, item, this)) {
            break;
        }
    }

    // pop cursor
    releaseCursor(this);
};

List.prototype.some = function(fn, context) {
    var cursor = this.head;

    if (context === undefined) {
        context = this;
    }

    while (cursor !== null) {
        if (fn.call(context, cursor.data, cursor, this)) {
            return true;
        }

        cursor = cursor.next;
    }

    return false;
};

List.prototype.map = function(fn, context) {
    var result = new List();
    var cursor = this.head;

    if (context === undefined) {
        context = this;
    }

    while (cursor !== null) {
        result.appendData(fn.call(context, cursor.data, cursor, this));
        cursor = cursor.next;
    }

    return result;
};

List.prototype.filter = function(fn, context) {
    var result = new List();
    var cursor = this.head;

    if (context === undefined) {
        context = this;
    }

    while (cursor !== null) {
        if (fn.call(context, cursor.data, cursor, this)) {
            result.appendData(cursor.data);
        }
        cursor = cursor.next;
    }

    return result;
};

List.prototype.clear = function() {
    this.head = null;
    this.tail = null;
};

List.prototype.copy = function() {
    var result = new List();
    var cursor = this.head;

    while (cursor !== null) {
        result.insert(createItem(cursor.data));
        cursor = cursor.next;
    }

    return result;
};

List.prototype.prepend = function(item) {
    //      head
    //    ^
    // item
    this.updateCursors(null, item, this.head, item);

    // insert to the beginning of the list
    if (this.head !== null) {
        // new item <- first item
        this.head.prev = item;

        // new item -> first item
        item.next = this.head;
    } else {
        // if list has no head, then it also has no tail
        // in this case tail points to the new item
        this.tail = item;
    }

    // head always points to new item
    this.head = item;

    return this;
};

List.prototype.prependData = function(data) {
    return this.prepend(createItem(data));
};

List.prototype.append = function(item) {
    return this.insert(item);
};

List.prototype.appendData = function(data) {
    return this.insert(createItem(data));
};

List.prototype.insert = function(item, before) {
    if (before !== undefined && before !== null) {
        // prev   before
        //      ^
        //     item
        this.updateCursors(before.prev, item, before, item);

        if (before.prev === null) {
            // insert to the beginning of list
            if (this.head !== before) {
                throw new Error('before doesn\'t belong to list');
            }

            // since head points to before therefore list doesn't empty
            // no need to check tail
            this.head = item;
            before.prev = item;
            item.next = before;

            this.updateCursors(null, item);
        } else {

            // insert between two items
            before.prev.next = item;
            item.prev = before.prev;

            before.prev = item;
            item.next = before;
        }
    } else {
        // tail
        //      ^
        //      item
        this.updateCursors(this.tail, item, null, item);

        // insert to the ending of the list
        if (this.tail !== null) {
            // last item -> new item
            this.tail.next = item;

            // last item <- new item
            item.prev = this.tail;
        } else {
            // if list has no tail, then it also has no head
            // in this case head points to new item
            this.head = item;
        }

        // tail always points to new item
        this.tail = item;
    }

    return this;
};

List.prototype.insertData = function(data, before) {
    return this.insert(createItem(data), before);
};

List.prototype.remove = function(item) {
    //      item
    //       ^
    // prev     next
    this.updateCursors(item, item.prev, item, item.next);

    if (item.prev !== null) {
        item.prev.next = item.next;
    } else {
        if (this.head !== item) {
            throw new Error('item doesn\'t belong to list');
        }

        this.head = item.next;
    }

    if (item.next !== null) {
        item.next.prev = item.prev;
    } else {
        if (this.tail !== item) {
            throw new Error('item doesn\'t belong to list');
        }

        this.tail = item.prev;
    }

    item.prev = null;
    item.next = null;

    return item;
};

List.prototype.push = function(data) {
    this.insert(createItem(data));
};

List.prototype.pop = function() {
    if (this.tail !== null) {
        return this.remove(this.tail);
    }
};

List.prototype.unshift = function(data) {
    this.prepend(createItem(data));
};

List.prototype.shift = function() {
    if (this.head !== null) {
        return this.remove(this.head);
    }
};

List.prototype.prependList = function(list) {
    return this.insertList(list, this.head);
};

List.prototype.appendList = function(list) {
    return this.insertList(list);
};

List.prototype.insertList = function(list, before) {
    // ignore empty lists
    if (list.head === null) {
        return this;
    }

    if (before !== undefined && before !== null) {
        this.updateCursors(before.prev, list.tail, before, list.head);

        // insert in the middle of dist list
        if (before.prev !== null) {
            // before.prev <-> list.head
            before.prev.next = list.head;
            list.head.prev = before.prev;
        } else {
            this.head = list.head;
        }

        before.prev = list.tail;
        list.tail.next = before;
    } else {
        this.updateCursors(this.tail, list.tail, null, list.head);

        // insert to end of the list
        if (this.tail !== null) {
            // if destination list has a tail, then it also has a head,
            // but head doesn't change

            // dest tail -> source head
            this.tail.next = list.head;

            // dest tail <- source head
            list.head.prev = this.tail;
        } else {
            // if list has no a tail, then it also has no a head
            // in this case points head to new item
            this.head = list.head;
        }

        // tail always start point to new item
        this.tail = list.tail;
    }

    list.head = null;
    list.tail = null;

    return this;
};

List.prototype.replace = function(oldItem, newItemOrList) {
    if ('head' in newItemOrList) {
        this.insertList(newItemOrList, oldItem);
    } else {
        this.insert(newItemOrList, oldItem);
    }

    this.remove(oldItem);
};

module.exports = List;

},{}],662:[function(require,module,exports){
'use strict';

var hasOwnProperty = Object.prototype.hasOwnProperty;
var keywords = Object.create(null);
var properties = Object.create(null);
var HYPHENMINUS = 45; // '-'.charCodeAt()

function isCustomProperty(str, offset) {
    offset = offset || 0;

    return str.length - offset >= 2 &&
           str.charCodeAt(offset) === HYPHENMINUS &&
           str.charCodeAt(offset + 1) === HYPHENMINUS;
}

function getVendorPrefix(str, offset) {
    offset = offset || 0;

    // verdor prefix should be at least 3 chars length
    if (str.length - offset >= 3) {
        // vendor prefix starts with hyper minus following non-hyper minus
        if (str.charCodeAt(offset) === HYPHENMINUS &&
            str.charCodeAt(offset + 1) !== HYPHENMINUS) {
            // vendor prefix should contain a hyper minus at the ending
            var secondDashIndex = str.indexOf('-', offset + 2);

            if (secondDashIndex !== -1) {
                return str.substring(offset, secondDashIndex + 1);
            }
        }
    }

    return '';
}

function getKeywordDescriptor(keyword) {
    if (hasOwnProperty.call(keywords, keyword)) {
        return keywords[keyword];
    }

    var name = keyword.toLowerCase();

    if (hasOwnProperty.call(keywords, name)) {
        return keywords[keyword] = keywords[name];
    }

    var custom = isCustomProperty(name, 0);
    var vendor = !custom ? getVendorPrefix(name, 0) : '';

    return keywords[keyword] = Object.freeze({
        basename: name.substr(vendor.length),
        name: name,
        vendor: vendor,
        prefix: vendor,
        custom: custom
    });
}

function getPropertyDescriptor(property) {
    if (hasOwnProperty.call(properties, property)) {
        return properties[property];
    }

    var name = property;
    var hack = property[0];

    if (hack === '/') {
        hack = property[1] === '/' ? '//' : '/';
    } else if (hack !== '_' &&
               hack !== '*' &&
               hack !== '$' &&
               hack !== '#' &&
               hack !== '+') {
        hack = '';
    }

    var custom = isCustomProperty(name, hack.length);

    // re-use result when possible (the same as for lower case)
    if (!custom) {
        name = name.toLowerCase();
        if (hasOwnProperty.call(properties, name)) {
            return properties[property] = properties[name];
        }
    }

    var vendor = !custom ? getVendorPrefix(name, hack.length) : '';
    var prefix = name.substr(0, hack.length + vendor.length);

    return properties[property] = Object.freeze({
        basename: name.substr(prefix.length),
        name: name.substr(hack.length),
        hack: hack,
        vendor: vendor,
        prefix: prefix,
        custom: custom
    });
}

module.exports = {
    keyword: getKeywordDescriptor,
    property: getPropertyDescriptor,
    isCustomProperty: isCustomProperty,
    vendorPrefix: getVendorPrefix
};

},{}],663:[function(require,module,exports){
'use strict';

var hasOwnProperty = Object.prototype.hasOwnProperty;
var noop = function() {};

function ensureFunction(value) {
    return typeof value === 'function' ? value : noop;
}

function invokeForType(fn, type) {
    return function(node, item, list) {
        if (node.type === type) {
            fn.call(this, node, item, list);
        }
    };
}

function getWalkersFromStructure(name, nodeType) {
    var structure = nodeType.structure;
    var walkers = [];

    for (var key in structure) {
        if (hasOwnProperty.call(structure, key) === false) {
            continue;
        }

        var fieldTypes = structure[key];
        var walker = {
            name: key,
            type: false,
            nullable: false
        };

        if (!Array.isArray(structure[key])) {
            fieldTypes = [structure[key]];
        }

        for (var i = 0; i < fieldTypes.length; i++) {
            var fieldType = fieldTypes[i];
            if (fieldType === null) {
                walker.nullable = true;
            } else if (typeof fieldType === 'string') {
                walker.type = 'node';
            } else if (Array.isArray(fieldType)) {
                walker.type = 'list';
            }
        }

        if (walker.type) {
            walkers.push(walker);
        }
    }

    if (walkers.length) {
        return {
            context: nodeType.walkContext,
            fields: walkers
        };
    }

    return null;
}

function getTypesFromConfig(config) {
    var types = {};

    for (var name in config.node) {
        if (hasOwnProperty.call(config.node, name)) {
            var nodeType = config.node[name];

            if (!nodeType.structure) {
                throw new Error('Missed `structure` field in `' + name + '` node type definition');
            }

            types[name] = getWalkersFromStructure(name, nodeType);
        }
    }

    return types;
}

function createTypeIterator(config, reverse) {
    var fields = reverse ? config.fields.slice().reverse() : config.fields;
    var body = fields.map(function(field) {
        var ref = 'node.' + field.name;
        var line;

        if (field.type === 'list') {
            line = reverse
                ? ref + '.forEachRight(walk);'
                : ref + '.forEach(walk);';
        } else {
            line = 'walk(' + ref + ');';
        }

        if (field.nullable) {
            line = 'if (' + ref + ') {\n    ' + line + '}';
        }

        return line;
    });

    if (config.context) {
        body = [].concat(
            'var old = context.' + config.context + ';',
            'context.' + config.context + ' = node;',
            body,
            'context.' + config.context + ' = old;'
        );
    }

    return new Function('node', 'context', 'walk', body.join('\n'));
}

function createFastTraveralMap(iterators) {
    return {
        Atrule: {
            StyleSheet: iterators.StyleSheet,
            Atrule: iterators.Atrule,
            Rule: iterators.Rule,
            Block: iterators.Block
        },
        Rule: {
            StyleSheet: iterators.StyleSheet,
            Atrule: iterators.Atrule,
            Rule: iterators.Rule,
            Block: iterators.Block
        },
        Declaration: {
            StyleSheet: iterators.StyleSheet,
            Atrule: iterators.Atrule,
            Rule: iterators.Rule,
            Block: iterators.Block
        }
    };
}

module.exports = function createWalker(config) {
    var types = getTypesFromConfig(config);
    var iteratorsNatural = {};
    var iteratorsReverse = {};

    for (var name in types) {
        if (hasOwnProperty.call(types, name) && types[name] !== null) {
            iteratorsNatural[name] = createTypeIterator(types[name], false);
            iteratorsReverse[name] = createTypeIterator(types[name], true);
        }
    }

    var fastTraversalIteratorsNatural = createFastTraveralMap(iteratorsNatural);
    var fastTraversalIteratorsReverse = createFastTraveralMap(iteratorsReverse);

    return function walk(root, options) {
        function walkNode(node, item, list) {
            enter.call(context, node, item, list);

            if (iterators.hasOwnProperty(node.type)) {
                iterators[node.type](node, context, walkNode);
            }

            leave.call(context, node, item, list);
        }

        var enter = noop;
        var leave = noop;
        var iterators = iteratorsNatural;
        var context = {
            root: root,
            stylesheet: null,
            atrule: null,
            atrulePrelude: null,
            rule: null,
            selector: null,
            block: null,
            declaration: null,
            function: null
        };

        if (typeof options === 'function') {
            enter = options;
        } else if (options) {
            enter = ensureFunction(options.enter);
            leave = ensureFunction(options.leave);

            if (options.reverse) {
                iterators = iteratorsReverse;
            }

            if (options.visit) {
                if (fastTraversalIteratorsNatural.hasOwnProperty(options.visit)) {
                    iterators = options.reverse
                        ? fastTraversalIteratorsReverse[options.visit]
                        : fastTraversalIteratorsNatural[options.visit];
                } else if (!types.hasOwnProperty(options.visit)) {
                    throw new Error('Bad value `' + options.visit + '` for `visit` option (should be: ' + Object.keys(types).join(', ') + ')');
                }

                enter = invokeForType(enter, options.visit);
                leave = invokeForType(leave, options.visit);
            }
        }

        if (enter === noop && leave === noop) {
            throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
        }

        // swap handlers in reverse mode to invert visit order
        if (options.reverse) {
            var tmp = enter;
            enter = leave;
            leave = tmp;
        }

        walkNode(root);
    };
};

},{}],664:[function(require,module,exports){
var conversions = {
    // length
    'px': {
        'px': 1,
        'cm': 96.0/2.54,
        'mm': 96.0/25.4,
        'in': 96,
        'pt': 96.0/72.0,
        'pc': 16
    },
    'cm': {
        'px': 2.54/96.0,
        'cm': 1,
        'mm': 0.1,
        'in': 2.54,
        'pt': 2.54/72.0,
        'pc': 2.54/6.0
    },
    'mm': {
        'px': 25.4/96.0,
        'cm': 10,
        'mm': 1,
        'in': 25.4,
        'pt': 25.4/72.0,
        'pc': 25.4/6.0
    },
    'in': {
        'px': 1.0/96.0,
        'cm': 1.0/2.54,
        'mm': 1.0/25.4,
        'in': 1,
        'pt': 1.0/72.0,
        'pc': 1.0/6.0
    },
    'pt': {
        'px': 0.75,
        'cm': 72.0/2.54,
        'mm': 72.0/25.4,
        'in': 72,
        'pt': 1,
        'pc': 12
    },
    'pc': {
        'px': 6.0/96.0,
        'cm': 6.0/2.54,
        'mm': 6.0/25.4,
        'in': 6,
        'pt': 6.0/72.0,
        'pc': 1
    },
    // angle
    'deg': {
        'deg': 1,
        'grad': 0.9,
        'rad': 180/Math.PI,
        'turn': 360
    },
    'grad': {
        'deg': 400/360,
        'grad': 1,
        'rad': 200/Math.PI,
        'turn': 400
    },
    'rad': {
        'deg': Math.PI/180,
        'grad': Math.PI/200,
        'rad': 1,
        'turn': Math.PI*2
    },
    'turn': {
        'deg': 1/360,
        'grad': 1/400,
        'rad': 0.5/Math.PI,
        'turn': 1
    },
    // time
    's': {
        's': 1,
        'ms': 1/1000
    },
    'ms': {
        's': 1000,
        'ms': 1
    },
    // frequency
    'Hz': {
        'Hz': 1,
        'kHz': 1000
    },
    'kHz': {
        'Hz': 1/1000,
        'kHz': 1
    },
    // resolution
    'dpi': {
        'dpi': 1,
        'dpcm': 1.0/2.54,
        'dppx': 1/96
    },
    'dpcm': {
        'dpi': 2.54,
        'dpcm': 1,
        'dppx': 2.54/96.0
    },
    'dppx': {
        'dpi': 96,
        'dpcm': 96.0/2.54,
        'dppx': 1
    }
};

module.exports = function (value, sourceUnit, targetUnit, precision) {
    if (!conversions.hasOwnProperty(targetUnit))
        throw new Error("Cannot convert to " + targetUnit);

    if (!conversions[targetUnit].hasOwnProperty(sourceUnit))
        throw new Error("Cannot convert from " + sourceUnit + " to " + targetUnit);

    precision = Math.pow(10, parseInt(precision) || 5);
    return Math.round((conversions[targetUnit][sourceUnit] * value) * precision) / precision;
};

},{}],665:[function(require,module,exports){
"use strict";

module.exports = parse;

var re_name = /^(?:\\.|[\w\-\u00b0-\uFFFF])+/,
    re_escape = /\\([\da-f]{1,6}\s?|(\s)|.)/ig,
    //modified version of https://github.com/jquery/sizzle/blob/master/src/sizzle.js#L87
    re_attr = /^\s*((?:\\.|[\w\u00b0-\uFFFF\-])+)\s*(?:(\S?)=\s*(?:(['"])([^]*?)\3|(#?(?:\\.|[\w\u00b0-\uFFFF\-])*)|)|)\s*(i)?\]/;

var actionTypes = {
	__proto__: null,
	"undefined": "exists",
	"":  "equals",
	"~": "element",
	"^": "start",
	"$": "end",
	"*": "any",
	"!": "not",
	"|": "hyphen"
};

var simpleSelectors = {
	__proto__: null,
	">": "child",
	"<": "parent",
	"~": "sibling",
	"+": "adjacent"
};

var attribSelectors = {
	__proto__: null,
	"#": ["id", "equals"],
	".": ["class", "element"]
};

//pseudos, whose data-property is parsed as well
var unpackPseudos = {
	__proto__: null,
	"has": true,
	"not": true,
	"matches": true
};

var stripQuotesFromPseudos = {
	__proto__: null,
	"contains": true,
	"icontains": true
};

var quotes = {
	__proto__: null,
	"\"": true,
	"'": true
};

//unescape function taken from https://github.com/jquery/sizzle/blob/master/src/sizzle.js#L139
function funescape( _, escaped, escapedWhitespace ) {
	var high = "0x" + escaped - 0x10000;
	// NaN means non-codepoint
	// Support: Firefox
	// Workaround erroneous numeric interpretation of +"0x"
	return high !== high || escapedWhitespace ?
		escaped :
		// BMP codepoint
		high < 0 ?
			String.fromCharCode( high + 0x10000 ) :
			// Supplemental Plane codepoint (surrogate pair)
			String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
}

function unescapeCSS(str){
	return str.replace(re_escape, funescape);
}

function isWhitespace(c){
	return c === " " || c === "\n" || c === "\t" || c === "\f" || c === "\r";
}

function parse(selector, options){
	var subselects = [];

	selector = parseSelector(subselects, selector + "", options);

	if(selector !== ""){
		throw new SyntaxError("Unmatched selector: " + selector);
	}

	return subselects;
}

function parseSelector(subselects, selector, options){
	var tokens = [],
		sawWS = false,
		data, firstChar, name, quot;

	function getName(){
		var sub = selector.match(re_name)[0];
		selector = selector.substr(sub.length);
		return unescapeCSS(sub);
	}

	function stripWhitespace(start){
		while(isWhitespace(selector.charAt(start))) start++;
		selector = selector.substr(start);
	}

	function isEscaped(pos) {
		var slashCount = 0;

		while (selector.charAt(--pos) === "\\") slashCount++;
		return (slashCount & 1) === 1;
	}

	stripWhitespace(0);

	while(selector !== ""){
		firstChar = selector.charAt(0);

		if(isWhitespace(firstChar)){
			sawWS = true;
			stripWhitespace(1);
		} else if(firstChar in simpleSelectors){
			tokens.push({type: simpleSelectors[firstChar]});
			sawWS = false;

			stripWhitespace(1);
		} else if(firstChar === ","){
			if(tokens.length === 0){
				throw new SyntaxError("empty sub-selector");
			}
			subselects.push(tokens);
			tokens = [];
			sawWS = false;
			stripWhitespace(1);
		} else {
			if(sawWS){
				if(tokens.length > 0){
					tokens.push({type: "descendant"});
				}
				sawWS = false;
			}

			if(firstChar === "*"){
				selector = selector.substr(1);
				tokens.push({type: "universal"});
			} else if(firstChar in attribSelectors){
				selector = selector.substr(1);
				tokens.push({
					type: "attribute",
					name: attribSelectors[firstChar][0],
					action: attribSelectors[firstChar][1],
					value: getName(),
					ignoreCase: false
				});
			} else if(firstChar === "["){
				selector = selector.substr(1);
				data = selector.match(re_attr);
				if(!data){
					throw new SyntaxError("Malformed attribute selector: " + selector);
				}
				selector = selector.substr(data[0].length);
				name = unescapeCSS(data[1]);

				if(
					!options || (
						"lowerCaseAttributeNames" in options ?
							options.lowerCaseAttributeNames :
							!options.xmlMode
					)
				){
					name = name.toLowerCase();
				}

				tokens.push({
					type: "attribute",
					name: name,
					action: actionTypes[data[2]],
					value: unescapeCSS(data[4] || data[5] || ""),
					ignoreCase: !!data[6]
				});

			} else if(firstChar === ":"){
				if(selector.charAt(1) === ":"){
					selector = selector.substr(2);
					tokens.push({type: "pseudo-element", name: getName().toLowerCase()});
					continue;
				}

				selector = selector.substr(1);

				name = getName().toLowerCase();
				data = null;

				if(selector.charAt(0) === "("){
					if(name in unpackPseudos){
						quot = selector.charAt(1);
						var quoted = quot in quotes;

						selector = selector.substr(quoted + 1);

						data = [];
						selector = parseSelector(data, selector, options);

						if(quoted){
							if(selector.charAt(0) !== quot){
								throw new SyntaxError("unmatched quotes in :" + name);
							} else {
								selector = selector.substr(1);
							}
						}

						if(selector.charAt(0) !== ")"){
							throw new SyntaxError("missing closing parenthesis in :" + name + " " + selector);
						}

						selector = selector.substr(1);
					} else {
						var pos = 1, counter = 1;

						for(; counter > 0 && pos < selector.length; pos++){
							if(selector.charAt(pos) === "(" && !isEscaped(pos)) counter++;
							else if(selector.charAt(pos) === ")" && !isEscaped(pos)) counter--;
						}

						if(counter){
							throw new SyntaxError("parenthesis not matched");
						}

						data = selector.substr(1, pos - 2);
						selector = selector.substr(pos);

						if(name in stripQuotesFromPseudos){
							quot = data.charAt(0);

							if(quot === data.slice(-1) && quot in quotes){
								data = data.slice(1, -1);
							}

							data = unescapeCSS(data);
						}
					}
				}

				tokens.push({type: "pseudo", name: name, data: data});
			} else if(re_name.test(selector)){
				name = getName();

				if(!options || ("lowerCaseTags" in options ? options.lowerCaseTags : !options.xmlMode)){
					name = name.toLowerCase();
				}

				tokens.push({type: "tag", name: name});
			} else {
				if(tokens.length && tokens[tokens.length - 1].type === "descendant"){
					tokens.pop();
				}
				addToken(subselects, tokens);
				return selector;
			}
		}
	}

	addToken(subselects, tokens);

	return selector;
}

function addToken(subselects, tokens){
	if(subselects.length > 0 && tokens.length === 0){
		throw new SyntaxError("empty sub-selector");
	}

	subselects.push(tokens);
}

},{}],666:[function(require,module,exports){
/*! https://mths.be/cssesc v1.0.1 by @mathias */
'use strict';

var object = {};
var hasOwnProperty = object.hasOwnProperty;
var merge = function merge(options, defaults) {
	if (!options) {
		return defaults;
	}
	var result = {};
	for (var key in defaults) {
		// `if (defaults.hasOwnProperty(key) {  }` is not needed here, since
		// only recognized option names are used.
		result[key] = hasOwnProperty.call(options, key) ? options[key] : defaults[key];
	}
	return result;
};

var regexAnySingleEscape = /[ -,\.\/;-@\[-\^`\{-~]/;
var regexSingleEscape = /[ -,\.\/;-@\[\]\^`\{-~]/;
var regexAlwaysEscape = /['"\\]/;
var regexExcessiveSpaces = /(^|\\+)?(\\[A-F0-9]{1,6})\x20(?![a-fA-F0-9\x20])/g;

// https://mathiasbynens.be/notes/css-escapes#css
var cssesc = function cssesc(string, options) {
	options = merge(options, cssesc.options);
	if (options.quotes != 'single' && options.quotes != 'double') {
		options.quotes = 'single';
	}
	var quote = options.quotes == 'double' ? '"' : '\'';
	var isIdentifier = options.isIdentifier;

	var firstChar = string.charAt(0);
	var output = '';
	var counter = 0;
	var length = string.length;
	while (counter < length) {
		var character = string.charAt(counter++);
		var codePoint = character.charCodeAt();
		var value = void 0;
		// If its not a printable ASCII character
		if (codePoint < 0x20 || codePoint > 0x7E) {
			if (codePoint >= 0xD800 && codePoint <= 0xDBFF && counter < length) {
				// Its a high surrogate, and there is a next character.
				var extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) {
					// next character is low surrogate
					codePoint = ((codePoint & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000;
				} else {
					// Its an unmatched surrogate; only append this code unit, in case
					// the next code unit is the high surrogate of a surrogate pair.
					counter--;
				}
			}
			value = '\\' + codePoint.toString(16).toUpperCase() + ' ';
		} else {
			if (options.escapeEverything) {
				if (regexAnySingleEscape.test(character)) {
					value = '\\' + character;
				} else {
					value = '\\' + codePoint.toString(16).toUpperCase() + ' ';
				}
				// Note: `:` could be escaped as `\:`, but that fails in IE < 8.
			} else if (/[\t\n\f\r\x0B:]/.test(character)) {
				if (!isIdentifier && character == ':') {
					value = character;
				} else {
					value = '\\' + codePoint.toString(16).toUpperCase() + ' ';
				}
			} else if (character == '\\' || !isIdentifier && (character == '"' && quote == character || character == '\'' && quote == character) || isIdentifier && regexSingleEscape.test(character)) {
				value = '\\' + character;
			} else {
				value = character;
			}
		}
		output += value;
	}

	if (isIdentifier) {
		if (/^_/.test(output)) {
			// Prevent IE6 from ignoring the rule altogether (in case this is for an
			// identifier used as a selector)
			output = '\\_' + output.slice(1);
		} else if (/^-[-\d]/.test(output)) {
			output = '\\-' + output.slice(1);
		} else if (/\d/.test(firstChar)) {
			output = '\\3' + firstChar + ' ' + output.slice(1);
		}
	}

	// Remove spaces after `\HEX` escapes that are not followed by a hex digit,
	// since theyre redundant. Note that this is only possible if the escape
	// sequence isnt preceded by an odd number of backslashes.
	output = output.replace(regexExcessiveSpaces, function ($0, $1, $2) {
		if ($1 && $1.length % 2) {
			// Its not safe to remove the space, so dont.
			return $0;
		}
		// Strip the space.
		return ($1 || '') + $2;
	});

	if (!isIdentifier && options.wrap) {
		return quote + output + quote;
	}
	return output;
};

// Expose default options (so they can be overridden globally).
cssesc.options = {
	'escapeEverything': false,
	'isIdentifier': false,
	'quotes': 'single',
	'wrap': false
};

cssesc.version = '1.0.1';

module.exports = cssesc;

},{}],667:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = defaultPreset;

var _cssDeclarationSorter = require('css-declaration-sorter');

var _cssDeclarationSorter2 = _interopRequireDefault(_cssDeclarationSorter);

var _postcssDiscardComments = require('postcss-discard-comments');

var _postcssDiscardComments2 = _interopRequireDefault(_postcssDiscardComments);

var _postcssReduceInitial = require('postcss-reduce-initial');

var _postcssReduceInitial2 = _interopRequireDefault(_postcssReduceInitial);

var _postcssMinifyGradients = require('postcss-minify-gradients');

var _postcssMinifyGradients2 = _interopRequireDefault(_postcssMinifyGradients);

var _postcssSvgo = require('postcss-svgo');

var _postcssSvgo2 = _interopRequireDefault(_postcssSvgo);

var _postcssReduceTransforms = require('postcss-reduce-transforms');

var _postcssReduceTransforms2 = _interopRequireDefault(_postcssReduceTransforms);

var _postcssConvertValues = require('postcss-convert-values');

var _postcssConvertValues2 = _interopRequireDefault(_postcssConvertValues);

var _postcssCalc = require('postcss-calc');

var _postcssCalc2 = _interopRequireDefault(_postcssCalc);

var _postcssColormin = require('postcss-colormin');

var _postcssColormin2 = _interopRequireDefault(_postcssColormin);

var _postcssOrderedValues = require('postcss-ordered-values');

var _postcssOrderedValues2 = _interopRequireDefault(_postcssOrderedValues);

var _postcssMinifySelectors = require('postcss-minify-selectors');

var _postcssMinifySelectors2 = _interopRequireDefault(_postcssMinifySelectors);

var _postcssMinifyParams = require('postcss-minify-params');

var _postcssMinifyParams2 = _interopRequireDefault(_postcssMinifyParams);

var _postcssNormalizeCharset = require('postcss-normalize-charset');

var _postcssNormalizeCharset2 = _interopRequireDefault(_postcssNormalizeCharset);

var _postcssMinifyFontValues = require('postcss-minify-font-values');

var _postcssMinifyFontValues2 = _interopRequireDefault(_postcssMinifyFontValues);

var _postcssNormalizeUrl = require('postcss-normalize-url');

var _postcssNormalizeUrl2 = _interopRequireDefault(_postcssNormalizeUrl);

var _postcssMergeLonghand = require('postcss-merge-longhand');

var _postcssMergeLonghand2 = _interopRequireDefault(_postcssMergeLonghand);

var _postcssDiscardDuplicates = require('postcss-discard-duplicates');

var _postcssDiscardDuplicates2 = _interopRequireDefault(_postcssDiscardDuplicates);

var _postcssDiscardOverridden = require('postcss-discard-overridden');

var _postcssDiscardOverridden2 = _interopRequireDefault(_postcssDiscardOverridden);

var _postcssNormalizeRepeatStyle = require('postcss-normalize-repeat-style');

var _postcssNormalizeRepeatStyle2 = _interopRequireDefault(_postcssNormalizeRepeatStyle);

var _postcssMergeRules = require('postcss-merge-rules');

var _postcssMergeRules2 = _interopRequireDefault(_postcssMergeRules);

var _postcssDiscardEmpty = require('postcss-discard-empty');

var _postcssDiscardEmpty2 = _interopRequireDefault(_postcssDiscardEmpty);

var _postcssUniqueSelectors = require('postcss-unique-selectors');

var _postcssUniqueSelectors2 = _interopRequireDefault(_postcssUniqueSelectors);

var _postcssNormalizeString = require('postcss-normalize-string');

var _postcssNormalizeString2 = _interopRequireDefault(_postcssNormalizeString);

var _postcssNormalizePositions = require('postcss-normalize-positions');

var _postcssNormalizePositions2 = _interopRequireDefault(_postcssNormalizePositions);

var _postcssNormalizeWhitespace = require('postcss-normalize-whitespace');

var _postcssNormalizeWhitespace2 = _interopRequireDefault(_postcssNormalizeWhitespace);

var _postcssNormalizeUnicode = require('postcss-normalize-unicode');

var _postcssNormalizeUnicode2 = _interopRequireDefault(_postcssNormalizeUnicode);

var _postcssNormalizeDisplayValues = require('postcss-normalize-display-values');

var _postcssNormalizeDisplayValues2 = _interopRequireDefault(_postcssNormalizeDisplayValues);

var _postcssNormalizeTimingFunctions = require('postcss-normalize-timing-functions');

var _postcssNormalizeTimingFunctions2 = _interopRequireDefault(_postcssNormalizeTimingFunctions);

var _cssnanoUtilRawCache = require('cssnano-util-raw-cache');

var _cssnanoUtilRawCache2 = _interopRequireDefault(_cssnanoUtilRawCache);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const defaultOpts = {
    convertValues: {
        length: false
    },
    normalizeCharset: {
        add: false
    },
    cssDeclarationSorter: {
        exclude: true
    }
}; /**
    * @author Ben Briggs
    * @license MIT
    * @module cssnano:preset:default
    * @overview
    *
    * This default preset for cssnano only includes transforms that make no
    * assumptions about your CSS other than what is passed in. In previous
    * iterations of cssnano, assumptions were made about your CSS which caused
    * output to look different in certain use cases, but not others. These
    * transforms have been moved from the defaults to other presets, to make
    * this preset require only minimal configuration.
    */

function defaultPreset(opts = {}) {
    const options = Object.assign({}, defaultOpts, opts);

    const plugins = [[_postcssDiscardComments2.default, options.discardComments], [_postcssMinifyGradients2.default, options.minifyGradients], [_postcssReduceInitial2.default, options.reduceInitial], [_postcssSvgo2.default, options.svgo], [_postcssNormalizeDisplayValues2.default, options.normalizeDisplayValues], [_postcssReduceTransforms2.default, options.reduceTransforms], [_postcssColormin2.default, options.colormin], [_postcssNormalizeTimingFunctions2.default, options.normalizeTimingFunctions], [_postcssCalc2.default, options.calc], [_postcssConvertValues2.default, options.convertValues], [_postcssOrderedValues2.default, options.orderedValues], [_postcssMinifySelectors2.default, options.minifySelectors], [_postcssMinifyParams2.default, options.minifyParams], [_postcssNormalizeCharset2.default, options.normalizeCharset], [_postcssDiscardOverridden2.default, options.discardOverridden], [_postcssNormalizeString2.default, options.normalizeString], [_postcssNormalizeUnicode2.default, options.normalizeUnicode], [_postcssMinifyFontValues2.default, options.minifyFontValues], [_postcssNormalizeUrl2.default, options.normalizeUrl], [_postcssNormalizeRepeatStyle2.default, options.normalizeRepeatStyle], [_postcssNormalizePositions2.default, options.normalizePositions], [_postcssNormalizeWhitespace2.default, options.normalizeWhitespace], [_postcssMergeLonghand2.default, options.mergeLonghand], [_postcssDiscardDuplicates2.default, options.discardDuplicates], [_postcssMergeRules2.default, options.mergeRules], [_postcssDiscardEmpty2.default, options.discardEmpty], [_postcssUniqueSelectors2.default, options.uniqueSelectors], [_cssDeclarationSorter2.default, options.cssDeclarationSorter], [_cssnanoUtilRawCache2.default, options.rawCache]];

    return { plugins };
}
module.exports = exports['default'];
},{"css-declaration-sorter":551,"cssnano-util-raw-cache":670,"postcss-calc":849,"postcss-colormin":856,"postcss-convert-values":859,"postcss-discard-comments":861,"postcss-discard-duplicates":864,"postcss-discard-empty":865,"postcss-discard-overridden":866,"postcss-merge-longhand":875,"postcss-merge-rules":900,"postcss-minify-font-values":927,"postcss-minify-gradients":933,"postcss-minify-params":934,"postcss-minify-selectors":935,"postcss-normalize-charset":964,"postcss-normalize-display-values":965,"postcss-normalize-positions":967,"postcss-normalize-repeat-style":968,"postcss-normalize-string":970,"postcss-normalize-timing-functions":971,"postcss-normalize-unicode":973,"postcss-normalize-url":974,"postcss-normalize-whitespace":975,"postcss-ordered-values":976,"postcss-reduce-initial":986,"postcss-reduce-transforms":987,"postcss-svgo":1054,"postcss-unique-selectors":1056}],668:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = getArguments;
function getArguments(node) {
    return node.nodes.reduce((list, child) => {
        if (child.type !== 'div') {
            list[list.length - 1].push(child);
        } else {
            list.push([]);
        }
        return list;
    }, [[]]);
}
module.exports = exports['default'];
},{}],669:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = getMatchFactory;
function getMatchFactory(map) {
    return function getMatch(args) {
        const match = args.reduce((list, arg, i) => {
            return list.filter(keyword => keyword[1][i] === arg);
        }, map);
        if (match.length) {
            return match[0][0];
        }
        return false;
    };
}
module.exports = exports["default"];
},{}],670:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _postcss = require('postcss');

exports.default = (0, _postcss.plugin)('cssnano-util-raw-cache', () => {
    return (css, result) => {
        result.root.rawCache = {
            colon: ':',
            indent: '',
            beforeDecl: '',
            beforeRule: '',
            beforeOpen: '',
            beforeClose: '',
            beforeComment: '',
            after: '',
            emptyBody: '',
            commentLeft: '',
            commentRight: ''
        };
    };
});
module.exports = exports['default'];
},{"postcss":1074}],671:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = sameParent;
function sameParent(ruleA, ruleB) {
    let hasParent = ruleA.parent && ruleB.parent;
    // Check for detached rules
    if (!hasParent) {
        return true;
    }
    // If an at rule, ensure that the parameters are the same
    if (ruleA.parent.type === 'atrule' && ruleB.parent.type === 'atrule') {
        return ruleA.parent.params === ruleB.parent.params && ruleA.parent.name.toLowerCase() === ruleB.parent.name.toLowerCase();
    }
    return ruleA.parent.type === ruleB.parent.type;
}
module.exports = exports['default'];
},{}],672:[function(require,module,exports){
(function (process){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _postcss = require('postcss');

var _postcss2 = _interopRequireDefault(_postcss);

var _cosmiconfig = require('cosmiconfig');

var _cosmiconfig2 = _interopRequireDefault(_cosmiconfig);

var _isResolvable = require('is-resolvable');

var _isResolvable2 = _interopRequireDefault(_isResolvable);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const cssnano = 'cssnano';

function initializePlugin(plugin, css, result) {
    if (Array.isArray(plugin)) {
        const [processor, opts] = plugin;
        if (typeof opts === 'undefined' || typeof opts === 'object' && !opts.exclude || typeof opts === 'boolean' && opts === true) {
            return Promise.resolve(processor(opts)(css, result));
        }
    } else {
        return Promise.resolve(plugin()(css, result));
    }
    // Handle excluded plugins
    return Promise.resolve();
}

/*
 * preset can be one of four possibilities:
 * preset = 'default'
 * preset = ['default', {}]
 * preset = function <- to be invoked
 * preset = {plugins: []} <- already invoked function
 */

function resolvePreset(preset) {
    let fn, options;
    if (Array.isArray(preset)) {
        fn = preset[0];
        options = preset[1];
    } else {
        fn = preset;
        options = {};
    }
    // For JS setups where we invoked the preset already
    if (preset.plugins) {
        return Promise.resolve(preset.plugins);
    }
    // Provide an alias for the default preset, as it is built-in.
    if (fn === 'default') {
        return Promise.resolve(require('cssnano-preset-default')(options).plugins);
    }
    // For non-JS setups; we'll need to invoke the preset ourselves.
    if (typeof fn === 'function') {
        return Promise.resolve(fn(options).plugins);
    }
    // Try loading a preset from node_modules
    if ((0, _isResolvable2.default)(fn)) {
        return Promise.resolve(require(fn)(options).plugins);
    }
    const sugar = `cssnano-preset-${fn}`;
    // Try loading a preset from node_modules (sugar)
    if ((0, _isResolvable2.default)(sugar)) {
        return Promise.resolve(require(sugar)(options).plugins);
    }
    // If all else fails, we probably have a typo in the config somewhere
    throw new Error(`Cannot load preset "${fn}". Please check your configuration for errors and try again.`);
}

/*
 * cssnano will look for configuration firstly as options passed
 * directly to it, and failing this it will use cosmiconfig to
 * load an external file.
 */

function resolveConfig(css, result, options) {
    if (options.preset) {
        return resolvePreset(options.preset);
    }

    const inputFile = css.source && css.source.input && css.source.input.file;
    let searchPath = inputFile ? _path2.default.dirname(inputFile) : process.cwd();
    let configPath = null;

    if (options.configFile) {
        searchPath = null;
        configPath = _path2.default.resolve(process.cwd(), options.configFile);
    }

    const configExplorer = (0, _cosmiconfig2.default)(cssnano);
    const searchForConfig = configPath ? configExplorer.load(configPath) : configExplorer.search(searchPath);

    return searchForConfig.then(config => {
        if (config === null) {
            return resolvePreset('default');
        }
        return resolvePreset(config.config.preset || config.config);
    });
}

exports.default = _postcss2.default.plugin(cssnano, (options = {}) => {
    return (css, result) => {
        return resolveConfig(css, result, options).then(plugins => {
            return plugins.reduce((promise, plugin) => {
                return promise.then(initializePlugin.bind(null, plugin, css, result));
            }, Promise.resolve());
        });
    };
});
module.exports = exports['default'];
}).call(this,require('_process'))
},{"_process":1098,"cosmiconfig":547,"cssnano-preset-default":667,"is-resolvable":748,"path":802,"postcss":1074}],673:[function(require,module,exports){
module.exports = function specificity(simpleSelector) {
    var A = 0;
    var B = 0;
    var C = 0;

    simpleSelector.children.each(function walk(node) {
        switch (node.type) {
            case 'SelectorList':
            case 'Selector':
                node.children.each(walk);
                break;

            case 'IdSelector':
                A++;
                break;

            case 'ClassSelector':
            case 'AttributeSelector':
                B++;
                break;

            case 'PseudoClassSelector':
                switch (node.name.toLowerCase()) {
                    case 'not':
                        node.children.each(walk);
                        break;

                    case 'before':
                    case 'after':
                    case 'first-line':
                    case 'first-letter':
                        C++;
                        break;

                    // TODO: support for :nth-*(.. of <SelectorList>), :matches(), :has()

                    default:
                        B++;
                }
                break;

            case 'PseudoElementSelector':
                C++;
                break;

            case 'TypeSelector':
                // ignore universal selector
                if (node.name.charAt(node.name.length - 1) !== '*') {
                    C++;
                }
                break;

        }
    });

    return [A, B, C];
};

},{}],674:[function(require,module,exports){
'use strict';

var keys = require('object-keys');
var hasSymbols = typeof Symbol === 'function' && typeof Symbol('foo') === 'symbol';

var toStr = Object.prototype.toString;
var concat = Array.prototype.concat;
var origDefineProperty = Object.defineProperty;

var isFunction = function (fn) {
	return typeof fn === 'function' && toStr.call(fn) === '[object Function]';
};

var arePropertyDescriptorsSupported = function () {
	var obj = {};
	try {
		origDefineProperty(obj, 'x', { enumerable: false, value: obj });
		// eslint-disable-next-line no-unused-vars, no-restricted-syntax
		for (var _ in obj) { // jscs:ignore disallowUnusedVariables
			return false;
		}
		return obj.x === obj;
	} catch (e) { /* this is IE 8. */
		return false;
	}
};
var supportsDescriptors = origDefineProperty && arePropertyDescriptorsSupported();

var defineProperty = function (object, name, value, predicate) {
	if (name in object && (!isFunction(predicate) || !predicate())) {
		return;
	}
	if (supportsDescriptors) {
		origDefineProperty(object, name, {
			configurable: true,
			enumerable: false,
			value: value,
			writable: true
		});
	} else {
		object[name] = value;
	}
};

var defineProperties = function (object, map) {
	var predicates = arguments.length > 2 ? arguments[2] : {};
	var props = keys(map);
	if (hasSymbols) {
		props = concat.call(props, Object.getOwnPropertySymbols(map));
	}
	for (var i = 0; i < props.length; i += 1) {
		defineProperty(object, props[i], map[props[i]], predicates[props[i]]);
	}
};

defineProperties.supportsDescriptors = !!supportsDescriptors;

module.exports = defineProperties;

},{"object-keys":794}],675:[function(require,module,exports){
module.exports = function () {
    for (var i = 0; i < arguments.length; i++) {
        if (arguments[i] !== undefined) return arguments[i];
    }
};

},{}],676:[function(require,module,exports){
/*
  Module dependencies
*/
var ElementType = require('domelementtype');
var entities = require('entities');

var unencodedElements = {
  __proto__: null,
  style: true,
  script: true,
  xmp: true,
  iframe: true,
  noembed: true,
  noframes: true,
  plaintext: true,
  noscript: true
};

/*
  Format attributes
*/
function formatAttrs(attributes, opts) {
  if (!attributes) return;

  var output = '',
      value;

  // Loop through the attributes
  for (var key in attributes) {
    value = attributes[key];
    if (output) {
      output += ' ';
    }

    output += key;
    if ((value !== null && value !== '') || opts.xmlMode) {
        output += '="' + (opts.decodeEntities ? entities.encodeXML(value) : value) + '"';
    }
  }

  return output;
}

/*
  Self-enclosing tags (stolen from node-htmlparser)
*/
var singleTag = {
  __proto__: null,
  area: true,
  base: true,
  basefont: true,
  br: true,
  col: true,
  command: true,
  embed: true,
  frame: true,
  hr: true,
  img: true,
  input: true,
  isindex: true,
  keygen: true,
  link: true,
  meta: true,
  param: true,
  source: true,
  track: true,
  wbr: true,
};


var render = module.exports = function(dom, opts) {
  if (!Array.isArray(dom) && !dom.cheerio) dom = [dom];
  opts = opts || {};

  var output = '';

  for(var i = 0; i < dom.length; i++){
    var elem = dom[i];

    if (elem.type === 'root')
      output += render(elem.children, opts);
    else if (ElementType.isTag(elem))
      output += renderTag(elem, opts);
    else if (elem.type === ElementType.Directive)
      output += renderDirective(elem);
    else if (elem.type === ElementType.Comment)
      output += renderComment(elem);
    else if (elem.type === ElementType.CDATA)
      output += renderCdata(elem);
    else
      output += renderText(elem, opts);
  }

  return output;
};

function renderTag(elem, opts) {
  // Handle SVG
  if (elem.name === "svg") opts = {decodeEntities: opts.decodeEntities, xmlMode: true};

  var tag = '<' + elem.name,
      attribs = formatAttrs(elem.attribs, opts);

  if (attribs) {
    tag += ' ' + attribs;
  }

  if (
    opts.xmlMode
    && (!elem.children || elem.children.length === 0)
  ) {
    tag += '/>';
  } else {
    tag += '>';
    if (elem.children) {
      tag += render(elem.children, opts);
    }

    if (!singleTag[elem.name] || opts.xmlMode) {
      tag += '</' + elem.name + '>';
    }
  }

  return tag;
}

function renderDirective(elem) {
  return '<' + elem.data + '>';
}

function renderText(elem, opts) {
  var data = elem.data || '';

  // if entities weren't decoded, no need to encode them back
  if (opts.decodeEntities && !(elem.parent && elem.parent.name in unencodedElements)) {
    data = entities.encodeXML(data);
  }

  return data;
}

function renderCdata(elem) {
  return '<![CDATA[' + elem.children[0].data + ']]>';
}

function renderComment(elem) {
  return '<!--' + elem.data + '-->';
}

},{"domelementtype":677,"entities":687}],677:[function(require,module,exports){
//Types of elements found in the DOM
module.exports = {
	Text: "text", //Text
	Directive: "directive", //<? ... ?>
	Comment: "comment", //<!-- ... -->
	Script: "script", //<script> tags
	Style: "style", //<style> tags
	Tag: "tag", //Any tag
	CDATA: "cdata", //<![CDATA[ ... ]]>
	Doctype: "doctype",

	isTag: function(elem){
		return elem.type === "tag" || elem.type === "script" || elem.type === "style";
	}
};

},{}],678:[function(require,module,exports){
var DomUtils = module.exports;

[
	require("./lib/stringify"),
	require("./lib/traversal"),
	require("./lib/manipulation"),
	require("./lib/querying"),
	require("./lib/legacy"),
	require("./lib/helpers")
].forEach(function(ext){
	Object.keys(ext).forEach(function(key){
		DomUtils[key] = ext[key].bind(DomUtils);
	});
});

},{"./lib/helpers":679,"./lib/legacy":680,"./lib/manipulation":681,"./lib/querying":682,"./lib/stringify":683,"./lib/traversal":684}],679:[function(require,module,exports){
// removeSubsets
// Given an array of nodes, remove any member that is contained by another.
exports.removeSubsets = function(nodes) {
	var idx = nodes.length, node, ancestor, replace;

	// Check if each node (or one of its ancestors) is already contained in the
	// array.
	while (--idx > -1) {
		node = ancestor = nodes[idx];

		// Temporarily remove the node under consideration
		nodes[idx] = null;
		replace = true;

		while (ancestor) {
			if (nodes.indexOf(ancestor) > -1) {
				replace = false;
				nodes.splice(idx, 1);
				break;
			}
			ancestor = ancestor.parent;
		}

		// If the node has been found to be unique, re-insert it.
		if (replace) {
			nodes[idx] = node;
		}
	}

	return nodes;
};

// Source: http://dom.spec.whatwg.org/#dom-node-comparedocumentposition
var POSITION = {
	DISCONNECTED: 1,
	PRECEDING: 2,
	FOLLOWING: 4,
	CONTAINS: 8,
	CONTAINED_BY: 16
};

// Compare the position of one node against another node in any other document.
// The return value is a bitmask with the following values:
//
// document order:
// > There is an ordering, document order, defined on all the nodes in the
// > document corresponding to the order in which the first character of the
// > XML representation of each node occurs in the XML representation of the
// > document after expansion of general entities. Thus, the document element
// > node will be the first node. Element nodes occur before their children.
// > Thus, document order orders element nodes in order of the occurrence of
// > their start-tag in the XML (after expansion of entities). The attribute
// > nodes of an element occur after the element and before its children. The
// > relative order of attribute nodes is implementation-dependent./
// Source:
// http://www.w3.org/TR/DOM-Level-3-Core/glossary.html#dt-document-order
//
// @argument {Node} nodaA The first node to use in the comparison
// @argument {Node} nodeB The second node to use in the comparison
//
// @return {Number} A bitmask describing the input nodes' relative position.
//         See http://dom.spec.whatwg.org/#dom-node-comparedocumentposition for
//         a description of these values.
var comparePos = exports.compareDocumentPosition = function(nodeA, nodeB) {
	var aParents = [];
	var bParents = [];
	var current, sharedParent, siblings, aSibling, bSibling, idx;

	if (nodeA === nodeB) {
		return 0;
	}

	current = nodeA;
	while (current) {
		aParents.unshift(current);
		current = current.parent;
	}
	current = nodeB;
	while (current) {
		bParents.unshift(current);
		current = current.parent;
	}

	idx = 0;
	while (aParents[idx] === bParents[idx]) {
		idx++;
	}

	if (idx === 0) {
		return POSITION.DISCONNECTED;
	}

	sharedParent = aParents[idx - 1];
	siblings = sharedParent.children;
	aSibling = aParents[idx];
	bSibling = bParents[idx];

	if (siblings.indexOf(aSibling) > siblings.indexOf(bSibling)) {
		if (sharedParent === nodeB) {
			return POSITION.FOLLOWING | POSITION.CONTAINED_BY;
		}
		return POSITION.FOLLOWING;
	} else {
		if (sharedParent === nodeA) {
			return POSITION.PRECEDING | POSITION.CONTAINS;
		}
		return POSITION.PRECEDING;
	}
};

// Sort an array of nodes based on their relative position in the document and
// remove any duplicate nodes. If the array contains nodes that do not belong
// to the same document, sort order is unspecified.
//
// @argument {Array} nodes Array of DOM nodes
//
// @returns {Array} collection of unique nodes, sorted in document order
exports.uniqueSort = function(nodes) {
	var idx = nodes.length, node, position;

	nodes = nodes.slice();

	while (--idx > -1) {
		node = nodes[idx];
		position = nodes.indexOf(node);
		if (position > -1 && position < idx) {
			nodes.splice(idx, 1);
		}
	}
	nodes.sort(function(a, b) {
		var relative = comparePos(a, b);
		if (relative & POSITION.PRECEDING) {
			return -1;
		} else if (relative & POSITION.FOLLOWING) {
			return 1;
		}
		return 0;
	});

	return nodes;
};

},{}],680:[function(require,module,exports){
var ElementType = require("domelementtype");
var isTag = exports.isTag = ElementType.isTag;

exports.testElement = function(options, element){
	for(var key in options){
		if(!options.hasOwnProperty(key));
		else if(key === "tag_name"){
			if(!isTag(element) || !options.tag_name(element.name)){
				return false;
			}
		} else if(key === "tag_type"){
			if(!options.tag_type(element.type)) return false;
		} else if(key === "tag_contains"){
			if(isTag(element) || !options.tag_contains(element.data)){
				return false;
			}
		} else if(!element.attribs || !options[key](element.attribs[key])){
			return false;
		}
	}
	return true;
};

var Checks = {
	tag_name: function(name){
		if(typeof name === "function"){
			return function(elem){ return isTag(elem) && name(elem.name); };
		} else if(name === "*"){
			return isTag;
		} else {
			return function(elem){ return isTag(elem) && elem.name === name; };
		}
	},
	tag_type: function(type){
		if(typeof type === "function"){
			return function(elem){ return type(elem.type); };
		} else {
			return function(elem){ return elem.type === type; };
		}
	},
	tag_contains: function(data){
		if(typeof data === "function"){
			return function(elem){ return !isTag(elem) && data(elem.data); };
		} else {
			return function(elem){ return !isTag(elem) && elem.data === data; };
		}
	}
};

function getAttribCheck(attrib, value){
	if(typeof value === "function"){
		return function(elem){ return elem.attribs && value(elem.attribs[attrib]); };
	} else {
		return function(elem){ return elem.attribs && elem.attribs[attrib] === value; };
	}
}

function combineFuncs(a, b){
	return function(elem){
		return a(elem) || b(elem);
	};
}

exports.getElements = function(options, element, recurse, limit){
	var funcs = Object.keys(options).map(function(key){
		var value = options[key];
		return key in Checks ? Checks[key](value) : getAttribCheck(key, value);
	});

	return funcs.length === 0 ? [] : this.filter(
		funcs.reduce(combineFuncs),
		element, recurse, limit
	);
};

exports.getElementById = function(id, element, recurse){
	if(!Array.isArray(element)) element = [element];
	return this.findOne(getAttribCheck("id", id), element, recurse !== false);
};

exports.getElementsByTagName = function(name, element, recurse, limit){
	return this.filter(Checks.tag_name(name), element, recurse, limit);
};

exports.getElementsByTagType = function(type, element, recurse, limit){
	return this.filter(Checks.tag_type(type), element, recurse, limit);
};

},{"domelementtype":677}],681:[function(require,module,exports){
exports.removeElement = function(elem){
	if(elem.prev) elem.prev.next = elem.next;
	if(elem.next) elem.next.prev = elem.prev;

	if(elem.parent){
		var childs = elem.parent.children;
		childs.splice(childs.lastIndexOf(elem), 1);
	}
};

exports.replaceElement = function(elem, replacement){
	var prev = replacement.prev = elem.prev;
	if(prev){
		prev.next = replacement;
	}

	var next = replacement.next = elem.next;
	if(next){
		next.prev = replacement;
	}

	var parent = replacement.parent = elem.parent;
	if(parent){
		var childs = parent.children;
		childs[childs.lastIndexOf(elem)] = replacement;
	}
};

exports.appendChild = function(elem, child){
	child.parent = elem;

	if(elem.children.push(child) !== 1){
		var sibling = elem.children[elem.children.length - 2];
		sibling.next = child;
		child.prev = sibling;
		child.next = null;
	}
};

exports.append = function(elem, next){
	var parent = elem.parent,
		currNext = elem.next;

	next.next = currNext;
	next.prev = elem;
	elem.next = next;
	next.parent = parent;

	if(currNext){
		currNext.prev = next;
		if(parent){
			var childs = parent.children;
			childs.splice(childs.lastIndexOf(currNext), 0, next);
		}
	} else if(parent){
		parent.children.push(next);
	}
};

exports.prepend = function(elem, prev){
	var parent = elem.parent;
	if(parent){
		var childs = parent.children;
		childs.splice(childs.lastIndexOf(elem), 0, prev);
	}

	if(elem.prev){
		elem.prev.next = prev;
	}
	
	prev.parent = parent;
	prev.prev = elem.prev;
	prev.next = elem;
	elem.prev = prev;
};



},{}],682:[function(require,module,exports){
var isTag = require("domelementtype").isTag;

module.exports = {
	filter: filter,
	find: find,
	findOneChild: findOneChild,
	findOne: findOne,
	existsOne: existsOne,
	findAll: findAll
};

function filter(test, element, recurse, limit){
	if(!Array.isArray(element)) element = [element];

	if(typeof limit !== "number" || !isFinite(limit)){
		limit = Infinity;
	}
	return find(test, element, recurse !== false, limit);
}

function find(test, elems, recurse, limit){
	var result = [], childs;

	for(var i = 0, j = elems.length; i < j; i++){
		if(test(elems[i])){
			result.push(elems[i]);
			if(--limit <= 0) break;
		}

		childs = elems[i].children;
		if(recurse && childs && childs.length > 0){
			childs = find(test, childs, recurse, limit);
			result = result.concat(childs);
			limit -= childs.length;
			if(limit <= 0) break;
		}
	}

	return result;
}

function findOneChild(test, elems){
	for(var i = 0, l = elems.length; i < l; i++){
		if(test(elems[i])) return elems[i];
	}

	return null;
}

function findOne(test, elems){
	var elem = null;

	for(var i = 0, l = elems.length; i < l && !elem; i++){
		if(!isTag(elems[i])){
			continue;
		} else if(test(elems[i])){
			elem = elems[i];
		} else if(elems[i].children.length > 0){
			elem = findOne(test, elems[i].children);
		}
	}

	return elem;
}

function existsOne(test, elems){
	for(var i = 0, l = elems.length; i < l; i++){
		if(
			isTag(elems[i]) && (
				test(elems[i]) || (
					elems[i].children.length > 0 &&
					existsOne(test, elems[i].children)
				)
			)
		){
			return true;
		}
	}

	return false;
}

function findAll(test, rootElems){
	var result = [];
	var stack = rootElems.slice();
	while(stack.length){
		var elem = stack.shift();
		if(!isTag(elem)) continue;
		if (elem.children && elem.children.length > 0) {
			stack.unshift.apply(stack, elem.children);
		}
		if(test(elem)) result.push(elem);
	}
	return result;
}

},{"domelementtype":677}],683:[function(require,module,exports){
var ElementType = require("domelementtype"),
    getOuterHTML = require("dom-serializer"),
    isTag = ElementType.isTag;

module.exports = {
	getInnerHTML: getInnerHTML,
	getOuterHTML: getOuterHTML,
	getText: getText
};

function getInnerHTML(elem, opts){
	return elem.children ? elem.children.map(function(elem){
		return getOuterHTML(elem, opts);
	}).join("") : "";
}

function getText(elem){
	if(Array.isArray(elem)) return elem.map(getText).join("");
	if(isTag(elem)) return elem.name === "br" ? "\n" : getText(elem.children);
	if(elem.type === ElementType.CDATA) return getText(elem.children);
	if(elem.type === ElementType.Text) return elem.data;
	return "";
}

},{"dom-serializer":676,"domelementtype":677}],684:[function(require,module,exports){
var getChildren = exports.getChildren = function(elem){
	return elem.children;
};

var getParent = exports.getParent = function(elem){
	return elem.parent;
};

exports.getSiblings = function(elem){
	var parent = getParent(elem);
	return parent ? getChildren(parent) : [elem];
};

exports.getAttributeValue = function(elem, name){
	return elem.attribs && elem.attribs[name];
};

exports.hasAttrib = function(elem, name){
	return !!elem.attribs && hasOwnProperty.call(elem.attribs, name);
};

exports.getName = function(elem){
	return elem.name;
};

},{}],685:[function(require,module,exports){
'use strict';
const isObj = require('is-obj');

function getPathSegments(path) {
	const pathArr = path.split('.');
	const parts = [];

	for (let i = 0; i < pathArr.length; i++) {
		let p = pathArr[i];

		while (p[p.length - 1] === '\\' && pathArr[i + 1] !== undefined) {
			p = p.slice(0, -1) + '.';
			p += pathArr[++i];
		}

		parts.push(p);
	}

	return parts;
}

module.exports = {
	get(obj, path, value) {
		if (!isObj(obj) || typeof path !== 'string') {
			return value === undefined ? obj : value;
		}

		const pathArr = getPathSegments(path);

		for (let i = 0; i < pathArr.length; i++) {
			if (!Object.prototype.propertyIsEnumerable.call(obj, pathArr[i])) {
				return value;
			}

			obj = obj[pathArr[i]];

			if (obj === undefined || obj === null) {
				// `obj` is either `undefined` or `null` so we want to stop the loop, and
				// if this is not the last bit of the path, and
				// if it did't return `undefined`
				// it would return `null` if `obj` is `null`
				// but we want `get({foo: null}, 'foo.bar')` to equal `undefined`, or the supplied value, not `null`
				if (i !== pathArr.length - 1) {
					return value;
				}

				break;
			}
		}

		return obj;
	},

	set(obj, path, value) {
		if (!isObj(obj) || typeof path !== 'string') {
			return obj;
		}

		const root = obj;
		const pathArr = getPathSegments(path);

		for (let i = 0; i < pathArr.length; i++) {
			const p = pathArr[i];

			if (!isObj(obj[p])) {
				obj[p] = {};
			}

			if (i === pathArr.length - 1) {
				obj[p] = value;
			}

			obj = obj[p];
		}

		return root;
	},

	delete(obj, path) {
		if (!isObj(obj) || typeof path !== 'string') {
			return;
		}

		const pathArr = getPathSegments(path);

		for (let i = 0; i < pathArr.length; i++) {
			const p = pathArr[i];

			if (i === pathArr.length - 1) {
				delete obj[p];
				return;
			}

			obj = obj[p];

			if (!isObj(obj)) {
				return;
			}
		}
	},

	has(obj, path) {
		if (!isObj(obj) || typeof path !== 'string') {
			return false;
		}

		const pathArr = getPathSegments(path);

		for (let i = 0; i < pathArr.length; i++) {
			if (isObj(obj)) {
				if (!(pathArr[i] in obj)) {
					return false;
				}

				obj = obj[pathArr[i]];
			} else {
				return false;
			}
		}

		return true;
	}
};

},{"is-obj":746}],686:[function(require,module,exports){
module.exports = {
	"5.0": "72",
	"4.0": "69",
	"3.1": "66",
	"3.0": "66",
	"2.1": "61",
	"2.0": "61",
	"1.8": "59",
	"1.7": "58",
	"1.6": "56",
	"1.5": "54",
	"1.4": "53",
	"1.3": "52",
	"1.2": "51",
	"1.1": "50",
	"1.0": "49",
	"0.37": "49",
	"0.36": "47",
	"0.35": "45",
	"0.34": "45",
	"0.33": "45",
	"0.32": "45",
	"0.31": "44",
	"0.30": "44",
	"0.29": "43",
	"0.28": "43",
	"0.27": "42",
	"0.26": "42",
	"0.25": "42",
	"0.24": "41",
	"0.23": "41",
	"0.22": "41",
	"0.21": "40",
	"0.20": "39"
};
},{}],687:[function(require,module,exports){
var encode = require("./lib/encode.js"),
    decode = require("./lib/decode.js");

exports.decode = function(data, level) {
    return (!level || level <= 0 ? decode.XML : decode.HTML)(data);
};

exports.decodeStrict = function(data, level) {
    return (!level || level <= 0 ? decode.XML : decode.HTMLStrict)(data);
};

exports.encode = function(data, level) {
    return (!level || level <= 0 ? encode.XML : encode.HTML)(data);
};

exports.encodeXML = encode.XML;

exports.encodeHTML4 = exports.encodeHTML5 = exports.encodeHTML = encode.HTML;

exports.decodeXML = exports.decodeXMLStrict = decode.XML;

exports.decodeHTML4 = exports.decodeHTML5 = exports.decodeHTML = decode.HTML;

exports.decodeHTML4Strict = exports.decodeHTML5Strict = exports.decodeHTMLStrict = decode.HTMLStrict;

exports.escape = encode.escape;

},{"./lib/decode.js":688,"./lib/encode.js":690}],688:[function(require,module,exports){
var entityMap = require("../maps/entities.json"),
    legacyMap = require("../maps/legacy.json"),
    xmlMap = require("../maps/xml.json"),
    decodeCodePoint = require("./decode_codepoint.js");

var decodeXMLStrict = getStrictDecoder(xmlMap),
    decodeHTMLStrict = getStrictDecoder(entityMap);

function getStrictDecoder(map) {
    var keys = Object.keys(map).join("|"),
        replace = getReplacer(map);

    keys += "|#[xX][\\da-fA-F]+|#\\d+";

    var re = new RegExp("&(?:" + keys + ");", "g");

    return function(str) {
        return String(str).replace(re, replace);
    };
}

var decodeHTML = (function() {
    var legacy = Object.keys(legacyMap).sort(sorter);

    var keys = Object.keys(entityMap).sort(sorter);

    for (var i = 0, j = 0; i < keys.length; i++) {
        if (legacy[j] === keys[i]) {
            keys[i] += ";?";
            j++;
        } else {
            keys[i] += ";";
        }
    }

    var re = new RegExp("&(?:" + keys.join("|") + "|#[xX][\\da-fA-F]+;?|#\\d+;?)", "g"),
        replace = getReplacer(entityMap);

    function replacer(str) {
        if (str.substr(-1) !== ";") str += ";";
        return replace(str);
    }

    //TODO consider creating a merged map
    return function(str) {
        return String(str).replace(re, replacer);
    };
})();

function sorter(a, b) {
    return a < b ? 1 : -1;
}

function getReplacer(map) {
    return function replace(str) {
        if (str.charAt(1) === "#") {
            if (str.charAt(2) === "X" || str.charAt(2) === "x") {
                return decodeCodePoint(parseInt(str.substr(3), 16));
            }
            return decodeCodePoint(parseInt(str.substr(2), 10));
        }
        return map[str.slice(1, -1)];
    };
}

module.exports = {
    XML: decodeXMLStrict,
    HTML: decodeHTML,
    HTMLStrict: decodeHTMLStrict
};

},{"../maps/entities.json":692,"../maps/legacy.json":693,"../maps/xml.json":694,"./decode_codepoint.js":689}],689:[function(require,module,exports){
var decodeMap = require("../maps/decode.json");

module.exports = decodeCodePoint;

// modified version of https://github.com/mathiasbynens/he/blob/master/src/he.js#L94-L119
function decodeCodePoint(codePoint) {
    if ((codePoint >= 0xd800 && codePoint <= 0xdfff) || codePoint > 0x10ffff) {
        return "\uFFFD";
    }

    if (codePoint in decodeMap) {
        codePoint = decodeMap[codePoint];
    }

    var output = "";

    if (codePoint > 0xffff) {
        codePoint -= 0x10000;
        output += String.fromCharCode(((codePoint >>> 10) & 0x3ff) | 0xd800);
        codePoint = 0xdc00 | (codePoint & 0x3ff);
    }

    output += String.fromCharCode(codePoint);
    return output;
}

},{"../maps/decode.json":691}],690:[function(require,module,exports){
var inverseXML = getInverseObj(require("../maps/xml.json")),
    xmlReplacer = getInverseReplacer(inverseXML);

exports.XML = getInverse(inverseXML, xmlReplacer);

var inverseHTML = getInverseObj(require("../maps/entities.json")),
    htmlReplacer = getInverseReplacer(inverseHTML);

exports.HTML = getInverse(inverseHTML, htmlReplacer);

function getInverseObj(obj) {
    return Object.keys(obj)
        .sort()
        .reduce(function(inverse, name) {
            inverse[obj[name]] = "&" + name + ";";
            return inverse;
        }, {});
}

function getInverseReplacer(inverse) {
    var single = [],
        multiple = [];

    Object.keys(inverse).forEach(function(k) {
        if (k.length === 1) {
            single.push("\\" + k);
        } else {
            multiple.push(k);
        }
    });

    //TODO add ranges
    multiple.unshift("[" + single.join("") + "]");

    return new RegExp(multiple.join("|"), "g");
}

var re_nonASCII = /[^\0-\x7F]/g,
    re_astralSymbols = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;

function singleCharReplacer(c) {
    return (
        "&#x" +
        c
            .charCodeAt(0)
            .toString(16)
            .toUpperCase() +
        ";"
    );
}

function astralReplacer(c) {
    // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
    var high = c.charCodeAt(0);
    var low = c.charCodeAt(1);
    var codePoint = (high - 0xd800) * 0x400 + low - 0xdc00 + 0x10000;
    return "&#x" + codePoint.toString(16).toUpperCase() + ";";
}

function getInverse(inverse, re) {
    function func(name) {
        return inverse[name];
    }

    return function(data) {
        return data
            .replace(re, func)
            .replace(re_astralSymbols, astralReplacer)
            .replace(re_nonASCII, singleCharReplacer);
    };
}

var re_xmlChars = getInverseReplacer(inverseXML);

function escapeXML(data) {
    return data
        .replace(re_xmlChars, singleCharReplacer)
        .replace(re_astralSymbols, astralReplacer)
        .replace(re_nonASCII, singleCharReplacer);
}

exports.escape = escapeXML;

},{"../maps/entities.json":692,"../maps/xml.json":694}],691:[function(require,module,exports){
module.exports={"0":65533,"128":8364,"130":8218,"131":402,"132":8222,"133":8230,"134":8224,"135":8225,"136":710,"137":8240,"138":352,"139":8249,"140":338,"142":381,"145":8216,"146":8217,"147":8220,"148":8221,"149":8226,"150":8211,"151":8212,"152":732,"153":8482,"154":353,"155":8250,"156":339,"158":382,"159":376}
},{}],692:[function(require,module,exports){
module.exports={"Aacute":"\u00C1","aacute":"\u00E1","Abreve":"\u0102","abreve":"\u0103","ac":"\u223E","acd":"\u223F","acE":"\u223E\u0333","Acirc":"\u00C2","acirc":"\u00E2","acute":"\u00B4","Acy":"\u0410","acy":"\u0430","AElig":"\u00C6","aelig":"\u00E6","af":"\u2061","Afr":"\uD835\uDD04","afr":"\uD835\uDD1E","Agrave":"\u00C0","agrave":"\u00E0","alefsym":"\u2135","aleph":"\u2135","Alpha":"\u0391","alpha":"\u03B1","Amacr":"\u0100","amacr":"\u0101","amalg":"\u2A3F","amp":"&","AMP":"&","andand":"\u2A55","And":"\u2A53","and":"\u2227","andd":"\u2A5C","andslope":"\u2A58","andv":"\u2A5A","ang":"\u2220","ange":"\u29A4","angle":"\u2220","angmsdaa":"\u29A8","angmsdab":"\u29A9","angmsdac":"\u29AA","angmsdad":"\u29AB","angmsdae":"\u29AC","angmsdaf":"\u29AD","angmsdag":"\u29AE","angmsdah":"\u29AF","angmsd":"\u2221","angrt":"\u221F","angrtvb":"\u22BE","angrtvbd":"\u299D","angsph":"\u2222","angst":"\u00C5","angzarr":"\u237C","Aogon":"\u0104","aogon":"\u0105","Aopf":"\uD835\uDD38","aopf":"\uD835\uDD52","apacir":"\u2A6F","ap":"\u2248","apE":"\u2A70","ape":"\u224A","apid":"\u224B","apos":"'","ApplyFunction":"\u2061","approx":"\u2248","approxeq":"\u224A","Aring":"\u00C5","aring":"\u00E5","Ascr":"\uD835\uDC9C","ascr":"\uD835\uDCB6","Assign":"\u2254","ast":"*","asymp":"\u2248","asympeq":"\u224D","Atilde":"\u00C3","atilde":"\u00E3","Auml":"\u00C4","auml":"\u00E4","awconint":"\u2233","awint":"\u2A11","backcong":"\u224C","backepsilon":"\u03F6","backprime":"\u2035","backsim":"\u223D","backsimeq":"\u22CD","Backslash":"\u2216","Barv":"\u2AE7","barvee":"\u22BD","barwed":"\u2305","Barwed":"\u2306","barwedge":"\u2305","bbrk":"\u23B5","bbrktbrk":"\u23B6","bcong":"\u224C","Bcy":"\u0411","bcy":"\u0431","bdquo":"\u201E","becaus":"\u2235","because":"\u2235","Because":"\u2235","bemptyv":"\u29B0","bepsi":"\u03F6","bernou":"\u212C","Bernoullis":"\u212C","Beta":"\u0392","beta":"\u03B2","beth":"\u2136","between":"\u226C","Bfr":"\uD835\uDD05","bfr":"\uD835\uDD1F","bigcap":"\u22C2","bigcirc":"\u25EF","bigcup":"\u22C3","bigodot":"\u2A00","bigoplus":"\u2A01","bigotimes":"\u2A02","bigsqcup":"\u2A06","bigstar":"\u2605","bigtriangledown":"\u25BD","bigtriangleup":"\u25B3","biguplus":"\u2A04","bigvee":"\u22C1","bigwedge":"\u22C0","bkarow":"\u290D","blacklozenge":"\u29EB","blacksquare":"\u25AA","blacktriangle":"\u25B4","blacktriangledown":"\u25BE","blacktriangleleft":"\u25C2","blacktriangleright":"\u25B8","blank":"\u2423","blk12":"\u2592","blk14":"\u2591","blk34":"\u2593","block":"\u2588","bne":"=\u20E5","bnequiv":"\u2261\u20E5","bNot":"\u2AED","bnot":"\u2310","Bopf":"\uD835\uDD39","bopf":"\uD835\uDD53","bot":"\u22A5","bottom":"\u22A5","bowtie":"\u22C8","boxbox":"\u29C9","boxdl":"\u2510","boxdL":"\u2555","boxDl":"\u2556","boxDL":"\u2557","boxdr":"\u250C","boxdR":"\u2552","boxDr":"\u2553","boxDR":"\u2554","boxh":"\u2500","boxH":"\u2550","boxhd":"\u252C","boxHd":"\u2564","boxhD":"\u2565","boxHD":"\u2566","boxhu":"\u2534","boxHu":"\u2567","boxhU":"\u2568","boxHU":"\u2569","boxminus":"\u229F","boxplus":"\u229E","boxtimes":"\u22A0","boxul":"\u2518","boxuL":"\u255B","boxUl":"\u255C","boxUL":"\u255D","boxur":"\u2514","boxuR":"\u2558","boxUr":"\u2559","boxUR":"\u255A","boxv":"\u2502","boxV":"\u2551","boxvh":"\u253C","boxvH":"\u256A","boxVh":"\u256B","boxVH":"\u256C","boxvl":"\u2524","boxvL":"\u2561","boxVl":"\u2562","boxVL":"\u2563","boxvr":"\u251C","boxvR":"\u255E","boxVr":"\u255F","boxVR":"\u2560","bprime":"\u2035","breve":"\u02D8","Breve":"\u02D8","brvbar":"\u00A6","bscr":"\uD835\uDCB7","Bscr":"\u212C","bsemi":"\u204F","bsim":"\u223D","bsime":"\u22CD","bsolb":"\u29C5","bsol":"\\","bsolhsub":"\u27C8","bull":"\u2022","bullet":"\u2022","bump":"\u224E","bumpE":"\u2AAE","bumpe":"\u224F","Bumpeq":"\u224E","bumpeq":"\u224F","Cacute":"\u0106","cacute":"\u0107","capand":"\u2A44","capbrcup":"\u2A49","capcap":"\u2A4B","cap":"\u2229","Cap":"\u22D2","capcup":"\u2A47","capdot":"\u2A40","CapitalDifferentialD":"\u2145","caps":"\u2229\uFE00","caret":"\u2041","caron":"\u02C7","Cayleys":"\u212D","ccaps":"\u2A4D","Ccaron":"\u010C","ccaron":"\u010D","Ccedil":"\u00C7","ccedil":"\u00E7","Ccirc":"\u0108","ccirc":"\u0109","Cconint":"\u2230","ccups":"\u2A4C","ccupssm":"\u2A50","Cdot":"\u010A","cdot":"\u010B","cedil":"\u00B8","Cedilla":"\u00B8","cemptyv":"\u29B2","cent":"\u00A2","centerdot":"\u00B7","CenterDot":"\u00B7","cfr":"\uD835\uDD20","Cfr":"\u212D","CHcy":"\u0427","chcy":"\u0447","check":"\u2713","checkmark":"\u2713","Chi":"\u03A7","chi":"\u03C7","circ":"\u02C6","circeq":"\u2257","circlearrowleft":"\u21BA","circlearrowright":"\u21BB","circledast":"\u229B","circledcirc":"\u229A","circleddash":"\u229D","CircleDot":"\u2299","circledR":"\u00AE","circledS":"\u24C8","CircleMinus":"\u2296","CirclePlus":"\u2295","CircleTimes":"\u2297","cir":"\u25CB","cirE":"\u29C3","cire":"\u2257","cirfnint":"\u2A10","cirmid":"\u2AEF","cirscir":"\u29C2","ClockwiseContourIntegral":"\u2232","CloseCurlyDoubleQuote":"\u201D","CloseCurlyQuote":"\u2019","clubs":"\u2663","clubsuit":"\u2663","colon":":","Colon":"\u2237","Colone":"\u2A74","colone":"\u2254","coloneq":"\u2254","comma":",","commat":"@","comp":"\u2201","compfn":"\u2218","complement":"\u2201","complexes":"\u2102","cong":"\u2245","congdot":"\u2A6D","Congruent":"\u2261","conint":"\u222E","Conint":"\u222F","ContourIntegral":"\u222E","copf":"\uD835\uDD54","Copf":"\u2102","coprod":"\u2210","Coproduct":"\u2210","copy":"\u00A9","COPY":"\u00A9","copysr":"\u2117","CounterClockwiseContourIntegral":"\u2233","crarr":"\u21B5","cross":"\u2717","Cross":"\u2A2F","Cscr":"\uD835\uDC9E","cscr":"\uD835\uDCB8","csub":"\u2ACF","csube":"\u2AD1","csup":"\u2AD0","csupe":"\u2AD2","ctdot":"\u22EF","cudarrl":"\u2938","cudarrr":"\u2935","cuepr":"\u22DE","cuesc":"\u22DF","cularr":"\u21B6","cularrp":"\u293D","cupbrcap":"\u2A48","cupcap":"\u2A46","CupCap":"\u224D","cup":"\u222A","Cup":"\u22D3","cupcup":"\u2A4A","cupdot":"\u228D","cupor":"\u2A45","cups":"\u222A\uFE00","curarr":"\u21B7","curarrm":"\u293C","curlyeqprec":"\u22DE","curlyeqsucc":"\u22DF","curlyvee":"\u22CE","curlywedge":"\u22CF","curren":"\u00A4","curvearrowleft":"\u21B6","curvearrowright":"\u21B7","cuvee":"\u22CE","cuwed":"\u22CF","cwconint":"\u2232","cwint":"\u2231","cylcty":"\u232D","dagger":"\u2020","Dagger":"\u2021","daleth":"\u2138","darr":"\u2193","Darr":"\u21A1","dArr":"\u21D3","dash":"\u2010","Dashv":"\u2AE4","dashv":"\u22A3","dbkarow":"\u290F","dblac":"\u02DD","Dcaron":"\u010E","dcaron":"\u010F","Dcy":"\u0414","dcy":"\u0434","ddagger":"\u2021","ddarr":"\u21CA","DD":"\u2145","dd":"\u2146","DDotrahd":"\u2911","ddotseq":"\u2A77","deg":"\u00B0","Del":"\u2207","Delta":"\u0394","delta":"\u03B4","demptyv":"\u29B1","dfisht":"\u297F","Dfr":"\uD835\uDD07","dfr":"\uD835\uDD21","dHar":"\u2965","dharl":"\u21C3","dharr":"\u21C2","DiacriticalAcute":"\u00B4","DiacriticalDot":"\u02D9","DiacriticalDoubleAcute":"\u02DD","DiacriticalGrave":"`","DiacriticalTilde":"\u02DC","diam":"\u22C4","diamond":"\u22C4","Diamond":"\u22C4","diamondsuit":"\u2666","diams":"\u2666","die":"\u00A8","DifferentialD":"\u2146","digamma":"\u03DD","disin":"\u22F2","div":"\u00F7","divide":"\u00F7","divideontimes":"\u22C7","divonx":"\u22C7","DJcy":"\u0402","djcy":"\u0452","dlcorn":"\u231E","dlcrop":"\u230D","dollar":"$","Dopf":"\uD835\uDD3B","dopf":"\uD835\uDD55","Dot":"\u00A8","dot":"\u02D9","DotDot":"\u20DC","doteq":"\u2250","doteqdot":"\u2251","DotEqual":"\u2250","dotminus":"\u2238","dotplus":"\u2214","dotsquare":"\u22A1","doublebarwedge":"\u2306","DoubleContourIntegral":"\u222F","DoubleDot":"\u00A8","DoubleDownArrow":"\u21D3","DoubleLeftArrow":"\u21D0","DoubleLeftRightArrow":"\u21D4","DoubleLeftTee":"\u2AE4","DoubleLongLeftArrow":"\u27F8","DoubleLongLeftRightArrow":"\u27FA","DoubleLongRightArrow":"\u27F9","DoubleRightArrow":"\u21D2","DoubleRightTee":"\u22A8","DoubleUpArrow":"\u21D1","DoubleUpDownArrow":"\u21D5","DoubleVerticalBar":"\u2225","DownArrowBar":"\u2913","downarrow":"\u2193","DownArrow":"\u2193","Downarrow":"\u21D3","DownArrowUpArrow":"\u21F5","DownBreve":"\u0311","downdownarrows":"\u21CA","downharpoonleft":"\u21C3","downharpoonright":"\u21C2","DownLeftRightVector":"\u2950","DownLeftTeeVector":"\u295E","DownLeftVectorBar":"\u2956","DownLeftVector":"\u21BD","DownRightTeeVector":"\u295F","DownRightVectorBar":"\u2957","DownRightVector":"\u21C1","DownTeeArrow":"\u21A7","DownTee":"\u22A4","drbkarow":"\u2910","drcorn":"\u231F","drcrop":"\u230C","Dscr":"\uD835\uDC9F","dscr":"\uD835\uDCB9","DScy":"\u0405","dscy":"\u0455","dsol":"\u29F6","Dstrok":"\u0110","dstrok":"\u0111","dtdot":"\u22F1","dtri":"\u25BF","dtrif":"\u25BE","duarr":"\u21F5","duhar":"\u296F","dwangle":"\u29A6","DZcy":"\u040F","dzcy":"\u045F","dzigrarr":"\u27FF","Eacute":"\u00C9","eacute":"\u00E9","easter":"\u2A6E","Ecaron":"\u011A","ecaron":"\u011B","Ecirc":"\u00CA","ecirc":"\u00EA","ecir":"\u2256","ecolon":"\u2255","Ecy":"\u042D","ecy":"\u044D","eDDot":"\u2A77","Edot":"\u0116","edot":"\u0117","eDot":"\u2251","ee":"\u2147","efDot":"\u2252","Efr":"\uD835\uDD08","efr":"\uD835\uDD22","eg":"\u2A9A","Egrave":"\u00C8","egrave":"\u00E8","egs":"\u2A96","egsdot":"\u2A98","el":"\u2A99","Element":"\u2208","elinters":"\u23E7","ell":"\u2113","els":"\u2A95","elsdot":"\u2A97","Emacr":"\u0112","emacr":"\u0113","empty":"\u2205","emptyset":"\u2205","EmptySmallSquare":"\u25FB","emptyv":"\u2205","EmptyVerySmallSquare":"\u25AB","emsp13":"\u2004","emsp14":"\u2005","emsp":"\u2003","ENG":"\u014A","eng":"\u014B","ensp":"\u2002","Eogon":"\u0118","eogon":"\u0119","Eopf":"\uD835\uDD3C","eopf":"\uD835\uDD56","epar":"\u22D5","eparsl":"\u29E3","eplus":"\u2A71","epsi":"\u03B5","Epsilon":"\u0395","epsilon":"\u03B5","epsiv":"\u03F5","eqcirc":"\u2256","eqcolon":"\u2255","eqsim":"\u2242","eqslantgtr":"\u2A96","eqslantless":"\u2A95","Equal":"\u2A75","equals":"=","EqualTilde":"\u2242","equest":"\u225F","Equilibrium":"\u21CC","equiv":"\u2261","equivDD":"\u2A78","eqvparsl":"\u29E5","erarr":"\u2971","erDot":"\u2253","escr":"\u212F","Escr":"\u2130","esdot":"\u2250","Esim":"\u2A73","esim":"\u2242","Eta":"\u0397","eta":"\u03B7","ETH":"\u00D0","eth":"\u00F0","Euml":"\u00CB","euml":"\u00EB","euro":"\u20AC","excl":"!","exist":"\u2203","Exists":"\u2203","expectation":"\u2130","exponentiale":"\u2147","ExponentialE":"\u2147","fallingdotseq":"\u2252","Fcy":"\u0424","fcy":"\u0444","female":"\u2640","ffilig":"\uFB03","fflig":"\uFB00","ffllig":"\uFB04","Ffr":"\uD835\uDD09","ffr":"\uD835\uDD23","filig":"\uFB01","FilledSmallSquare":"\u25FC","FilledVerySmallSquare":"\u25AA","fjlig":"fj","flat":"\u266D","fllig":"\uFB02","fltns":"\u25B1","fnof":"\u0192","Fopf":"\uD835\uDD3D","fopf":"\uD835\uDD57","forall":"\u2200","ForAll":"\u2200","fork":"\u22D4","forkv":"\u2AD9","Fouriertrf":"\u2131","fpartint":"\u2A0D","frac12":"\u00BD","frac13":"\u2153","frac14":"\u00BC","frac15":"\u2155","frac16":"\u2159","frac18":"\u215B","frac23":"\u2154","frac25":"\u2156","frac34":"\u00BE","frac35":"\u2157","frac38":"\u215C","frac45":"\u2158","frac56":"\u215A","frac58":"\u215D","frac78":"\u215E","frasl":"\u2044","frown":"\u2322","fscr":"\uD835\uDCBB","Fscr":"\u2131","gacute":"\u01F5","Gamma":"\u0393","gamma":"\u03B3","Gammad":"\u03DC","gammad":"\u03DD","gap":"\u2A86","Gbreve":"\u011E","gbreve":"\u011F","Gcedil":"\u0122","Gcirc":"\u011C","gcirc":"\u011D","Gcy":"\u0413","gcy":"\u0433","Gdot":"\u0120","gdot":"\u0121","ge":"\u2265","gE":"\u2267","gEl":"\u2A8C","gel":"\u22DB","geq":"\u2265","geqq":"\u2267","geqslant":"\u2A7E","gescc":"\u2AA9","ges":"\u2A7E","gesdot":"\u2A80","gesdoto":"\u2A82","gesdotol":"\u2A84","gesl":"\u22DB\uFE00","gesles":"\u2A94","Gfr":"\uD835\uDD0A","gfr":"\uD835\uDD24","gg":"\u226B","Gg":"\u22D9","ggg":"\u22D9","gimel":"\u2137","GJcy":"\u0403","gjcy":"\u0453","gla":"\u2AA5","gl":"\u2277","glE":"\u2A92","glj":"\u2AA4","gnap":"\u2A8A","gnapprox":"\u2A8A","gne":"\u2A88","gnE":"\u2269","gneq":"\u2A88","gneqq":"\u2269","gnsim":"\u22E7","Gopf":"\uD835\uDD3E","gopf":"\uD835\uDD58","grave":"`","GreaterEqual":"\u2265","GreaterEqualLess":"\u22DB","GreaterFullEqual":"\u2267","GreaterGreater":"\u2AA2","GreaterLess":"\u2277","GreaterSlantEqual":"\u2A7E","GreaterTilde":"\u2273","Gscr":"\uD835\uDCA2","gscr":"\u210A","gsim":"\u2273","gsime":"\u2A8E","gsiml":"\u2A90","gtcc":"\u2AA7","gtcir":"\u2A7A","gt":">","GT":">","Gt":"\u226B","gtdot":"\u22D7","gtlPar":"\u2995","gtquest":"\u2A7C","gtrapprox":"\u2A86","gtrarr":"\u2978","gtrdot":"\u22D7","gtreqless":"\u22DB","gtreqqless":"\u2A8C","gtrless":"\u2277","gtrsim":"\u2273","gvertneqq":"\u2269\uFE00","gvnE":"\u2269\uFE00","Hacek":"\u02C7","hairsp":"\u200A","half":"\u00BD","hamilt":"\u210B","HARDcy":"\u042A","hardcy":"\u044A","harrcir":"\u2948","harr":"\u2194","hArr":"\u21D4","harrw":"\u21AD","Hat":"^","hbar":"\u210F","Hcirc":"\u0124","hcirc":"\u0125","hearts":"\u2665","heartsuit":"\u2665","hellip":"\u2026","hercon":"\u22B9","hfr":"\uD835\uDD25","Hfr":"\u210C","HilbertSpace":"\u210B","hksearow":"\u2925","hkswarow":"\u2926","hoarr":"\u21FF","homtht":"\u223B","hookleftarrow":"\u21A9","hookrightarrow":"\u21AA","hopf":"\uD835\uDD59","Hopf":"\u210D","horbar":"\u2015","HorizontalLine":"\u2500","hscr":"\uD835\uDCBD","Hscr":"\u210B","hslash":"\u210F","Hstrok":"\u0126","hstrok":"\u0127","HumpDownHump":"\u224E","HumpEqual":"\u224F","hybull":"\u2043","hyphen":"\u2010","Iacute":"\u00CD","iacute":"\u00ED","ic":"\u2063","Icirc":"\u00CE","icirc":"\u00EE","Icy":"\u0418","icy":"\u0438","Idot":"\u0130","IEcy":"\u0415","iecy":"\u0435","iexcl":"\u00A1","iff":"\u21D4","ifr":"\uD835\uDD26","Ifr":"\u2111","Igrave":"\u00CC","igrave":"\u00EC","ii":"\u2148","iiiint":"\u2A0C","iiint":"\u222D","iinfin":"\u29DC","iiota":"\u2129","IJlig":"\u0132","ijlig":"\u0133","Imacr":"\u012A","imacr":"\u012B","image":"\u2111","ImaginaryI":"\u2148","imagline":"\u2110","imagpart":"\u2111","imath":"\u0131","Im":"\u2111","imof":"\u22B7","imped":"\u01B5","Implies":"\u21D2","incare":"\u2105","in":"\u2208","infin":"\u221E","infintie":"\u29DD","inodot":"\u0131","intcal":"\u22BA","int":"\u222B","Int":"\u222C","integers":"\u2124","Integral":"\u222B","intercal":"\u22BA","Intersection":"\u22C2","intlarhk":"\u2A17","intprod":"\u2A3C","InvisibleComma":"\u2063","InvisibleTimes":"\u2062","IOcy":"\u0401","iocy":"\u0451","Iogon":"\u012E","iogon":"\u012F","Iopf":"\uD835\uDD40","iopf":"\uD835\uDD5A","Iota":"\u0399","iota":"\u03B9","iprod":"\u2A3C","iquest":"\u00BF","iscr":"\uD835\uDCBE","Iscr":"\u2110","isin":"\u2208","isindot":"\u22F5","isinE":"\u22F9","isins":"\u22F4","isinsv":"\u22F3","isinv":"\u2208","it":"\u2062","Itilde":"\u0128","itilde":"\u0129","Iukcy":"\u0406","iukcy":"\u0456","Iuml":"\u00CF","iuml":"\u00EF","Jcirc":"\u0134","jcirc":"\u0135","Jcy":"\u0419","jcy":"\u0439","Jfr":"\uD835\uDD0D","jfr":"\uD835\uDD27","jmath":"\u0237","Jopf":"\uD835\uDD41","jopf":"\uD835\uDD5B","Jscr":"\uD835\uDCA5","jscr":"\uD835\uDCBF","Jsercy":"\u0408","jsercy":"\u0458","Jukcy":"\u0404","jukcy":"\u0454","Kappa":"\u039A","kappa":"\u03BA","kappav":"\u03F0","Kcedil":"\u0136","kcedil":"\u0137","Kcy":"\u041A","kcy":"\u043A","Kfr":"\uD835\uDD0E","kfr":"\uD835\uDD28","kgreen":"\u0138","KHcy":"\u0425","khcy":"\u0445","KJcy":"\u040C","kjcy":"\u045C","Kopf":"\uD835\uDD42","kopf":"\uD835\uDD5C","Kscr":"\uD835\uDCA6","kscr":"\uD835\uDCC0","lAarr":"\u21DA","Lacute":"\u0139","lacute":"\u013A","laemptyv":"\u29B4","lagran":"\u2112","Lambda":"\u039B","lambda":"\u03BB","lang":"\u27E8","Lang":"\u27EA","langd":"\u2991","langle":"\u27E8","lap":"\u2A85","Laplacetrf":"\u2112","laquo":"\u00AB","larrb":"\u21E4","larrbfs":"\u291F","larr":"\u2190","Larr":"\u219E","lArr":"\u21D0","larrfs":"\u291D","larrhk":"\u21A9","larrlp":"\u21AB","larrpl":"\u2939","larrsim":"\u2973","larrtl":"\u21A2","latail":"\u2919","lAtail":"\u291B","lat":"\u2AAB","late":"\u2AAD","lates":"\u2AAD\uFE00","lbarr":"\u290C","lBarr":"\u290E","lbbrk":"\u2772","lbrace":"{","lbrack":"[","lbrke":"\u298B","lbrksld":"\u298F","lbrkslu":"\u298D","Lcaron":"\u013D","lcaron":"\u013E","Lcedil":"\u013B","lcedil":"\u013C","lceil":"\u2308","lcub":"{","Lcy":"\u041B","lcy":"\u043B","ldca":"\u2936","ldquo":"\u201C","ldquor":"\u201E","ldrdhar":"\u2967","ldrushar":"\u294B","ldsh":"\u21B2","le":"\u2264","lE":"\u2266","LeftAngleBracket":"\u27E8","LeftArrowBar":"\u21E4","leftarrow":"\u2190","LeftArrow":"\u2190","Leftarrow":"\u21D0","LeftArrowRightArrow":"\u21C6","leftarrowtail":"\u21A2","LeftCeiling":"\u2308","LeftDoubleBracket":"\u27E6","LeftDownTeeVector":"\u2961","LeftDownVectorBar":"\u2959","LeftDownVector":"\u21C3","LeftFloor":"\u230A","leftharpoondown":"\u21BD","leftharpoonup":"\u21BC","leftleftarrows":"\u21C7","leftrightarrow":"\u2194","LeftRightArrow":"\u2194","Leftrightarrow":"\u21D4","leftrightarrows":"\u21C6","leftrightharpoons":"\u21CB","leftrightsquigarrow":"\u21AD","LeftRightVector":"\u294E","LeftTeeArrow":"\u21A4","LeftTee":"\u22A3","LeftTeeVector":"\u295A","leftthreetimes":"\u22CB","LeftTriangleBar":"\u29CF","LeftTriangle":"\u22B2","LeftTriangleEqual":"\u22B4","LeftUpDownVector":"\u2951","LeftUpTeeVector":"\u2960","LeftUpVectorBar":"\u2958","LeftUpVector":"\u21BF","LeftVectorBar":"\u2952","LeftVector":"\u21BC","lEg":"\u2A8B","leg":"\u22DA","leq":"\u2264","leqq":"\u2266","leqslant":"\u2A7D","lescc":"\u2AA8","les":"\u2A7D","lesdot":"\u2A7F","lesdoto":"\u2A81","lesdotor":"\u2A83","lesg":"\u22DA\uFE00","lesges":"\u2A93","lessapprox":"\u2A85","lessdot":"\u22D6","lesseqgtr":"\u22DA","lesseqqgtr":"\u2A8B","LessEqualGreater":"\u22DA","LessFullEqual":"\u2266","LessGreater":"\u2276","lessgtr":"\u2276","LessLess":"\u2AA1","lesssim":"\u2272","LessSlantEqual":"\u2A7D","LessTilde":"\u2272","lfisht":"\u297C","lfloor":"\u230A","Lfr":"\uD835\uDD0F","lfr":"\uD835\uDD29","lg":"\u2276","lgE":"\u2A91","lHar":"\u2962","lhard":"\u21BD","lharu":"\u21BC","lharul":"\u296A","lhblk":"\u2584","LJcy":"\u0409","ljcy":"\u0459","llarr":"\u21C7","ll":"\u226A","Ll":"\u22D8","llcorner":"\u231E","Lleftarrow":"\u21DA","llhard":"\u296B","lltri":"\u25FA","Lmidot":"\u013F","lmidot":"\u0140","lmoustache":"\u23B0","lmoust":"\u23B0","lnap":"\u2A89","lnapprox":"\u2A89","lne":"\u2A87","lnE":"\u2268","lneq":"\u2A87","lneqq":"\u2268","lnsim":"\u22E6","loang":"\u27EC","loarr":"\u21FD","lobrk":"\u27E6","longleftarrow":"\u27F5","LongLeftArrow":"\u27F5","Longleftarrow":"\u27F8","longleftrightarrow":"\u27F7","LongLeftRightArrow":"\u27F7","Longleftrightarrow":"\u27FA","longmapsto":"\u27FC","longrightarrow":"\u27F6","LongRightArrow":"\u27F6","Longrightarrow":"\u27F9","looparrowleft":"\u21AB","looparrowright":"\u21AC","lopar":"\u2985","Lopf":"\uD835\uDD43","lopf":"\uD835\uDD5D","loplus":"\u2A2D","lotimes":"\u2A34","lowast":"\u2217","lowbar":"_","LowerLeftArrow":"\u2199","LowerRightArrow":"\u2198","loz":"\u25CA","lozenge":"\u25CA","lozf":"\u29EB","lpar":"(","lparlt":"\u2993","lrarr":"\u21C6","lrcorner":"\u231F","lrhar":"\u21CB","lrhard":"\u296D","lrm":"\u200E","lrtri":"\u22BF","lsaquo":"\u2039","lscr":"\uD835\uDCC1","Lscr":"\u2112","lsh":"\u21B0","Lsh":"\u21B0","lsim":"\u2272","lsime":"\u2A8D","lsimg":"\u2A8F","lsqb":"[","lsquo":"\u2018","lsquor":"\u201A","Lstrok":"\u0141","lstrok":"\u0142","ltcc":"\u2AA6","ltcir":"\u2A79","lt":"<","LT":"<","Lt":"\u226A","ltdot":"\u22D6","lthree":"\u22CB","ltimes":"\u22C9","ltlarr":"\u2976","ltquest":"\u2A7B","ltri":"\u25C3","ltrie":"\u22B4","ltrif":"\u25C2","ltrPar":"\u2996","lurdshar":"\u294A","luruhar":"\u2966","lvertneqq":"\u2268\uFE00","lvnE":"\u2268\uFE00","macr":"\u00AF","male":"\u2642","malt":"\u2720","maltese":"\u2720","Map":"\u2905","map":"\u21A6","mapsto":"\u21A6","mapstodown":"\u21A7","mapstoleft":"\u21A4","mapstoup":"\u21A5","marker":"\u25AE","mcomma":"\u2A29","Mcy":"\u041C","mcy":"\u043C","mdash":"\u2014","mDDot":"\u223A","measuredangle":"\u2221","MediumSpace":"\u205F","Mellintrf":"\u2133","Mfr":"\uD835\uDD10","mfr":"\uD835\uDD2A","mho":"\u2127","micro":"\u00B5","midast":"*","midcir":"\u2AF0","mid":"\u2223","middot":"\u00B7","minusb":"\u229F","minus":"\u2212","minusd":"\u2238","minusdu":"\u2A2A","MinusPlus":"\u2213","mlcp":"\u2ADB","mldr":"\u2026","mnplus":"\u2213","models":"\u22A7","Mopf":"\uD835\uDD44","mopf":"\uD835\uDD5E","mp":"\u2213","mscr":"\uD835\uDCC2","Mscr":"\u2133","mstpos":"\u223E","Mu":"\u039C","mu":"\u03BC","multimap":"\u22B8","mumap":"\u22B8","nabla":"\u2207","Nacute":"\u0143","nacute":"\u0144","nang":"\u2220\u20D2","nap":"\u2249","napE":"\u2A70\u0338","napid":"\u224B\u0338","napos":"\u0149","napprox":"\u2249","natural":"\u266E","naturals":"\u2115","natur":"\u266E","nbsp":"\u00A0","nbump":"\u224E\u0338","nbumpe":"\u224F\u0338","ncap":"\u2A43","Ncaron":"\u0147","ncaron":"\u0148","Ncedil":"\u0145","ncedil":"\u0146","ncong":"\u2247","ncongdot":"\u2A6D\u0338","ncup":"\u2A42","Ncy":"\u041D","ncy":"\u043D","ndash":"\u2013","nearhk":"\u2924","nearr":"\u2197","neArr":"\u21D7","nearrow":"\u2197","ne":"\u2260","nedot":"\u2250\u0338","NegativeMediumSpace":"\u200B","NegativeThickSpace":"\u200B","NegativeThinSpace":"\u200B","NegativeVeryThinSpace":"\u200B","nequiv":"\u2262","nesear":"\u2928","nesim":"\u2242\u0338","NestedGreaterGreater":"\u226B","NestedLessLess":"\u226A","NewLine":"\n","nexist":"\u2204","nexists":"\u2204","Nfr":"\uD835\uDD11","nfr":"\uD835\uDD2B","ngE":"\u2267\u0338","nge":"\u2271","ngeq":"\u2271","ngeqq":"\u2267\u0338","ngeqslant":"\u2A7E\u0338","nges":"\u2A7E\u0338","nGg":"\u22D9\u0338","ngsim":"\u2275","nGt":"\u226B\u20D2","ngt":"\u226F","ngtr":"\u226F","nGtv":"\u226B\u0338","nharr":"\u21AE","nhArr":"\u21CE","nhpar":"\u2AF2","ni":"\u220B","nis":"\u22FC","nisd":"\u22FA","niv":"\u220B","NJcy":"\u040A","njcy":"\u045A","nlarr":"\u219A","nlArr":"\u21CD","nldr":"\u2025","nlE":"\u2266\u0338","nle":"\u2270","nleftarrow":"\u219A","nLeftarrow":"\u21CD","nleftrightarrow":"\u21AE","nLeftrightarrow":"\u21CE","nleq":"\u2270","nleqq":"\u2266\u0338","nleqslant":"\u2A7D\u0338","nles":"\u2A7D\u0338","nless":"\u226E","nLl":"\u22D8\u0338","nlsim":"\u2274","nLt":"\u226A\u20D2","nlt":"\u226E","nltri":"\u22EA","nltrie":"\u22EC","nLtv":"\u226A\u0338","nmid":"\u2224","NoBreak":"\u2060","NonBreakingSpace":"\u00A0","nopf":"\uD835\uDD5F","Nopf":"\u2115","Not":"\u2AEC","not":"\u00AC","NotCongruent":"\u2262","NotCupCap":"\u226D","NotDoubleVerticalBar":"\u2226","NotElement":"\u2209","NotEqual":"\u2260","NotEqualTilde":"\u2242\u0338","NotExists":"\u2204","NotGreater":"\u226F","NotGreaterEqual":"\u2271","NotGreaterFullEqual":"\u2267\u0338","NotGreaterGreater":"\u226B\u0338","NotGreaterLess":"\u2279","NotGreaterSlantEqual":"\u2A7E\u0338","NotGreaterTilde":"\u2275","NotHumpDownHump":"\u224E\u0338","NotHumpEqual":"\u224F\u0338","notin":"\u2209","notindot":"\u22F5\u0338","notinE":"\u22F9\u0338","notinva":"\u2209","notinvb":"\u22F7","notinvc":"\u22F6","NotLeftTriangleBar":"\u29CF\u0338","NotLeftTriangle":"\u22EA","NotLeftTriangleEqual":"\u22EC","NotLess":"\u226E","NotLessEqual":"\u2270","NotLessGreater":"\u2278","NotLessLess":"\u226A\u0338","NotLessSlantEqual":"\u2A7D\u0338","NotLessTilde":"\u2274","NotNestedGreaterGreater":"\u2AA2\u0338","NotNestedLessLess":"\u2AA1\u0338","notni":"\u220C","notniva":"\u220C","notnivb":"\u22FE","notnivc":"\u22FD","NotPrecedes":"\u2280","NotPrecedesEqual":"\u2AAF\u0338","NotPrecedesSlantEqual":"\u22E0","NotReverseElement":"\u220C","NotRightTriangleBar":"\u29D0\u0338","NotRightTriangle":"\u22EB","NotRightTriangleEqual":"\u22ED","NotSquareSubset":"\u228F\u0338","NotSquareSubsetEqual":"\u22E2","NotSquareSuperset":"\u2290\u0338","NotSquareSupersetEqual":"\u22E3","NotSubset":"\u2282\u20D2","NotSubsetEqual":"\u2288","NotSucceeds":"\u2281","NotSucceedsEqual":"\u2AB0\u0338","NotSucceedsSlantEqual":"\u22E1","NotSucceedsTilde":"\u227F\u0338","NotSuperset":"\u2283\u20D2","NotSupersetEqual":"\u2289","NotTilde":"\u2241","NotTildeEqual":"\u2244","NotTildeFullEqual":"\u2247","NotTildeTilde":"\u2249","NotVerticalBar":"\u2224","nparallel":"\u2226","npar":"\u2226","nparsl":"\u2AFD\u20E5","npart":"\u2202\u0338","npolint":"\u2A14","npr":"\u2280","nprcue":"\u22E0","nprec":"\u2280","npreceq":"\u2AAF\u0338","npre":"\u2AAF\u0338","nrarrc":"\u2933\u0338","nrarr":"\u219B","nrArr":"\u21CF","nrarrw":"\u219D\u0338","nrightarrow":"\u219B","nRightarrow":"\u21CF","nrtri":"\u22EB","nrtrie":"\u22ED","nsc":"\u2281","nsccue":"\u22E1","nsce":"\u2AB0\u0338","Nscr":"\uD835\uDCA9","nscr":"\uD835\uDCC3","nshortmid":"\u2224","nshortparallel":"\u2226","nsim":"\u2241","nsime":"\u2244","nsimeq":"\u2244","nsmid":"\u2224","nspar":"\u2226","nsqsube":"\u22E2","nsqsupe":"\u22E3","nsub":"\u2284","nsubE":"\u2AC5\u0338","nsube":"\u2288","nsubset":"\u2282\u20D2","nsubseteq":"\u2288","nsubseteqq":"\u2AC5\u0338","nsucc":"\u2281","nsucceq":"\u2AB0\u0338","nsup":"\u2285","nsupE":"\u2AC6\u0338","nsupe":"\u2289","nsupset":"\u2283\u20D2","nsupseteq":"\u2289","nsupseteqq":"\u2AC6\u0338","ntgl":"\u2279","Ntilde":"\u00D1","ntilde":"\u00F1","ntlg":"\u2278","ntriangleleft":"\u22EA","ntrianglelefteq":"\u22EC","ntriangleright":"\u22EB","ntrianglerighteq":"\u22ED","Nu":"\u039D","nu":"\u03BD","num":"#","numero":"\u2116","numsp":"\u2007","nvap":"\u224D\u20D2","nvdash":"\u22AC","nvDash":"\u22AD","nVdash":"\u22AE","nVDash":"\u22AF","nvge":"\u2265\u20D2","nvgt":">\u20D2","nvHarr":"\u2904","nvinfin":"\u29DE","nvlArr":"\u2902","nvle":"\u2264\u20D2","nvlt":"<\u20D2","nvltrie":"\u22B4\u20D2","nvrArr":"\u2903","nvrtrie":"\u22B5\u20D2","nvsim":"\u223C\u20D2","nwarhk":"\u2923","nwarr":"\u2196","nwArr":"\u21D6","nwarrow":"\u2196","nwnear":"\u2927","Oacute":"\u00D3","oacute":"\u00F3","oast":"\u229B","Ocirc":"\u00D4","ocirc":"\u00F4","ocir":"\u229A","Ocy":"\u041E","ocy":"\u043E","odash":"\u229D","Odblac":"\u0150","odblac":"\u0151","odiv":"\u2A38","odot":"\u2299","odsold":"\u29BC","OElig":"\u0152","oelig":"\u0153","ofcir":"\u29BF","Ofr":"\uD835\uDD12","ofr":"\uD835\uDD2C","ogon":"\u02DB","Ograve":"\u00D2","ograve":"\u00F2","ogt":"\u29C1","ohbar":"\u29B5","ohm":"\u03A9","oint":"\u222E","olarr":"\u21BA","olcir":"\u29BE","olcross":"\u29BB","oline":"\u203E","olt":"\u29C0","Omacr":"\u014C","omacr":"\u014D","Omega":"\u03A9","omega":"\u03C9","Omicron":"\u039F","omicron":"\u03BF","omid":"\u29B6","ominus":"\u2296","Oopf":"\uD835\uDD46","oopf":"\uD835\uDD60","opar":"\u29B7","OpenCurlyDoubleQuote":"\u201C","OpenCurlyQuote":"\u2018","operp":"\u29B9","oplus":"\u2295","orarr":"\u21BB","Or":"\u2A54","or":"\u2228","ord":"\u2A5D","order":"\u2134","orderof":"\u2134","ordf":"\u00AA","ordm":"\u00BA","origof":"\u22B6","oror":"\u2A56","orslope":"\u2A57","orv":"\u2A5B","oS":"\u24C8","Oscr":"\uD835\uDCAA","oscr":"\u2134","Oslash":"\u00D8","oslash":"\u00F8","osol":"\u2298","Otilde":"\u00D5","otilde":"\u00F5","otimesas":"\u2A36","Otimes":"\u2A37","otimes":"\u2297","Ouml":"\u00D6","ouml":"\u00F6","ovbar":"\u233D","OverBar":"\u203E","OverBrace":"\u23DE","OverBracket":"\u23B4","OverParenthesis":"\u23DC","para":"\u00B6","parallel":"\u2225","par":"\u2225","parsim":"\u2AF3","parsl":"\u2AFD","part":"\u2202","PartialD":"\u2202","Pcy":"\u041F","pcy":"\u043F","percnt":"%","period":".","permil":"\u2030","perp":"\u22A5","pertenk":"\u2031","Pfr":"\uD835\uDD13","pfr":"\uD835\uDD2D","Phi":"\u03A6","phi":"\u03C6","phiv":"\u03D5","phmmat":"\u2133","phone":"\u260E","Pi":"\u03A0","pi":"\u03C0","pitchfork":"\u22D4","piv":"\u03D6","planck":"\u210F","planckh":"\u210E","plankv":"\u210F","plusacir":"\u2A23","plusb":"\u229E","pluscir":"\u2A22","plus":"+","plusdo":"\u2214","plusdu":"\u2A25","pluse":"\u2A72","PlusMinus":"\u00B1","plusmn":"\u00B1","plussim":"\u2A26","plustwo":"\u2A27","pm":"\u00B1","Poincareplane":"\u210C","pointint":"\u2A15","popf":"\uD835\uDD61","Popf":"\u2119","pound":"\u00A3","prap":"\u2AB7","Pr":"\u2ABB","pr":"\u227A","prcue":"\u227C","precapprox":"\u2AB7","prec":"\u227A","preccurlyeq":"\u227C","Precedes":"\u227A","PrecedesEqual":"\u2AAF","PrecedesSlantEqual":"\u227C","PrecedesTilde":"\u227E","preceq":"\u2AAF","precnapprox":"\u2AB9","precneqq":"\u2AB5","precnsim":"\u22E8","pre":"\u2AAF","prE":"\u2AB3","precsim":"\u227E","prime":"\u2032","Prime":"\u2033","primes":"\u2119","prnap":"\u2AB9","prnE":"\u2AB5","prnsim":"\u22E8","prod":"\u220F","Product":"\u220F","profalar":"\u232E","profline":"\u2312","profsurf":"\u2313","prop":"\u221D","Proportional":"\u221D","Proportion":"\u2237","propto":"\u221D","prsim":"\u227E","prurel":"\u22B0","Pscr":"\uD835\uDCAB","pscr":"\uD835\uDCC5","Psi":"\u03A8","psi":"\u03C8","puncsp":"\u2008","Qfr":"\uD835\uDD14","qfr":"\uD835\uDD2E","qint":"\u2A0C","qopf":"\uD835\uDD62","Qopf":"\u211A","qprime":"\u2057","Qscr":"\uD835\uDCAC","qscr":"\uD835\uDCC6","quaternions":"\u210D","quatint":"\u2A16","quest":"?","questeq":"\u225F","quot":"\"","QUOT":"\"","rAarr":"\u21DB","race":"\u223D\u0331","Racute":"\u0154","racute":"\u0155","radic":"\u221A","raemptyv":"\u29B3","rang":"\u27E9","Rang":"\u27EB","rangd":"\u2992","range":"\u29A5","rangle":"\u27E9","raquo":"\u00BB","rarrap":"\u2975","rarrb":"\u21E5","rarrbfs":"\u2920","rarrc":"\u2933","rarr":"\u2192","Rarr":"\u21A0","rArr":"\u21D2","rarrfs":"\u291E","rarrhk":"\u21AA","rarrlp":"\u21AC","rarrpl":"\u2945","rarrsim":"\u2974","Rarrtl":"\u2916","rarrtl":"\u21A3","rarrw":"\u219D","ratail":"\u291A","rAtail":"\u291C","ratio":"\u2236","rationals":"\u211A","rbarr":"\u290D","rBarr":"\u290F","RBarr":"\u2910","rbbrk":"\u2773","rbrace":"}","rbrack":"]","rbrke":"\u298C","rbrksld":"\u298E","rbrkslu":"\u2990","Rcaron":"\u0158","rcaron":"\u0159","Rcedil":"\u0156","rcedil":"\u0157","rceil":"\u2309","rcub":"}","Rcy":"\u0420","rcy":"\u0440","rdca":"\u2937","rdldhar":"\u2969","rdquo":"\u201D","rdquor":"\u201D","rdsh":"\u21B3","real":"\u211C","realine":"\u211B","realpart":"\u211C","reals":"\u211D","Re":"\u211C","rect":"\u25AD","reg":"\u00AE","REG":"\u00AE","ReverseElement":"\u220B","ReverseEquilibrium":"\u21CB","ReverseUpEquilibrium":"\u296F","rfisht":"\u297D","rfloor":"\u230B","rfr":"\uD835\uDD2F","Rfr":"\u211C","rHar":"\u2964","rhard":"\u21C1","rharu":"\u21C0","rharul":"\u296C","Rho":"\u03A1","rho":"\u03C1","rhov":"\u03F1","RightAngleBracket":"\u27E9","RightArrowBar":"\u21E5","rightarrow":"\u2192","RightArrow":"\u2192","Rightarrow":"\u21D2","RightArrowLeftArrow":"\u21C4","rightarrowtail":"\u21A3","RightCeiling":"\u2309","RightDoubleBracket":"\u27E7","RightDownTeeVector":"\u295D","RightDownVectorBar":"\u2955","RightDownVector":"\u21C2","RightFloor":"\u230B","rightharpoondown":"\u21C1","rightharpoonup":"\u21C0","rightleftarrows":"\u21C4","rightleftharpoons":"\u21CC","rightrightarrows":"\u21C9","rightsquigarrow":"\u219D","RightTeeArrow":"\u21A6","RightTee":"\u22A2","RightTeeVector":"\u295B","rightthreetimes":"\u22CC","RightTriangleBar":"\u29D0","RightTriangle":"\u22B3","RightTriangleEqual":"\u22B5","RightUpDownVector":"\u294F","RightUpTeeVector":"\u295C","RightUpVectorBar":"\u2954","RightUpVector":"\u21BE","RightVectorBar":"\u2953","RightVector":"\u21C0","ring":"\u02DA","risingdotseq":"\u2253","rlarr":"\u21C4","rlhar":"\u21CC","rlm":"\u200F","rmoustache":"\u23B1","rmoust":"\u23B1","rnmid":"\u2AEE","roang":"\u27ED","roarr":"\u21FE","robrk":"\u27E7","ropar":"\u2986","ropf":"\uD835\uDD63","Ropf":"\u211D","roplus":"\u2A2E","rotimes":"\u2A35","RoundImplies":"\u2970","rpar":")","rpargt":"\u2994","rppolint":"\u2A12","rrarr":"\u21C9","Rrightarrow":"\u21DB","rsaquo":"\u203A","rscr":"\uD835\uDCC7","Rscr":"\u211B","rsh":"\u21B1","Rsh":"\u21B1","rsqb":"]","rsquo":"\u2019","rsquor":"\u2019","rthree":"\u22CC","rtimes":"\u22CA","rtri":"\u25B9","rtrie":"\u22B5","rtrif":"\u25B8","rtriltri":"\u29CE","RuleDelayed":"\u29F4","ruluhar":"\u2968","rx":"\u211E","Sacute":"\u015A","sacute":"\u015B","sbquo":"\u201A","scap":"\u2AB8","Scaron":"\u0160","scaron":"\u0161","Sc":"\u2ABC","sc":"\u227B","sccue":"\u227D","sce":"\u2AB0","scE":"\u2AB4","Scedil":"\u015E","scedil":"\u015F","Scirc":"\u015C","scirc":"\u015D","scnap":"\u2ABA","scnE":"\u2AB6","scnsim":"\u22E9","scpolint":"\u2A13","scsim":"\u227F","Scy":"\u0421","scy":"\u0441","sdotb":"\u22A1","sdot":"\u22C5","sdote":"\u2A66","searhk":"\u2925","searr":"\u2198","seArr":"\u21D8","searrow":"\u2198","sect":"\u00A7","semi":";","seswar":"\u2929","setminus":"\u2216","setmn":"\u2216","sext":"\u2736","Sfr":"\uD835\uDD16","sfr":"\uD835\uDD30","sfrown":"\u2322","sharp":"\u266F","SHCHcy":"\u0429","shchcy":"\u0449","SHcy":"\u0428","shcy":"\u0448","ShortDownArrow":"\u2193","ShortLeftArrow":"\u2190","shortmid":"\u2223","shortparallel":"\u2225","ShortRightArrow":"\u2192","ShortUpArrow":"\u2191","shy":"\u00AD","Sigma":"\u03A3","sigma":"\u03C3","sigmaf":"\u03C2","sigmav":"\u03C2","sim":"\u223C","simdot":"\u2A6A","sime":"\u2243","simeq":"\u2243","simg":"\u2A9E","simgE":"\u2AA0","siml":"\u2A9D","simlE":"\u2A9F","simne":"\u2246","simplus":"\u2A24","simrarr":"\u2972","slarr":"\u2190","SmallCircle":"\u2218","smallsetminus":"\u2216","smashp":"\u2A33","smeparsl":"\u29E4","smid":"\u2223","smile":"\u2323","smt":"\u2AAA","smte":"\u2AAC","smtes":"\u2AAC\uFE00","SOFTcy":"\u042C","softcy":"\u044C","solbar":"\u233F","solb":"\u29C4","sol":"/","Sopf":"\uD835\uDD4A","sopf":"\uD835\uDD64","spades":"\u2660","spadesuit":"\u2660","spar":"\u2225","sqcap":"\u2293","sqcaps":"\u2293\uFE00","sqcup":"\u2294","sqcups":"\u2294\uFE00","Sqrt":"\u221A","sqsub":"\u228F","sqsube":"\u2291","sqsubset":"\u228F","sqsubseteq":"\u2291","sqsup":"\u2290","sqsupe":"\u2292","sqsupset":"\u2290","sqsupseteq":"\u2292","square":"\u25A1","Square":"\u25A1","SquareIntersection":"\u2293","SquareSubset":"\u228F","SquareSubsetEqual":"\u2291","SquareSuperset":"\u2290","SquareSupersetEqual":"\u2292","SquareUnion":"\u2294","squarf":"\u25AA","squ":"\u25A1","squf":"\u25AA","srarr":"\u2192","Sscr":"\uD835\uDCAE","sscr":"\uD835\uDCC8","ssetmn":"\u2216","ssmile":"\u2323","sstarf":"\u22C6","Star":"\u22C6","star":"\u2606","starf":"\u2605","straightepsilon":"\u03F5","straightphi":"\u03D5","strns":"\u00AF","sub":"\u2282","Sub":"\u22D0","subdot":"\u2ABD","subE":"\u2AC5","sube":"\u2286","subedot":"\u2AC3","submult":"\u2AC1","subnE":"\u2ACB","subne":"\u228A","subplus":"\u2ABF","subrarr":"\u2979","subset":"\u2282","Subset":"\u22D0","subseteq":"\u2286","subseteqq":"\u2AC5","SubsetEqual":"\u2286","subsetneq":"\u228A","subsetneqq":"\u2ACB","subsim":"\u2AC7","subsub":"\u2AD5","subsup":"\u2AD3","succapprox":"\u2AB8","succ":"\u227B","succcurlyeq":"\u227D","Succeeds":"\u227B","SucceedsEqual":"\u2AB0","SucceedsSlantEqual":"\u227D","SucceedsTilde":"\u227F","succeq":"\u2AB0","succnapprox":"\u2ABA","succneqq":"\u2AB6","succnsim":"\u22E9","succsim":"\u227F","SuchThat":"\u220B","sum":"\u2211","Sum":"\u2211","sung":"\u266A","sup1":"\u00B9","sup2":"\u00B2","sup3":"\u00B3","sup":"\u2283","Sup":"\u22D1","supdot":"\u2ABE","supdsub":"\u2AD8","supE":"\u2AC6","supe":"\u2287","supedot":"\u2AC4","Superset":"\u2283","SupersetEqual":"\u2287","suphsol":"\u27C9","suphsub":"\u2AD7","suplarr":"\u297B","supmult":"\u2AC2","supnE":"\u2ACC","supne":"\u228B","supplus":"\u2AC0","supset":"\u2283","Supset":"\u22D1","supseteq":"\u2287","supseteqq":"\u2AC6","supsetneq":"\u228B","supsetneqq":"\u2ACC","supsim":"\u2AC8","supsub":"\u2AD4","supsup":"\u2AD6","swarhk":"\u2926","swarr":"\u2199","swArr":"\u21D9","swarrow":"\u2199","swnwar":"\u292A","szlig":"\u00DF","Tab":"\t","target":"\u2316","Tau":"\u03A4","tau":"\u03C4","tbrk":"\u23B4","Tcaron":"\u0164","tcaron":"\u0165","Tcedil":"\u0162","tcedil":"\u0163","Tcy":"\u0422","tcy":"\u0442","tdot":"\u20DB","telrec":"\u2315","Tfr":"\uD835\uDD17","tfr":"\uD835\uDD31","there4":"\u2234","therefore":"\u2234","Therefore":"\u2234","Theta":"\u0398","theta":"\u03B8","thetasym":"\u03D1","thetav":"\u03D1","thickapprox":"\u2248","thicksim":"\u223C","ThickSpace":"\u205F\u200A","ThinSpace":"\u2009","thinsp":"\u2009","thkap":"\u2248","thksim":"\u223C","THORN":"\u00DE","thorn":"\u00FE","tilde":"\u02DC","Tilde":"\u223C","TildeEqual":"\u2243","TildeFullEqual":"\u2245","TildeTilde":"\u2248","timesbar":"\u2A31","timesb":"\u22A0","times":"\u00D7","timesd":"\u2A30","tint":"\u222D","toea":"\u2928","topbot":"\u2336","topcir":"\u2AF1","top":"\u22A4","Topf":"\uD835\uDD4B","topf":"\uD835\uDD65","topfork":"\u2ADA","tosa":"\u2929","tprime":"\u2034","trade":"\u2122","TRADE":"\u2122","triangle":"\u25B5","triangledown":"\u25BF","triangleleft":"\u25C3","trianglelefteq":"\u22B4","triangleq":"\u225C","triangleright":"\u25B9","trianglerighteq":"\u22B5","tridot":"\u25EC","trie":"\u225C","triminus":"\u2A3A","TripleDot":"\u20DB","triplus":"\u2A39","trisb":"\u29CD","tritime":"\u2A3B","trpezium":"\u23E2","Tscr":"\uD835\uDCAF","tscr":"\uD835\uDCC9","TScy":"\u0426","tscy":"\u0446","TSHcy":"\u040B","tshcy":"\u045B","Tstrok":"\u0166","tstrok":"\u0167","twixt":"\u226C","twoheadleftarrow":"\u219E","twoheadrightarrow":"\u21A0","Uacute":"\u00DA","uacute":"\u00FA","uarr":"\u2191","Uarr":"\u219F","uArr":"\u21D1","Uarrocir":"\u2949","Ubrcy":"\u040E","ubrcy":"\u045E","Ubreve":"\u016C","ubreve":"\u016D","Ucirc":"\u00DB","ucirc":"\u00FB","Ucy":"\u0423","ucy":"\u0443","udarr":"\u21C5","Udblac":"\u0170","udblac":"\u0171","udhar":"\u296E","ufisht":"\u297E","Ufr":"\uD835\uDD18","ufr":"\uD835\uDD32","Ugrave":"\u00D9","ugrave":"\u00F9","uHar":"\u2963","uharl":"\u21BF","uharr":"\u21BE","uhblk":"\u2580","ulcorn":"\u231C","ulcorner":"\u231C","ulcrop":"\u230F","ultri":"\u25F8","Umacr":"\u016A","umacr":"\u016B","uml":"\u00A8","UnderBar":"_","UnderBrace":"\u23DF","UnderBracket":"\u23B5","UnderParenthesis":"\u23DD","Union":"\u22C3","UnionPlus":"\u228E","Uogon":"\u0172","uogon":"\u0173","Uopf":"\uD835\uDD4C","uopf":"\uD835\uDD66","UpArrowBar":"\u2912","uparrow":"\u2191","UpArrow":"\u2191","Uparrow":"\u21D1","UpArrowDownArrow":"\u21C5","updownarrow":"\u2195","UpDownArrow":"\u2195","Updownarrow":"\u21D5","UpEquilibrium":"\u296E","upharpoonleft":"\u21BF","upharpoonright":"\u21BE","uplus":"\u228E","UpperLeftArrow":"\u2196","UpperRightArrow":"\u2197","upsi":"\u03C5","Upsi":"\u03D2","upsih":"\u03D2","Upsilon":"\u03A5","upsilon":"\u03C5","UpTeeArrow":"\u21A5","UpTee":"\u22A5","upuparrows":"\u21C8","urcorn":"\u231D","urcorner":"\u231D","urcrop":"\u230E","Uring":"\u016E","uring":"\u016F","urtri":"\u25F9","Uscr":"\uD835\uDCB0","uscr":"\uD835\uDCCA","utdot":"\u22F0","Utilde":"\u0168","utilde":"\u0169","utri":"\u25B5","utrif":"\u25B4","uuarr":"\u21C8","Uuml":"\u00DC","uuml":"\u00FC","uwangle":"\u29A7","vangrt":"\u299C","varepsilon":"\u03F5","varkappa":"\u03F0","varnothing":"\u2205","varphi":"\u03D5","varpi":"\u03D6","varpropto":"\u221D","varr":"\u2195","vArr":"\u21D5","varrho":"\u03F1","varsigma":"\u03C2","varsubsetneq":"\u228A\uFE00","varsubsetneqq":"\u2ACB\uFE00","varsupsetneq":"\u228B\uFE00","varsupsetneqq":"\u2ACC\uFE00","vartheta":"\u03D1","vartriangleleft":"\u22B2","vartriangleright":"\u22B3","vBar":"\u2AE8","Vbar":"\u2AEB","vBarv":"\u2AE9","Vcy":"\u0412","vcy":"\u0432","vdash":"\u22A2","vDash":"\u22A8","Vdash":"\u22A9","VDash":"\u22AB","Vdashl":"\u2AE6","veebar":"\u22BB","vee":"\u2228","Vee":"\u22C1","veeeq":"\u225A","vellip":"\u22EE","verbar":"|","Verbar":"\u2016","vert":"|","Vert":"\u2016","VerticalBar":"\u2223","VerticalLine":"|","VerticalSeparator":"\u2758","VerticalTilde":"\u2240","VeryThinSpace":"\u200A","Vfr":"\uD835\uDD19","vfr":"\uD835\uDD33","vltri":"\u22B2","vnsub":"\u2282\u20D2","vnsup":"\u2283\u20D2","Vopf":"\uD835\uDD4D","vopf":"\uD835\uDD67","vprop":"\u221D","vrtri":"\u22B3","Vscr":"\uD835\uDCB1","vscr":"\uD835\uDCCB","vsubnE":"\u2ACB\uFE00","vsubne":"\u228A\uFE00","vsupnE":"\u2ACC\uFE00","vsupne":"\u228B\uFE00","Vvdash":"\u22AA","vzigzag":"\u299A","Wcirc":"\u0174","wcirc":"\u0175","wedbar":"\u2A5F","wedge":"\u2227","Wedge":"\u22C0","wedgeq":"\u2259","weierp":"\u2118","Wfr":"\uD835\uDD1A","wfr":"\uD835\uDD34","Wopf":"\uD835\uDD4E","wopf":"\uD835\uDD68","wp":"\u2118","wr":"\u2240","wreath":"\u2240","Wscr":"\uD835\uDCB2","wscr":"\uD835\uDCCC","xcap":"\u22C2","xcirc":"\u25EF","xcup":"\u22C3","xdtri":"\u25BD","Xfr":"\uD835\uDD1B","xfr":"\uD835\uDD35","xharr":"\u27F7","xhArr":"\u27FA","Xi":"\u039E","xi":"\u03BE","xlarr":"\u27F5","xlArr":"\u27F8","xmap":"\u27FC","xnis":"\u22FB","xodot":"\u2A00","Xopf":"\uD835\uDD4F","xopf":"\uD835\uDD69","xoplus":"\u2A01","xotime":"\u2A02","xrarr":"\u27F6","xrArr":"\u27F9","Xscr":"\uD835\uDCB3","xscr":"\uD835\uDCCD","xsqcup":"\u2A06","xuplus":"\u2A04","xutri":"\u25B3","xvee":"\u22C1","xwedge":"\u22C0","Yacute":"\u00DD","yacute":"\u00FD","YAcy":"\u042F","yacy":"\u044F","Ycirc":"\u0176","ycirc":"\u0177","Ycy":"\u042B","ycy":"\u044B","yen":"\u00A5","Yfr":"\uD835\uDD1C","yfr":"\uD835\uDD36","YIcy":"\u0407","yicy":"\u0457","Yopf":"\uD835\uDD50","yopf":"\uD835\uDD6A","Yscr":"\uD835\uDCB4","yscr":"\uD835\uDCCE","YUcy":"\u042E","yucy":"\u044E","yuml":"\u00FF","Yuml":"\u0178","Zacute":"\u0179","zacute":"\u017A","Zcaron":"\u017D","zcaron":"\u017E","Zcy":"\u0417","zcy":"\u0437","Zdot":"\u017B","zdot":"\u017C","zeetrf":"\u2128","ZeroWidthSpace":"\u200B","Zeta":"\u0396","zeta":"\u03B6","zfr":"\uD835\uDD37","Zfr":"\u2128","ZHcy":"\u0416","zhcy":"\u0436","zigrarr":"\u21DD","zopf":"\uD835\uDD6B","Zopf":"\u2124","Zscr":"\uD835\uDCB5","zscr":"\uD835\uDCCF","zwj":"\u200D","zwnj":"\u200C"}
},{}],693:[function(require,module,exports){
module.exports={"Aacute":"\u00C1","aacute":"\u00E1","Acirc":"\u00C2","acirc":"\u00E2","acute":"\u00B4","AElig":"\u00C6","aelig":"\u00E6","Agrave":"\u00C0","agrave":"\u00E0","amp":"&","AMP":"&","Aring":"\u00C5","aring":"\u00E5","Atilde":"\u00C3","atilde":"\u00E3","Auml":"\u00C4","auml":"\u00E4","brvbar":"\u00A6","Ccedil":"\u00C7","ccedil":"\u00E7","cedil":"\u00B8","cent":"\u00A2","copy":"\u00A9","COPY":"\u00A9","curren":"\u00A4","deg":"\u00B0","divide":"\u00F7","Eacute":"\u00C9","eacute":"\u00E9","Ecirc":"\u00CA","ecirc":"\u00EA","Egrave":"\u00C8","egrave":"\u00E8","ETH":"\u00D0","eth":"\u00F0","Euml":"\u00CB","euml":"\u00EB","frac12":"\u00BD","frac14":"\u00BC","frac34":"\u00BE","gt":">","GT":">","Iacute":"\u00CD","iacute":"\u00ED","Icirc":"\u00CE","icirc":"\u00EE","iexcl":"\u00A1","Igrave":"\u00CC","igrave":"\u00EC","iquest":"\u00BF","Iuml":"\u00CF","iuml":"\u00EF","laquo":"\u00AB","lt":"<","LT":"<","macr":"\u00AF","micro":"\u00B5","middot":"\u00B7","nbsp":"\u00A0","not":"\u00AC","Ntilde":"\u00D1","ntilde":"\u00F1","Oacute":"\u00D3","oacute":"\u00F3","Ocirc":"\u00D4","ocirc":"\u00F4","Ograve":"\u00D2","ograve":"\u00F2","ordf":"\u00AA","ordm":"\u00BA","Oslash":"\u00D8","oslash":"\u00F8","Otilde":"\u00D5","otilde":"\u00F5","Ouml":"\u00D6","ouml":"\u00F6","para":"\u00B6","plusmn":"\u00B1","pound":"\u00A3","quot":"\"","QUOT":"\"","raquo":"\u00BB","reg":"\u00AE","REG":"\u00AE","sect":"\u00A7","shy":"\u00AD","sup1":"\u00B9","sup2":"\u00B2","sup3":"\u00B3","szlig":"\u00DF","THORN":"\u00DE","thorn":"\u00FE","times":"\u00D7","Uacute":"\u00DA","uacute":"\u00FA","Ucirc":"\u00DB","ucirc":"\u00FB","Ugrave":"\u00D9","ugrave":"\u00F9","uml":"\u00A8","Uuml":"\u00DC","uuml":"\u00FC","Yacute":"\u00DD","yacute":"\u00FD","yen":"\u00A5","yuml":"\u00FF"}
},{}],694:[function(require,module,exports){
module.exports={"amp":"&","apos":"'","gt":">","lt":"<","quot":"\""}

},{}],695:[function(require,module,exports){
'use strict';

var util = require('util');
var isArrayish = require('is-arrayish');

var errorEx = function errorEx(name, properties) {
	if (!name || name.constructor !== String) {
		properties = name || {};
		name = Error.name;
	}

	var errorExError = function ErrorEXError(message) {
		if (!this) {
			return new ErrorEXError(message);
		}

		message = message instanceof Error
			? message.message
			: (message || this.message);

		Error.call(this, message);
		Error.captureStackTrace(this, errorExError);

		this.name = name;

		Object.defineProperty(this, 'message', {
			configurable: true,
			enumerable: false,
			get: function () {
				var newMessage = message.split(/\r?\n/g);

				for (var key in properties) {
					if (!properties.hasOwnProperty(key)) {
						continue;
					}

					var modifier = properties[key];

					if ('message' in modifier) {
						newMessage = modifier.message(this[key], newMessage) || newMessage;
						if (!isArrayish(newMessage)) {
							newMessage = [newMessage];
						}
					}
				}

				return newMessage.join('\n');
			},
			set: function (v) {
				message = v;
			}
		});

		var overwrittenStack = null;

		var stackDescriptor = Object.getOwnPropertyDescriptor(this, 'stack');
		var stackGetter = stackDescriptor.get;
		var stackValue = stackDescriptor.value;
		delete stackDescriptor.value;
		delete stackDescriptor.writable;

		stackDescriptor.set = function (newstack) {
			overwrittenStack = newstack;
		};

		stackDescriptor.get = function () {
			var stack = (overwrittenStack || ((stackGetter)
				? stackGetter.call(this)
				: stackValue)).split(/\r?\n+/g);

			// starting in Node 7, the stack builder caches the message.
			// just replace it.
			if (!overwrittenStack) {
				stack[0] = this.name + ': ' + this.message;
			}

			var lineCount = 1;
			for (var key in properties) {
				if (!properties.hasOwnProperty(key)) {
					continue;
				}

				var modifier = properties[key];

				if ('line' in modifier) {
					var line = modifier.line(this[key]);
					if (line) {
						stack.splice(lineCount++, 0, '    ' + line);
					}
				}

				if ('stack' in modifier) {
					modifier.stack(this[key], stack);
				}
			}

			return stack.join('\n');
		};

		Object.defineProperty(this, 'stack', stackDescriptor);
	};

	if (Object.setPrototypeOf) {
		Object.setPrototypeOf(errorExError.prototype, Error.prototype);
		Object.setPrototypeOf(errorExError, Error);
	} else {
		util.inherits(errorExError, Error);
	}

	return errorExError;
};

errorEx.append = function (str, def) {
	return {
		message: function (v, message) {
			v = v || def;

			if (v) {
				message[0] += ' ' + str.replace('%s', v.toString());
			}

			return message;
		}
	};
};

errorEx.line = function (str, def) {
	return {
		line: function (v) {
			v = v || def;

			if (v) {
				return str.replace('%s', v.toString());
			}

			return null;
		}
	};
};

module.exports = errorEx;

},{"is-arrayish":730,"util":1204}],696:[function(require,module,exports){
'use strict';

/* globals
	Set,
	Map,
	WeakSet,
	WeakMap,

	Promise,

	Symbol,
	Proxy,

	Atomics,
	SharedArrayBuffer,

	ArrayBuffer,
	DataView,
	Uint8Array,
	Float32Array,
	Float64Array,
	Int8Array,
	Int16Array,
	Int32Array,
	Uint8ClampedArray,
	Uint16Array,
	Uint32Array,
*/

var undefined; // eslint-disable-line no-shadow-restricted-names

var ThrowTypeError = Object.getOwnPropertyDescriptor
	? (function () { return Object.getOwnPropertyDescriptor(arguments, 'callee').get; }())
	: function () { throw new TypeError(); };

var hasSymbols = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol';

var getProto = Object.getPrototypeOf || function (x) { return x.__proto__; }; // eslint-disable-line no-proto

var generator; // = function * () {};
var generatorFunction = generator ? getProto(generator) : undefined;
var asyncFn; // async function() {};
var asyncFunction = asyncFn ? asyncFn.constructor : undefined;
var asyncGen; // async function * () {};
var asyncGenFunction = asyncGen ? getProto(asyncGen) : undefined;
var asyncGenIterator = asyncGen ? asyncGen() : undefined;

var TypedArray = typeof Uint8Array === 'undefined' ? undefined : getProto(Uint8Array);

var INTRINSICS = {
	'$ %Array%': Array,
	'$ %ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,
	'$ %ArrayBufferPrototype%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer.prototype,
	'$ %ArrayIteratorPrototype%': hasSymbols ? getProto([][Symbol.iterator]()) : undefined,
	'$ %ArrayPrototype%': Array.prototype,
	'$ %ArrayProto_entries%': Array.prototype.entries,
	'$ %ArrayProto_forEach%': Array.prototype.forEach,
	'$ %ArrayProto_keys%': Array.prototype.keys,
	'$ %ArrayProto_values%': Array.prototype.values,
	'$ %AsyncFromSyncIteratorPrototype%': undefined,
	'$ %AsyncFunction%': asyncFunction,
	'$ %AsyncFunctionPrototype%': asyncFunction ? asyncFunction.prototype : undefined,
	'$ %AsyncGenerator%': asyncGen ? getProto(asyncGenIterator) : undefined,
	'$ %AsyncGeneratorFunction%': asyncGenFunction,
	'$ %AsyncGeneratorPrototype%': asyncGenFunction ? asyncGenFunction.prototype : undefined,
	'$ %AsyncIteratorPrototype%': asyncGenIterator && hasSymbols && Symbol.asyncIterator ? asyncGenIterator[Symbol.asyncIterator]() : undefined,
	'$ %Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,
	'$ %Boolean%': Boolean,
	'$ %BooleanPrototype%': Boolean.prototype,
	'$ %DataView%': typeof DataView === 'undefined' ? undefined : DataView,
	'$ %DataViewPrototype%': typeof DataView === 'undefined' ? undefined : DataView.prototype,
	'$ %Date%': Date,
	'$ %DatePrototype%': Date.prototype,
	'$ %decodeURI%': decodeURI,
	'$ %decodeURIComponent%': decodeURIComponent,
	'$ %encodeURI%': encodeURI,
	'$ %encodeURIComponent%': encodeURIComponent,
	'$ %Error%': Error,
	'$ %ErrorPrototype%': Error.prototype,
	'$ %eval%': eval, // eslint-disable-line no-eval
	'$ %EvalError%': EvalError,
	'$ %EvalErrorPrototype%': EvalError.prototype,
	'$ %Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,
	'$ %Float32ArrayPrototype%': typeof Float32Array === 'undefined' ? undefined : Float32Array.prototype,
	'$ %Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,
	'$ %Float64ArrayPrototype%': typeof Float64Array === 'undefined' ? undefined : Float64Array.prototype,
	'$ %Function%': Function,
	'$ %FunctionPrototype%': Function.prototype,
	'$ %Generator%': generator ? getProto(generator()) : undefined,
	'$ %GeneratorFunction%': generatorFunction,
	'$ %GeneratorPrototype%': generatorFunction ? generatorFunction.prototype : undefined,
	'$ %Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,
	'$ %Int8ArrayPrototype%': typeof Int8Array === 'undefined' ? undefined : Int8Array.prototype,
	'$ %Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,
	'$ %Int16ArrayPrototype%': typeof Int16Array === 'undefined' ? undefined : Int8Array.prototype,
	'$ %Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,
	'$ %Int32ArrayPrototype%': typeof Int32Array === 'undefined' ? undefined : Int32Array.prototype,
	'$ %isFinite%': isFinite,
	'$ %isNaN%': isNaN,
	'$ %IteratorPrototype%': hasSymbols ? getProto(getProto([][Symbol.iterator]())) : undefined,
	'$ %JSON%': JSON,
	'$ %JSONParse%': JSON.parse,
	'$ %Map%': typeof Map === 'undefined' ? undefined : Map,
	'$ %MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols ? undefined : getProto(new Map()[Symbol.iterator]()),
	'$ %MapPrototype%': typeof Map === 'undefined' ? undefined : Map.prototype,
	'$ %Math%': Math,
	'$ %Number%': Number,
	'$ %NumberPrototype%': Number.prototype,
	'$ %Object%': Object,
	'$ %ObjectPrototype%': Object.prototype,
	'$ %ObjProto_toString%': Object.prototype.toString,
	'$ %ObjProto_valueOf%': Object.prototype.valueOf,
	'$ %parseFloat%': parseFloat,
	'$ %parseInt%': parseInt,
	'$ %Promise%': typeof Promise === 'undefined' ? undefined : Promise,
	'$ %PromisePrototype%': typeof Promise === 'undefined' ? undefined : Promise.prototype,
	'$ %PromiseProto_then%': typeof Promise === 'undefined' ? undefined : Promise.prototype.then,
	'$ %Promise_all%': typeof Promise === 'undefined' ? undefined : Promise.all,
	'$ %Promise_reject%': typeof Promise === 'undefined' ? undefined : Promise.reject,
	'$ %Promise_resolve%': typeof Promise === 'undefined' ? undefined : Promise.resolve,
	'$ %Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,
	'$ %RangeError%': RangeError,
	'$ %RangeErrorPrototype%': RangeError.prototype,
	'$ %ReferenceError%': ReferenceError,
	'$ %ReferenceErrorPrototype%': ReferenceError.prototype,
	'$ %Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,
	'$ %RegExp%': RegExp,
	'$ %RegExpPrototype%': RegExp.prototype,
	'$ %Set%': typeof Set === 'undefined' ? undefined : Set,
	'$ %SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols ? undefined : getProto(new Set()[Symbol.iterator]()),
	'$ %SetPrototype%': typeof Set === 'undefined' ? undefined : Set.prototype,
	'$ %SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,
	'$ %SharedArrayBufferPrototype%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer.prototype,
	'$ %String%': String,
	'$ %StringIteratorPrototype%': hasSymbols ? getProto(''[Symbol.iterator]()) : undefined,
	'$ %StringPrototype%': String.prototype,
	'$ %Symbol%': hasSymbols ? Symbol : undefined,
	'$ %SymbolPrototype%': hasSymbols ? Symbol.prototype : undefined,
	'$ %SyntaxError%': SyntaxError,
	'$ %SyntaxErrorPrototype%': SyntaxError.prototype,
	'$ %ThrowTypeError%': ThrowTypeError,
	'$ %TypedArray%': TypedArray,
	'$ %TypedArrayPrototype%': TypedArray ? TypedArray.prototype : undefined,
	'$ %TypeError%': TypeError,
	'$ %TypeErrorPrototype%': TypeError.prototype,
	'$ %Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,
	'$ %Uint8ArrayPrototype%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array.prototype,
	'$ %Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,
	'$ %Uint8ClampedArrayPrototype%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray.prototype,
	'$ %Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,
	'$ %Uint16ArrayPrototype%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array.prototype,
	'$ %Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,
	'$ %Uint32ArrayPrototype%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array.prototype,
	'$ %URIError%': URIError,
	'$ %URIErrorPrototype%': URIError.prototype,
	'$ %WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,
	'$ %WeakMapPrototype%': typeof WeakMap === 'undefined' ? undefined : WeakMap.prototype,
	'$ %WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet,
	'$ %WeakSetPrototype%': typeof WeakSet === 'undefined' ? undefined : WeakSet.prototype
};

module.exports = function GetIntrinsic(name, allowMissing) {
	if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
		throw new TypeError('"allowMissing" argument must be a boolean');
	}

	var key = '$ ' + name;
	if (!(key in INTRINSICS)) {
		throw new SyntaxError('intrinsic ' + name + ' does not exist!');
	}

	// istanbul ignore if // hopefully this is impossible to test :-)
	if (typeof INTRINSICS[key] === 'undefined' && !allowMissing) {
		throw new TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
	}
	return INTRINSICS[key];
};

},{}],697:[function(require,module,exports){
'use strict';

var has = require('has');
var toPrimitive = require('es-to-primitive/es6');
var keys = require('object-keys');

var GetIntrinsic = require('./GetIntrinsic');

var $TypeError = GetIntrinsic('%TypeError%');
var $SyntaxError = GetIntrinsic('%SyntaxError%');
var $Array = GetIntrinsic('%Array%');
var $String = GetIntrinsic('%String%');
var $Object = GetIntrinsic('%Object%');
var $Number = GetIntrinsic('%Number%');
var $Symbol = GetIntrinsic('%Symbol%', true);
var $RegExp = GetIntrinsic('%RegExp%');

var hasSymbols = !!$Symbol;

var assertRecord = require('./helpers/assertRecord');
var $isNaN = require('./helpers/isNaN');
var $isFinite = require('./helpers/isFinite');
var MAX_SAFE_INTEGER = $Number.MAX_SAFE_INTEGER || Math.pow(2, 53) - 1;

var assign = require('./helpers/assign');
var sign = require('./helpers/sign');
var mod = require('./helpers/mod');
var isPrimitive = require('./helpers/isPrimitive');
var parseInteger = parseInt;
var bind = require('function-bind');
var arraySlice = bind.call(Function.call, $Array.prototype.slice);
var strSlice = bind.call(Function.call, $String.prototype.slice);
var isBinary = bind.call(Function.call, $RegExp.prototype.test, /^0b[01]+$/i);
var isOctal = bind.call(Function.call, $RegExp.prototype.test, /^0o[0-7]+$/i);
var regexExec = bind.call(Function.call, $RegExp.prototype.exec);
var nonWS = ['\u0085', '\u200b', '\ufffe'].join('');
var nonWSregex = new $RegExp('[' + nonWS + ']', 'g');
var hasNonWS = bind.call(Function.call, $RegExp.prototype.test, nonWSregex);
var invalidHexLiteral = /^[-+]0x[0-9a-f]+$/i;
var isInvalidHexLiteral = bind.call(Function.call, $RegExp.prototype.test, invalidHexLiteral);
var $charCodeAt = bind.call(Function.call, $String.prototype.charCodeAt);

var toStr = bind.call(Function.call, Object.prototype.toString);

var $NumberValueOf = bind.call(Function.call, GetIntrinsic('%NumberPrototype%').valueOf);
var $BooleanValueOf = bind.call(Function.call, GetIntrinsic('%BooleanPrototype%').valueOf);
var $StringValueOf = bind.call(Function.call, GetIntrinsic('%StringPrototype%').valueOf);
var $DateValueOf = bind.call(Function.call, GetIntrinsic('%DatePrototype%').valueOf);

var $floor = Math.floor;
var $abs = Math.abs;

var $ObjectCreate = Object.create;
var $gOPD = $Object.getOwnPropertyDescriptor;

var $isExtensible = $Object.isExtensible;

var $defineProperty = $Object.defineProperty;

// whitespace from: http://es5.github.io/#x15.5.4.20
// implementation from https://github.com/es-shims/es5-shim/blob/v3.4.0/es5-shim.js#L1304-L1324
var ws = [
	'\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003',
	'\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028',
	'\u2029\uFEFF'
].join('');
var trimRegex = new RegExp('(^[' + ws + ']+)|([' + ws + ']+$)', 'g');
var replace = bind.call(Function.call, $String.prototype.replace);
var trim = function (value) {
	return replace(value, trimRegex, '');
};

var ES5 = require('./es5');

var hasRegExpMatcher = require('is-regex');

// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-abstract-operations
var ES6 = assign(assign({}, ES5), {

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-call-f-v-args
	Call: function Call(F, V) {
		var args = arguments.length > 2 ? arguments[2] : [];
		if (!this.IsCallable(F)) {
			throw new $TypeError(F + ' is not a function');
		}
		return F.apply(V, args);
	},

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-toprimitive
	ToPrimitive: toPrimitive,

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-toboolean
	// ToBoolean: ES5.ToBoolean,

	// https://ecma-international.org/ecma-262/6.0/#sec-tonumber
	ToNumber: function ToNumber(argument) {
		var value = isPrimitive(argument) ? argument : toPrimitive(argument, $Number);
		if (typeof value === 'symbol') {
			throw new $TypeError('Cannot convert a Symbol value to a number');
		}
		if (typeof value === 'string') {
			if (isBinary(value)) {
				return this.ToNumber(parseInteger(strSlice(value, 2), 2));
			} else if (isOctal(value)) {
				return this.ToNumber(parseInteger(strSlice(value, 2), 8));
			} else if (hasNonWS(value) || isInvalidHexLiteral(value)) {
				return NaN;
			} else {
				var trimmed = trim(value);
				if (trimmed !== value) {
					return this.ToNumber(trimmed);
				}
			}
		}
		return $Number(value);
	},

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tointeger
	// ToInteger: ES5.ToNumber,

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-toint32
	// ToInt32: ES5.ToInt32,

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-touint32
	// ToUint32: ES5.ToUint32,

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-toint16
	ToInt16: function ToInt16(argument) {
		var int16bit = this.ToUint16(argument);
		return int16bit >= 0x8000 ? int16bit - 0x10000 : int16bit;
	},

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-touint16
	// ToUint16: ES5.ToUint16,

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-toint8
	ToInt8: function ToInt8(argument) {
		var int8bit = this.ToUint8(argument);
		return int8bit >= 0x80 ? int8bit - 0x100 : int8bit;
	},

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-touint8
	ToUint8: function ToUint8(argument) {
		var number = this.ToNumber(argument);
		if ($isNaN(number) || number === 0 || !$isFinite(number)) { return 0; }
		var posInt = sign(number) * $floor($abs(number));
		return mod(posInt, 0x100);
	},

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-touint8clamp
	ToUint8Clamp: function ToUint8Clamp(argument) {
		var number = this.ToNumber(argument);
		if ($isNaN(number) || number <= 0) { return 0; }
		if (number >= 0xFF) { return 0xFF; }
		var f = $floor(argument);
		if (f + 0.5 < number) { return f + 1; }
		if (number < f + 0.5) { return f; }
		if (f % 2 !== 0) { return f + 1; }
		return f;
	},

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tostring
	ToString: function ToString(argument) {
		if (typeof argument === 'symbol') {
			throw new $TypeError('Cannot convert a Symbol value to a string');
		}
		return $String(argument);
	},

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-toobject
	ToObject: function ToObject(value) {
		this.RequireObjectCoercible(value);
		return $Object(value);
	},

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-topropertykey
	ToPropertyKey: function ToPropertyKey(argument) {
		var key = this.ToPrimitive(argument, $String);
		return typeof key === 'symbol' ? key : this.ToString(key);
	},

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
	ToLength: function ToLength(argument) {
		var len = this.ToInteger(argument);
		if (len <= 0) { return 0; } // includes converting -0 to +0
		if (len > MAX_SAFE_INTEGER) { return MAX_SAFE_INTEGER; }
		return len;
	},

	// https://ecma-international.org/ecma-262/6.0/#sec-canonicalnumericindexstring
	CanonicalNumericIndexString: function CanonicalNumericIndexString(argument) {
		if (toStr(argument) !== '[object String]') {
			throw new $TypeError('must be a string');
		}
		if (argument === '-0') { return -0; }
		var n = this.ToNumber(argument);
		if (this.SameValue(this.ToString(n), argument)) { return n; }
		return void 0;
	},

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-requireobjectcoercible
	RequireObjectCoercible: ES5.CheckObjectCoercible,

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-isarray
	IsArray: $Array.isArray || function IsArray(argument) {
		return toStr(argument) === '[object Array]';
	},

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-iscallable
	// IsCallable: ES5.IsCallable,

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-isconstructor
	IsConstructor: function IsConstructor(argument) {
		return typeof argument === 'function' && !!argument.prototype; // unfortunately there's no way to truly check this without try/catch `new argument`
	},

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-isextensible-o
	IsExtensible: Object.preventExtensions
		? function IsExtensible(obj) {
			if (isPrimitive(obj)) {
				return false;
			}
			return $isExtensible(obj);
		}
		: function isExtensible(obj) { return true; }, // eslint-disable-line no-unused-vars

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-isinteger
	IsInteger: function IsInteger(argument) {
		if (typeof argument !== 'number' || $isNaN(argument) || !$isFinite(argument)) {
			return false;
		}
		var abs = $abs(argument);
		return $floor(abs) === abs;
	},

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-ispropertykey
	IsPropertyKey: function IsPropertyKey(argument) {
		return typeof argument === 'string' || typeof argument === 'symbol';
	},

	// https://ecma-international.org/ecma-262/6.0/#sec-isregexp
	IsRegExp: function IsRegExp(argument) {
		if (!argument || typeof argument !== 'object') {
			return false;
		}
		if (hasSymbols) {
			var isRegExp = argument[$Symbol.match];
			if (typeof isRegExp !== 'undefined') {
				return ES5.ToBoolean(isRegExp);
			}
		}
		return hasRegExpMatcher(argument);
	},

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevalue
	// SameValue: ES5.SameValue,

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero
	SameValueZero: function SameValueZero(x, y) {
		return (x === y) || ($isNaN(x) && $isNaN(y));
	},

	/**
	 * 7.3.2 GetV (V, P)
	 * 1. Assert: IsPropertyKey(P) is true.
	 * 2. Let O be ToObject(V).
	 * 3. ReturnIfAbrupt(O).
	 * 4. Return O.[[Get]](P, V).
	 */
	GetV: function GetV(V, P) {
		// 7.3.2.1
		if (!this.IsPropertyKey(P)) {
			throw new $TypeError('Assertion failed: IsPropertyKey(P) is not true');
		}

		// 7.3.2.2-3
		var O = this.ToObject(V);

		// 7.3.2.4
		return O[P];
	},

	/**
	 * 7.3.9 - https://ecma-international.org/ecma-262/6.0/#sec-getmethod
	 * 1. Assert: IsPropertyKey(P) is true.
	 * 2. Let func be GetV(O, P).
	 * 3. ReturnIfAbrupt(func).
	 * 4. If func is either undefined or null, return undefined.
	 * 5. If IsCallable(func) is false, throw a TypeError exception.
	 * 6. Return func.
	 */
	GetMethod: function GetMethod(O, P) {
		// 7.3.9.1
		if (!this.IsPropertyKey(P)) {
			throw new $TypeError('Assertion failed: IsPropertyKey(P) is not true');
		}

		// 7.3.9.2
		var func = this.GetV(O, P);

		// 7.3.9.4
		if (func == null) {
			return void 0;
		}

		// 7.3.9.5
		if (!this.IsCallable(func)) {
			throw new $TypeError(P + 'is not a function');
		}

		// 7.3.9.6
		return func;
	},

	/**
	 * 7.3.1 Get (O, P) - https://ecma-international.org/ecma-262/6.0/#sec-get-o-p
	 * 1. Assert: Type(O) is Object.
	 * 2. Assert: IsPropertyKey(P) is true.
	 * 3. Return O.[[Get]](P, O).
	 */
	Get: function Get(O, P) {
		// 7.3.1.1
		if (this.Type(O) !== 'Object') {
			throw new $TypeError('Assertion failed: Type(O) is not Object');
		}
		// 7.3.1.2
		if (!this.IsPropertyKey(P)) {
			throw new $TypeError('Assertion failed: IsPropertyKey(P) is not true');
		}
		// 7.3.1.3
		return O[P];
	},

	Type: function Type(x) {
		if (typeof x === 'symbol') {
			return 'Symbol';
		}
		return ES5.Type(x);
	},

	// https://ecma-international.org/ecma-262/6.0/#sec-speciesconstructor
	SpeciesConstructor: function SpeciesConstructor(O, defaultConstructor) {
		if (this.Type(O) !== 'Object') {
			throw new $TypeError('Assertion failed: Type(O) is not Object');
		}
		var C = O.constructor;
		if (typeof C === 'undefined') {
			return defaultConstructor;
		}
		if (this.Type(C) !== 'Object') {
			throw new $TypeError('O.constructor is not an Object');
		}
		var S = hasSymbols && $Symbol.species ? C[$Symbol.species] : void 0;
		if (S == null) {
			return defaultConstructor;
		}
		if (this.IsConstructor(S)) {
			return S;
		}
		throw new $TypeError('no constructor found');
	},

	// https://ecma-international.org/ecma-262/6.0/#sec-completepropertydescriptor
	CompletePropertyDescriptor: function CompletePropertyDescriptor(Desc) {
		assertRecord(this, 'Property Descriptor', 'Desc', Desc);

		if (this.IsGenericDescriptor(Desc) || this.IsDataDescriptor(Desc)) {
			if (!has(Desc, '[[Value]]')) {
				Desc['[[Value]]'] = void 0;
			}
			if (!has(Desc, '[[Writable]]')) {
				Desc['[[Writable]]'] = false;
			}
		} else {
			if (!has(Desc, '[[Get]]')) {
				Desc['[[Get]]'] = void 0;
			}
			if (!has(Desc, '[[Set]]')) {
				Desc['[[Set]]'] = void 0;
			}
		}
		if (!has(Desc, '[[Enumerable]]')) {
			Desc['[[Enumerable]]'] = false;
		}
		if (!has(Desc, '[[Configurable]]')) {
			Desc['[[Configurable]]'] = false;
		}
		return Desc;
	},

	// https://ecma-international.org/ecma-262/6.0/#sec-set-o-p-v-throw
	Set: function Set(O, P, V, Throw) {
		if (this.Type(O) !== 'Object') {
			throw new $TypeError('O must be an Object');
		}
		if (!this.IsPropertyKey(P)) {
			throw new $TypeError('P must be a Property Key');
		}
		if (this.Type(Throw) !== 'Boolean') {
			throw new $TypeError('Throw must be a Boolean');
		}
		if (Throw) {
			O[P] = V;
			return true;
		} else {
			try {
				O[P] = V;
			} catch (e) {
				return false;
			}
		}
	},

	// https://ecma-international.org/ecma-262/6.0/#sec-hasownproperty
	HasOwnProperty: function HasOwnProperty(O, P) {
		if (this.Type(O) !== 'Object') {
			throw new $TypeError('O must be an Object');
		}
		if (!this.IsPropertyKey(P)) {
			throw new $TypeError('P must be a Property Key');
		}
		return has(O, P);
	},

	// https://ecma-international.org/ecma-262/6.0/#sec-hasproperty
	HasProperty: function HasProperty(O, P) {
		if (this.Type(O) !== 'Object') {
			throw new $TypeError('O must be an Object');
		}
		if (!this.IsPropertyKey(P)) {
			throw new $TypeError('P must be a Property Key');
		}
		return P in O;
	},

	// https://ecma-international.org/ecma-262/6.0/#sec-isconcatspreadable
	IsConcatSpreadable: function IsConcatSpreadable(O) {
		if (this.Type(O) !== 'Object') {
			return false;
		}
		if (hasSymbols && typeof $Symbol.isConcatSpreadable === 'symbol') {
			var spreadable = this.Get(O, Symbol.isConcatSpreadable);
			if (typeof spreadable !== 'undefined') {
				return this.ToBoolean(spreadable);
			}
		}
		return this.IsArray(O);
	},

	// https://ecma-international.org/ecma-262/6.0/#sec-invoke
	Invoke: function Invoke(O, P) {
		if (!this.IsPropertyKey(P)) {
			throw new $TypeError('P must be a Property Key');
		}
		var argumentsList = arraySlice(arguments, 2);
		var func = this.GetV(O, P);
		return this.Call(func, O, argumentsList);
	},

	// https://ecma-international.org/ecma-262/6.0/#sec-getiterator
	GetIterator: function GetIterator(obj, method) {
		if (!hasSymbols) {
			throw new SyntaxError('ES.GetIterator depends on native iterator support.');
		}

		var actualMethod = method;
		if (arguments.length < 2) {
			actualMethod = this.GetMethod(obj, $Symbol.iterator);
		}
		var iterator = this.Call(actualMethod, obj);
		if (this.Type(iterator) !== 'Object') {
			throw new $TypeError('iterator must return an object');
		}

		return iterator;
	},

	// https://ecma-international.org/ecma-262/6.0/#sec-iteratornext
	IteratorNext: function IteratorNext(iterator, value) {
		var result = this.Invoke(iterator, 'next', arguments.length < 2 ? [] : [value]);
		if (this.Type(result) !== 'Object') {
			throw new $TypeError('iterator next must return an object');
		}
		return result;
	},

	// https://ecma-international.org/ecma-262/6.0/#sec-iteratorcomplete
	IteratorComplete: function IteratorComplete(iterResult) {
		if (this.Type(iterResult) !== 'Object') {
			throw new $TypeError('Assertion failed: Type(iterResult) is not Object');
		}
		return this.ToBoolean(this.Get(iterResult, 'done'));
	},

	// https://ecma-international.org/ecma-262/6.0/#sec-iteratorvalue
	IteratorValue: function IteratorValue(iterResult) {
		if (this.Type(iterResult) !== 'Object') {
			throw new $TypeError('Assertion failed: Type(iterResult) is not Object');
		}
		return this.Get(iterResult, 'value');
	},

	// https://ecma-international.org/ecma-262/6.0/#sec-iteratorstep
	IteratorStep: function IteratorStep(iterator) {
		var result = this.IteratorNext(iterator);
		var done = this.IteratorComplete(result);
		return done === true ? false : result;
	},

	// https://ecma-international.org/ecma-262/6.0/#sec-iteratorclose
	IteratorClose: function IteratorClose(iterator, completion) {
		if (this.Type(iterator) !== 'Object') {
			throw new $TypeError('Assertion failed: Type(iterator) is not Object');
		}
		if (!this.IsCallable(completion)) {
			throw new $TypeError('Assertion failed: completion is not a thunk for a Completion Record');
		}
		var completionThunk = completion;

		var iteratorReturn = this.GetMethod(iterator, 'return');

		if (typeof iteratorReturn === 'undefined') {
			return completionThunk();
		}

		var completionRecord;
		try {
			var innerResult = this.Call(iteratorReturn, iterator, []);
		} catch (e) {
			// if we hit here, then "e" is the innerResult completion that needs re-throwing

			// if the completion is of type "throw", this will throw.
			completionRecord = completionThunk();
			completionThunk = null; // ensure it's not called twice.

			// if not, then return the innerResult completion
			throw e;
		}
		completionRecord = completionThunk(); // if innerResult worked, then throw if the completion does
		completionThunk = null; // ensure it's not called twice.

		if (this.Type(innerResult) !== 'Object') {
			throw new $TypeError('iterator .return must return an object');
		}

		return completionRecord;
	},

	// https://ecma-international.org/ecma-262/6.0/#sec-createiterresultobject
	CreateIterResultObject: function CreateIterResultObject(value, done) {
		if (this.Type(done) !== 'Boolean') {
			throw new $TypeError('Assertion failed: Type(done) is not Boolean');
		}
		return {
			value: value,
			done: done
		};
	},

	// https://ecma-international.org/ecma-262/6.0/#sec-regexpexec
	RegExpExec: function RegExpExec(R, S) {
		if (this.Type(R) !== 'Object') {
			throw new $TypeError('R must be an Object');
		}
		if (this.Type(S) !== 'String') {
			throw new $TypeError('S must be a String');
		}
		var exec = this.Get(R, 'exec');
		if (this.IsCallable(exec)) {
			var result = this.Call(exec, R, [S]);
			if (result === null || this.Type(result) === 'Object') {
				return result;
			}
			throw new $TypeError('"exec" method must return `null` or an Object');
		}
		return regexExec(R, S);
	},

	// https://ecma-international.org/ecma-262/6.0/#sec-arrayspeciescreate
	ArraySpeciesCreate: function ArraySpeciesCreate(originalArray, length) {
		if (!this.IsInteger(length) || length < 0) {
			throw new $TypeError('Assertion failed: length must be an integer >= 0');
		}
		var len = length === 0 ? 0 : length;
		var C;
		var isArray = this.IsArray(originalArray);
		if (isArray) {
			C = this.Get(originalArray, 'constructor');
			// TODO: figure out how to make a cross-realm normal Array, a same-realm Array
			// if (this.IsConstructor(C)) {
			// 	if C is another realm's Array, C = undefined
			// 	Object.getPrototypeOf(Object.getPrototypeOf(Object.getPrototypeOf(Array))) === null ?
			// }
			if (this.Type(C) === 'Object' && hasSymbols && $Symbol.species) {
				C = this.Get(C, $Symbol.species);
				if (C === null) {
					C = void 0;
				}
			}
		}
		if (typeof C === 'undefined') {
			return $Array(len);
		}
		if (!this.IsConstructor(C)) {
			throw new $TypeError('C must be a constructor');
		}
		return new C(len); // this.Construct(C, len);
	},

	CreateDataProperty: function CreateDataProperty(O, P, V) {
		if (this.Type(O) !== 'Object') {
			throw new $TypeError('Assertion failed: Type(O) is not Object');
		}
		if (!this.IsPropertyKey(P)) {
			throw new $TypeError('Assertion failed: IsPropertyKey(P) is not true');
		}
		var oldDesc = $gOPD(O, P);
		var extensible = oldDesc || (typeof $isExtensible !== 'function' || $isExtensible(O));
		var immutable = oldDesc && (!oldDesc.writable || !oldDesc.configurable);
		if (immutable || !extensible) {
			return false;
		}
		var newDesc = {
			configurable: true,
			enumerable: true,
			value: V,
			writable: true
		};
		$defineProperty(O, P, newDesc);
		return true;
	},

	// https://ecma-international.org/ecma-262/6.0/#sec-createdatapropertyorthrow
	CreateDataPropertyOrThrow: function CreateDataPropertyOrThrow(O, P, V) {
		if (this.Type(O) !== 'Object') {
			throw new $TypeError('Assertion failed: Type(O) is not Object');
		}
		if (!this.IsPropertyKey(P)) {
			throw new $TypeError('Assertion failed: IsPropertyKey(P) is not true');
		}
		var success = this.CreateDataProperty(O, P, V);
		if (!success) {
			throw new $TypeError('unable to create data property');
		}
		return success;
	},

	// https://www.ecma-international.org/ecma-262/6.0/#sec-objectcreate
	ObjectCreate: function ObjectCreate(proto, internalSlotsList) {
		if (proto !== null && this.Type(proto) !== 'Object') {
			throw new $TypeError('Assertion failed: proto must be null or an object');
		}
		var slots = arguments.length < 2 ? [] : internalSlotsList;
		if (slots.length > 0) {
			throw new $SyntaxError('es-abstract does not yet support internal slots');
		}

		if (proto === null && !$ObjectCreate) {
			throw new $SyntaxError('native Object.create support is required to create null objects');
		}

		return $ObjectCreate(proto);
	},

	// https://ecma-international.org/ecma-262/6.0/#sec-advancestringindex
	AdvanceStringIndex: function AdvanceStringIndex(S, index, unicode) {
		if (this.Type(S) !== 'String') {
			throw new $TypeError('S must be a String');
		}
		if (!this.IsInteger(index) || index < 0 || index > MAX_SAFE_INTEGER) {
			throw new $TypeError('Assertion failed: length must be an integer >= 0 and <= 2**53');
		}
		if (this.Type(unicode) !== 'Boolean') {
			throw new $TypeError('Assertion failed: unicode must be a Boolean');
		}
		if (!unicode) {
			return index + 1;
		}
		var length = S.length;
		if ((index + 1) >= length) {
			return index + 1;
		}

		var first = $charCodeAt(S, index);
		if (first < 0xD800 || first > 0xDBFF) {
			return index + 1;
		}

		var second = $charCodeAt(S, index + 1);
		if (second < 0xDC00 || second > 0xDFFF) {
			return index + 1;
		}

		return index + 2;
	},

	// https://www.ecma-international.org/ecma-262/6.0/#sec-createmethodproperty
	CreateMethodProperty: function CreateMethodProperty(O, P, V) {
		if (this.Type(O) !== 'Object') {
			throw new $TypeError('Assertion failed: Type(O) is not Object');
		}

		if (!this.IsPropertyKey(P)) {
			throw new $TypeError('Assertion failed: IsPropertyKey(P) is not true');
		}

		var newDesc = {
			configurable: true,
			enumerable: false,
			value: V,
			writable: true
		};
		return !!$defineProperty(O, P, newDesc);
	},

	// https://www.ecma-international.org/ecma-262/6.0/#sec-definepropertyorthrow
	DefinePropertyOrThrow: function DefinePropertyOrThrow(O, P, desc) {
		if (this.Type(O) !== 'Object') {
			throw new $TypeError('Assertion failed: Type(O) is not Object');
		}

		if (!this.IsPropertyKey(P)) {
			throw new $TypeError('Assertion failed: IsPropertyKey(P) is not true');
		}

		return !!$defineProperty(O, P, desc);
	},

	// https://www.ecma-international.org/ecma-262/6.0/#sec-deletepropertyorthrow
	DeletePropertyOrThrow: function DeletePropertyOrThrow(O, P) {
		if (this.Type(O) !== 'Object') {
			throw new $TypeError('Assertion failed: Type(O) is not Object');
		}

		if (!this.IsPropertyKey(P)) {
			throw new $TypeError('Assertion failed: IsPropertyKey(P) is not true');
		}

		var success = delete O[P];
		if (!success) {
			throw new TypeError('Attempt to delete property failed.');
		}
		return success;
	},

	// https://www.ecma-international.org/ecma-262/6.0/#sec-enumerableownnames
	EnumerableOwnNames: function EnumerableOwnNames(O) {
		if (this.Type(O) !== 'Object') {
			throw new $TypeError('Assertion failed: Type(O) is not Object');
		}

		return keys(O);
	},

	// https://ecma-international.org/ecma-262/6.0/#sec-properties-of-the-number-prototype-object
	thisNumberValue: function thisNumberValue(value) {
		if (this.Type(value) === 'Number') {
			return value;
		}

		return $NumberValueOf(value);
	},

	// https://ecma-international.org/ecma-262/6.0/#sec-properties-of-the-boolean-prototype-object
	thisBooleanValue: function thisBooleanValue(value) {
		if (this.Type(value) === 'Boolean') {
			return value;
		}

		return $BooleanValueOf(value);
	},

	// https://ecma-international.org/ecma-262/6.0/#sec-properties-of-the-string-prototype-object
	thisStringValue: function thisStringValue(value) {
		if (this.Type(value) === 'String') {
			return value;
		}

		return $StringValueOf(value);
	},

	// https://ecma-international.org/ecma-262/6.0/#sec-properties-of-the-date-prototype-object
	thisTimeValue: function thisTimeValue(value) {
		return $DateValueOf(value);
	}
});

delete ES6.CheckObjectCoercible; // renamed in ES6 to RequireObjectCoercible

module.exports = ES6;

},{"./GetIntrinsic":696,"./es5":699,"./helpers/assertRecord":701,"./helpers/assign":702,"./helpers/isFinite":703,"./helpers/isNaN":704,"./helpers/isPrimitive":705,"./helpers/mod":706,"./helpers/sign":707,"es-to-primitive/es6":710,"function-bind":715,"has":720,"is-regex":747,"object-keys":794}],698:[function(require,module,exports){
'use strict';

var ES2015 = require('./es2015');
var assign = require('./helpers/assign');

var ES2016 = assign(assign({}, ES2015), {
	// https://github.com/tc39/ecma262/pull/60
	SameValueNonNumber: function SameValueNonNumber(x, y) {
		if (typeof x === 'number' || typeof x !== typeof y) {
			throw new TypeError('SameValueNonNumber requires two non-number values of the same type.');
		}
		return this.SameValue(x, y);
	}
});

module.exports = ES2016;

},{"./es2015":697,"./helpers/assign":702}],699:[function(require,module,exports){
'use strict';

var GetIntrinsic = require('./GetIntrinsic');

var $Object = GetIntrinsic('%Object%');
var $TypeError = GetIntrinsic('%TypeError%');
var $String = GetIntrinsic('%String%');

var assertRecord = require('./helpers/assertRecord');
var $isNaN = require('./helpers/isNaN');
var $isFinite = require('./helpers/isFinite');

var sign = require('./helpers/sign');
var mod = require('./helpers/mod');

var IsCallable = require('is-callable');
var toPrimitive = require('es-to-primitive/es5');

var has = require('has');

// https://es5.github.io/#x9
var ES5 = {
	ToPrimitive: toPrimitive,

	ToBoolean: function ToBoolean(value) {
		return !!value;
	},
	ToNumber: function ToNumber(value) {
		return +value; // eslint-disable-line no-implicit-coercion
	},
	ToInteger: function ToInteger(value) {
		var number = this.ToNumber(value);
		if ($isNaN(number)) { return 0; }
		if (number === 0 || !$isFinite(number)) { return number; }
		return sign(number) * Math.floor(Math.abs(number));
	},
	ToInt32: function ToInt32(x) {
		return this.ToNumber(x) >> 0;
	},
	ToUint32: function ToUint32(x) {
		return this.ToNumber(x) >>> 0;
	},
	ToUint16: function ToUint16(value) {
		var number = this.ToNumber(value);
		if ($isNaN(number) || number === 0 || !$isFinite(number)) { return 0; }
		var posInt = sign(number) * Math.floor(Math.abs(number));
		return mod(posInt, 0x10000);
	},
	ToString: function ToString(value) {
		return $String(value);
	},
	ToObject: function ToObject(value) {
		this.CheckObjectCoercible(value);
		return $Object(value);
	},
	CheckObjectCoercible: function CheckObjectCoercible(value, optMessage) {
		/* jshint eqnull:true */
		if (value == null) {
			throw new $TypeError(optMessage || 'Cannot call method on ' + value);
		}
		return value;
	},
	IsCallable: IsCallable,
	SameValue: function SameValue(x, y) {
		if (x === y) { // 0 === -0, but they are not identical.
			if (x === 0) { return 1 / x === 1 / y; }
			return true;
		}
		return $isNaN(x) && $isNaN(y);
	},

	// https://www.ecma-international.org/ecma-262/5.1/#sec-8
	Type: function Type(x) {
		if (x === null) {
			return 'Null';
		}
		if (typeof x === 'undefined') {
			return 'Undefined';
		}
		if (typeof x === 'function' || typeof x === 'object') {
			return 'Object';
		}
		if (typeof x === 'number') {
			return 'Number';
		}
		if (typeof x === 'boolean') {
			return 'Boolean';
		}
		if (typeof x === 'string') {
			return 'String';
		}
	},

	// https://ecma-international.org/ecma-262/6.0/#sec-property-descriptor-specification-type
	IsPropertyDescriptor: function IsPropertyDescriptor(Desc) {
		if (this.Type(Desc) !== 'Object') {
			return false;
		}
		var allowed = {
			'[[Configurable]]': true,
			'[[Enumerable]]': true,
			'[[Get]]': true,
			'[[Set]]': true,
			'[[Value]]': true,
			'[[Writable]]': true
		};

		for (var key in Desc) { // eslint-disable-line
			if (has(Desc, key) && !allowed[key]) {
				return false;
			}
		}

		var isData = has(Desc, '[[Value]]');
		var IsAccessor = has(Desc, '[[Get]]') || has(Desc, '[[Set]]');
		if (isData && IsAccessor) {
			throw new $TypeError('Property Descriptors may not be both accessor and data descriptors');
		}
		return true;
	},

	// https://ecma-international.org/ecma-262/5.1/#sec-8.10.1
	IsAccessorDescriptor: function IsAccessorDescriptor(Desc) {
		if (typeof Desc === 'undefined') {
			return false;
		}

		assertRecord(this, 'Property Descriptor', 'Desc', Desc);

		if (!has(Desc, '[[Get]]') && !has(Desc, '[[Set]]')) {
			return false;
		}

		return true;
	},

	// https://ecma-international.org/ecma-262/5.1/#sec-8.10.2
	IsDataDescriptor: function IsDataDescriptor(Desc) {
		if (typeof Desc === 'undefined') {
			return false;
		}

		assertRecord(this, 'Property Descriptor', 'Desc', Desc);

		if (!has(Desc, '[[Value]]') && !has(Desc, '[[Writable]]')) {
			return false;
		}

		return true;
	},

	// https://ecma-international.org/ecma-262/5.1/#sec-8.10.3
	IsGenericDescriptor: function IsGenericDescriptor(Desc) {
		if (typeof Desc === 'undefined') {
			return false;
		}

		assertRecord(this, 'Property Descriptor', 'Desc', Desc);

		if (!this.IsAccessorDescriptor(Desc) && !this.IsDataDescriptor(Desc)) {
			return true;
		}

		return false;
	},

	// https://ecma-international.org/ecma-262/5.1/#sec-8.10.4
	FromPropertyDescriptor: function FromPropertyDescriptor(Desc) {
		if (typeof Desc === 'undefined') {
			return Desc;
		}

		assertRecord(this, 'Property Descriptor', 'Desc', Desc);

		if (this.IsDataDescriptor(Desc)) {
			return {
				value: Desc['[[Value]]'],
				writable: !!Desc['[[Writable]]'],
				enumerable: !!Desc['[[Enumerable]]'],
				configurable: !!Desc['[[Configurable]]']
			};
		} else if (this.IsAccessorDescriptor(Desc)) {
			return {
				get: Desc['[[Get]]'],
				set: Desc['[[Set]]'],
				enumerable: !!Desc['[[Enumerable]]'],
				configurable: !!Desc['[[Configurable]]']
			};
		} else {
			throw new $TypeError('FromPropertyDescriptor must be called with a fully populated Property Descriptor');
		}
	},

	// https://ecma-international.org/ecma-262/5.1/#sec-8.10.5
	ToPropertyDescriptor: function ToPropertyDescriptor(Obj) {
		if (this.Type(Obj) !== 'Object') {
			throw new $TypeError('ToPropertyDescriptor requires an object');
		}

		var desc = {};
		if (has(Obj, 'enumerable')) {
			desc['[[Enumerable]]'] = this.ToBoolean(Obj.enumerable);
		}
		if (has(Obj, 'configurable')) {
			desc['[[Configurable]]'] = this.ToBoolean(Obj.configurable);
		}
		if (has(Obj, 'value')) {
			desc['[[Value]]'] = Obj.value;
		}
		if (has(Obj, 'writable')) {
			desc['[[Writable]]'] = this.ToBoolean(Obj.writable);
		}
		if (has(Obj, 'get')) {
			var getter = Obj.get;
			if (typeof getter !== 'undefined' && !this.IsCallable(getter)) {
				throw new TypeError('getter must be a function');
			}
			desc['[[Get]]'] = getter;
		}
		if (has(Obj, 'set')) {
			var setter = Obj.set;
			if (typeof setter !== 'undefined' && !this.IsCallable(setter)) {
				throw new $TypeError('setter must be a function');
			}
			desc['[[Set]]'] = setter;
		}

		if ((has(desc, '[[Get]]') || has(desc, '[[Set]]')) && (has(desc, '[[Value]]') || has(desc, '[[Writable]]'))) {
			throw new $TypeError('Invalid property descriptor. Cannot both specify accessors and a value or writable attribute');
		}
		return desc;
	}
};

module.exports = ES5;

},{"./GetIntrinsic":696,"./helpers/assertRecord":701,"./helpers/isFinite":703,"./helpers/isNaN":704,"./helpers/mod":706,"./helpers/sign":707,"es-to-primitive/es5":709,"has":720,"is-callable":732}],700:[function(require,module,exports){
'use strict';

module.exports = require('./es2016');

},{"./es2016":698}],701:[function(require,module,exports){
'use strict';

var GetIntrinsic = require('../GetIntrinsic');

var $TypeError = GetIntrinsic('%TypeError%');
var $SyntaxError = GetIntrinsic('%SyntaxError%');

var has = require('has');

var predicates = {
  // https://ecma-international.org/ecma-262/6.0/#sec-property-descriptor-specification-type
  'Property Descriptor': function isPropertyDescriptor(ES, Desc) {
    if (ES.Type(Desc) !== 'Object') {
      return false;
    }
    var allowed = {
      '[[Configurable]]': true,
      '[[Enumerable]]': true,
      '[[Get]]': true,
      '[[Set]]': true,
      '[[Value]]': true,
      '[[Writable]]': true
    };

    for (var key in Desc) { // eslint-disable-line
      if (has(Desc, key) && !allowed[key]) {
        return false;
      }
    }

    var isData = has(Desc, '[[Value]]');
    var IsAccessor = has(Desc, '[[Get]]') || has(Desc, '[[Set]]');
    if (isData && IsAccessor) {
      throw new $TypeError('Property Descriptors may not be both accessor and data descriptors');
    }
    return true;
  }
};

module.exports = function assertRecord(ES, recordType, argumentName, value) {
  var predicate = predicates[recordType];
  if (typeof predicate !== 'function') {
    throw new $SyntaxError('unknown record type: ' + recordType);
  }
  if (!predicate(ES, value)) {
    throw new $TypeError(argumentName + ' must be a ' + recordType);
  }
  console.log(predicate(ES, value), value);
};

},{"../GetIntrinsic":696,"has":720}],702:[function(require,module,exports){
var bind = require('function-bind');
var has = bind.call(Function.call, Object.prototype.hasOwnProperty);

var $assign = Object.assign;

module.exports = function assign(target, source) {
	if ($assign) {
		return $assign(target, source);
	}

	for (var key in source) {
		if (has(source, key)) {
			target[key] = source[key];
		}
	}
	return target;
};

},{"function-bind":715}],703:[function(require,module,exports){
var $isNaN = Number.isNaN || function (a) { return a !== a; };

module.exports = Number.isFinite || function (x) { return typeof x === 'number' && !$isNaN(x) && x !== Infinity && x !== -Infinity; };

},{}],704:[function(require,module,exports){
module.exports = Number.isNaN || function isNaN(a) {
	return a !== a;
};

},{}],705:[function(require,module,exports){
module.exports = function isPrimitive(value) {
	return value === null || (typeof value !== 'function' && typeof value !== 'object');
};

},{}],706:[function(require,module,exports){
module.exports = function mod(number, modulo) {
	var remain = number % modulo;
	return Math.floor(remain >= 0 ? remain : remain + modulo);
};

},{}],707:[function(require,module,exports){
module.exports = function sign(number) {
	return number >= 0 ? 1 : -1;
};

},{}],708:[function(require,module,exports){
'use strict';

var hasSymbols = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol';

var isPrimitive = require('./helpers/isPrimitive');
var isCallable = require('is-callable');
var isDate = require('is-date-object');
var isSymbol = require('is-symbol');

var ordinaryToPrimitive = function OrdinaryToPrimitive(O, hint) {
	if (typeof O === 'undefined' || O === null) {
		throw new TypeError('Cannot call method on ' + O);
	}
	if (typeof hint !== 'string' || (hint !== 'number' && hint !== 'string')) {
		throw new TypeError('hint must be "string" or "number"');
	}
	var methodNames = hint === 'string' ? ['toString', 'valueOf'] : ['valueOf', 'toString'];
	var method, result, i;
	for (i = 0; i < methodNames.length; ++i) {
		method = O[methodNames[i]];
		if (isCallable(method)) {
			result = method.call(O);
			if (isPrimitive(result)) {
				return result;
			}
		}
	}
	throw new TypeError('No default value');
};

var GetMethod = function GetMethod(O, P) {
	var func = O[P];
	if (func !== null && typeof func !== 'undefined') {
		if (!isCallable(func)) {
			throw new TypeError(func + ' returned for property ' + P + ' of object ' + O + ' is not a function');
		}
		return func;
	}
	return void 0;
};

// http://www.ecma-international.org/ecma-262/6.0/#sec-toprimitive
module.exports = function ToPrimitive(input) {
	if (isPrimitive(input)) {
		return input;
	}
	var hint = 'default';
	if (arguments.length > 1) {
		if (arguments[1] === String) {
			hint = 'string';
		} else if (arguments[1] === Number) {
			hint = 'number';
		}
	}

	var exoticToPrim;
	if (hasSymbols) {
		if (Symbol.toPrimitive) {
			exoticToPrim = GetMethod(input, Symbol.toPrimitive);
		} else if (isSymbol(input)) {
			exoticToPrim = Symbol.prototype.valueOf;
		}
	}
	if (typeof exoticToPrim !== 'undefined') {
		var result = exoticToPrim.call(input, hint);
		if (isPrimitive(result)) {
			return result;
		}
		throw new TypeError('unable to convert exotic object to primitive');
	}
	if (hint === 'default' && (isDate(input) || isSymbol(input))) {
		hint = 'string';
	}
	return ordinaryToPrimitive(input, hint === 'default' ? 'number' : hint);
};

},{"./helpers/isPrimitive":711,"is-callable":732,"is-date-object":744,"is-symbol":750}],709:[function(require,module,exports){
'use strict';

var toStr = Object.prototype.toString;

var isPrimitive = require('./helpers/isPrimitive');

var isCallable = require('is-callable');

// http://ecma-international.org/ecma-262/5.1/#sec-8.12.8
var ES5internalSlots = {
	'[[DefaultValue]]': function (O) {
		var actualHint;
		if (arguments.length > 1) {
			actualHint = arguments[1];
		} else {
			actualHint = toStr.call(O) === '[object Date]' ? String : Number;
		}

		if (actualHint === String || actualHint === Number) {
			var methods = actualHint === String ? ['toString', 'valueOf'] : ['valueOf', 'toString'];
			var value, i;
			for (i = 0; i < methods.length; ++i) {
				if (isCallable(O[methods[i]])) {
					value = O[methods[i]]();
					if (isPrimitive(value)) {
						return value;
					}
				}
			}
			throw new TypeError('No default value');
		}
		throw new TypeError('invalid [[DefaultValue]] hint supplied');
	}
};

// http://ecma-international.org/ecma-262/5.1/#sec-9.1
module.exports = function ToPrimitive(input) {
	if (isPrimitive(input)) {
		return input;
	}
	if (arguments.length > 1) {
		return ES5internalSlots['[[DefaultValue]]'](input, arguments[1]);
	}
	return ES5internalSlots['[[DefaultValue]]'](input);
};

},{"./helpers/isPrimitive":711,"is-callable":732}],710:[function(require,module,exports){
'use strict';

module.exports = require('./es2015');

},{"./es2015":708}],711:[function(require,module,exports){
arguments[4][705][0].apply(exports,arguments)
},{"dup":705}],712:[function(require,module,exports){
'use strict';

var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;

module.exports = function (str) {
	if (typeof str !== 'string') {
		throw new TypeError('Expected a string');
	}

	return str.replace(matchOperatorsRe, '\\$&');
};

},{}],713:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var objectCreate = Object.create || objectCreatePolyfill
var objectKeys = Object.keys || objectKeysPolyfill
var bind = Function.prototype.bind || functionBindPolyfill

function EventEmitter() {
  if (!this._events || !Object.prototype.hasOwnProperty.call(this, '_events')) {
    this._events = objectCreate(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

var hasDefineProperty;
try {
  var o = {};
  if (Object.defineProperty) Object.defineProperty(o, 'x', { value: 0 });
  hasDefineProperty = o.x === 0;
} catch (err) { hasDefineProperty = false }
if (hasDefineProperty) {
  Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
    enumerable: true,
    get: function() {
      return defaultMaxListeners;
    },
    set: function(arg) {
      // check whether the input is a positive number (whose value is zero or
      // greater and not a NaN).
      if (typeof arg !== 'number' || arg < 0 || arg !== arg)
        throw new TypeError('"defaultMaxListeners" must be a positive number');
      defaultMaxListeners = arg;
    }
  });
} else {
  EventEmitter.defaultMaxListeners = defaultMaxListeners;
}

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || isNaN(n))
    throw new TypeError('"n" argument must be a positive number');
  this._maxListeners = n;
  return this;
};

function $getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return $getMaxListeners(this);
};

// These standalone emit* functions are used to optimize calling of event
// handlers for fast cases because emit() itself often has a variable number of
// arguments and can be deoptimized because of that. These functions always have
// the same number of arguments and thus do not get deoptimized, so the code
// inside them can execute faster.
function emitNone(handler, isFn, self) {
  if (isFn)
    handler.call(self);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self);
  }
}
function emitOne(handler, isFn, self, arg1) {
  if (isFn)
    handler.call(self, arg1);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1);
  }
}
function emitTwo(handler, isFn, self, arg1, arg2) {
  if (isFn)
    handler.call(self, arg1, arg2);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1, arg2);
  }
}
function emitThree(handler, isFn, self, arg1, arg2, arg3) {
  if (isFn)
    handler.call(self, arg1, arg2, arg3);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1, arg2, arg3);
  }
}

function emitMany(handler, isFn, self, args) {
  if (isFn)
    handler.apply(self, args);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].apply(self, args);
  }
}

EventEmitter.prototype.emit = function emit(type) {
  var er, handler, len, args, i, events;
  var doError = (type === 'error');

  events = this._events;
  if (events)
    doError = (doError && events.error == null);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    if (arguments.length > 1)
      er = arguments[1];
    if (er instanceof Error) {
      throw er; // Unhandled 'error' event
    } else {
      // At least give some kind of context to the user
      var err = new Error('Unhandled "error" event. (' + er + ')');
      err.context = er;
      throw err;
    }
    return false;
  }

  handler = events[type];

  if (!handler)
    return false;

  var isFn = typeof handler === 'function';
  len = arguments.length;
  switch (len) {
      // fast cases
    case 1:
      emitNone(handler, isFn, this);
      break;
    case 2:
      emitOne(handler, isFn, this, arguments[1]);
      break;
    case 3:
      emitTwo(handler, isFn, this, arguments[1], arguments[2]);
      break;
    case 4:
      emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
      break;
      // slower
    default:
      args = new Array(len - 1);
      for (i = 1; i < len; i++)
        args[i - 1] = arguments[i];
      emitMany(handler, isFn, this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  if (typeof listener !== 'function')
    throw new TypeError('"listener" argument must be a function');

  events = target._events;
  if (!events) {
    events = target._events = objectCreate(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener) {
      target.emit('newListener', type,
          listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (!existing) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
          prepend ? [listener, existing] : [existing, listener];
    } else {
      // If we've already got an array, just append.
      if (prepend) {
        existing.unshift(listener);
      } else {
        existing.push(listener);
      }
    }

    // Check for listener leak
    if (!existing.warned) {
      m = $getMaxListeners(target);
      if (m && m > 0 && existing.length > m) {
        existing.warned = true;
        var w = new Error('Possible EventEmitter memory leak detected. ' +
            existing.length + ' "' + String(type) + '" listeners ' +
            'added. Use emitter.setMaxListeners() to ' +
            'increase limit.');
        w.name = 'MaxListenersExceededWarning';
        w.emitter = target;
        w.type = type;
        w.count = existing.length;
        if (typeof console === 'object' && console.warn) {
          console.warn('%s: %s', w.name, w.message);
        }
      }
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    switch (arguments.length) {
      case 0:
        return this.listener.call(this.target);
      case 1:
        return this.listener.call(this.target, arguments[0]);
      case 2:
        return this.listener.call(this.target, arguments[0], arguments[1]);
      case 3:
        return this.listener.call(this.target, arguments[0], arguments[1],
            arguments[2]);
      default:
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; ++i)
          args[i] = arguments[i];
        this.listener.apply(this.target, args);
    }
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = bind.call(onceWrapper, state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  if (typeof listener !== 'function')
    throw new TypeError('"listener" argument must be a function');
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      if (typeof listener !== 'function')
        throw new TypeError('"listener" argument must be a function');
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      if (typeof listener !== 'function')
        throw new TypeError('"listener" argument must be a function');

      events = this._events;
      if (!events)
        return this;

      list = events[type];
      if (!list)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = objectCreate(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else
          spliceOne(list, position);

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (!events)
        return this;

      // not listening for removeListener, no need to emit
      if (!events.removeListener) {
        if (arguments.length === 0) {
          this._events = objectCreate(null);
          this._eventsCount = 0;
        } else if (events[type]) {
          if (--this._eventsCount === 0)
            this._events = objectCreate(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = objectKeys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = objectCreate(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (!events)
    return [];

  var evlistener = events[type];
  if (!evlistener)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
};

// About 1.5x faster than the two-arg version of Array#splice().
function spliceOne(list, index) {
  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)
    list[i] = list[k];
  list.pop();
}

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function objectCreatePolyfill(proto) {
  var F = function() {};
  F.prototype = proto;
  return new F;
}
function objectKeysPolyfill(obj) {
  var keys = [];
  for (var k in obj) if (Object.prototype.hasOwnProperty.call(obj, k)) {
    keys.push(k);
  }
  return k;
}
function functionBindPolyfill(context) {
  var fn = this;
  return function () {
    return fn.apply(context, arguments);
  };
}

},{}],714:[function(require,module,exports){
'use strict';

/* eslint no-invalid-this: 1 */

var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
var slice = Array.prototype.slice;
var toStr = Object.prototype.toString;
var funcType = '[object Function]';

module.exports = function bind(that) {
    var target = this;
    if (typeof target !== 'function' || toStr.call(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slice.call(arguments, 1);

    var bound;
    var binder = function () {
        if (this instanceof bound) {
            var result = target.apply(
                this,
                args.concat(slice.call(arguments))
            );
            if (Object(result) === result) {
                return result;
            }
            return this;
        } else {
            return target.apply(
                that,
                args.concat(slice.call(arguments))
            );
        }
    };

    var boundLength = Math.max(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0; i < boundLength; i++) {
        boundArgs.push('$' + i);
    }

    bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);

    if (target.prototype) {
        var Empty = function Empty() {};
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
    }

    return bound;
};

},{}],715:[function(require,module,exports){
'use strict';

var implementation = require('./implementation');

module.exports = Function.prototype.bind || implementation;

},{"./implementation":714}],716:[function(require,module,exports){
'use strict';
var ansiRegex = require('ansi-regex');
var re = new RegExp(ansiRegex().source); // remove the `g` flag
module.exports = re.test.bind(re);

},{"ansi-regex":717}],717:[function(require,module,exports){
'use strict';
module.exports = function () {
	return /[\u001b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-PRZcf-nqry=><]/g;
};

},{}],718:[function(require,module,exports){
(function (global){
'use strict';

var origSymbol = global.Symbol;
var hasSymbolSham = require('./shams');

module.exports = function hasNativeSymbols() {
	if (typeof origSymbol !== 'function') { return false; }
	if (typeof Symbol !== 'function') { return false; }
	if (typeof origSymbol('foo') !== 'symbol') { return false; }
	if (typeof Symbol('bar') !== 'symbol') { return false; }

	return hasSymbolSham();
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./shams":719}],719:[function(require,module,exports){
'use strict';

/* eslint complexity: [2, 17], max-statements: [2, 33] */
module.exports = function hasSymbols() {
	if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }
	if (typeof Symbol.iterator === 'symbol') { return true; }

	var obj = {};
	var sym = Symbol('test');
	var symObj = Object(sym);
	if (typeof sym === 'string') { return false; }

	if (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }
	if (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }

	// temp disabled per https://github.com/ljharb/object.assign/issues/17
	// if (sym instanceof Symbol) { return false; }
	// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
	// if (!(symObj instanceof Symbol)) { return false; }

	// if (typeof Symbol.prototype.toString !== 'function') { return false; }
	// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }

	var symVal = 42;
	obj[sym] = symVal;
	for (sym in obj) { return false; } // eslint-disable-line no-restricted-syntax
	if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }

	if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }

	var syms = Object.getOwnPropertySymbols(obj);
	if (syms.length !== 1 || syms[0] !== sym) { return false; }

	if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }

	if (typeof Object.getOwnPropertyDescriptor === 'function') {
		var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
		if (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }
	}

	return true;
};

},{}],720:[function(require,module,exports){
'use strict';

var bind = require('function-bind');

module.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);

},{"function-bind":715}],721:[function(require,module,exports){
/*!
 * hex-color-regex <https://github.com/regexps/hex-color-regex>
 *
 * Copyright (c) 2015 Charlike Mike Reagent <@tunnckoCore> (http://www.tunnckocore.tk)
 * Released under the MIT license.
 */

'use strict'

module.exports = function hexColorRegex(opts) {
  opts = opts && typeof opts === 'object' ? opts : {}

  return opts.strict
    ? /^#([a-f0-9]{3,4}|[a-f0-9]{4}(?:[a-f0-9]{2}){1,2})\b$/i
    : /#([a-f0-9]{3}|[a-f0-9]{4}(?:[a-f0-9]{2}){0,2})\b/gi
}

},{}],722:[function(require,module,exports){
'use strict';

module.exports = function hslRegex(options) {
  options = options || {};

  return options.exact ?
    /^hsl\(\s*(\d+)\s*,\s*(\d*(?:\.\d+)?%)\s*,\s*(\d*(?:\.\d+)?%)\)$/ :
    /hsl\(\s*(\d+)\s*,\s*(\d*(?:\.\d+)?%)\s*,\s*(\d*(?:\.\d+)?%)\)/ig;
}

},{}],723:[function(require,module,exports){
'use strict';

module.exports = function hslaRegex(options) {
  options = options || {};

  return options.exact ?
    /^hsla\((\d+),\s*([\d.]+)%,\s*([\d.]+)%,\s*(\d*(?:\.\d+)?)\)$/ :
    /hsla\((\d+),\s*([\d.]+)%,\s*([\d.]+)%,\s*(\d*(?:\.\d+)?)\)/ig;
}

},{}],724:[function(require,module,exports){
'use strict';
module.exports = /<!--([\s\S]*?)-->/g;

},{}],725:[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],726:[function(require,module,exports){
'use strict';
const path = require('path');
const resolveFrom = require('resolve-from');
const callerPath = require('caller-path');

module.exports = moduleId => {
	if (typeof moduleId !== 'string') {
		throw new TypeError('Expected a string');
	}

	const filePath = resolveFrom(path.dirname(callerPath()), moduleId);

	// Delete itself from module parent
	if (require.cache[filePath] && require.cache[filePath].parent) {
		let i = require.cache[filePath].parent.children.length;

		while (i--) {
			if (require.cache[filePath].parent.children[i].id === filePath) {
				require.cache[filePath].parent.children.splice(i, 1);
			}
		}
	}

	// Delete module from cache
	delete require.cache[filePath];

	// Return fresh module
	return require(filePath);
};

},{"caller-path":15,"path":802,"resolve-from":1115}],727:[function(require,module,exports){
module.exports = function (ary, item) {
  var i = -1, indexes = []
  while((i = ary.indexOf(item, i + 1)) !== -1)
    indexes.push(i)
  return indexes
}

},{}],728:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],729:[function(require,module,exports){
'use strict';
module.exports = function (url) {
	if (typeof url !== 'string') {
		throw new TypeError('Expected a string');
	}

	return /^[a-z][a-z0-9+.-]*:/.test(url);
};

},{}],730:[function(require,module,exports){
'use strict';

module.exports = function isArrayish(obj) {
	if (!obj) {
		return false;
	}

	return obj instanceof Array || Array.isArray(obj) ||
		(obj.length >= 0 && obj.splice instanceof Function);
};

},{}],731:[function(require,module,exports){
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
module.exports = function (obj) {
  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)
}

function isBuffer (obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
}

// For Node v0.10 support. Remove this eventually.
function isSlowBuffer (obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))
}

},{}],732:[function(require,module,exports){
'use strict';

var fnToStr = Function.prototype.toString;

var constructorRegex = /^\s*class\b/;
var isES6ClassFn = function isES6ClassFunction(value) {
	try {
		var fnStr = fnToStr.call(value);
		return constructorRegex.test(fnStr);
	} catch (e) {
		return false; // not a function
	}
};

var tryFunctionObject = function tryFunctionToStr(value) {
	try {
		if (isES6ClassFn(value)) { return false; }
		fnToStr.call(value);
		return true;
	} catch (e) {
		return false;
	}
};
var toStr = Object.prototype.toString;
var fnClass = '[object Function]';
var genClass = '[object GeneratorFunction]';
var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';

module.exports = function isCallable(value) {
	if (!value) { return false; }
	if (typeof value !== 'function' && typeof value !== 'object') { return false; }
	if (typeof value === 'function' && !value.prototype) { return true; }
	if (hasToStringTag) { return tryFunctionObject(value); }
	if (isES6ClassFn(value)) { return false; }
	var strClass = toStr.call(value);
	return strClass === fnClass || strClass === genClass;
};

},{}],733:[function(require,module,exports){
'use strict';

const isRGB = require('./lib/isRGB');
const isRGBA = require('./lib/isRGBA');
const isHSL = require('./lib/isHSL');
const isHSLA = require('./lib/isHSLA');
const isHex = require('./lib/isHex');
const isCSSColorName = require('./lib/isCSSColorName');
const isTransparent = require('./lib/isTransparent');
const isCSSLengthUnit = require('./lib/isCSSLengthUnit');
const isStop = require('./lib/isStop');

function isColor(colorStr) {
  const color =
    isRGB(colorStr) ||
    isRGBA(colorStr) ||
    isHSL(colorStr) ||
    isHSLA(colorStr) ||
    isHex(colorStr) ||
    isCSSColorName(colorStr) ||
    isTransparent(colorStr);

  return color;
}


module.exports = function isColorStop(color, stop) {
  return isColor(color) && isStop(stop);
};
module.exports.isColor = isColor;
module.exports.isRGB = isRGB;
module.exports.isRGBA = isRGBA;
module.exports.isHSL = isHSL;
module.exports.isHSLA = isHSLA;
module.exports.isHex = isHex;
module.exports.isCSSColorName = isCSSColorName;
module.exports.isTransparent = isTransparent;
module.exports.isCSSLengthUnit = isCSSLengthUnit;

},{"./lib/isCSSColorName":734,"./lib/isCSSLengthUnit":735,"./lib/isHSL":736,"./lib/isHSLA":737,"./lib/isHex":738,"./lib/isRGB":739,"./lib/isRGBA":740,"./lib/isStop":741,"./lib/isTransparent":742}],734:[function(require,module,exports){
'use strict';

const colorNames = require('css-color-names');

function isCSSColorName(str) {
  return !!colorNames[str];
}

module.exports = isCSSColorName;

},{"css-color-names":550}],735:[function(require,module,exports){
'use strict';

const lengthArray = [
  'PX',
  'IN',
  'CM',
  'MM',
  'EM',
  'REM',
  'POINTS',
  'PC',
  'EX',
  'CH',
  'VW',
  'VH',
  'VMIN',
  'VMAX',
  '%',
];

function isCSSLengthUnit(unit) {
  return lengthArray.indexOf(unit.toUpperCase()) >= 0;
}

module.exports = isCSSLengthUnit;

},{}],736:[function(require,module,exports){
'use strict';

const hslRegex = require('hsl-regex');

function isHSL(str) {
  return hslRegex({ exact: true }).test(str);
}

module.exports = isHSL;

},{"hsl-regex":722}],737:[function(require,module,exports){
'use strict';

const hslaRegex = require('hsla-regex');

function isHSLA(str) {
  return hslaRegex({ exact: true }).test(str);
}

module.exports = isHSLA;

},{"hsla-regex":723}],738:[function(require,module,exports){
'use strict';

const hexRegex = require('hex-color-regex');

function isHex(str) {
  return hexRegex({ exact: true }).test(str);
}

module.exports = isHex;

},{"hex-color-regex":721}],739:[function(require,module,exports){
'use strict';

const rgbRegex = require('rgb-regex');

function isRGB(str) {
  return rgbRegex({ exact: true }).test(str);
}

module.exports = isRGB;

},{"rgb-regex":1116}],740:[function(require,module,exports){
'use strict';

const rgbaRegex = require('rgba-regex');

function isRgba(str) {
  return rgbaRegex({ exact: true }).test(str);
}

module.exports = isRgba;

},{"rgba-regex":1117}],741:[function(require,module,exports){
'use strict';

const isCSSLengthUnit = require('./isCSSLengthUnit');
const unit = require('../util/unit');

function isStop(str) {
  let stop = !str;
  
  if (!stop) {
    const node = unit(str);
    if (node) {
      if (node.number === 0 || (!isNaN(node.number) && isCSSLengthUnit(node.unit))) {
        stop = true;
      }
    } else {
      stop = (/^calc\(\S+\)$/g).test(str);
    }
  }

  return stop;
}

module.exports = isStop;

},{"../util/unit":743,"./isCSSLengthUnit":735}],742:[function(require,module,exports){
'use strict';

function isTransparent(str) {
  return str === 'transparent';
}

module.exports = isTransparent;

},{}],743:[function(require,module,exports){
'use strict';

/**
 * https://github.com/TrySound/postcss-value-parser/blob/fc679a7e17877841ff9fe455722280b65abd4f28/lib/unit.js
 * parse node -> number and unit
 */

const minus = '-'.charCodeAt(0);
const plus = '+'.charCodeAt(0);
const dot = '.'.charCodeAt(0);

module.exports = function unit(value) {
  let pos = 0;
  const length = value.length;
  let dotted = false;
  let containsNumber = false;
  let code;
  let number = '';

  while (pos < length) {
    code = value.charCodeAt(pos);

    if (code >= 48 && code <= 57) {
      number += value[pos];
      containsNumber = true;
    } else if (code === dot) {
      if (dotted) {
        break;
      }
      dotted = true;
      number += value[pos];
    } else if (code === plus || code === minus) {
      if (pos !== 0) {
        break;
      }
      number += value[pos];
    } else {
      break;
    }

    pos += 1;
  }

  return containsNumber ? {
    number,
    unit: value.slice(pos),
  } : false;
};

},{}],744:[function(require,module,exports){
'use strict';

var getDay = Date.prototype.getDay;
var tryDateObject = function tryDateObject(value) {
	try {
		getDay.call(value);
		return true;
	} catch (e) {
		return false;
	}
};

var toStr = Object.prototype.toString;
var dateClass = '[object Date]';
var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';

module.exports = function isDateObject(value) {
	if (typeof value !== 'object' || value === null) { return false; }
	return hasToStringTag ? tryDateObject(value) : toStr.call(value) === dateClass;
};

},{}],745:[function(require,module,exports){
/*!
 * is-directory <https://github.com/jonschlinkert/is-directory>
 *
 * Copyright (c) 2014-2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */

'use strict';

var fs = require('fs');

/**
 * async
 */

function isDirectory(filepath, cb) {
  if (typeof cb !== 'function') {
    throw new Error('expected a callback function');
  }

  if (typeof filepath !== 'string') {
    cb(new Error('expected filepath to be a string'));
    return;
  }

  fs.stat(filepath, function(err, stats) {
    if (err) {
      if (err.code === 'ENOENT') {
        cb(null, false);
        return;
      }
      cb(err);
      return;
    }
    cb(null, stats.isDirectory());
  });
}

/**
 * sync
 */

isDirectory.sync = function isDirectorySync(filepath) {
  if (typeof filepath !== 'string') {
    throw new Error('expected filepath to be a string');
  }

  try {
    var stat = fs.statSync(filepath);
    return stat.isDirectory();
  } catch (err) {
    if (err.code === 'ENOENT') {
      return false;
    } else {
      throw err;
    }
  }
  return false;
};

/**
 * Expose `isDirectory`
 */

module.exports = isDirectory;

},{"fs":8}],746:[function(require,module,exports){
'use strict';
module.exports = function (x) {
	var type = typeof x;
	return x !== null && (type === 'object' || type === 'function');
};

},{}],747:[function(require,module,exports){
'use strict';

var has = require('has');
var regexExec = RegExp.prototype.exec;
var gOPD = Object.getOwnPropertyDescriptor;

var tryRegexExecCall = function tryRegexExec(value) {
	try {
		var lastIndex = value.lastIndex;
		value.lastIndex = 0;

		regexExec.call(value);
		return true;
	} catch (e) {
		return false;
	} finally {
		value.lastIndex = lastIndex;
	}
};
var toStr = Object.prototype.toString;
var regexClass = '[object RegExp]';
var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';

module.exports = function isRegex(value) {
	if (!value || typeof value !== 'object') {
		return false;
	}
	if (!hasToStringTag) {
		return toStr.call(value) === regexClass;
	}

	var descriptor = gOPD(value, 'lastIndex');
	var hasLastIndexDataProperty = descriptor && has(descriptor, 'value');
	if (!hasLastIndexDataProperty) {
		return false;
	}

	return tryRegexExecCall(value);
};

},{"has":720}],748:[function(require,module,exports){
'use strict';

var inspect = require('util').inspect;

module.exports = function isResolvable(moduleId, options) {
	if (typeof moduleId !== 'string') {
		throw new TypeError(inspect(moduleId) + ' is not a string. Expected a valid Node.js module identifier (<string>), for example \'eslint\', \'./index.js\', \'./lib\'.');
	}

	try {
		require.resolve(moduleId, options);
		return true;
	} catch (err) {
		return false;
	}
};

},{"util":1204}],749:[function(require,module,exports){
(function (Buffer){
'use strict';
const htmlCommentRegex = require('html-comment-regex');

function isBinary(buf) {
	const isBuf = Buffer.isBuffer(buf);

	for (let i = 0; i < 24; i++) {
		const charCode = isBuf ? buf[i] : buf.charCodeAt(i);

		if (charCode === 65533 || charCode <= 8) {
			return true;
		}
	}

	return false;
}

const regex = /^\s*(?:<\?xml[^>]*>\s*)?(?:<!doctype svg[^>]*\s*(?:\[?(?:\s*<![^>]*>\s*)*\]?)*[^>]*>\s*)?<svg[^>]*>[^]*<\/svg>\s*$/i;

module.exports = input => Boolean(input) && !isBinary(input) && regex.test(input.toString().replace(htmlCommentRegex, ''));

}).call(this,{"isBuffer":require("../is-buffer/index.js")})
},{"../is-buffer/index.js":731,"html-comment-regex":724}],750:[function(require,module,exports){
'use strict';

var toStr = Object.prototype.toString;
var hasSymbols = require('has-symbols')();

if (hasSymbols) {
	var symToStr = Symbol.prototype.toString;
	var symStringRegex = /^Symbol\(.*\)$/;
	var isSymbolObject = function isRealSymbolObject(value) {
		if (typeof value.valueOf() !== 'symbol') {
			return false;
		}
		return symStringRegex.test(symToStr.call(value));
	};

	module.exports = function isSymbol(value) {
		if (typeof value === 'symbol') {
			return true;
		}
		if (toStr.call(value) !== '[object Symbol]') {
			return false;
		}
		try {
			return isSymbolObject(value);
		} catch (e) {
			return false;
		}
	};
} else {

	module.exports = function isSymbol(value) {
		// this environment does not support Symbols.
		return false && value;
	};
}

},{"has-symbols":718}],751:[function(require,module,exports){
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},{}],752:[function(require,module,exports){
(function (global){
/*
 *  base64.js
 *
 *  Licensed under the BSD 3-Clause License.
 *    http://opensource.org/licenses/BSD-3-Clause
 *
 *  References:
 *    http://en.wikipedia.org/wiki/Base64
 */
;(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined'
        ? module.exports = factory(global)
        : typeof define === 'function' && define.amd
        ? define(factory) : factory(global)
}((
    typeof self !== 'undefined' ? self
        : typeof window !== 'undefined' ? window
        : typeof global !== 'undefined' ? global
: this
), function(global) {
    'use strict';
    // existing version for noConflict()
    global = global || {};
    var _Base64 = global.Base64;
    var version = "2.5.1";
    // if node.js and NOT React Native, we use Buffer
    var buffer;
    if (typeof module !== 'undefined' && module.exports) {
        try {
            buffer = eval("require('buffer').Buffer");
        } catch (err) {
            buffer = undefined;
        }
    }
    // constants
    var b64chars
        = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
    var b64tab = function(bin) {
        var t = {};
        for (var i = 0, l = bin.length; i < l; i++) t[bin.charAt(i)] = i;
        return t;
    }(b64chars);
    var fromCharCode = String.fromCharCode;
    // encoder stuff
    var cb_utob = function(c) {
        if (c.length < 2) {
            var cc = c.charCodeAt(0);
            return cc < 0x80 ? c
                : cc < 0x800 ? (fromCharCode(0xc0 | (cc >>> 6))
                                + fromCharCode(0x80 | (cc & 0x3f)))
                : (fromCharCode(0xe0 | ((cc >>> 12) & 0x0f))
                   + fromCharCode(0x80 | ((cc >>>  6) & 0x3f))
                   + fromCharCode(0x80 | ( cc         & 0x3f)));
        } else {
            var cc = 0x10000
                + (c.charCodeAt(0) - 0xD800) * 0x400
                + (c.charCodeAt(1) - 0xDC00);
            return (fromCharCode(0xf0 | ((cc >>> 18) & 0x07))
                    + fromCharCode(0x80 | ((cc >>> 12) & 0x3f))
                    + fromCharCode(0x80 | ((cc >>>  6) & 0x3f))
                    + fromCharCode(0x80 | ( cc         & 0x3f)));
        }
    };
    var re_utob = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g;
    var utob = function(u) {
        return u.replace(re_utob, cb_utob);
    };
    var cb_encode = function(ccc) {
        var padlen = [0, 2, 1][ccc.length % 3],
        ord = ccc.charCodeAt(0) << 16
            | ((ccc.length > 1 ? ccc.charCodeAt(1) : 0) << 8)
            | ((ccc.length > 2 ? ccc.charCodeAt(2) : 0)),
        chars = [
            b64chars.charAt( ord >>> 18),
            b64chars.charAt((ord >>> 12) & 63),
            padlen >= 2 ? '=' : b64chars.charAt((ord >>> 6) & 63),
            padlen >= 1 ? '=' : b64chars.charAt(ord & 63)
        ];
        return chars.join('');
    };
    var btoa = global.btoa ? function(b) {
        return global.btoa(b);
    } : function(b) {
        return b.replace(/[\s\S]{1,3}/g, cb_encode);
    };
    var _encode = buffer ?
        buffer.from && Uint8Array && buffer.from !== Uint8Array.from
        ? function (u) {
            return (u.constructor === buffer.constructor ? u : buffer.from(u))
                .toString('base64')
        }
        :  function (u) {
            return (u.constructor === buffer.constructor ? u : new  buffer(u))
                .toString('base64')
        }
        : function (u) { return btoa(utob(u)) }
    ;
    var encode = function(u, urisafe) {
        return !urisafe
            ? _encode(String(u))
            : _encode(String(u)).replace(/[+\/]/g, function(m0) {
                return m0 == '+' ? '-' : '_';
            }).replace(/=/g, '');
    };
    var encodeURI = function(u) { return encode(u, true) };
    // decoder stuff
    var re_btou = new RegExp([
        '[\xC0-\xDF][\x80-\xBF]',
        '[\xE0-\xEF][\x80-\xBF]{2}',
        '[\xF0-\xF7][\x80-\xBF]{3}'
    ].join('|'), 'g');
    var cb_btou = function(cccc) {
        switch(cccc.length) {
        case 4:
            var cp = ((0x07 & cccc.charCodeAt(0)) << 18)
                |    ((0x3f & cccc.charCodeAt(1)) << 12)
                |    ((0x3f & cccc.charCodeAt(2)) <<  6)
                |     (0x3f & cccc.charCodeAt(3)),
            offset = cp - 0x10000;
            return (fromCharCode((offset  >>> 10) + 0xD800)
                    + fromCharCode((offset & 0x3FF) + 0xDC00));
        case 3:
            return fromCharCode(
                ((0x0f & cccc.charCodeAt(0)) << 12)
                    | ((0x3f & cccc.charCodeAt(1)) << 6)
                    |  (0x3f & cccc.charCodeAt(2))
            );
        default:
            return  fromCharCode(
                ((0x1f & cccc.charCodeAt(0)) << 6)
                    |  (0x3f & cccc.charCodeAt(1))
            );
        }
    };
    var btou = function(b) {
        return b.replace(re_btou, cb_btou);
    };
    var cb_decode = function(cccc) {
        var len = cccc.length,
        padlen = len % 4,
        n = (len > 0 ? b64tab[cccc.charAt(0)] << 18 : 0)
            | (len > 1 ? b64tab[cccc.charAt(1)] << 12 : 0)
            | (len > 2 ? b64tab[cccc.charAt(2)] <<  6 : 0)
            | (len > 3 ? b64tab[cccc.charAt(3)]       : 0),
        chars = [
            fromCharCode( n >>> 16),
            fromCharCode((n >>>  8) & 0xff),
            fromCharCode( n         & 0xff)
        ];
        chars.length -= [0, 0, 2, 1][padlen];
        return chars.join('');
    };
    var _atob = global.atob ? function(a) {
        return global.atob(a);
    } : function(a){
        return a.replace(/\S{1,4}/g, cb_decode);
    };
    var atob = function(a) {
        return _atob(String(a).replace(/[^A-Za-z0-9\+\/]/g, ''));
    };
    var _decode = buffer ?
        buffer.from && Uint8Array && buffer.from !== Uint8Array.from
        ? function(a) {
            return (a.constructor === buffer.constructor
                    ? a : buffer.from(a, 'base64')).toString();
        }
        : function(a) {
            return (a.constructor === buffer.constructor
                    ? a : new buffer(a, 'base64')).toString();
        }
        : function(a) { return btou(_atob(a)) };
    var decode = function(a){
        return _decode(
            String(a).replace(/[-_]/g, function(m0) { return m0 == '-' ? '+' : '/' })
                .replace(/[^A-Za-z0-9\+\/]/g, '')
        );
    };
    var noConflict = function() {
        var Base64 = global.Base64;
        global.Base64 = _Base64;
        return Base64;
    };
    // export Base64
    global.Base64 = {
        VERSION: version,
        atob: atob,
        btoa: btoa,
        fromBase64: decode,
        toBase64: encode,
        utob: utob,
        encode: encode,
        encodeURI: encodeURI,
        btou: btou,
        decode: decode,
        noConflict: noConflict,
        __buffer__: buffer
    };
    // if ES5 is available, make Base64.extendString() available
    if (typeof Object.defineProperty === 'function') {
        var noEnum = function(v){
            return {value:v,enumerable:false,writable:true,configurable:true};
        };
        global.Base64.extendString = function () {
            Object.defineProperty(
                String.prototype, 'fromBase64', noEnum(function () {
                    return decode(this)
                }));
            Object.defineProperty(
                String.prototype, 'toBase64', noEnum(function (urisafe) {
                    return encode(this, urisafe)
                }));
            Object.defineProperty(
                String.prototype, 'toBase64URI', noEnum(function () {
                    return encode(this, true)
                }));
        };
    }
    //
    // export Base64 to the namespace
    //
    if (global['Meteor']) { // Meteor.js
        Base64 = global.Base64;
    }
    // module.exports and AMD are mutually exclusive.
    // module.exports has precedence.
    if (typeof module !== 'undefined' && module.exports) {
        module.exports.Base64 = global.Base64;
    }
    else if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define([], function(){ return global.Base64 });
    }
    // that's it!
    return {Base64: global.Base64}
}));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],753:[function(require,module,exports){
'use strict';


var yaml = require('./lib/js-yaml.js');


module.exports = yaml;

},{"./lib/js-yaml.js":754}],754:[function(require,module,exports){
'use strict';


var loader = require('./js-yaml/loader');
var dumper = require('./js-yaml/dumper');


function deprecated(name) {
  return function () {
    throw new Error('Function ' + name + ' is deprecated and cannot be used.');
  };
}


module.exports.Type                = require('./js-yaml/type');
module.exports.Schema              = require('./js-yaml/schema');
module.exports.FAILSAFE_SCHEMA     = require('./js-yaml/schema/failsafe');
module.exports.JSON_SCHEMA         = require('./js-yaml/schema/json');
module.exports.CORE_SCHEMA         = require('./js-yaml/schema/core');
module.exports.DEFAULT_SAFE_SCHEMA = require('./js-yaml/schema/default_safe');
module.exports.DEFAULT_FULL_SCHEMA = require('./js-yaml/schema/default_full');
module.exports.load                = loader.load;
module.exports.loadAll             = loader.loadAll;
module.exports.safeLoad            = loader.safeLoad;
module.exports.safeLoadAll         = loader.safeLoadAll;
module.exports.dump                = dumper.dump;
module.exports.safeDump            = dumper.safeDump;
module.exports.YAMLException       = require('./js-yaml/exception');

// Deprecated schema names from JS-YAML 2.0.x
module.exports.MINIMAL_SCHEMA = require('./js-yaml/schema/failsafe');
module.exports.SAFE_SCHEMA    = require('./js-yaml/schema/default_safe');
module.exports.DEFAULT_SCHEMA = require('./js-yaml/schema/default_full');

// Deprecated functions from JS-YAML 1.x.x
module.exports.scan           = deprecated('scan');
module.exports.parse          = deprecated('parse');
module.exports.compose        = deprecated('compose');
module.exports.addConstructor = deprecated('addConstructor');

},{"./js-yaml/dumper":756,"./js-yaml/exception":757,"./js-yaml/loader":758,"./js-yaml/schema":760,"./js-yaml/schema/core":761,"./js-yaml/schema/default_full":762,"./js-yaml/schema/default_safe":763,"./js-yaml/schema/failsafe":764,"./js-yaml/schema/json":765,"./js-yaml/type":766}],755:[function(require,module,exports){
'use strict';


function isNothing(subject) {
  return (typeof subject === 'undefined') || (subject === null);
}


function isObject(subject) {
  return (typeof subject === 'object') && (subject !== null);
}


function toArray(sequence) {
  if (Array.isArray(sequence)) return sequence;
  else if (isNothing(sequence)) return [];

  return [ sequence ];
}


function extend(target, source) {
  var index, length, key, sourceKeys;

  if (source) {
    sourceKeys = Object.keys(source);

    for (index = 0, length = sourceKeys.length; index < length; index += 1) {
      key = sourceKeys[index];
      target[key] = source[key];
    }
  }

  return target;
}


function repeat(string, count) {
  var result = '', cycle;

  for (cycle = 0; cycle < count; cycle += 1) {
    result += string;
  }

  return result;
}


function isNegativeZero(number) {
  return (number === 0) && (Number.NEGATIVE_INFINITY === 1 / number);
}


module.exports.isNothing      = isNothing;
module.exports.isObject       = isObject;
module.exports.toArray        = toArray;
module.exports.repeat         = repeat;
module.exports.isNegativeZero = isNegativeZero;
module.exports.extend         = extend;

},{}],756:[function(require,module,exports){
'use strict';

/*eslint-disable no-use-before-define*/

var common              = require('./common');
var YAMLException       = require('./exception');
var DEFAULT_FULL_SCHEMA = require('./schema/default_full');
var DEFAULT_SAFE_SCHEMA = require('./schema/default_safe');

var _toString       = Object.prototype.toString;
var _hasOwnProperty = Object.prototype.hasOwnProperty;

var CHAR_TAB                  = 0x09; /* Tab */
var CHAR_LINE_FEED            = 0x0A; /* LF */
var CHAR_SPACE                = 0x20; /* Space */
var CHAR_EXCLAMATION          = 0x21; /* ! */
var CHAR_DOUBLE_QUOTE         = 0x22; /* " */
var CHAR_SHARP                = 0x23; /* # */
var CHAR_PERCENT              = 0x25; /* % */
var CHAR_AMPERSAND            = 0x26; /* & */
var CHAR_SINGLE_QUOTE         = 0x27; /* ' */
var CHAR_ASTERISK             = 0x2A; /* * */
var CHAR_COMMA                = 0x2C; /* , */
var CHAR_MINUS                = 0x2D; /* - */
var CHAR_COLON                = 0x3A; /* : */
var CHAR_GREATER_THAN         = 0x3E; /* > */
var CHAR_QUESTION             = 0x3F; /* ? */
var CHAR_COMMERCIAL_AT        = 0x40; /* @ */
var CHAR_LEFT_SQUARE_BRACKET  = 0x5B; /* [ */
var CHAR_RIGHT_SQUARE_BRACKET = 0x5D; /* ] */
var CHAR_GRAVE_ACCENT         = 0x60; /* ` */
var CHAR_LEFT_CURLY_BRACKET   = 0x7B; /* { */
var CHAR_VERTICAL_LINE        = 0x7C; /* | */
var CHAR_RIGHT_CURLY_BRACKET  = 0x7D; /* } */

var ESCAPE_SEQUENCES = {};

ESCAPE_SEQUENCES[0x00]   = '\\0';
ESCAPE_SEQUENCES[0x07]   = '\\a';
ESCAPE_SEQUENCES[0x08]   = '\\b';
ESCAPE_SEQUENCES[0x09]   = '\\t';
ESCAPE_SEQUENCES[0x0A]   = '\\n';
ESCAPE_SEQUENCES[0x0B]   = '\\v';
ESCAPE_SEQUENCES[0x0C]   = '\\f';
ESCAPE_SEQUENCES[0x0D]   = '\\r';
ESCAPE_SEQUENCES[0x1B]   = '\\e';
ESCAPE_SEQUENCES[0x22]   = '\\"';
ESCAPE_SEQUENCES[0x5C]   = '\\\\';
ESCAPE_SEQUENCES[0x85]   = '\\N';
ESCAPE_SEQUENCES[0xA0]   = '\\_';
ESCAPE_SEQUENCES[0x2028] = '\\L';
ESCAPE_SEQUENCES[0x2029] = '\\P';

var DEPRECATED_BOOLEANS_SYNTAX = [
  'y', 'Y', 'yes', 'Yes', 'YES', 'on', 'On', 'ON',
  'n', 'N', 'no', 'No', 'NO', 'off', 'Off', 'OFF'
];

function compileStyleMap(schema, map) {
  var result, keys, index, length, tag, style, type;

  if (map === null) return {};

  result = {};
  keys = Object.keys(map);

  for (index = 0, length = keys.length; index < length; index += 1) {
    tag = keys[index];
    style = String(map[tag]);

    if (tag.slice(0, 2) === '!!') {
      tag = 'tag:yaml.org,2002:' + tag.slice(2);
    }
    type = schema.compiledTypeMap['fallback'][tag];

    if (type && _hasOwnProperty.call(type.styleAliases, style)) {
      style = type.styleAliases[style];
    }

    result[tag] = style;
  }

  return result;
}

function encodeHex(character) {
  var string, handle, length;

  string = character.toString(16).toUpperCase();

  if (character <= 0xFF) {
    handle = 'x';
    length = 2;
  } else if (character <= 0xFFFF) {
    handle = 'u';
    length = 4;
  } else if (character <= 0xFFFFFFFF) {
    handle = 'U';
    length = 8;
  } else {
    throw new YAMLException('code point within a string may not be greater than 0xFFFFFFFF');
  }

  return '\\' + handle + common.repeat('0', length - string.length) + string;
}

function State(options) {
  this.schema        = options['schema'] || DEFAULT_FULL_SCHEMA;
  this.indent        = Math.max(1, (options['indent'] || 2));
  this.noArrayIndent = options['noArrayIndent'] || false;
  this.skipInvalid   = options['skipInvalid'] || false;
  this.flowLevel     = (common.isNothing(options['flowLevel']) ? -1 : options['flowLevel']);
  this.styleMap      = compileStyleMap(this.schema, options['styles'] || null);
  this.sortKeys      = options['sortKeys'] || false;
  this.lineWidth     = options['lineWidth'] || 80;
  this.noRefs        = options['noRefs'] || false;
  this.noCompatMode  = options['noCompatMode'] || false;
  this.condenseFlow  = options['condenseFlow'] || false;

  this.implicitTypes = this.schema.compiledImplicit;
  this.explicitTypes = this.schema.compiledExplicit;

  this.tag = null;
  this.result = '';

  this.duplicates = [];
  this.usedDuplicates = null;
}

// Indents every line in a string. Empty lines (\n only) are not indented.
function indentString(string, spaces) {
  var ind = common.repeat(' ', spaces),
      position = 0,
      next = -1,
      result = '',
      line,
      length = string.length;

  while (position < length) {
    next = string.indexOf('\n', position);
    if (next === -1) {
      line = string.slice(position);
      position = length;
    } else {
      line = string.slice(position, next + 1);
      position = next + 1;
    }

    if (line.length && line !== '\n') result += ind;

    result += line;
  }

  return result;
}

function generateNextLine(state, level) {
  return '\n' + common.repeat(' ', state.indent * level);
}

function testImplicitResolving(state, str) {
  var index, length, type;

  for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
    type = state.implicitTypes[index];

    if (type.resolve(str)) {
      return true;
    }
  }

  return false;
}

// [33] s-white ::= s-space | s-tab
function isWhitespace(c) {
  return c === CHAR_SPACE || c === CHAR_TAB;
}

// Returns true if the character can be printed without escaping.
// From YAML 1.2: "any allowed characters known to be non-printable
// should also be escaped. [However,] This isnt mandatory"
// Derived from nb-char - \t - #x85 - #xA0 - #x2028 - #x2029.
function isPrintable(c) {
  return  (0x00020 <= c && c <= 0x00007E)
      || ((0x000A1 <= c && c <= 0x00D7FF) && c !== 0x2028 && c !== 0x2029)
      || ((0x0E000 <= c && c <= 0x00FFFD) && c !== 0xFEFF /* BOM */)
      ||  (0x10000 <= c && c <= 0x10FFFF);
}

// Simplified test for values allowed after the first character in plain style.
function isPlainSafe(c) {
  // Uses a subset of nb-char - c-flow-indicator - ":" - "#"
  // where nb-char ::= c-printable - b-char - c-byte-order-mark.
  return isPrintable(c) && c !== 0xFEFF
    // - c-flow-indicator
    && c !== CHAR_COMMA
    && c !== CHAR_LEFT_SQUARE_BRACKET
    && c !== CHAR_RIGHT_SQUARE_BRACKET
    && c !== CHAR_LEFT_CURLY_BRACKET
    && c !== CHAR_RIGHT_CURLY_BRACKET
    // - ":" - "#"
    && c !== CHAR_COLON
    && c !== CHAR_SHARP;
}

// Simplified test for values allowed as the first character in plain style.
function isPlainSafeFirst(c) {
  // Uses a subset of ns-char - c-indicator
  // where ns-char = nb-char - s-white.
  return isPrintable(c) && c !== 0xFEFF
    && !isWhitespace(c) // - s-white
    // - (c-indicator ::=
    // - | ? | : | , | [ | ] | { | }
    && c !== CHAR_MINUS
    && c !== CHAR_QUESTION
    && c !== CHAR_COLON
    && c !== CHAR_COMMA
    && c !== CHAR_LEFT_SQUARE_BRACKET
    && c !== CHAR_RIGHT_SQUARE_BRACKET
    && c !== CHAR_LEFT_CURLY_BRACKET
    && c !== CHAR_RIGHT_CURLY_BRACKET
    // | # | & | * | ! | | | > | ' | "
    && c !== CHAR_SHARP
    && c !== CHAR_AMPERSAND
    && c !== CHAR_ASTERISK
    && c !== CHAR_EXCLAMATION
    && c !== CHAR_VERTICAL_LINE
    && c !== CHAR_GREATER_THAN
    && c !== CHAR_SINGLE_QUOTE
    && c !== CHAR_DOUBLE_QUOTE
    // | % | @ | `)
    && c !== CHAR_PERCENT
    && c !== CHAR_COMMERCIAL_AT
    && c !== CHAR_GRAVE_ACCENT;
}

// Determines whether block indentation indicator is required.
function needIndentIndicator(string) {
  var leadingSpaceRe = /^\n* /;
  return leadingSpaceRe.test(string);
}

var STYLE_PLAIN   = 1,
    STYLE_SINGLE  = 2,
    STYLE_LITERAL = 3,
    STYLE_FOLDED  = 4,
    STYLE_DOUBLE  = 5;

// Determines which scalar styles are possible and returns the preferred style.
// lineWidth = -1 => no limit.
// Pre-conditions: str.length > 0.
// Post-conditions:
//    STYLE_PLAIN or STYLE_SINGLE => no \n are in the string.
//    STYLE_LITERAL => no lines are suitable for folding (or lineWidth is -1).
//    STYLE_FOLDED => a line > lineWidth and can be folded (and lineWidth != -1).
function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType) {
  var i;
  var char;
  var hasLineBreak = false;
  var hasFoldableLine = false; // only checked if shouldTrackWidth
  var shouldTrackWidth = lineWidth !== -1;
  var previousLineBreak = -1; // count the first line correctly
  var plain = isPlainSafeFirst(string.charCodeAt(0))
          && !isWhitespace(string.charCodeAt(string.length - 1));

  if (singleLineOnly) {
    // Case: no block styles.
    // Check for disallowed characters to rule out plain and single.
    for (i = 0; i < string.length; i++) {
      char = string.charCodeAt(i);
      if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain && isPlainSafe(char);
    }
  } else {
    // Case: block styles permitted.
    for (i = 0; i < string.length; i++) {
      char = string.charCodeAt(i);
      if (char === CHAR_LINE_FEED) {
        hasLineBreak = true;
        // Check if any line can be folded.
        if (shouldTrackWidth) {
          hasFoldableLine = hasFoldableLine ||
            // Foldable line = too long, and not more-indented.
            (i - previousLineBreak - 1 > lineWidth &&
             string[previousLineBreak + 1] !== ' ');
          previousLineBreak = i;
        }
      } else if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain && isPlainSafe(char);
    }
    // in case the end is missing a \n
    hasFoldableLine = hasFoldableLine || (shouldTrackWidth &&
      (i - previousLineBreak - 1 > lineWidth &&
       string[previousLineBreak + 1] !== ' '));
  }
  // Although every style can represent \n without escaping, prefer block styles
  // for multiline, since they're more readable and they don't add empty lines.
  // Also prefer folding a super-long line.
  if (!hasLineBreak && !hasFoldableLine) {
    // Strings interpretable as another type have to be quoted;
    // e.g. the string 'true' vs. the boolean true.
    return plain && !testAmbiguousType(string)
      ? STYLE_PLAIN : STYLE_SINGLE;
  }
  // Edge case: block indentation indicator can only have one digit.
  if (indentPerLevel > 9 && needIndentIndicator(string)) {
    return STYLE_DOUBLE;
  }
  // At this point we know block styles are valid.
  // Prefer literal style unless we want to fold.
  return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
}

// Note: line breaking/folding is implemented for only the folded style.
// NB. We drop the last trailing newline (if any) of a returned block scalar
//  since the dumper adds its own newline. This always works:
//     No ending newline => unaffected; already using strip "-" chomping.
//     Ending newline    => removed then restored.
//  Importantly, this keeps the "+" chomp indicator from gaining an extra line.
function writeScalar(state, string, level, iskey) {
  state.dump = (function () {
    if (string.length === 0) {
      return "''";
    }
    if (!state.noCompatMode &&
        DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1) {
      return "'" + string + "'";
    }

    var indent = state.indent * Math.max(1, level); // no 0-indent scalars
    // As indentation gets deeper, let the width decrease monotonically
    // to the lower bound min(state.lineWidth, 40).
    // Note that this implies
    //  state.lineWidth  40 + state.indent: width is fixed at the lower bound.
    //  state.lineWidth > 40 + state.indent: width decreases until the lower bound.
    // This behaves better than a constant minimum width which disallows narrower options,
    // or an indent threshold which causes the width to suddenly increase.
    var lineWidth = state.lineWidth === -1
      ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);

    // Without knowing if keys are implicit/explicit, assume implicit for safety.
    var singleLineOnly = iskey
      // No block styles in flow mode.
      || (state.flowLevel > -1 && level >= state.flowLevel);
    function testAmbiguity(string) {
      return testImplicitResolving(state, string);
    }

    switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth, testAmbiguity)) {
      case STYLE_PLAIN:
        return string;
      case STYLE_SINGLE:
        return "'" + string.replace(/'/g, "''") + "'";
      case STYLE_LITERAL:
        return '|' + blockHeader(string, state.indent)
          + dropEndingNewline(indentString(string, indent));
      case STYLE_FOLDED:
        return '>' + blockHeader(string, state.indent)
          + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
      case STYLE_DOUBLE:
        return '"' + escapeString(string, lineWidth) + '"';
      default:
        throw new YAMLException('impossible error: invalid scalar style');
    }
  }());
}

// Pre-conditions: string is valid for a block scalar, 1 <= indentPerLevel <= 9.
function blockHeader(string, indentPerLevel) {
  var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : '';

  // note the special case: the string '\n' counts as a "trailing" empty line.
  var clip =          string[string.length - 1] === '\n';
  var keep = clip && (string[string.length - 2] === '\n' || string === '\n');
  var chomp = keep ? '+' : (clip ? '' : '-');

  return indentIndicator + chomp + '\n';
}

// (See the note for writeScalar.)
function dropEndingNewline(string) {
  return string[string.length - 1] === '\n' ? string.slice(0, -1) : string;
}

// Note: a long line without a suitable break point will exceed the width limit.
// Pre-conditions: every char in str isPrintable, str.length > 0, width > 0.
function foldString(string, width) {
  // In folded style, $k$ consecutive newlines output as $k+1$ newlines
  // unless they're before or after a more-indented line, or at the very
  // beginning or end, in which case $k$ maps to $k$.
  // Therefore, parse each chunk as newline(s) followed by a content line.
  var lineRe = /(\n+)([^\n]*)/g;

  // first line (possibly an empty line)
  var result = (function () {
    var nextLF = string.indexOf('\n');
    nextLF = nextLF !== -1 ? nextLF : string.length;
    lineRe.lastIndex = nextLF;
    return foldLine(string.slice(0, nextLF), width);
  }());
  // If we haven't reached the first content line yet, don't add an extra \n.
  var prevMoreIndented = string[0] === '\n' || string[0] === ' ';
  var moreIndented;

  // rest of the lines
  var match;
  while ((match = lineRe.exec(string))) {
    var prefix = match[1], line = match[2];
    moreIndented = (line[0] === ' ');
    result += prefix
      + (!prevMoreIndented && !moreIndented && line !== ''
        ? '\n' : '')
      + foldLine(line, width);
    prevMoreIndented = moreIndented;
  }

  return result;
}

// Greedy line breaking.
// Picks the longest line under the limit each time,
// otherwise settles for the shortest line over the limit.
// NB. More-indented lines *cannot* be folded, as that would add an extra \n.
function foldLine(line, width) {
  if (line === '' || line[0] === ' ') return line;

  // Since a more-indented line adds a \n, breaks can't be followed by a space.
  var breakRe = / [^ ]/g; // note: the match index will always be <= length-2.
  var match;
  // start is an inclusive index. end, curr, and next are exclusive.
  var start = 0, end, curr = 0, next = 0;
  var result = '';

  // Invariants: 0 <= start <= length-1.
  //   0 <= curr <= next <= max(0, length-2). curr - start <= width.
  // Inside the loop:
  //   A match implies length >= 2, so curr and next are <= length-2.
  while ((match = breakRe.exec(line))) {
    next = match.index;
    // maintain invariant: curr - start <= width
    if (next - start > width) {
      end = (curr > start) ? curr : next; // derive end <= length-2
      result += '\n' + line.slice(start, end);
      // skip the space that was output as \n
      start = end + 1;                    // derive start <= length-1
    }
    curr = next;
  }

  // By the invariants, start <= length-1, so there is something left over.
  // It is either the whole string or a part starting from non-whitespace.
  result += '\n';
  // Insert a break if the remainder is too long and there is a break available.
  if (line.length - start > width && curr > start) {
    result += line.slice(start, curr) + '\n' + line.slice(curr + 1);
  } else {
    result += line.slice(start);
  }

  return result.slice(1); // drop extra \n joiner
}

// Escapes a double-quoted string.
function escapeString(string) {
  var result = '';
  var char, nextChar;
  var escapeSeq;

  for (var i = 0; i < string.length; i++) {
    char = string.charCodeAt(i);
    // Check for surrogate pairs (reference Unicode 3.0 section "3.7 Surrogates").
    if (char >= 0xD800 && char <= 0xDBFF/* high surrogate */) {
      nextChar = string.charCodeAt(i + 1);
      if (nextChar >= 0xDC00 && nextChar <= 0xDFFF/* low surrogate */) {
        // Combine the surrogate pair and store it escaped.
        result += encodeHex((char - 0xD800) * 0x400 + nextChar - 0xDC00 + 0x10000);
        // Advance index one extra since we already used that char here.
        i++; continue;
      }
    }
    escapeSeq = ESCAPE_SEQUENCES[char];
    result += !escapeSeq && isPrintable(char)
      ? string[i]
      : escapeSeq || encodeHex(char);
  }

  return result;
}

function writeFlowSequence(state, level, object) {
  var _result = '',
      _tag    = state.tag,
      index,
      length;

  for (index = 0, length = object.length; index < length; index += 1) {
    // Write only valid elements.
    if (writeNode(state, level, object[index], false, false)) {
      if (index !== 0) _result += ',' + (!state.condenseFlow ? ' ' : '');
      _result += state.dump;
    }
  }

  state.tag = _tag;
  state.dump = '[' + _result + ']';
}

function writeBlockSequence(state, level, object, compact) {
  var _result = '',
      _tag    = state.tag,
      index,
      length;

  for (index = 0, length = object.length; index < length; index += 1) {
    // Write only valid elements.
    if (writeNode(state, level + 1, object[index], true, true)) {
      if (!compact || index !== 0) {
        _result += generateNextLine(state, level);
      }

      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        _result += '-';
      } else {
        _result += '- ';
      }

      _result += state.dump;
    }
  }

  state.tag = _tag;
  state.dump = _result || '[]'; // Empty sequence if no valid values.
}

function writeFlowMapping(state, level, object) {
  var _result       = '',
      _tag          = state.tag,
      objectKeyList = Object.keys(object),
      index,
      length,
      objectKey,
      objectValue,
      pairBuffer;

  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = state.condenseFlow ? '"' : '';

    if (index !== 0) pairBuffer += ', ';

    objectKey = objectKeyList[index];
    objectValue = object[objectKey];

    if (!writeNode(state, level, objectKey, false, false)) {
      continue; // Skip this pair because of invalid key;
    }

    if (state.dump.length > 1024) pairBuffer += '? ';

    pairBuffer += state.dump + (state.condenseFlow ? '"' : '') + ':' + (state.condenseFlow ? '' : ' ');

    if (!writeNode(state, level, objectValue, false, false)) {
      continue; // Skip this pair because of invalid value.
    }

    pairBuffer += state.dump;

    // Both key and value are valid.
    _result += pairBuffer;
  }

  state.tag = _tag;
  state.dump = '{' + _result + '}';
}

function writeBlockMapping(state, level, object, compact) {
  var _result       = '',
      _tag          = state.tag,
      objectKeyList = Object.keys(object),
      index,
      length,
      objectKey,
      objectValue,
      explicitPair,
      pairBuffer;

  // Allow sorting keys so that the output file is deterministic
  if (state.sortKeys === true) {
    // Default sorting
    objectKeyList.sort();
  } else if (typeof state.sortKeys === 'function') {
    // Custom sort function
    objectKeyList.sort(state.sortKeys);
  } else if (state.sortKeys) {
    // Something is wrong
    throw new YAMLException('sortKeys must be a boolean or a function');
  }

  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = '';

    if (!compact || index !== 0) {
      pairBuffer += generateNextLine(state, level);
    }

    objectKey = objectKeyList[index];
    objectValue = object[objectKey];

    if (!writeNode(state, level + 1, objectKey, true, true, true)) {
      continue; // Skip this pair because of invalid key.
    }

    explicitPair = (state.tag !== null && state.tag !== '?') ||
                   (state.dump && state.dump.length > 1024);

    if (explicitPair) {
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        pairBuffer += '?';
      } else {
        pairBuffer += '? ';
      }
    }

    pairBuffer += state.dump;

    if (explicitPair) {
      pairBuffer += generateNextLine(state, level);
    }

    if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
      continue; // Skip this pair because of invalid value.
    }

    if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
      pairBuffer += ':';
    } else {
      pairBuffer += ': ';
    }

    pairBuffer += state.dump;

    // Both key and value are valid.
    _result += pairBuffer;
  }

  state.tag = _tag;
  state.dump = _result || '{}'; // Empty mapping if no valid pairs.
}

function detectType(state, object, explicit) {
  var _result, typeList, index, length, type, style;

  typeList = explicit ? state.explicitTypes : state.implicitTypes;

  for (index = 0, length = typeList.length; index < length; index += 1) {
    type = typeList[index];

    if ((type.instanceOf  || type.predicate) &&
        (!type.instanceOf || ((typeof object === 'object') && (object instanceof type.instanceOf))) &&
        (!type.predicate  || type.predicate(object))) {

      state.tag = explicit ? type.tag : '?';

      if (type.represent) {
        style = state.styleMap[type.tag] || type.defaultStyle;

        if (_toString.call(type.represent) === '[object Function]') {
          _result = type.represent(object, style);
        } else if (_hasOwnProperty.call(type.represent, style)) {
          _result = type.represent[style](object, style);
        } else {
          throw new YAMLException('!<' + type.tag + '> tag resolver accepts not "' + style + '" style');
        }

        state.dump = _result;
      }

      return true;
    }
  }

  return false;
}

// Serializes `object` and writes it to global `result`.
// Returns true on success, or false on invalid object.
//
function writeNode(state, level, object, block, compact, iskey) {
  state.tag = null;
  state.dump = object;

  if (!detectType(state, object, false)) {
    detectType(state, object, true);
  }

  var type = _toString.call(state.dump);

  if (block) {
    block = (state.flowLevel < 0 || state.flowLevel > level);
  }

  var objectOrArray = type === '[object Object]' || type === '[object Array]',
      duplicateIndex,
      duplicate;

  if (objectOrArray) {
    duplicateIndex = state.duplicates.indexOf(object);
    duplicate = duplicateIndex !== -1;
  }

  if ((state.tag !== null && state.tag !== '?') || duplicate || (state.indent !== 2 && level > 0)) {
    compact = false;
  }

  if (duplicate && state.usedDuplicates[duplicateIndex]) {
    state.dump = '*ref_' + duplicateIndex;
  } else {
    if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
      state.usedDuplicates[duplicateIndex] = true;
    }
    if (type === '[object Object]') {
      if (block && (Object.keys(state.dump).length !== 0)) {
        writeBlockMapping(state, level, state.dump, compact);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + state.dump;
        }
      } else {
        writeFlowMapping(state, level, state.dump);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
        }
      }
    } else if (type === '[object Array]') {
      var arrayLevel = (state.noArrayIndent && (level > 0)) ? level - 1 : level;
      if (block && (state.dump.length !== 0)) {
        writeBlockSequence(state, arrayLevel, state.dump, compact);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + state.dump;
        }
      } else {
        writeFlowSequence(state, arrayLevel, state.dump);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
        }
      }
    } else if (type === '[object String]') {
      if (state.tag !== '?') {
        writeScalar(state, state.dump, level, iskey);
      }
    } else {
      if (state.skipInvalid) return false;
      throw new YAMLException('unacceptable kind of an object to dump ' + type);
    }

    if (state.tag !== null && state.tag !== '?') {
      state.dump = '!<' + state.tag + '> ' + state.dump;
    }
  }

  return true;
}

function getDuplicateReferences(object, state) {
  var objects = [],
      duplicatesIndexes = [],
      index,
      length;

  inspectNode(object, objects, duplicatesIndexes);

  for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
    state.duplicates.push(objects[duplicatesIndexes[index]]);
  }
  state.usedDuplicates = new Array(length);
}

function inspectNode(object, objects, duplicatesIndexes) {
  var objectKeyList,
      index,
      length;

  if (object !== null && typeof object === 'object') {
    index = objects.indexOf(object);
    if (index !== -1) {
      if (duplicatesIndexes.indexOf(index) === -1) {
        duplicatesIndexes.push(index);
      }
    } else {
      objects.push(object);

      if (Array.isArray(object)) {
        for (index = 0, length = object.length; index < length; index += 1) {
          inspectNode(object[index], objects, duplicatesIndexes);
        }
      } else {
        objectKeyList = Object.keys(object);

        for (index = 0, length = objectKeyList.length; index < length; index += 1) {
          inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
        }
      }
    }
  }
}

function dump(input, options) {
  options = options || {};

  var state = new State(options);

  if (!state.noRefs) getDuplicateReferences(input, state);

  if (writeNode(state, 0, input, true, true)) return state.dump + '\n';

  return '';
}

function safeDump(input, options) {
  return dump(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
}

module.exports.dump     = dump;
module.exports.safeDump = safeDump;

},{"./common":755,"./exception":757,"./schema/default_full":762,"./schema/default_safe":763}],757:[function(require,module,exports){
// YAML error class. http://stackoverflow.com/questions/8458984
//
'use strict';

function YAMLException(reason, mark) {
  // Super constructor
  Error.call(this);

  this.name = 'YAMLException';
  this.reason = reason;
  this.mark = mark;
  this.message = (this.reason || '(unknown reason)') + (this.mark ? ' ' + this.mark.toString() : '');

  // Include stack trace in error object
  if (Error.captureStackTrace) {
    // Chrome and NodeJS
    Error.captureStackTrace(this, this.constructor);
  } else {
    // FF, IE 10+ and Safari 6+. Fallback for others
    this.stack = (new Error()).stack || '';
  }
}


// Inherit from Error
YAMLException.prototype = Object.create(Error.prototype);
YAMLException.prototype.constructor = YAMLException;


YAMLException.prototype.toString = function toString(compact) {
  var result = this.name + ': ';

  result += this.reason || '(unknown reason)';

  if (!compact && this.mark) {
    result += ' ' + this.mark.toString();
  }

  return result;
};


module.exports = YAMLException;

},{}],758:[function(require,module,exports){
'use strict';

/*eslint-disable max-len,no-use-before-define*/

var common              = require('./common');
var YAMLException       = require('./exception');
var Mark                = require('./mark');
var DEFAULT_SAFE_SCHEMA = require('./schema/default_safe');
var DEFAULT_FULL_SCHEMA = require('./schema/default_full');


var _hasOwnProperty = Object.prototype.hasOwnProperty;


var CONTEXT_FLOW_IN   = 1;
var CONTEXT_FLOW_OUT  = 2;
var CONTEXT_BLOCK_IN  = 3;
var CONTEXT_BLOCK_OUT = 4;


var CHOMPING_CLIP  = 1;
var CHOMPING_STRIP = 2;
var CHOMPING_KEEP  = 3;


var PATTERN_NON_PRINTABLE         = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
var PATTERN_FLOW_INDICATORS       = /[,\[\]\{\}]/;
var PATTERN_TAG_HANDLE            = /^(?:!|!!|![a-z\-]+!)$/i;
var PATTERN_TAG_URI               = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;


function is_EOL(c) {
  return (c === 0x0A/* LF */) || (c === 0x0D/* CR */);
}

function is_WHITE_SPACE(c) {
  return (c === 0x09/* Tab */) || (c === 0x20/* Space */);
}

function is_WS_OR_EOL(c) {
  return (c === 0x09/* Tab */) ||
         (c === 0x20/* Space */) ||
         (c === 0x0A/* LF */) ||
         (c === 0x0D/* CR */);
}

function is_FLOW_INDICATOR(c) {
  return c === 0x2C/* , */ ||
         c === 0x5B/* [ */ ||
         c === 0x5D/* ] */ ||
         c === 0x7B/* { */ ||
         c === 0x7D/* } */;
}

function fromHexCode(c) {
  var lc;

  if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {
    return c - 0x30;
  }

  /*eslint-disable no-bitwise*/
  lc = c | 0x20;

  if ((0x61/* a */ <= lc) && (lc <= 0x66/* f */)) {
    return lc - 0x61 + 10;
  }

  return -1;
}

function escapedHexLen(c) {
  if (c === 0x78/* x */) { return 2; }
  if (c === 0x75/* u */) { return 4; }
  if (c === 0x55/* U */) { return 8; }
  return 0;
}

function fromDecimalCode(c) {
  if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {
    return c - 0x30;
  }

  return -1;
}

function simpleEscapeSequence(c) {
  /* eslint-disable indent */
  return (c === 0x30/* 0 */) ? '\x00' :
        (c === 0x61/* a */) ? '\x07' :
        (c === 0x62/* b */) ? '\x08' :
        (c === 0x74/* t */) ? '\x09' :
        (c === 0x09/* Tab */) ? '\x09' :
        (c === 0x6E/* n */) ? '\x0A' :
        (c === 0x76/* v */) ? '\x0B' :
        (c === 0x66/* f */) ? '\x0C' :
        (c === 0x72/* r */) ? '\x0D' :
        (c === 0x65/* e */) ? '\x1B' :
        (c === 0x20/* Space */) ? ' ' :
        (c === 0x22/* " */) ? '\x22' :
        (c === 0x2F/* / */) ? '/' :
        (c === 0x5C/* \ */) ? '\x5C' :
        (c === 0x4E/* N */) ? '\x85' :
        (c === 0x5F/* _ */) ? '\xA0' :
        (c === 0x4C/* L */) ? '\u2028' :
        (c === 0x50/* P */) ? '\u2029' : '';
}

function charFromCodepoint(c) {
  if (c <= 0xFFFF) {
    return String.fromCharCode(c);
  }
  // Encode UTF-16 surrogate pair
  // https://en.wikipedia.org/wiki/UTF-16#Code_points_U.2B010000_to_U.2B10FFFF
  return String.fromCharCode(
    ((c - 0x010000) >> 10) + 0xD800,
    ((c - 0x010000) & 0x03FF) + 0xDC00
  );
}

var simpleEscapeCheck = new Array(256); // integer, for fast access
var simpleEscapeMap = new Array(256);
for (var i = 0; i < 256; i++) {
  simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
  simpleEscapeMap[i] = simpleEscapeSequence(i);
}


function State(input, options) {
  this.input = input;

  this.filename  = options['filename']  || null;
  this.schema    = options['schema']    || DEFAULT_FULL_SCHEMA;
  this.onWarning = options['onWarning'] || null;
  this.legacy    = options['legacy']    || false;
  this.json      = options['json']      || false;
  this.listener  = options['listener']  || null;

  this.implicitTypes = this.schema.compiledImplicit;
  this.typeMap       = this.schema.compiledTypeMap;

  this.length     = input.length;
  this.position   = 0;
  this.line       = 0;
  this.lineStart  = 0;
  this.lineIndent = 0;

  this.documents = [];

  /*
  this.version;
  this.checkLineBreaks;
  this.tagMap;
  this.anchorMap;
  this.tag;
  this.anchor;
  this.kind;
  this.result;*/

}


function generateError(state, message) {
  return new YAMLException(
    message,
    new Mark(state.filename, state.input, state.position, state.line, (state.position - state.lineStart)));
}

function throwError(state, message) {
  throw generateError(state, message);
}

function throwWarning(state, message) {
  if (state.onWarning) {
    state.onWarning.call(null, generateError(state, message));
  }
}


var directiveHandlers = {

  YAML: function handleYamlDirective(state, name, args) {

    var match, major, minor;

    if (state.version !== null) {
      throwError(state, 'duplication of %YAML directive');
    }

    if (args.length !== 1) {
      throwError(state, 'YAML directive accepts exactly one argument');
    }

    match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);

    if (match === null) {
      throwError(state, 'ill-formed argument of the YAML directive');
    }

    major = parseInt(match[1], 10);
    minor = parseInt(match[2], 10);

    if (major !== 1) {
      throwError(state, 'unacceptable YAML version of the document');
    }

    state.version = args[0];
    state.checkLineBreaks = (minor < 2);

    if (minor !== 1 && minor !== 2) {
      throwWarning(state, 'unsupported YAML version of the document');
    }
  },

  TAG: function handleTagDirective(state, name, args) {

    var handle, prefix;

    if (args.length !== 2) {
      throwError(state, 'TAG directive accepts exactly two arguments');
    }

    handle = args[0];
    prefix = args[1];

    if (!PATTERN_TAG_HANDLE.test(handle)) {
      throwError(state, 'ill-formed tag handle (first argument) of the TAG directive');
    }

    if (_hasOwnProperty.call(state.tagMap, handle)) {
      throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
    }

    if (!PATTERN_TAG_URI.test(prefix)) {
      throwError(state, 'ill-formed tag prefix (second argument) of the TAG directive');
    }

    state.tagMap[handle] = prefix;
  }
};


function captureSegment(state, start, end, checkJson) {
  var _position, _length, _character, _result;

  if (start < end) {
    _result = state.input.slice(start, end);

    if (checkJson) {
      for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
        _character = _result.charCodeAt(_position);
        if (!(_character === 0x09 ||
              (0x20 <= _character && _character <= 0x10FFFF))) {
          throwError(state, 'expected valid JSON character');
        }
      }
    } else if (PATTERN_NON_PRINTABLE.test(_result)) {
      throwError(state, 'the stream contains non-printable characters');
    }

    state.result += _result;
  }
}

function mergeMappings(state, destination, source, overridableKeys) {
  var sourceKeys, key, index, quantity;

  if (!common.isObject(source)) {
    throwError(state, 'cannot merge mappings; the provided source object is unacceptable');
  }

  sourceKeys = Object.keys(source);

  for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
    key = sourceKeys[index];

    if (!_hasOwnProperty.call(destination, key)) {
      destination[key] = source[key];
      overridableKeys[key] = true;
    }
  }
}

function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startPos) {
  var index, quantity;

  keyNode = String(keyNode);

  if (_result === null) {
    _result = {};
  }

  if (keyTag === 'tag:yaml.org,2002:merge') {
    if (Array.isArray(valueNode)) {
      for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
        mergeMappings(state, _result, valueNode[index], overridableKeys);
      }
    } else {
      mergeMappings(state, _result, valueNode, overridableKeys);
    }
  } else {
    if (!state.json &&
        !_hasOwnProperty.call(overridableKeys, keyNode) &&
        _hasOwnProperty.call(_result, keyNode)) {
      state.line = startLine || state.line;
      state.position = startPos || state.position;
      throwError(state, 'duplicated mapping key');
    }
    _result[keyNode] = valueNode;
    delete overridableKeys[keyNode];
  }

  return _result;
}

function readLineBreak(state) {
  var ch;

  ch = state.input.charCodeAt(state.position);

  if (ch === 0x0A/* LF */) {
    state.position++;
  } else if (ch === 0x0D/* CR */) {
    state.position++;
    if (state.input.charCodeAt(state.position) === 0x0A/* LF */) {
      state.position++;
    }
  } else {
    throwError(state, 'a line break is expected');
  }

  state.line += 1;
  state.lineStart = state.position;
}

function skipSeparationSpace(state, allowComments, checkIndent) {
  var lineBreaks = 0,
      ch = state.input.charCodeAt(state.position);

  while (ch !== 0) {
    while (is_WHITE_SPACE(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }

    if (allowComments && ch === 0x23/* # */) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (ch !== 0x0A/* LF */ && ch !== 0x0D/* CR */ && ch !== 0);
    }

    if (is_EOL(ch)) {
      readLineBreak(state);

      ch = state.input.charCodeAt(state.position);
      lineBreaks++;
      state.lineIndent = 0;

      while (ch === 0x20/* Space */) {
        state.lineIndent++;
        ch = state.input.charCodeAt(++state.position);
      }
    } else {
      break;
    }
  }

  if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
    throwWarning(state, 'deficient indentation');
  }

  return lineBreaks;
}

function testDocumentSeparator(state) {
  var _position = state.position,
      ch;

  ch = state.input.charCodeAt(_position);

  // Condition state.position === state.lineStart is tested
  // in parent on each call, for efficiency. No needs to test here again.
  if ((ch === 0x2D/* - */ || ch === 0x2E/* . */) &&
      ch === state.input.charCodeAt(_position + 1) &&
      ch === state.input.charCodeAt(_position + 2)) {

    _position += 3;

    ch = state.input.charCodeAt(_position);

    if (ch === 0 || is_WS_OR_EOL(ch)) {
      return true;
    }
  }

  return false;
}

function writeFoldedLines(state, count) {
  if (count === 1) {
    state.result += ' ';
  } else if (count > 1) {
    state.result += common.repeat('\n', count - 1);
  }
}


function readPlainScalar(state, nodeIndent, withinFlowCollection) {
  var preceding,
      following,
      captureStart,
      captureEnd,
      hasPendingContent,
      _line,
      _lineStart,
      _lineIndent,
      _kind = state.kind,
      _result = state.result,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (is_WS_OR_EOL(ch)      ||
      is_FLOW_INDICATOR(ch) ||
      ch === 0x23/* # */    ||
      ch === 0x26/* & */    ||
      ch === 0x2A/* * */    ||
      ch === 0x21/* ! */    ||
      ch === 0x7C/* | */    ||
      ch === 0x3E/* > */    ||
      ch === 0x27/* ' */    ||
      ch === 0x22/* " */    ||
      ch === 0x25/* % */    ||
      ch === 0x40/* @ */    ||
      ch === 0x60/* ` */) {
    return false;
  }

  if (ch === 0x3F/* ? */ || ch === 0x2D/* - */) {
    following = state.input.charCodeAt(state.position + 1);

    if (is_WS_OR_EOL(following) ||
        withinFlowCollection && is_FLOW_INDICATOR(following)) {
      return false;
    }
  }

  state.kind = 'scalar';
  state.result = '';
  captureStart = captureEnd = state.position;
  hasPendingContent = false;

  while (ch !== 0) {
    if (ch === 0x3A/* : */) {
      following = state.input.charCodeAt(state.position + 1);

      if (is_WS_OR_EOL(following) ||
          withinFlowCollection && is_FLOW_INDICATOR(following)) {
        break;
      }

    } else if (ch === 0x23/* # */) {
      preceding = state.input.charCodeAt(state.position - 1);

      if (is_WS_OR_EOL(preceding)) {
        break;
      }

    } else if ((state.position === state.lineStart && testDocumentSeparator(state)) ||
               withinFlowCollection && is_FLOW_INDICATOR(ch)) {
      break;

    } else if (is_EOL(ch)) {
      _line = state.line;
      _lineStart = state.lineStart;
      _lineIndent = state.lineIndent;
      skipSeparationSpace(state, false, -1);

      if (state.lineIndent >= nodeIndent) {
        hasPendingContent = true;
        ch = state.input.charCodeAt(state.position);
        continue;
      } else {
        state.position = captureEnd;
        state.line = _line;
        state.lineStart = _lineStart;
        state.lineIndent = _lineIndent;
        break;
      }
    }

    if (hasPendingContent) {
      captureSegment(state, captureStart, captureEnd, false);
      writeFoldedLines(state, state.line - _line);
      captureStart = captureEnd = state.position;
      hasPendingContent = false;
    }

    if (!is_WHITE_SPACE(ch)) {
      captureEnd = state.position + 1;
    }

    ch = state.input.charCodeAt(++state.position);
  }

  captureSegment(state, captureStart, captureEnd, false);

  if (state.result) {
    return true;
  }

  state.kind = _kind;
  state.result = _result;
  return false;
}

function readSingleQuotedScalar(state, nodeIndent) {
  var ch,
      captureStart, captureEnd;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x27/* ' */) {
    return false;
  }

  state.kind = 'scalar';
  state.result = '';
  state.position++;
  captureStart = captureEnd = state.position;

  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 0x27/* ' */) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);

      if (ch === 0x27/* ' */) {
        captureStart = state.position;
        state.position++;
        captureEnd = state.position;
      } else {
        return true;
      }

    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;

    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, 'unexpected end of the document within a single quoted scalar');

    } else {
      state.position++;
      captureEnd = state.position;
    }
  }

  throwError(state, 'unexpected end of the stream within a single quoted scalar');
}

function readDoubleQuotedScalar(state, nodeIndent) {
  var captureStart,
      captureEnd,
      hexLength,
      hexResult,
      tmp,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x22/* " */) {
    return false;
  }

  state.kind = 'scalar';
  state.result = '';
  state.position++;
  captureStart = captureEnd = state.position;

  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 0x22/* " */) {
      captureSegment(state, captureStart, state.position, true);
      state.position++;
      return true;

    } else if (ch === 0x5C/* \ */) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);

      if (is_EOL(ch)) {
        skipSeparationSpace(state, false, nodeIndent);

        // TODO: rework to inline fn with no type cast?
      } else if (ch < 256 && simpleEscapeCheck[ch]) {
        state.result += simpleEscapeMap[ch];
        state.position++;

      } else if ((tmp = escapedHexLen(ch)) > 0) {
        hexLength = tmp;
        hexResult = 0;

        for (; hexLength > 0; hexLength--) {
          ch = state.input.charCodeAt(++state.position);

          if ((tmp = fromHexCode(ch)) >= 0) {
            hexResult = (hexResult << 4) + tmp;

          } else {
            throwError(state, 'expected hexadecimal character');
          }
        }

        state.result += charFromCodepoint(hexResult);

        state.position++;

      } else {
        throwError(state, 'unknown escape sequence');
      }

      captureStart = captureEnd = state.position;

    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;

    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, 'unexpected end of the document within a double quoted scalar');

    } else {
      state.position++;
      captureEnd = state.position;
    }
  }

  throwError(state, 'unexpected end of the stream within a double quoted scalar');
}

function readFlowCollection(state, nodeIndent) {
  var readNext = true,
      _line,
      _tag     = state.tag,
      _result,
      _anchor  = state.anchor,
      following,
      terminator,
      isPair,
      isExplicitPair,
      isMapping,
      overridableKeys = {},
      keyNode,
      keyTag,
      valueNode,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch === 0x5B/* [ */) {
    terminator = 0x5D;/* ] */
    isMapping = false;
    _result = [];
  } else if (ch === 0x7B/* { */) {
    terminator = 0x7D;/* } */
    isMapping = true;
    _result = {};
  } else {
    return false;
  }

  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }

  ch = state.input.charCodeAt(++state.position);

  while (ch !== 0) {
    skipSeparationSpace(state, true, nodeIndent);

    ch = state.input.charCodeAt(state.position);

    if (ch === terminator) {
      state.position++;
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = isMapping ? 'mapping' : 'sequence';
      state.result = _result;
      return true;
    } else if (!readNext) {
      throwError(state, 'missed comma between flow collection entries');
    }

    keyTag = keyNode = valueNode = null;
    isPair = isExplicitPair = false;

    if (ch === 0x3F/* ? */) {
      following = state.input.charCodeAt(state.position + 1);

      if (is_WS_OR_EOL(following)) {
        isPair = isExplicitPair = true;
        state.position++;
        skipSeparationSpace(state, true, nodeIndent);
      }
    }

    _line = state.line;
    composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
    keyTag = state.tag;
    keyNode = state.result;
    skipSeparationSpace(state, true, nodeIndent);

    ch = state.input.charCodeAt(state.position);

    if ((isExplicitPair || state.line === _line) && ch === 0x3A/* : */) {
      isPair = true;
      ch = state.input.charCodeAt(++state.position);
      skipSeparationSpace(state, true, nodeIndent);
      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
      valueNode = state.result;
    }

    if (isMapping) {
      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode);
    } else if (isPair) {
      _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode));
    } else {
      _result.push(keyNode);
    }

    skipSeparationSpace(state, true, nodeIndent);

    ch = state.input.charCodeAt(state.position);

    if (ch === 0x2C/* , */) {
      readNext = true;
      ch = state.input.charCodeAt(++state.position);
    } else {
      readNext = false;
    }
  }

  throwError(state, 'unexpected end of the stream within a flow collection');
}

function readBlockScalar(state, nodeIndent) {
  var captureStart,
      folding,
      chomping       = CHOMPING_CLIP,
      didReadContent = false,
      detectedIndent = false,
      textIndent     = nodeIndent,
      emptyLines     = 0,
      atMoreIndented = false,
      tmp,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch === 0x7C/* | */) {
    folding = false;
  } else if (ch === 0x3E/* > */) {
    folding = true;
  } else {
    return false;
  }

  state.kind = 'scalar';
  state.result = '';

  while (ch !== 0) {
    ch = state.input.charCodeAt(++state.position);

    if (ch === 0x2B/* + */ || ch === 0x2D/* - */) {
      if (CHOMPING_CLIP === chomping) {
        chomping = (ch === 0x2B/* + */) ? CHOMPING_KEEP : CHOMPING_STRIP;
      } else {
        throwError(state, 'repeat of a chomping mode identifier');
      }

    } else if ((tmp = fromDecimalCode(ch)) >= 0) {
      if (tmp === 0) {
        throwError(state, 'bad explicit indentation width of a block scalar; it cannot be less than one');
      } else if (!detectedIndent) {
        textIndent = nodeIndent + tmp - 1;
        detectedIndent = true;
      } else {
        throwError(state, 'repeat of an indentation width identifier');
      }

    } else {
      break;
    }
  }

  if (is_WHITE_SPACE(ch)) {
    do { ch = state.input.charCodeAt(++state.position); }
    while (is_WHITE_SPACE(ch));

    if (ch === 0x23/* # */) {
      do { ch = state.input.charCodeAt(++state.position); }
      while (!is_EOL(ch) && (ch !== 0));
    }
  }

  while (ch !== 0) {
    readLineBreak(state);
    state.lineIndent = 0;

    ch = state.input.charCodeAt(state.position);

    while ((!detectedIndent || state.lineIndent < textIndent) &&
           (ch === 0x20/* Space */)) {
      state.lineIndent++;
      ch = state.input.charCodeAt(++state.position);
    }

    if (!detectedIndent && state.lineIndent > textIndent) {
      textIndent = state.lineIndent;
    }

    if (is_EOL(ch)) {
      emptyLines++;
      continue;
    }

    // End of the scalar.
    if (state.lineIndent < textIndent) {

      // Perform the chomping.
      if (chomping === CHOMPING_KEEP) {
        state.result += common.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);
      } else if (chomping === CHOMPING_CLIP) {
        if (didReadContent) { // i.e. only if the scalar is not empty.
          state.result += '\n';
        }
      }

      // Break this `while` cycle and go to the funciton's epilogue.
      break;
    }

    // Folded style: use fancy rules to handle line breaks.
    if (folding) {

      // Lines starting with white space characters (more-indented lines) are not folded.
      if (is_WHITE_SPACE(ch)) {
        atMoreIndented = true;
        // except for the first content line (cf. Example 8.1)
        state.result += common.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);

      // End of more-indented block.
      } else if (atMoreIndented) {
        atMoreIndented = false;
        state.result += common.repeat('\n', emptyLines + 1);

      // Just one line break - perceive as the same line.
      } else if (emptyLines === 0) {
        if (didReadContent) { // i.e. only if we have already read some scalar content.
          state.result += ' ';
        }

      // Several line breaks - perceive as different lines.
      } else {
        state.result += common.repeat('\n', emptyLines);
      }

    // Literal style: just add exact number of line breaks between content lines.
    } else {
      // Keep all line breaks except the header line break.
      state.result += common.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);
    }

    didReadContent = true;
    detectedIndent = true;
    emptyLines = 0;
    captureStart = state.position;

    while (!is_EOL(ch) && (ch !== 0)) {
      ch = state.input.charCodeAt(++state.position);
    }

    captureSegment(state, captureStart, state.position, false);
  }

  return true;
}

function readBlockSequence(state, nodeIndent) {
  var _line,
      _tag      = state.tag,
      _anchor   = state.anchor,
      _result   = [],
      following,
      detected  = false,
      ch;

  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }

  ch = state.input.charCodeAt(state.position);

  while (ch !== 0) {

    if (ch !== 0x2D/* - */) {
      break;
    }

    following = state.input.charCodeAt(state.position + 1);

    if (!is_WS_OR_EOL(following)) {
      break;
    }

    detected = true;
    state.position++;

    if (skipSeparationSpace(state, true, -1)) {
      if (state.lineIndent <= nodeIndent) {
        _result.push(null);
        ch = state.input.charCodeAt(state.position);
        continue;
      }
    }

    _line = state.line;
    composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
    _result.push(state.result);
    skipSeparationSpace(state, true, -1);

    ch = state.input.charCodeAt(state.position);

    if ((state.line === _line || state.lineIndent > nodeIndent) && (ch !== 0)) {
      throwError(state, 'bad indentation of a sequence entry');
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }

  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = 'sequence';
    state.result = _result;
    return true;
  }
  return false;
}

function readBlockMapping(state, nodeIndent, flowIndent) {
  var following,
      allowCompact,
      _line,
      _pos,
      _tag          = state.tag,
      _anchor       = state.anchor,
      _result       = {},
      overridableKeys = {},
      keyTag        = null,
      keyNode       = null,
      valueNode     = null,
      atExplicitKey = false,
      detected      = false,
      ch;

  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }

  ch = state.input.charCodeAt(state.position);

  while (ch !== 0) {
    following = state.input.charCodeAt(state.position + 1);
    _line = state.line; // Save the current line.
    _pos = state.position;

    //
    // Explicit notation case. There are two separate blocks:
    // first for the key (denoted by "?") and second for the value (denoted by ":")
    //
    if ((ch === 0x3F/* ? */ || ch === 0x3A/* : */) && is_WS_OR_EOL(following)) {

      if (ch === 0x3F/* ? */) {
        if (atExplicitKey) {
          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
          keyTag = keyNode = valueNode = null;
        }

        detected = true;
        atExplicitKey = true;
        allowCompact = true;

      } else if (atExplicitKey) {
        // i.e. 0x3A/* : */ === character after the explicit key.
        atExplicitKey = false;
        allowCompact = true;

      } else {
        throwError(state, 'incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line');
      }

      state.position += 1;
      ch = following;

    //
    // Implicit notation case. Flow-style node as the key first, then ":", and the value.
    //
    } else if (composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {

      if (state.line === _line) {
        ch = state.input.charCodeAt(state.position);

        while (is_WHITE_SPACE(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }

        if (ch === 0x3A/* : */) {
          ch = state.input.charCodeAt(++state.position);

          if (!is_WS_OR_EOL(ch)) {
            throwError(state, 'a whitespace character is expected after the key-value separator within a block mapping');
          }

          if (atExplicitKey) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
            keyTag = keyNode = valueNode = null;
          }

          detected = true;
          atExplicitKey = false;
          allowCompact = false;
          keyTag = state.tag;
          keyNode = state.result;

        } else if (detected) {
          throwError(state, 'can not read an implicit mapping pair; a colon is missed');

        } else {
          state.tag = _tag;
          state.anchor = _anchor;
          return true; // Keep the result of `composeNode`.
        }

      } else if (detected) {
        throwError(state, 'can not read a block mapping entry; a multiline key may not be an implicit key');

      } else {
        state.tag = _tag;
        state.anchor = _anchor;
        return true; // Keep the result of `composeNode`.
      }

    } else {
      break; // Reading is done. Go to the epilogue.
    }

    //
    // Common reading code for both explicit and implicit notations.
    //
    if (state.line === _line || state.lineIndent > nodeIndent) {
      if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
        if (atExplicitKey) {
          keyNode = state.result;
        } else {
          valueNode = state.result;
        }
      }

      if (!atExplicitKey) {
        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _pos);
        keyTag = keyNode = valueNode = null;
      }

      skipSeparationSpace(state, true, -1);
      ch = state.input.charCodeAt(state.position);
    }

    if (state.lineIndent > nodeIndent && (ch !== 0)) {
      throwError(state, 'bad indentation of a mapping entry');
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }

  //
  // Epilogue.
  //

  // Special case: last mapping's node contains only the key in explicit notation.
  if (atExplicitKey) {
    storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
  }

  // Expose the resulting mapping.
  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = 'mapping';
    state.result = _result;
  }

  return detected;
}

function readTagProperty(state) {
  var _position,
      isVerbatim = false,
      isNamed    = false,
      tagHandle,
      tagName,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x21/* ! */) return false;

  if (state.tag !== null) {
    throwError(state, 'duplication of a tag property');
  }

  ch = state.input.charCodeAt(++state.position);

  if (ch === 0x3C/* < */) {
    isVerbatim = true;
    ch = state.input.charCodeAt(++state.position);

  } else if (ch === 0x21/* ! */) {
    isNamed = true;
    tagHandle = '!!';
    ch = state.input.charCodeAt(++state.position);

  } else {
    tagHandle = '!';
  }

  _position = state.position;

  if (isVerbatim) {
    do { ch = state.input.charCodeAt(++state.position); }
    while (ch !== 0 && ch !== 0x3E/* > */);

    if (state.position < state.length) {
      tagName = state.input.slice(_position, state.position);
      ch = state.input.charCodeAt(++state.position);
    } else {
      throwError(state, 'unexpected end of the stream within a verbatim tag');
    }
  } else {
    while (ch !== 0 && !is_WS_OR_EOL(ch)) {

      if (ch === 0x21/* ! */) {
        if (!isNamed) {
          tagHandle = state.input.slice(_position - 1, state.position + 1);

          if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
            throwError(state, 'named tag handle cannot contain such characters');
          }

          isNamed = true;
          _position = state.position + 1;
        } else {
          throwError(state, 'tag suffix cannot contain exclamation marks');
        }
      }

      ch = state.input.charCodeAt(++state.position);
    }

    tagName = state.input.slice(_position, state.position);

    if (PATTERN_FLOW_INDICATORS.test(tagName)) {
      throwError(state, 'tag suffix cannot contain flow indicator characters');
    }
  }

  if (tagName && !PATTERN_TAG_URI.test(tagName)) {
    throwError(state, 'tag name cannot contain such characters: ' + tagName);
  }

  if (isVerbatim) {
    state.tag = tagName;

  } else if (_hasOwnProperty.call(state.tagMap, tagHandle)) {
    state.tag = state.tagMap[tagHandle] + tagName;

  } else if (tagHandle === '!') {
    state.tag = '!' + tagName;

  } else if (tagHandle === '!!') {
    state.tag = 'tag:yaml.org,2002:' + tagName;

  } else {
    throwError(state, 'undeclared tag handle "' + tagHandle + '"');
  }

  return true;
}

function readAnchorProperty(state) {
  var _position,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x26/* & */) return false;

  if (state.anchor !== null) {
    throwError(state, 'duplication of an anchor property');
  }

  ch = state.input.charCodeAt(++state.position);
  _position = state.position;

  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }

  if (state.position === _position) {
    throwError(state, 'name of an anchor node must contain at least one character');
  }

  state.anchor = state.input.slice(_position, state.position);
  return true;
}

function readAlias(state) {
  var _position, alias,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x2A/* * */) return false;

  ch = state.input.charCodeAt(++state.position);
  _position = state.position;

  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }

  if (state.position === _position) {
    throwError(state, 'name of an alias node must contain at least one character');
  }

  alias = state.input.slice(_position, state.position);

  if (!state.anchorMap.hasOwnProperty(alias)) {
    throwError(state, 'unidentified alias "' + alias + '"');
  }

  state.result = state.anchorMap[alias];
  skipSeparationSpace(state, true, -1);
  return true;
}

function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
  var allowBlockStyles,
      allowBlockScalars,
      allowBlockCollections,
      indentStatus = 1, // 1: this>parent, 0: this=parent, -1: this<parent
      atNewLine  = false,
      hasContent = false,
      typeIndex,
      typeQuantity,
      type,
      flowIndent,
      blockIndent;

  if (state.listener !== null) {
    state.listener('open', state);
  }

  state.tag    = null;
  state.anchor = null;
  state.kind   = null;
  state.result = null;

  allowBlockStyles = allowBlockScalars = allowBlockCollections =
    CONTEXT_BLOCK_OUT === nodeContext ||
    CONTEXT_BLOCK_IN  === nodeContext;

  if (allowToSeek) {
    if (skipSeparationSpace(state, true, -1)) {
      atNewLine = true;

      if (state.lineIndent > parentIndent) {
        indentStatus = 1;
      } else if (state.lineIndent === parentIndent) {
        indentStatus = 0;
      } else if (state.lineIndent < parentIndent) {
        indentStatus = -1;
      }
    }
  }

  if (indentStatus === 1) {
    while (readTagProperty(state) || readAnchorProperty(state)) {
      if (skipSeparationSpace(state, true, -1)) {
        atNewLine = true;
        allowBlockCollections = allowBlockStyles;

        if (state.lineIndent > parentIndent) {
          indentStatus = 1;
        } else if (state.lineIndent === parentIndent) {
          indentStatus = 0;
        } else if (state.lineIndent < parentIndent) {
          indentStatus = -1;
        }
      } else {
        allowBlockCollections = false;
      }
    }
  }

  if (allowBlockCollections) {
    allowBlockCollections = atNewLine || allowCompact;
  }

  if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
    if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
      flowIndent = parentIndent;
    } else {
      flowIndent = parentIndent + 1;
    }

    blockIndent = state.position - state.lineStart;

    if (indentStatus === 1) {
      if (allowBlockCollections &&
          (readBlockSequence(state, blockIndent) ||
           readBlockMapping(state, blockIndent, flowIndent)) ||
          readFlowCollection(state, flowIndent)) {
        hasContent = true;
      } else {
        if ((allowBlockScalars && readBlockScalar(state, flowIndent)) ||
            readSingleQuotedScalar(state, flowIndent) ||
            readDoubleQuotedScalar(state, flowIndent)) {
          hasContent = true;

        } else if (readAlias(state)) {
          hasContent = true;

          if (state.tag !== null || state.anchor !== null) {
            throwError(state, 'alias node should not have any properties');
          }

        } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
          hasContent = true;

          if (state.tag === null) {
            state.tag = '?';
          }
        }

        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    } else if (indentStatus === 0) {
      // Special case: block sequences are allowed to have same indentation level as the parent.
      // http://www.yaml.org/spec/1.2/spec.html#id2799784
      hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
    }
  }

  if (state.tag !== null && state.tag !== '!') {
    if (state.tag === '?') {
      for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
        type = state.implicitTypes[typeIndex];

        // Implicit resolving is not allowed for non-scalar types, and '?'
        // non-specific tag is only assigned to plain scalars. So, it isn't
        // needed to check for 'kind' conformity.

        if (type.resolve(state.result)) { // `state.result` updated in resolver if matched
          state.result = type.construct(state.result);
          state.tag = type.tag;
          if (state.anchor !== null) {
            state.anchorMap[state.anchor] = state.result;
          }
          break;
        }
      }
    } else if (_hasOwnProperty.call(state.typeMap[state.kind || 'fallback'], state.tag)) {
      type = state.typeMap[state.kind || 'fallback'][state.tag];

      if (state.result !== null && type.kind !== state.kind) {
        throwError(state, 'unacceptable node kind for !<' + state.tag + '> tag; it should be "' + type.kind + '", not "' + state.kind + '"');
      }

      if (!type.resolve(state.result)) { // `state.result` updated in resolver if matched
        throwError(state, 'cannot resolve a node with !<' + state.tag + '> explicit tag');
      } else {
        state.result = type.construct(state.result);
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    } else {
      throwError(state, 'unknown tag !<' + state.tag + '>');
    }
  }

  if (state.listener !== null) {
    state.listener('close', state);
  }
  return state.tag !== null ||  state.anchor !== null || hasContent;
}

function readDocument(state) {
  var documentStart = state.position,
      _position,
      directiveName,
      directiveArgs,
      hasDirectives = false,
      ch;

  state.version = null;
  state.checkLineBreaks = state.legacy;
  state.tagMap = {};
  state.anchorMap = {};

  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    skipSeparationSpace(state, true, -1);

    ch = state.input.charCodeAt(state.position);

    if (state.lineIndent > 0 || ch !== 0x25/* % */) {
      break;
    }

    hasDirectives = true;
    ch = state.input.charCodeAt(++state.position);
    _position = state.position;

    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }

    directiveName = state.input.slice(_position, state.position);
    directiveArgs = [];

    if (directiveName.length < 1) {
      throwError(state, 'directive name must not be less than one character in length');
    }

    while (ch !== 0) {
      while (is_WHITE_SPACE(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }

      if (ch === 0x23/* # */) {
        do { ch = state.input.charCodeAt(++state.position); }
        while (ch !== 0 && !is_EOL(ch));
        break;
      }

      if (is_EOL(ch)) break;

      _position = state.position;

      while (ch !== 0 && !is_WS_OR_EOL(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }

      directiveArgs.push(state.input.slice(_position, state.position));
    }

    if (ch !== 0) readLineBreak(state);

    if (_hasOwnProperty.call(directiveHandlers, directiveName)) {
      directiveHandlers[directiveName](state, directiveName, directiveArgs);
    } else {
      throwWarning(state, 'unknown document directive "' + directiveName + '"');
    }
  }

  skipSeparationSpace(state, true, -1);

  if (state.lineIndent === 0 &&
      state.input.charCodeAt(state.position)     === 0x2D/* - */ &&
      state.input.charCodeAt(state.position + 1) === 0x2D/* - */ &&
      state.input.charCodeAt(state.position + 2) === 0x2D/* - */) {
    state.position += 3;
    skipSeparationSpace(state, true, -1);

  } else if (hasDirectives) {
    throwError(state, 'directives end mark is expected');
  }

  composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
  skipSeparationSpace(state, true, -1);

  if (state.checkLineBreaks &&
      PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
    throwWarning(state, 'non-ASCII line breaks are interpreted as content');
  }

  state.documents.push(state.result);

  if (state.position === state.lineStart && testDocumentSeparator(state)) {

    if (state.input.charCodeAt(state.position) === 0x2E/* . */) {
      state.position += 3;
      skipSeparationSpace(state, true, -1);
    }
    return;
  }

  if (state.position < (state.length - 1)) {
    throwError(state, 'end of the stream or a document separator is expected');
  } else {
    return;
  }
}


function loadDocuments(input, options) {
  input = String(input);
  options = options || {};

  if (input.length !== 0) {

    // Add tailing `\n` if not exists
    if (input.charCodeAt(input.length - 1) !== 0x0A/* LF */ &&
        input.charCodeAt(input.length - 1) !== 0x0D/* CR */) {
      input += '\n';
    }

    // Strip BOM
    if (input.charCodeAt(0) === 0xFEFF) {
      input = input.slice(1);
    }
  }

  var state = new State(input, options);

  // Use 0 as string terminator. That significantly simplifies bounds check.
  state.input += '\0';

  while (state.input.charCodeAt(state.position) === 0x20/* Space */) {
    state.lineIndent += 1;
    state.position += 1;
  }

  while (state.position < (state.length - 1)) {
    readDocument(state);
  }

  return state.documents;
}


function loadAll(input, iterator, options) {
  var documents = loadDocuments(input, options), index, length;

  if (typeof iterator !== 'function') {
    return documents;
  }

  for (index = 0, length = documents.length; index < length; index += 1) {
    iterator(documents[index]);
  }
}


function load(input, options) {
  var documents = loadDocuments(input, options);

  if (documents.length === 0) {
    /*eslint-disable no-undefined*/
    return undefined;
  } else if (documents.length === 1) {
    return documents[0];
  }
  throw new YAMLException('expected a single document in the stream, but found more');
}


function safeLoadAll(input, output, options) {
  if (typeof output === 'function') {
    loadAll(input, output, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
  } else {
    return loadAll(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
  }
}


function safeLoad(input, options) {
  return load(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
}


module.exports.loadAll     = loadAll;
module.exports.load        = load;
module.exports.safeLoadAll = safeLoadAll;
module.exports.safeLoad    = safeLoad;

},{"./common":755,"./exception":757,"./mark":759,"./schema/default_full":762,"./schema/default_safe":763}],759:[function(require,module,exports){
'use strict';


var common = require('./common');


function Mark(name, buffer, position, line, column) {
  this.name     = name;
  this.buffer   = buffer;
  this.position = position;
  this.line     = line;
  this.column   = column;
}


Mark.prototype.getSnippet = function getSnippet(indent, maxLength) {
  var head, start, tail, end, snippet;

  if (!this.buffer) return null;

  indent = indent || 4;
  maxLength = maxLength || 75;

  head = '';
  start = this.position;

  while (start > 0 && '\x00\r\n\x85\u2028\u2029'.indexOf(this.buffer.charAt(start - 1)) === -1) {
    start -= 1;
    if (this.position - start > (maxLength / 2 - 1)) {
      head = ' ... ';
      start += 5;
      break;
    }
  }

  tail = '';
  end = this.position;

  while (end < this.buffer.length && '\x00\r\n\x85\u2028\u2029'.indexOf(this.buffer.charAt(end)) === -1) {
    end += 1;
    if (end - this.position > (maxLength / 2 - 1)) {
      tail = ' ... ';
      end -= 5;
      break;
    }
  }

  snippet = this.buffer.slice(start, end);

  return common.repeat(' ', indent) + head + snippet + tail + '\n' +
         common.repeat(' ', indent + this.position - start + head.length) + '^';
};


Mark.prototype.toString = function toString(compact) {
  var snippet, where = '';

  if (this.name) {
    where += 'in "' + this.name + '" ';
  }

  where += 'at line ' + (this.line + 1) + ', column ' + (this.column + 1);

  if (!compact) {
    snippet = this.getSnippet();

    if (snippet) {
      where += ':\n' + snippet;
    }
  }

  return where;
};


module.exports = Mark;

},{"./common":755}],760:[function(require,module,exports){
'use strict';

/*eslint-disable max-len*/

var common        = require('./common');
var YAMLException = require('./exception');
var Type          = require('./type');


function compileList(schema, name, result) {
  var exclude = [];

  schema.include.forEach(function (includedSchema) {
    result = compileList(includedSchema, name, result);
  });

  schema[name].forEach(function (currentType) {
    result.forEach(function (previousType, previousIndex) {
      if (previousType.tag === currentType.tag && previousType.kind === currentType.kind) {
        exclude.push(previousIndex);
      }
    });

    result.push(currentType);
  });

  return result.filter(function (type, index) {
    return exclude.indexOf(index) === -1;
  });
}


function compileMap(/* lists... */) {
  var result = {
        scalar: {},
        sequence: {},
        mapping: {},
        fallback: {}
      }, index, length;

  function collectType(type) {
    result[type.kind][type.tag] = result['fallback'][type.tag] = type;
  }

  for (index = 0, length = arguments.length; index < length; index += 1) {
    arguments[index].forEach(collectType);
  }
  return result;
}


function Schema(definition) {
  this.include  = definition.include  || [];
  this.implicit = definition.implicit || [];
  this.explicit = definition.explicit || [];

  this.implicit.forEach(function (type) {
    if (type.loadKind && type.loadKind !== 'scalar') {
      throw new YAMLException('There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.');
    }
  });

  this.compiledImplicit = compileList(this, 'implicit', []);
  this.compiledExplicit = compileList(this, 'explicit', []);
  this.compiledTypeMap  = compileMap(this.compiledImplicit, this.compiledExplicit);
}


Schema.DEFAULT = null;


Schema.create = function createSchema() {
  var schemas, types;

  switch (arguments.length) {
    case 1:
      schemas = Schema.DEFAULT;
      types = arguments[0];
      break;

    case 2:
      schemas = arguments[0];
      types = arguments[1];
      break;

    default:
      throw new YAMLException('Wrong number of arguments for Schema.create function');
  }

  schemas = common.toArray(schemas);
  types = common.toArray(types);

  if (!schemas.every(function (schema) { return schema instanceof Schema; })) {
    throw new YAMLException('Specified list of super schemas (or a single Schema object) contains a non-Schema object.');
  }

  if (!types.every(function (type) { return type instanceof Type; })) {
    throw new YAMLException('Specified list of YAML types (or a single Type object) contains a non-Type object.');
  }

  return new Schema({
    include: schemas,
    explicit: types
  });
};


module.exports = Schema;

},{"./common":755,"./exception":757,"./type":766}],761:[function(require,module,exports){
// Standard YAML's Core schema.
// http://www.yaml.org/spec/1.2/spec.html#id2804923
//
// NOTE: JS-YAML does not support schema-specific tag resolution restrictions.
// So, Core schema has no distinctions from JSON schema is JS-YAML.


'use strict';


var Schema = require('../schema');


module.exports = new Schema({
  include: [
    require('./json')
  ]
});

},{"../schema":760,"./json":765}],762:[function(require,module,exports){
// JS-YAML's default schema for `load` function.
// It is not described in the YAML specification.
//
// This schema is based on JS-YAML's default safe schema and includes
// JavaScript-specific types: !!js/undefined, !!js/regexp and !!js/function.
//
// Also this schema is used as default base schema at `Schema.create` function.


'use strict';


var Schema = require('../schema');


module.exports = Schema.DEFAULT = new Schema({
  include: [
    require('./default_safe')
  ],
  explicit: [
    require('../type/js/undefined'),
    require('../type/js/regexp'),
    require('../type/js/function')
  ]
});

},{"../schema":760,"../type/js/function":771,"../type/js/regexp":772,"../type/js/undefined":773,"./default_safe":763}],763:[function(require,module,exports){
// JS-YAML's default schema for `safeLoad` function.
// It is not described in the YAML specification.
//
// This schema is based on standard YAML's Core schema and includes most of
// extra types described at YAML tag repository. (http://yaml.org/type/)


'use strict';


var Schema = require('../schema');


module.exports = new Schema({
  include: [
    require('./core')
  ],
  implicit: [
    require('../type/timestamp'),
    require('../type/merge')
  ],
  explicit: [
    require('../type/binary'),
    require('../type/omap'),
    require('../type/pairs'),
    require('../type/set')
  ]
});

},{"../schema":760,"../type/binary":767,"../type/merge":775,"../type/omap":777,"../type/pairs":778,"../type/set":780,"../type/timestamp":782,"./core":761}],764:[function(require,module,exports){
// Standard YAML's Failsafe schema.
// http://www.yaml.org/spec/1.2/spec.html#id2802346


'use strict';


var Schema = require('../schema');


module.exports = new Schema({
  explicit: [
    require('../type/str'),
    require('../type/seq'),
    require('../type/map')
  ]
});

},{"../schema":760,"../type/map":774,"../type/seq":779,"../type/str":781}],765:[function(require,module,exports){
// Standard YAML's JSON schema.
// http://www.yaml.org/spec/1.2/spec.html#id2803231
//
// NOTE: JS-YAML does not support schema-specific tag resolution restrictions.
// So, this schema is not such strict as defined in the YAML specification.
// It allows numbers in binary notaion, use `Null` and `NULL` as `null`, etc.


'use strict';


var Schema = require('../schema');


module.exports = new Schema({
  include: [
    require('./failsafe')
  ],
  implicit: [
    require('../type/null'),
    require('../type/bool'),
    require('../type/int'),
    require('../type/float')
  ]
});

},{"../schema":760,"../type/bool":768,"../type/float":769,"../type/int":770,"../type/null":776,"./failsafe":764}],766:[function(require,module,exports){
'use strict';

var YAMLException = require('./exception');

var TYPE_CONSTRUCTOR_OPTIONS = [
  'kind',
  'resolve',
  'construct',
  'instanceOf',
  'predicate',
  'represent',
  'defaultStyle',
  'styleAliases'
];

var YAML_NODE_KINDS = [
  'scalar',
  'sequence',
  'mapping'
];

function compileStyleAliases(map) {
  var result = {};

  if (map !== null) {
    Object.keys(map).forEach(function (style) {
      map[style].forEach(function (alias) {
        result[String(alias)] = style;
      });
    });
  }

  return result;
}

function Type(tag, options) {
  options = options || {};

  Object.keys(options).forEach(function (name) {
    if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
      throw new YAMLException('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
    }
  });

  // TODO: Add tag format check.
  this.tag          = tag;
  this.kind         = options['kind']         || null;
  this.resolve      = options['resolve']      || function () { return true; };
  this.construct    = options['construct']    || function (data) { return data; };
  this.instanceOf   = options['instanceOf']   || null;
  this.predicate    = options['predicate']    || null;
  this.represent    = options['represent']    || null;
  this.defaultStyle = options['defaultStyle'] || null;
  this.styleAliases = compileStyleAliases(options['styleAliases'] || null);

  if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
    throw new YAMLException('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
  }
}

module.exports = Type;

},{"./exception":757}],767:[function(require,module,exports){
'use strict';

/*eslint-disable no-bitwise*/

var NodeBuffer;

try {
  // A trick for browserified version, to not include `Buffer` shim
  var _require = require;
  NodeBuffer = _require('buffer').Buffer;
} catch (__) {}

var Type       = require('../type');


// [ 64, 65, 66 ] -> [ padding, CR, LF ]
var BASE64_MAP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r';


function resolveYamlBinary(data) {
  if (data === null) return false;

  var code, idx, bitlen = 0, max = data.length, map = BASE64_MAP;

  // Convert one by one.
  for (idx = 0; idx < max; idx++) {
    code = map.indexOf(data.charAt(idx));

    // Skip CR/LF
    if (code > 64) continue;

    // Fail on illegal characters
    if (code < 0) return false;

    bitlen += 6;
  }

  // If there are any bits left, source was corrupted
  return (bitlen % 8) === 0;
}

function constructYamlBinary(data) {
  var idx, tailbits,
      input = data.replace(/[\r\n=]/g, ''), // remove CR/LF & padding to simplify scan
      max = input.length,
      map = BASE64_MAP,
      bits = 0,
      result = [];

  // Collect by 6*4 bits (3 bytes)

  for (idx = 0; idx < max; idx++) {
    if ((idx % 4 === 0) && idx) {
      result.push((bits >> 16) & 0xFF);
      result.push((bits >> 8) & 0xFF);
      result.push(bits & 0xFF);
    }

    bits = (bits << 6) | map.indexOf(input.charAt(idx));
  }

  // Dump tail

  tailbits = (max % 4) * 6;

  if (tailbits === 0) {
    result.push((bits >> 16) & 0xFF);
    result.push((bits >> 8) & 0xFF);
    result.push(bits & 0xFF);
  } else if (tailbits === 18) {
    result.push((bits >> 10) & 0xFF);
    result.push((bits >> 2) & 0xFF);
  } else if (tailbits === 12) {
    result.push((bits >> 4) & 0xFF);
  }

  // Wrap into Buffer for NodeJS and leave Array for browser
  if (NodeBuffer) {
    // Support node 6.+ Buffer API when available
    return NodeBuffer.from ? NodeBuffer.from(result) : new NodeBuffer(result);
  }

  return result;
}

function representYamlBinary(object /*, style*/) {
  var result = '', bits = 0, idx, tail,
      max = object.length,
      map = BASE64_MAP;

  // Convert every three bytes to 4 ASCII characters.

  for (idx = 0; idx < max; idx++) {
    if ((idx % 3 === 0) && idx) {
      result += map[(bits >> 18) & 0x3F];
      result += map[(bits >> 12) & 0x3F];
      result += map[(bits >> 6) & 0x3F];
      result += map[bits & 0x3F];
    }

    bits = (bits << 8) + object[idx];
  }

  // Dump tail

  tail = max % 3;

  if (tail === 0) {
    result += map[(bits >> 18) & 0x3F];
    result += map[(bits >> 12) & 0x3F];
    result += map[(bits >> 6) & 0x3F];
    result += map[bits & 0x3F];
  } else if (tail === 2) {
    result += map[(bits >> 10) & 0x3F];
    result += map[(bits >> 4) & 0x3F];
    result += map[(bits << 2) & 0x3F];
    result += map[64];
  } else if (tail === 1) {
    result += map[(bits >> 2) & 0x3F];
    result += map[(bits << 4) & 0x3F];
    result += map[64];
    result += map[64];
  }

  return result;
}

function isBinary(object) {
  return NodeBuffer && NodeBuffer.isBuffer(object);
}

module.exports = new Type('tag:yaml.org,2002:binary', {
  kind: 'scalar',
  resolve: resolveYamlBinary,
  construct: constructYamlBinary,
  predicate: isBinary,
  represent: representYamlBinary
});

},{"../type":766}],768:[function(require,module,exports){
'use strict';

var Type = require('../type');

function resolveYamlBoolean(data) {
  if (data === null) return false;

  var max = data.length;

  return (max === 4 && (data === 'true' || data === 'True' || data === 'TRUE')) ||
         (max === 5 && (data === 'false' || data === 'False' || data === 'FALSE'));
}

function constructYamlBoolean(data) {
  return data === 'true' ||
         data === 'True' ||
         data === 'TRUE';
}

function isBoolean(object) {
  return Object.prototype.toString.call(object) === '[object Boolean]';
}

module.exports = new Type('tag:yaml.org,2002:bool', {
  kind: 'scalar',
  resolve: resolveYamlBoolean,
  construct: constructYamlBoolean,
  predicate: isBoolean,
  represent: {
    lowercase: function (object) { return object ? 'true' : 'false'; },
    uppercase: function (object) { return object ? 'TRUE' : 'FALSE'; },
    camelcase: function (object) { return object ? 'True' : 'False'; }
  },
  defaultStyle: 'lowercase'
});

},{"../type":766}],769:[function(require,module,exports){
'use strict';

var common = require('../common');
var Type   = require('../type');

var YAML_FLOAT_PATTERN = new RegExp(
  // 2.5e4, 2.5 and integers
  '^(?:[-+]?(?:0|[1-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?' +
  // .2e4, .2
  // special case, seems not from spec
  '|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?' +
  // 20:59
  '|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*' +
  // .inf
  '|[-+]?\\.(?:inf|Inf|INF)' +
  // .nan
  '|\\.(?:nan|NaN|NAN))$');

function resolveYamlFloat(data) {
  if (data === null) return false;

  if (!YAML_FLOAT_PATTERN.test(data) ||
      // Quick hack to not allow integers end with `_`
      // Probably should update regexp & check speed
      data[data.length - 1] === '_') {
    return false;
  }

  return true;
}

function constructYamlFloat(data) {
  var value, sign, base, digits;

  value  = data.replace(/_/g, '').toLowerCase();
  sign   = value[0] === '-' ? -1 : 1;
  digits = [];

  if ('+-'.indexOf(value[0]) >= 0) {
    value = value.slice(1);
  }

  if (value === '.inf') {
    return (sign === 1) ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;

  } else if (value === '.nan') {
    return NaN;

  } else if (value.indexOf(':') >= 0) {
    value.split(':').forEach(function (v) {
      digits.unshift(parseFloat(v, 10));
    });

    value = 0.0;
    base = 1;

    digits.forEach(function (d) {
      value += d * base;
      base *= 60;
    });

    return sign * value;

  }
  return sign * parseFloat(value, 10);
}


var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;

function representYamlFloat(object, style) {
  var res;

  if (isNaN(object)) {
    switch (style) {
      case 'lowercase': return '.nan';
      case 'uppercase': return '.NAN';
      case 'camelcase': return '.NaN';
    }
  } else if (Number.POSITIVE_INFINITY === object) {
    switch (style) {
      case 'lowercase': return '.inf';
      case 'uppercase': return '.INF';
      case 'camelcase': return '.Inf';
    }
  } else if (Number.NEGATIVE_INFINITY === object) {
    switch (style) {
      case 'lowercase': return '-.inf';
      case 'uppercase': return '-.INF';
      case 'camelcase': return '-.Inf';
    }
  } else if (common.isNegativeZero(object)) {
    return '-0.0';
  }

  res = object.toString(10);

  // JS stringifier can build scientific format without dots: 5e-100,
  // while YAML requres dot: 5.e-100. Fix it with simple hack

  return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace('e', '.e') : res;
}

function isFloat(object) {
  return (Object.prototype.toString.call(object) === '[object Number]') &&
         (object % 1 !== 0 || common.isNegativeZero(object));
}

module.exports = new Type('tag:yaml.org,2002:float', {
  kind: 'scalar',
  resolve: resolveYamlFloat,
  construct: constructYamlFloat,
  predicate: isFloat,
  represent: representYamlFloat,
  defaultStyle: 'lowercase'
});

},{"../common":755,"../type":766}],770:[function(require,module,exports){
'use strict';

var common = require('../common');
var Type   = require('../type');

function isHexCode(c) {
  return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) ||
         ((0x41/* A */ <= c) && (c <= 0x46/* F */)) ||
         ((0x61/* a */ <= c) && (c <= 0x66/* f */));
}

function isOctCode(c) {
  return ((0x30/* 0 */ <= c) && (c <= 0x37/* 7 */));
}

function isDecCode(c) {
  return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */));
}

function resolveYamlInteger(data) {
  if (data === null) return false;

  var max = data.length,
      index = 0,
      hasDigits = false,
      ch;

  if (!max) return false;

  ch = data[index];

  // sign
  if (ch === '-' || ch === '+') {
    ch = data[++index];
  }

  if (ch === '0') {
    // 0
    if (index + 1 === max) return true;
    ch = data[++index];

    // base 2, base 8, base 16

    if (ch === 'b') {
      // base 2
      index++;

      for (; index < max; index++) {
        ch = data[index];
        if (ch === '_') continue;
        if (ch !== '0' && ch !== '1') return false;
        hasDigits = true;
      }
      return hasDigits && ch !== '_';
    }


    if (ch === 'x') {
      // base 16
      index++;

      for (; index < max; index++) {
        ch = data[index];
        if (ch === '_') continue;
        if (!isHexCode(data.charCodeAt(index))) return false;
        hasDigits = true;
      }
      return hasDigits && ch !== '_';
    }

    // base 8
    for (; index < max; index++) {
      ch = data[index];
      if (ch === '_') continue;
      if (!isOctCode(data.charCodeAt(index))) return false;
      hasDigits = true;
    }
    return hasDigits && ch !== '_';
  }

  // base 10 (except 0) or base 60

  // value should not start with `_`;
  if (ch === '_') return false;

  for (; index < max; index++) {
    ch = data[index];
    if (ch === '_') continue;
    if (ch === ':') break;
    if (!isDecCode(data.charCodeAt(index))) {
      return false;
    }
    hasDigits = true;
  }

  // Should have digits and should not end with `_`
  if (!hasDigits || ch === '_') return false;

  // if !base60 - done;
  if (ch !== ':') return true;

  // base60 almost not used, no needs to optimize
  return /^(:[0-5]?[0-9])+$/.test(data.slice(index));
}

function constructYamlInteger(data) {
  var value = data, sign = 1, ch, base, digits = [];

  if (value.indexOf('_') !== -1) {
    value = value.replace(/_/g, '');
  }

  ch = value[0];

  if (ch === '-' || ch === '+') {
    if (ch === '-') sign = -1;
    value = value.slice(1);
    ch = value[0];
  }

  if (value === '0') return 0;

  if (ch === '0') {
    if (value[1] === 'b') return sign * parseInt(value.slice(2), 2);
    if (value[1] === 'x') return sign * parseInt(value, 16);
    return sign * parseInt(value, 8);
  }

  if (value.indexOf(':') !== -1) {
    value.split(':').forEach(function (v) {
      digits.unshift(parseInt(v, 10));
    });

    value = 0;
    base = 1;

    digits.forEach(function (d) {
      value += (d * base);
      base *= 60;
    });

    return sign * value;

  }

  return sign * parseInt(value, 10);
}

function isInteger(object) {
  return (Object.prototype.toString.call(object)) === '[object Number]' &&
         (object % 1 === 0 && !common.isNegativeZero(object));
}

module.exports = new Type('tag:yaml.org,2002:int', {
  kind: 'scalar',
  resolve: resolveYamlInteger,
  construct: constructYamlInteger,
  predicate: isInteger,
  represent: {
    binary:      function (obj) { return obj >= 0 ? '0b' + obj.toString(2) : '-0b' + obj.toString(2).slice(1); },
    octal:       function (obj) { return obj >= 0 ? '0'  + obj.toString(8) : '-0'  + obj.toString(8).slice(1); },
    decimal:     function (obj) { return obj.toString(10); },
    /* eslint-disable max-len */
    hexadecimal: function (obj) { return obj >= 0 ? '0x' + obj.toString(16).toUpperCase() :  '-0x' + obj.toString(16).toUpperCase().slice(1); }
  },
  defaultStyle: 'decimal',
  styleAliases: {
    binary:      [ 2,  'bin' ],
    octal:       [ 8,  'oct' ],
    decimal:     [ 10, 'dec' ],
    hexadecimal: [ 16, 'hex' ]
  }
});

},{"../common":755,"../type":766}],771:[function(require,module,exports){
'use strict';

var esprima;

// Browserified version does not have esprima
//
// 1. For node.js just require module as deps
// 2. For browser try to require mudule via external AMD system.
//    If not found - try to fallback to window.esprima. If not
//    found too - then fail to parse.
//
try {
  // workaround to exclude package from browserify list.
  var _require = require;
  esprima = _require('esprima');
} catch (_) {
  /*global window */
  if (typeof window !== 'undefined') esprima = window.esprima;
}

var Type = require('../../type');

function resolveJavascriptFunction(data) {
  if (data === null) return false;

  try {
    var source = '(' + data + ')',
        ast    = esprima.parse(source, { range: true });

    if (ast.type                    !== 'Program'             ||
        ast.body.length             !== 1                     ||
        ast.body[0].type            !== 'ExpressionStatement' ||
        (ast.body[0].expression.type !== 'ArrowFunctionExpression' &&
          ast.body[0].expression.type !== 'FunctionExpression')) {
      return false;
    }

    return true;
  } catch (err) {
    return false;
  }
}

function constructJavascriptFunction(data) {
  /*jslint evil:true*/

  var source = '(' + data + ')',
      ast    = esprima.parse(source, { range: true }),
      params = [],
      body;

  if (ast.type                    !== 'Program'             ||
      ast.body.length             !== 1                     ||
      ast.body[0].type            !== 'ExpressionStatement' ||
      (ast.body[0].expression.type !== 'ArrowFunctionExpression' &&
        ast.body[0].expression.type !== 'FunctionExpression')) {
    throw new Error('Failed to resolve function');
  }

  ast.body[0].expression.params.forEach(function (param) {
    params.push(param.name);
  });

  body = ast.body[0].expression.body.range;

  // Esprima's ranges include the first '{' and the last '}' characters on
  // function expressions. So cut them out.
  if (ast.body[0].expression.body.type === 'BlockStatement') {
    /*eslint-disable no-new-func*/
    return new Function(params, source.slice(body[0] + 1, body[1] - 1));
  }
  // ES6 arrow functions can omit the BlockStatement. In that case, just return
  // the body.
  /*eslint-disable no-new-func*/
  return new Function(params, 'return ' + source.slice(body[0], body[1]));
}

function representJavascriptFunction(object /*, style*/) {
  return object.toString();
}

function isFunction(object) {
  return Object.prototype.toString.call(object) === '[object Function]';
}

module.exports = new Type('tag:yaml.org,2002:js/function', {
  kind: 'scalar',
  resolve: resolveJavascriptFunction,
  construct: constructJavascriptFunction,
  predicate: isFunction,
  represent: representJavascriptFunction
});

},{"../../type":766}],772:[function(require,module,exports){
'use strict';

var Type = require('../../type');

function resolveJavascriptRegExp(data) {
  if (data === null) return false;
  if (data.length === 0) return false;

  var regexp = data,
      tail   = /\/([gim]*)$/.exec(data),
      modifiers = '';

  // if regexp starts with '/' it can have modifiers and must be properly closed
  // `/foo/gim` - modifiers tail can be maximum 3 chars
  if (regexp[0] === '/') {
    if (tail) modifiers = tail[1];

    if (modifiers.length > 3) return false;
    // if expression starts with /, is should be properly terminated
    if (regexp[regexp.length - modifiers.length - 1] !== '/') return false;
  }

  return true;
}

function constructJavascriptRegExp(data) {
  var regexp = data,
      tail   = /\/([gim]*)$/.exec(data),
      modifiers = '';

  // `/foo/gim` - tail can be maximum 4 chars
  if (regexp[0] === '/') {
    if (tail) modifiers = tail[1];
    regexp = regexp.slice(1, regexp.length - modifiers.length - 1);
  }

  return new RegExp(regexp, modifiers);
}

function representJavascriptRegExp(object /*, style*/) {
  var result = '/' + object.source + '/';

  if (object.global) result += 'g';
  if (object.multiline) result += 'm';
  if (object.ignoreCase) result += 'i';

  return result;
}

function isRegExp(object) {
  return Object.prototype.toString.call(object) === '[object RegExp]';
}

module.exports = new Type('tag:yaml.org,2002:js/regexp', {
  kind: 'scalar',
  resolve: resolveJavascriptRegExp,
  construct: constructJavascriptRegExp,
  predicate: isRegExp,
  represent: representJavascriptRegExp
});

},{"../../type":766}],773:[function(require,module,exports){
'use strict';

var Type = require('../../type');

function resolveJavascriptUndefined() {
  return true;
}

function constructJavascriptUndefined() {
  /*eslint-disable no-undefined*/
  return undefined;
}

function representJavascriptUndefined() {
  return '';
}

function isUndefined(object) {
  return typeof object === 'undefined';
}

module.exports = new Type('tag:yaml.org,2002:js/undefined', {
  kind: 'scalar',
  resolve: resolveJavascriptUndefined,
  construct: constructJavascriptUndefined,
  predicate: isUndefined,
  represent: representJavascriptUndefined
});

},{"../../type":766}],774:[function(require,module,exports){
'use strict';

var Type = require('../type');

module.exports = new Type('tag:yaml.org,2002:map', {
  kind: 'mapping',
  construct: function (data) { return data !== null ? data : {}; }
});

},{"../type":766}],775:[function(require,module,exports){
'use strict';

var Type = require('../type');

function resolveYamlMerge(data) {
  return data === '<<' || data === null;
}

module.exports = new Type('tag:yaml.org,2002:merge', {
  kind: 'scalar',
  resolve: resolveYamlMerge
});

},{"../type":766}],776:[function(require,module,exports){
'use strict';

var Type = require('../type');

function resolveYamlNull(data) {
  if (data === null) return true;

  var max = data.length;

  return (max === 1 && data === '~') ||
         (max === 4 && (data === 'null' || data === 'Null' || data === 'NULL'));
}

function constructYamlNull() {
  return null;
}

function isNull(object) {
  return object === null;
}

module.exports = new Type('tag:yaml.org,2002:null', {
  kind: 'scalar',
  resolve: resolveYamlNull,
  construct: constructYamlNull,
  predicate: isNull,
  represent: {
    canonical: function () { return '~';    },
    lowercase: function () { return 'null'; },
    uppercase: function () { return 'NULL'; },
    camelcase: function () { return 'Null'; }
  },
  defaultStyle: 'lowercase'
});

},{"../type":766}],777:[function(require,module,exports){
'use strict';

var Type = require('../type');

var _hasOwnProperty = Object.prototype.hasOwnProperty;
var _toString       = Object.prototype.toString;

function resolveYamlOmap(data) {
  if (data === null) return true;

  var objectKeys = [], index, length, pair, pairKey, pairHasKey,
      object = data;

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    pairHasKey = false;

    if (_toString.call(pair) !== '[object Object]') return false;

    for (pairKey in pair) {
      if (_hasOwnProperty.call(pair, pairKey)) {
        if (!pairHasKey) pairHasKey = true;
        else return false;
      }
    }

    if (!pairHasKey) return false;

    if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);
    else return false;
  }

  return true;
}

function constructYamlOmap(data) {
  return data !== null ? data : [];
}

module.exports = new Type('tag:yaml.org,2002:omap', {
  kind: 'sequence',
  resolve: resolveYamlOmap,
  construct: constructYamlOmap
});

},{"../type":766}],778:[function(require,module,exports){
'use strict';

var Type = require('../type');

var _toString = Object.prototype.toString;

function resolveYamlPairs(data) {
  if (data === null) return true;

  var index, length, pair, keys, result,
      object = data;

  result = new Array(object.length);

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];

    if (_toString.call(pair) !== '[object Object]') return false;

    keys = Object.keys(pair);

    if (keys.length !== 1) return false;

    result[index] = [ keys[0], pair[keys[0]] ];
  }

  return true;
}

function constructYamlPairs(data) {
  if (data === null) return [];

  var index, length, pair, keys, result,
      object = data;

  result = new Array(object.length);

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];

    keys = Object.keys(pair);

    result[index] = [ keys[0], pair[keys[0]] ];
  }

  return result;
}

module.exports = new Type('tag:yaml.org,2002:pairs', {
  kind: 'sequence',
  resolve: resolveYamlPairs,
  construct: constructYamlPairs
});

},{"../type":766}],779:[function(require,module,exports){
'use strict';

var Type = require('../type');

module.exports = new Type('tag:yaml.org,2002:seq', {
  kind: 'sequence',
  construct: function (data) { return data !== null ? data : []; }
});

},{"../type":766}],780:[function(require,module,exports){
'use strict';

var Type = require('../type');

var _hasOwnProperty = Object.prototype.hasOwnProperty;

function resolveYamlSet(data) {
  if (data === null) return true;

  var key, object = data;

  for (key in object) {
    if (_hasOwnProperty.call(object, key)) {
      if (object[key] !== null) return false;
    }
  }

  return true;
}

function constructYamlSet(data) {
  return data !== null ? data : {};
}

module.exports = new Type('tag:yaml.org,2002:set', {
  kind: 'mapping',
  resolve: resolveYamlSet,
  construct: constructYamlSet
});

},{"../type":766}],781:[function(require,module,exports){
'use strict';

var Type = require('../type');

module.exports = new Type('tag:yaml.org,2002:str', {
  kind: 'scalar',
  construct: function (data) { return data !== null ? data : ''; }
});

},{"../type":766}],782:[function(require,module,exports){
'use strict';

var Type = require('../type');

var YAML_DATE_REGEXP = new RegExp(
  '^([0-9][0-9][0-9][0-9])'          + // [1] year
  '-([0-9][0-9])'                    + // [2] month
  '-([0-9][0-9])$');                   // [3] day

var YAML_TIMESTAMP_REGEXP = new RegExp(
  '^([0-9][0-9][0-9][0-9])'          + // [1] year
  '-([0-9][0-9]?)'                   + // [2] month
  '-([0-9][0-9]?)'                   + // [3] day
  '(?:[Tt]|[ \\t]+)'                 + // ...
  '([0-9][0-9]?)'                    + // [4] hour
  ':([0-9][0-9])'                    + // [5] minute
  ':([0-9][0-9])'                    + // [6] second
  '(?:\\.([0-9]*))?'                 + // [7] fraction
  '(?:[ \\t]*(Z|([-+])([0-9][0-9]?)' + // [8] tz [9] tz_sign [10] tz_hour
  '(?::([0-9][0-9]))?))?$');           // [11] tz_minute

function resolveYamlTimestamp(data) {
  if (data === null) return false;
  if (YAML_DATE_REGEXP.exec(data) !== null) return true;
  if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;
  return false;
}

function constructYamlTimestamp(data) {
  var match, year, month, day, hour, minute, second, fraction = 0,
      delta = null, tz_hour, tz_minute, date;

  match = YAML_DATE_REGEXP.exec(data);
  if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data);

  if (match === null) throw new Error('Date resolve error');

  // match: [1] year [2] month [3] day

  year = +(match[1]);
  month = +(match[2]) - 1; // JS month starts with 0
  day = +(match[3]);

  if (!match[4]) { // no hour
    return new Date(Date.UTC(year, month, day));
  }

  // match: [4] hour [5] minute [6] second [7] fraction

  hour = +(match[4]);
  minute = +(match[5]);
  second = +(match[6]);

  if (match[7]) {
    fraction = match[7].slice(0, 3);
    while (fraction.length < 3) { // milli-seconds
      fraction += '0';
    }
    fraction = +fraction;
  }

  // match: [8] tz [9] tz_sign [10] tz_hour [11] tz_minute

  if (match[9]) {
    tz_hour = +(match[10]);
    tz_minute = +(match[11] || 0);
    delta = (tz_hour * 60 + tz_minute) * 60000; // delta in mili-seconds
    if (match[9] === '-') delta = -delta;
  }

  date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));

  if (delta) date.setTime(date.getTime() - delta);

  return date;
}

function representYamlTimestamp(object /*, style*/) {
  return object.toISOString();
}

module.exports = new Type('tag:yaml.org,2002:timestamp', {
  kind: 'scalar',
  resolve: resolveYamlTimestamp,
  construct: constructYamlTimestamp,
  instanceOf: Date,
  represent: representYamlTimestamp
});

},{"../type":766}],783:[function(require,module,exports){
'use strict'

module.exports = parseJson
function parseJson (txt, reviver, context) {
  context = context || 20
  try {
    return JSON.parse(txt, reviver)
  } catch (e) {
    if (typeof txt !== 'string') {
      const isEmptyArray = Array.isArray(txt) && txt.length === 0
      const errorMessage = 'Cannot parse ' +
      (isEmptyArray ? 'an empty array' : String(txt))
      throw new TypeError(errorMessage)
    }
    const syntaxErr = e.message.match(/^Unexpected token.*position\s+(\d+)/i)
    const errIdx = syntaxErr
    ? +syntaxErr[1]
    : e.message.match(/^Unexpected end of JSON.*/i)
    ? txt.length - 1
    : null
    if (errIdx != null) {
      const start = errIdx <= context
      ? 0
      : errIdx - context
      const end = errIdx + context >= txt.length
      ? txt.length
      : errIdx + context
      e.message += ` while parsing near '${
        start === 0 ? '' : '...'
      }${txt.slice(start, end)}${
        end === txt.length ? '' : '...'
      }'`
    } else {
      e.message += ` while parsing '${txt.slice(0, context * 2)}'`
    }
    throw e
  }
}

},{}],784:[function(require,module,exports){
(function (global){
/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/** `Object#toString` result references. */
var funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    symbolTag = '[object Symbol]';

/** Used to match property names within property paths. */
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/,
    reLeadingDot = /^\./,
    rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to match backslashes in property paths. */
var reEscapeChar = /\\(\\)?/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */
function isHostObject(value) {
  // Many host objects are `Object` objects that can coerce to strings
  // despite having improperly defined `toString` methods.
  var result = false;
  if (value != null && typeof value.toString != 'function') {
    try {
      result = !!(value + '');
    } catch (e) {}
  }
  return result;
}

/** Used for built-in method references. */
var arrayProto = Array.prototype,
    funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/** Built-in value references. */
var Symbol = root.Symbol,
    splice = arrayProto.splice;

/* Built-in method references that are verified to be native. */
var Map = getNative(root, 'Map'),
    nativeCreate = getNative(Object, 'create');

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  return this.has(key) && delete this.__data__[key];
}

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
}

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  return true;
}

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  return getMapData(this, key)['delete'](key);
}

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  getMapData(this, key).set(key, value);
  return this;
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */
function baseGet(object, path) {
  path = isKey(path, object) ? [path] : castPath(path);

  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[toKey(path[index++])];
  }
  return (index && index == length) ? object : undefined;
}

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {Array} Returns the cast property path array.
 */
function castPath(value) {
  return isArray(value) ? value : stringToPath(value);
}

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */
function isKey(value, object) {
  if (isArray(value)) {
    return false;
  }
  var type = typeof value;
  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
      value == null || isSymbol(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
    (object != null && value in Object(object));
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
var stringToPath = memoize(function(string) {
  string = toString(string);

  var result = [];
  if (reLeadingDot.test(string)) {
    result.push('');
  }
  string.replace(rePropName, function(match, number, quote, string) {
    result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
  });
  return result;
});

/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to process.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function memoize(func, resolver) {
  if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result);
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache);
  return memoized;
}

// Assign cache to `_.memoize`.
memoize.Cache = MapCache;

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8-9 which returns 'object' for typed array and other constructors.
  var tag = isObject(value) ? objectToString.call(value) : '';
  return tag == funcTag || tag == genTag;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && objectToString.call(value) == symbolTag);
}

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : baseToString(value);
}

/**
 * Gets the value at `path` of `object`. If the resolved value is
 * `undefined`, the `defaultValue` is returned in its place.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.get(object, 'a[0].b.c');
 * // => 3
 *
 * _.get(object, ['a', '0', 'b', 'c']);
 * // => 3
 *
 * _.get(object, 'a.b.c', 'default');
 * // => 'default'
 */
function get(object, path, defaultValue) {
  var result = object == null ? undefined : baseGet(object, path);
  return result === undefined ? defaultValue : result;
}

module.exports = get;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],785:[function(require,module,exports){
(function (global){
/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** `Object#toString` result references. */
var funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]';

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */
function isHostObject(value) {
  // Many host objects are `Object` objects that can coerce to strings
  // despite having improperly defined `toString` methods.
  var result = false;
  if (value != null && typeof value.toString != 'function') {
    try {
      result = !!(value + '');
    } catch (e) {}
  }
  return result;
}

/** Used for built-in method references. */
var arrayProto = Array.prototype,
    funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/** Built-in value references. */
var splice = arrayProto.splice;

/* Built-in method references that are verified to be native. */
var Map = getNative(root, 'Map'),
    nativeCreate = getNative(Object, 'create');

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  return this.has(key) && delete this.__data__[key];
}

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
}

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  return true;
}

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  return getMapData(this, key)['delete'](key);
}

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  getMapData(this, key).set(key, value);
  return this;
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to process.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function memoize(func, resolver) {
  if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result);
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache);
  return memoized;
}

// Assign cache to `_.memoize`.
memoize.Cache = MapCache;

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8-9 which returns 'object' for typed array and other constructors.
  var tag = isObject(value) ? objectToString.call(value) : '';
  return tag == funcTag || tag == genTag;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

module.exports = memoize;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],786:[function(require,module,exports){
(function (global){
/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/** `Object#toString` result references. */
var funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]';

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/**
 * A specialized version of `_.includes` for arrays without support for
 * specifying an index to search from.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function arrayIncludes(array, value) {
  var length = array ? array.length : 0;
  return !!length && baseIndexOf(array, value, 0) > -1;
}

/**
 * This function is like `arrayIncludes` except that it accepts a comparator.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @param {Function} comparator The comparator invoked per element.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function arrayIncludesWith(array, value, comparator) {
  var index = -1,
      length = array ? array.length : 0;

  while (++index < length) {
    if (comparator(value, array[index])) {
      return true;
    }
  }
  return false;
}

/**
 * The base implementation of `_.findIndex` and `_.findLastIndex` without
 * support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} predicate The function invoked per iteration.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseFindIndex(array, predicate, fromIndex, fromRight) {
  var length = array.length,
      index = fromIndex + (fromRight ? 1 : -1);

  while ((fromRight ? index-- : ++index < length)) {
    if (predicate(array[index], index, array)) {
      return index;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseIndexOf(array, value, fromIndex) {
  if (value !== value) {
    return baseFindIndex(array, baseIsNaN, fromIndex);
  }
  var index = fromIndex - 1,
      length = array.length;

  while (++index < length) {
    if (array[index] === value) {
      return index;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.isNaN` without support for number objects.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
 */
function baseIsNaN(value) {
  return value !== value;
}

/**
 * Checks if a cache value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function cacheHas(cache, key) {
  return cache.has(key);
}

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */
function isHostObject(value) {
  // Many host objects are `Object` objects that can coerce to strings
  // despite having improperly defined `toString` methods.
  var result = false;
  if (value != null && typeof value.toString != 'function') {
    try {
      result = !!(value + '');
    } catch (e) {}
  }
  return result;
}

/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}

/** Used for built-in method references. */
var arrayProto = Array.prototype,
    funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/** Built-in value references. */
var splice = arrayProto.splice;

/* Built-in method references that are verified to be native. */
var Map = getNative(root, 'Map'),
    Set = getNative(root, 'Set'),
    nativeCreate = getNative(Object, 'create');

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  return this.has(key) && delete this.__data__[key];
}

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
}

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  return true;
}

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  return getMapData(this, key)['delete'](key);
}

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  getMapData(this, key).set(key, value);
  return this;
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */
function SetCache(values) {
  var index = -1,
      length = values ? values.length : 0;

  this.__data__ = new MapCache;
  while (++index < length) {
    this.add(values[index]);
  }
}

/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}

/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

/**
 * The base implementation of `_.uniqBy` without support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new duplicate free array.
 */
function baseUniq(array, iteratee, comparator) {
  var index = -1,
      includes = arrayIncludes,
      length = array.length,
      isCommon = true,
      result = [],
      seen = result;

  if (comparator) {
    isCommon = false;
    includes = arrayIncludesWith;
  }
  else if (length >= LARGE_ARRAY_SIZE) {
    var set = iteratee ? null : createSet(array);
    if (set) {
      return setToArray(set);
    }
    isCommon = false;
    includes = cacheHas;
    seen = new SetCache;
  }
  else {
    seen = iteratee ? [] : result;
  }
  outer:
  while (++index < length) {
    var value = array[index],
        computed = iteratee ? iteratee(value) : value;

    value = (comparator || value !== 0) ? value : 0;
    if (isCommon && computed === computed) {
      var seenIndex = seen.length;
      while (seenIndex--) {
        if (seen[seenIndex] === computed) {
          continue outer;
        }
      }
      if (iteratee) {
        seen.push(computed);
      }
      result.push(value);
    }
    else if (!includes(seen, computed, comparator)) {
      if (seen !== result) {
        seen.push(computed);
      }
      result.push(value);
    }
  }
  return result;
}

/**
 * Creates a set object of `values`.
 *
 * @private
 * @param {Array} values The values to add to the set.
 * @returns {Object} Returns the new set.
 */
var createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {
  return new Set(values);
};

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to process.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

/**
 * Creates a duplicate-free version of an array, using
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons, in which only the first occurrence of each
 * element is kept.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @returns {Array} Returns the new duplicate free array.
 * @example
 *
 * _.uniq([2, 1, 2]);
 * // => [2, 1]
 */
function uniq(array) {
  return (array && array.length)
    ? baseUniq(array)
    : [];
}

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8-9 which returns 'object' for typed array and other constructors.
  var tag = isObject(value) ? objectToString.call(value) : '';
  return tag == funcTag || tag == genTag;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * This method returns `undefined`.
 *
 * @static
 * @memberOf _
 * @since 2.3.0
 * @category Util
 * @example
 *
 * _.times(2, _.noop);
 * // => [undefined, undefined]
 */
function noop() {
  // No operation performed.
}

module.exports = uniq;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],787:[function(require,module,exports){
module.exports=[
  {
    "name": "nodejs",
    "version": "0.2.0",
    "date": "2011-08-26",
    "lts": false
  },
  {
    "name": "nodejs",
    "version": "0.3.0",
    "date": "2011-08-26",
    "lts": false
  },
  {
    "name": "nodejs",
    "version": "0.4.0",
    "date": "2011-08-26",
    "lts": false
  },
  {
    "name": "nodejs",
    "version": "0.5.0",
    "date": "2011-08-26",
    "lts": false
  },
  {
    "name": "nodejs",
    "version": "0.6.0",
    "date": "2011-11-04",
    "lts": false
  },
  {
    "name": "nodejs",
    "version": "0.7.0",
    "date": "2012-01-17",
    "lts": false
  },
  {
    "name": "nodejs",
    "version": "0.8.0",
    "date": "2012-06-22",
    "lts": false
  },
  {
    "name": "nodejs",
    "version": "0.9.0",
    "date": "2012-07-20",
    "lts": false
  },
  {
    "name": "nodejs",
    "version": "0.10.0",
    "date": "2013-03-11",
    "lts": false
  },
  {
    "name": "nodejs",
    "version": "0.11.0",
    "date": "2013-03-28",
    "lts": false
  },
  {
    "name": "nodejs",
    "version": "0.12.0",
    "date": "2015-02-06",
    "lts": false
  },
  {
    "name": "iojs",
    "version": "1.0.0",
    "date": "2015-01-14"
  },
  {
    "name": "iojs",
    "version": "1.1.0",
    "date": "2015-02-03"
  },
  {
    "name": "iojs",
    "version": "1.2.0",
    "date": "2015-02-11"
  },
  {
    "name": "iojs",
    "version": "1.3.0",
    "date": "2015-02-20"
  },
  {
    "name": "iojs",
    "version": "1.5.0",
    "date": "2015-03-06"
  },
  {
    "name": "iojs",
    "version": "1.6.0",
    "date": "2015-03-20"
  },
  {
    "name": "iojs",
    "version": "2.0.0",
    "date": "2015-05-04"
  },
  {
    "name": "iojs",
    "version": "2.1.0",
    "date": "2015-05-24"
  },
  {
    "name": "iojs",
    "version": "2.2.0",
    "date": "2015-06-01"
  },
  {
    "name": "iojs",
    "version": "2.3.0",
    "date": "2015-06-13"
  },
  {
    "name": "iojs",
    "version": "2.4.0",
    "date": "2015-07-17"
  },
  {
    "name": "iojs",
    "version": "2.5.0",
    "date": "2015-07-28"
  },
  {
    "name": "iojs",
    "version": "3.0.0",
    "date": "2015-08-04"
  },
  {
    "name": "iojs",
    "version": "3.1.0",
    "date": "2015-08-19"
  },
  {
    "name": "iojs",
    "version": "3.2.0",
    "date": "2015-08-25"
  },
  {
    "name": "iojs",
    "version": "3.3.0",
    "date": "2015-09-02"
  },
  {
    "name": "nodejs",
    "version": "4.0.0",
    "date": "2015-09-08",
    "lts": false
  },
  {
    "name": "nodejs",
    "version": "4.1.0",
    "date": "2015-09-17",
    "lts": false
  },
  {
    "name": "nodejs",
    "version": "4.2.0",
    "date": "2015-10-12",
    "lts": "Argon"
  },
  {
    "name": "nodejs",
    "version": "4.3.0",
    "date": "2016-02-09",
    "lts": "Argon"
  },
  {
    "name": "nodejs",
    "version": "4.4.0",
    "date": "2016-03-08",
    "lts": "Argon"
  },
  {
    "name": "nodejs",
    "version": "4.5.0",
    "date": "2016-08-16",
    "lts": "Argon"
  },
  {
    "name": "nodejs",
    "version": "4.6.0",
    "date": "2016-09-27",
    "lts": "Argon"
  },
  {
    "name": "nodejs",
    "version": "4.7.0",
    "date": "2016-12-06",
    "lts": "Argon"
  },
  {
    "name": "nodejs",
    "version": "4.8.0",
    "date": "2017-02-21",
    "lts": "Argon"
  },
  {
    "name": "nodejs",
    "version": "4.9.0",
    "date": "2018-03-28",
    "lts": "Argon"
  },
  {
    "name": "nodejs",
    "version": "5.0.0",
    "date": "2015-10-29",
    "lts": false
  },
  {
    "name": "nodejs",
    "version": "5.1.0",
    "date": "2015-11-17",
    "lts": false
  },
  {
    "name": "nodejs",
    "version": "5.2.0",
    "date": "2015-12-09",
    "lts": false
  },
  {
    "name": "nodejs",
    "version": "5.3.0",
    "date": "2015-12-15",
    "lts": false
  },
  {
    "name": "nodejs",
    "version": "5.4.0",
    "date": "2016-01-06",
    "lts": false
  },
  {
    "name": "nodejs",
    "version": "5.5.0",
    "date": "2016-01-21",
    "lts": false
  },
  {
    "name": "nodejs",
    "version": "5.6.0",
    "date": "2016-02-09",
    "lts": false
  },
  {
    "name": "nodejs",
    "version": "5.7.0",
    "date": "2016-02-23",
    "lts": false
  },
  {
    "name": "nodejs",
    "version": "5.8.0",
    "date": "2016-03-09",
    "lts": false
  },
  {
    "name": "nodejs",
    "version": "5.9.0",
    "date": "2016-03-16",
    "lts": false
  },
  {
    "name": "nodejs",
    "version": "5.10.0",
    "date": "2016-04-01",
    "lts": false
  },
  {
    "name": "nodejs",
    "version": "5.11.0",
    "date": "2016-04-21",
    "lts": false
  },
  {
    "name": "nodejs",
    "version": "5.12.0",
    "date": "2016-06-23",
    "lts": false
  },
  {
    "name": "nodejs",
    "version": "6.0.0",
    "date": "2016-04-26",
    "lts": false
  },
  {
    "name": "nodejs",
    "version": "6.1.0",
    "date": "2016-05-05",
    "lts": false
  },
  {
    "name": "nodejs",
    "version": "6.2.0",
    "date": "2016-05-17",
    "lts": false
  },
  {
    "name": "nodejs",
    "version": "6.3.0",
    "date": "2016-07-06",
    "lts": false
  },
  {
    "name": "nodejs",
    "version": "6.4.0",
    "date": "2016-08-12",
    "lts": false
  },
  {
    "name": "nodejs",
    "version": "6.5.0",
    "date": "2016-08-26",
    "lts": false
  },
  {
    "name": "nodejs",
    "version": "6.6.0",
    "date": "2016-09-14",
    "lts": false
  },
  {
    "name": "nodejs",
    "version": "6.7.0",
    "date": "2016-09-27",
    "lts": false
  },
  {
    "name": "nodejs",
    "version": "6.8.0",
    "date": "2016-10-12",
    "lts": false
  },
  {
    "name": "nodejs",
    "version": "6.9.0",
    "date": "2016-10-18",
    "lts": "Boron"
  },
  {
    "name": "nodejs",
    "version": "6.10.0",
    "date": "2017-02-21",
    "lts": "Boron"
  },
  {
    "name": "nodejs",
    "version": "6.11.0",
    "date": "2017-06-06",
    "lts": "Boron"
  },
  {
    "name": "nodejs",
    "version": "6.12.0",
    "date": "2017-11-06",
    "lts": "Boron"
  },
  {
    "name": "nodejs",
    "version": "6.13.0",
    "date": "2018-02-10",
    "lts": "Boron"
  },
  {
    "name": "nodejs",
    "version": "6.14.0",
    "date": "2018-03-28",
    "lts": "Boron"
  },
  {
    "name": "nodejs",
    "version": "6.15.0",
    "date": "2018-11-27",
    "lts": "Boron"
  },
  {
    "name": "nodejs",
    "version": "6.16.0",
    "date": "2018-12-26",
    "lts": "Boron"
  },
  {
    "name": "nodejs",
    "version": "6.17.0",
    "date": "2019-02-28",
    "lts": "Boron"
  },
  {
    "name": "nodejs",
    "version": "7.0.0",
    "date": "2016-10-25",
    "lts": false
  },
  {
    "name": "nodejs",
    "version": "7.1.0",
    "date": "2016-11-08",
    "lts": false
  },
  {
    "name": "nodejs",
    "version": "7.2.0",
    "date": "2016-11-22",
    "lts": false
  },
  {
    "name": "nodejs",
    "version": "7.3.0",
    "date": "2016-12-20",
    "lts": false
  },
  {
    "name": "nodejs",
    "version": "7.4.0",
    "date": "2017-01-04",
    "lts": false
  },
  {
    "name": "nodejs",
    "version": "7.5.0",
    "date": "2017-01-31",
    "lts": false
  },
  {
    "name": "nodejs",
    "version": "7.6.0",
    "date": "2017-02-21",
    "lts": false
  },
  {
    "name": "nodejs",
    "version": "7.7.0",
    "date": "2017-02-28",
    "lts": false
  },
  {
    "name": "nodejs",
    "version": "7.8.0",
    "date": "2017-03-29",
    "lts": false
  },
  {
    "name": "nodejs",
    "version": "7.9.0",
    "date": "2017-04-11",
    "lts": false
  },
  {
    "name": "nodejs",
    "version": "7.10.0",
    "date": "2017-05-02",
    "lts": false
  },
  {
    "name": "nodejs",
    "version": "8.0.0",
    "date": "2017-05-30",
    "lts": false
  },
  {
    "name": "nodejs",
    "version": "8.1.0",
    "date": "2017-06-08",
    "lts": false
  },
  {
    "name": "nodejs",
    "version": "8.2.0",
    "date": "2017-07-19",
    "lts": false
  },
  {
    "name": "nodejs",
    "version": "8.3.0",
    "date": "2017-08-08",
    "lts": false
  },
  {
    "name": "nodejs",
    "version": "8.4.0",
    "date": "2017-08-15",
    "lts": false
  },
  {
    "name": "nodejs",
    "version": "8.5.0",
    "date": "2017-09-12",
    "lts": false
  },
  {
    "name": "nodejs",
    "version": "8.6.0",
    "date": "2017-09-26",
    "lts": false
  },
  {
    "name": "nodejs",
    "version": "8.7.0",
    "date": "2017-10-11",
    "lts": false
  },
  {
    "name": "nodejs",
    "version": "8.8.0",
    "date": "2017-10-24",
    "lts": false
  },
  {
    "name": "nodejs",
    "version": "8.9.0",
    "date": "2017-10-31",
    "lts": "Carbon"
  },
  {
    "name": "nodejs",
    "version": "8.10.0",
    "date": "2018-03-06",
    "lts": "Carbon"
  },
  {
    "name": "nodejs",
    "version": "8.11.0",
    "date": "2018-03-28",
    "lts": "Carbon"
  },
  {
    "name": "nodejs",
    "version": "8.12.0",
    "date": "2018-09-10",
    "lts": "Carbon"
  },
  {
    "name": "nodejs",
    "version": "8.13.0",
    "date": "2018-11-20",
    "lts": "Carbon"
  },
  {
    "name": "nodejs",
    "version": "8.14.0",
    "date": "2018-11-27",
    "lts": "Carbon"
  },
  {
    "name": "nodejs",
    "version": "8.15.0",
    "date": "2018-12-26",
    "lts": "Carbon"
  },
  {
    "name": "nodejs",
    "version": "9.0.0",
    "date": "2017-10-31",
    "lts": false
  },
  {
    "name": "nodejs",
    "version": "9.1.0",
    "date": "2017-11-07",
    "lts": false
  },
  {
    "name": "nodejs",
    "version": "9.2.0",
    "date": "2017-11-14",
    "lts": false
  },
  {
    "name": "nodejs",
    "version": "9.3.0",
    "date": "2017-12-12",
    "lts": false
  },
  {
    "name": "nodejs",
    "version": "9.4.0",
    "date": "2018-01-10",
    "lts": false
  },
  {
    "name": "nodejs",
    "version": "9.5.0",
    "date": "2018-01-31",
    "lts": false
  },
  {
    "name": "nodejs",
    "version": "9.6.0",
    "date": "2018-02-21",
    "lts": false
  },
  {
    "name": "nodejs",
    "version": "9.7.0",
    "date": "2018-03-01",
    "lts": false
  },
  {
    "name": "nodejs",
    "version": "9.8.0",
    "date": "2018-03-07",
    "lts": false
  },
  {
    "name": "nodejs",
    "version": "9.9.0",
    "date": "2018-03-21",
    "lts": false
  },
  {
    "name": "nodejs",
    "version": "9.10.0",
    "date": "2018-03-28",
    "lts": false
  },
  {
    "name": "nodejs",
    "version": "9.11.0",
    "date": "2018-04-04",
    "lts": false
  },
  {
    "name": "nodejs",
    "version": "10.0.0",
    "date": "2018-04-24",
    "lts": false
  },
  {
    "name": "nodejs",
    "version": "10.1.0",
    "date": "2018-05-08",
    "lts": false
  },
  {
    "name": "nodejs",
    "version": "10.2.0",
    "date": "2018-05-23",
    "lts": false
  },
  {
    "name": "nodejs",
    "version": "10.3.0",
    "date": "2018-05-29",
    "lts": false
  },
  {
    "name": "nodejs",
    "version": "10.4.0",
    "date": "2018-06-06",
    "lts": false
  },
  {
    "name": "nodejs",
    "version": "10.5.0",
    "date": "2018-06-20",
    "lts": false
  },
  {
    "name": "nodejs",
    "version": "10.6.0",
    "date": "2018-07-04",
    "lts": false
  },
  {
    "name": "nodejs",
    "version": "10.7.0",
    "date": "2018-07-18",
    "lts": false
  },
  {
    "name": "nodejs",
    "version": "10.8.0",
    "date": "2018-08-01",
    "lts": false
  },
  {
    "name": "nodejs",
    "version": "10.9.0",
    "date": "2018-08-15",
    "lts": false
  },
  {
    "name": "nodejs",
    "version": "10.10.0",
    "date": "2018-09-06",
    "lts": false
  },
  {
    "name": "nodejs",
    "version": "10.11.0",
    "date": "2018-09-19",
    "lts": false
  },
  {
    "name": "nodejs",
    "version": "10.12.0",
    "date": "2018-10-10",
    "lts": false
  },
  {
    "name": "nodejs",
    "version": "10.13.0",
    "date": "2018-10-30",
    "lts": "Dubnium"
  },
  {
    "name": "nodejs",
    "version": "10.14.0",
    "date": "2018-11-27",
    "lts": "Dubnium"
  },
  {
    "name": "nodejs",
    "version": "10.15.0",
    "date": "2018-12-26",
    "lts": "Dubnium"
  },
  {
    "name": "nodejs",
    "version": "11.0.0",
    "date": "2018-10-23",
    "lts": false
  },
  {
    "name": "nodejs",
    "version": "11.1.0",
    "date": "2018-10-30",
    "lts": false
  },
  {
    "name": "nodejs",
    "version": "11.2.0",
    "date": "2018-11-15",
    "lts": false
  },
  {
    "name": "nodejs",
    "version": "11.3.0",
    "date": "2018-11-27",
    "lts": false
  },
  {
    "name": "nodejs",
    "version": "11.4.0",
    "date": "2018-12-07",
    "lts": false
  },
  {
    "name": "nodejs",
    "version": "11.5.0",
    "date": "2018-12-18",
    "lts": false
  },
  {
    "name": "nodejs",
    "version": "11.6.0",
    "date": "2018-12-26",
    "lts": false
  },
  {
    "name": "nodejs",
    "version": "11.7.0",
    "date": "2019-01-17",
    "lts": false
  },
  {
    "name": "nodejs",
    "version": "11.8.0",
    "date": "2019-01-24",
    "lts": false
  },
  {
    "name": "nodejs",
    "version": "11.9.0",
    "date": "2019-01-30",
    "lts": false
  },
  {
    "name": "nodejs",
    "version": "11.10.0",
    "date": "2019-02-14",
    "lts": false
  },
  {
    "name": "nodejs",
    "version": "11.11.0",
    "date": "2019-03-05",
    "lts": false
  }
]
},{}],788:[function(require,module,exports){
module.exports={
  "v0.10": {
    "start": "2013-03-11",
    "end": "2016-10-31"
  },
  "v0.12": {
    "start": "2015-02-06",
    "end": "2016-12-31"
  },
  "v4": {
    "start": "2015-09-08",
    "lts": "2015-10-12",
    "maintenance": "2017-04-01",
    "end": "2018-04-30",
    "codename": "Argon"
  },
  "v5": {
    "start": "2015-10-29",
    "maintenance": "2016-04-30",
    "end": "2016-06-30"
  },
  "v6": {
    "start": "2016-04-26",
    "lts": "2016-10-18",
    "maintenance": "2018-04-30",
    "end": "2019-04-01",
    "codename": "Boron"
  },
  "v7": {
    "start": "2016-10-25",
    "maintenance": "2017-04-30",
    "end": "2017-06-30"
  },
  "v8": {
    "start": "2017-05-30",
    "lts": "2017-10-31",
    "maintenance": "2019-01-01",
    "end": "2019-12-31",
    "codename": "Carbon"
  },
  "v9": {
    "start": "2017-10-01",
    "maintenance": "2018-04-01",
    "end": "2018-06-30"
  },
  "v10": {
    "start": "2018-04-24",
    "lts": "2018-10-30",
    "maintenance": "2020-04-01",
    "end": "2021-04-01",
    "codename": "Dubnium"
  },
  "v11": {
    "start": "2018-10-23",
    "maintenance": "2019-04-01",
    "end": "2019-06-30"
  },
  "v12": {
    "start": "2019-04-23",
    "lts": "2019-10-22",
    "maintenance": "2021-04-01",
    "end": "2022-04-01",
    "codename": ""
  }
}

},{}],789:[function(require,module,exports){
'use strict';
// TODO: Use the `URL` global when targeting Node.js 10
const URLParser = typeof URL === 'undefined' ? require('url').URL : URL;

const testParameter = (name, filters) => {
	return filters.some(filter => filter instanceof RegExp ? filter.test(name) : filter === name);
};

module.exports = (urlString, opts) => {
	opts = Object.assign({
		defaultProtocol: 'http:',
		normalizeProtocol: true,
		forceHttp: false,
		forceHttps: false,
		stripHash: true,
		stripWWW: true,
		removeQueryParameters: [/^utm_\w+/i],
		removeTrailingSlash: true,
		removeDirectoryIndex: false,
		sortQueryParameters: true
	}, opts);

	// Backwards compatibility
	if (Reflect.has(opts, 'normalizeHttps')) {
		opts.forceHttp = opts.normalizeHttps;
	}

	if (Reflect.has(opts, 'normalizeHttp')) {
		opts.forceHttps = opts.normalizeHttp;
	}

	if (Reflect.has(opts, 'stripFragment')) {
		opts.stripHash = opts.stripFragment;
	}

	urlString = urlString.trim();

	const hasRelativeProtocol = urlString.startsWith('//');
	const isRelativeUrl = !hasRelativeProtocol && /^\.*\//.test(urlString);

	// Prepend protocol
	if (!isRelativeUrl) {
		urlString = urlString.replace(/^(?!(?:\w+:)?\/\/)|^\/\//, opts.defaultProtocol);
	}

	const urlObj = new URLParser(urlString);

	if (opts.forceHttp && opts.forceHttps) {
		throw new Error('The `forceHttp` and `forceHttps` options cannot be used together');
	}

	if (opts.forceHttp && urlObj.protocol === 'https:') {
		urlObj.protocol = 'http:';
	}

	if (opts.forceHttps && urlObj.protocol === 'http:') {
		urlObj.protocol = 'https:';
	}

	// Remove hash
	if (opts.stripHash) {
		urlObj.hash = '';
	}

	// Remove duplicate slashes if not preceded by a protocol
	if (urlObj.pathname) {
		// TODO: Use the following instead when targeting Node.js 10
		// `urlObj.pathname = urlObj.pathname.replace(/(?<!https?:)\/{2,}/g, '/');`
		urlObj.pathname = urlObj.pathname.replace(/((?![https?:]).)\/{2,}/g, (_, p1) => {
			if (/^(?!\/)/g.test(p1)) {
				return `${p1}/`;
			}
			return '/';
		});
	}

	// Decode URI octets
	if (urlObj.pathname) {
		urlObj.pathname = decodeURI(urlObj.pathname);
	}

	// Remove directory index
	if (opts.removeDirectoryIndex === true) {
		opts.removeDirectoryIndex = [/^index\.[a-z]+$/];
	}

	if (Array.isArray(opts.removeDirectoryIndex) && opts.removeDirectoryIndex.length > 0) {
		let pathComponents = urlObj.pathname.split('/');
		const lastComponent = pathComponents[pathComponents.length - 1];

		if (testParameter(lastComponent, opts.removeDirectoryIndex)) {
			pathComponents = pathComponents.slice(0, pathComponents.length - 1);
			urlObj.pathname = pathComponents.slice(1).join('/') + '/';
		}
	}

	if (urlObj.hostname) {
		// Remove trailing dot
		urlObj.hostname = urlObj.hostname.replace(/\.$/, '');

		// Remove `www.`
		// eslint-disable-next-line no-useless-escape
		if (opts.stripWWW && /^www\.([a-z\-\d]{2,63})\.([a-z\.]{2,5})$/.test(urlObj.hostname)) {
			// Each label should be max 63 at length (min: 2).
			// The extension should be max 5 at length (min: 2).
			// Source: https://en.wikipedia.org/wiki/Hostname#Restrictions_on_valid_host_names
			urlObj.hostname = urlObj.hostname.replace(/^www\./, '');
		}
	}

	// Remove query unwanted parameters
	if (Array.isArray(opts.removeQueryParameters)) {
		for (const key of [...urlObj.searchParams.keys()]) {
			if (testParameter(key, opts.removeQueryParameters)) {
				urlObj.searchParams.delete(key);
			}
		}
	}

	// Sort query parameters
	if (opts.sortQueryParameters) {
		urlObj.searchParams.sort();
	}

	// Take advantage of many of the Node `url` normalizations
	urlString = urlObj.toString();

	// Remove ending `/`
	if (opts.removeTrailingSlash || urlObj.pathname === '/') {
		urlString = urlString.replace(/\/$/, '');
	}

	// Restore relative protocol, if applicable
	if (hasRelativeProtocol && !opts.normalizeProtocol) {
		urlString = urlString.replace(/^http:\/\//, '//');
	}

	return urlString;
};

},{"url":1200}],790:[function(require,module,exports){
module.exports = compile;

var BaseFuncs = require("boolbase"),
    trueFunc  = BaseFuncs.trueFunc,
    falseFunc = BaseFuncs.falseFunc;

/*
	returns a function that checks if an elements index matches the given rule
	highly optimized to return the fastest solution
*/
function compile(parsed){
	var a = parsed[0],
	    b = parsed[1] - 1;

	//when b <= 0, a*n won't be possible for any matches when a < 0
	//besides, the specification says that no element is matched when a and b are 0
	if(b < 0 && a <= 0) return falseFunc;

	//when a is in the range -1..1, it matches any element (so only b is checked)
	if(a ===-1) return function(pos){ return pos <= b; };
	if(a === 0) return function(pos){ return pos === b; };
	//when b <= 0 and a === 1, they match any element
	if(a === 1) return b < 0 ? trueFunc : function(pos){ return pos >= b; };

	//when a > 0, modulo can be used to check if there is a match
	var bMod = b % a;
	if(bMod < 0) bMod += a;

	if(a > 1){
		return function(pos){
			return pos >= b && pos % a === bMod;
		};
	}

	a *= -1; //make `a` positive

	return function(pos){
		return pos <= b && pos % a === bMod;
	};
}
},{"boolbase":6}],791:[function(require,module,exports){
var parse = require("./parse.js"),
    compile = require("./compile.js");

module.exports = function nthCheck(formula){
	return compile(parse(formula));
};

module.exports.parse = parse;
module.exports.compile = compile;
},{"./compile.js":790,"./parse.js":792}],792:[function(require,module,exports){
module.exports = parse;

//following http://www.w3.org/TR/css3-selectors/#nth-child-pseudo

//[ ['-'|'+']? INTEGER? {N} [ S* ['-'|'+'] S* INTEGER ]?
var re_nthElement = /^([+\-]?\d*n)?\s*(?:([+\-]?)\s*(\d+))?$/;

/*
	parses a nth-check formula, returns an array of two numbers
*/
function parse(formula){
	formula = formula.trim().toLowerCase();

	if(formula === "even"){
		return [2, 0];
	} else if(formula === "odd"){
		return [2, 1];
	} else {
		var parsed = formula.match(re_nthElement);

		if(!parsed){
			throw new SyntaxError("n-th rule couldn't be parsed ('" + formula + "')");
		}

		var a;

		if(parsed[1]){
			a = parseInt(parsed[1], 10);
			if(isNaN(a)){
				if(parsed[1].charAt(0) === "-") a = -1;
				else a = 1;
			}
		} else a = 0;

		return [
			a,
			parsed[3] ? parseInt((parsed[2] || "") + parsed[3], 10) : 0
		];
	}
}

},{}],793:[function(require,module,exports){
'use strict';

var keysShim;
if (!Object.keys) {
	// modified from https://github.com/es-shims/es5-shim
	var has = Object.prototype.hasOwnProperty;
	var toStr = Object.prototype.toString;
	var isArgs = require('./isArguments'); // eslint-disable-line global-require
	var isEnumerable = Object.prototype.propertyIsEnumerable;
	var hasDontEnumBug = !isEnumerable.call({ toString: null }, 'toString');
	var hasProtoEnumBug = isEnumerable.call(function () {}, 'prototype');
	var dontEnums = [
		'toString',
		'toLocaleString',
		'valueOf',
		'hasOwnProperty',
		'isPrototypeOf',
		'propertyIsEnumerable',
		'constructor'
	];
	var equalsConstructorPrototype = function (o) {
		var ctor = o.constructor;
		return ctor && ctor.prototype === o;
	};
	var excludedKeys = {
		$applicationCache: true,
		$console: true,
		$external: true,
		$frame: true,
		$frameElement: true,
		$frames: true,
		$innerHeight: true,
		$innerWidth: true,
		$outerHeight: true,
		$outerWidth: true,
		$pageXOffset: true,
		$pageYOffset: true,
		$parent: true,
		$scrollLeft: true,
		$scrollTop: true,
		$scrollX: true,
		$scrollY: true,
		$self: true,
		$webkitIndexedDB: true,
		$webkitStorageInfo: true,
		$window: true
	};
	var hasAutomationEqualityBug = (function () {
		/* global window */
		if (typeof window === 'undefined') { return false; }
		for (var k in window) {
			try {
				if (!excludedKeys['$' + k] && has.call(window, k) && window[k] !== null && typeof window[k] === 'object') {
					try {
						equalsConstructorPrototype(window[k]);
					} catch (e) {
						return true;
					}
				}
			} catch (e) {
				return true;
			}
		}
		return false;
	}());
	var equalsConstructorPrototypeIfNotBuggy = function (o) {
		/* global window */
		if (typeof window === 'undefined' || !hasAutomationEqualityBug) {
			return equalsConstructorPrototype(o);
		}
		try {
			return equalsConstructorPrototype(o);
		} catch (e) {
			return false;
		}
	};

	keysShim = function keys(object) {
		var isObject = object !== null && typeof object === 'object';
		var isFunction = toStr.call(object) === '[object Function]';
		var isArguments = isArgs(object);
		var isString = isObject && toStr.call(object) === '[object String]';
		var theKeys = [];

		if (!isObject && !isFunction && !isArguments) {
			throw new TypeError('Object.keys called on a non-object');
		}

		var skipProto = hasProtoEnumBug && isFunction;
		if (isString && object.length > 0 && !has.call(object, 0)) {
			for (var i = 0; i < object.length; ++i) {
				theKeys.push(String(i));
			}
		}

		if (isArguments && object.length > 0) {
			for (var j = 0; j < object.length; ++j) {
				theKeys.push(String(j));
			}
		} else {
			for (var name in object) {
				if (!(skipProto && name === 'prototype') && has.call(object, name)) {
					theKeys.push(String(name));
				}
			}
		}

		if (hasDontEnumBug) {
			var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);

			for (var k = 0; k < dontEnums.length; ++k) {
				if (!(skipConstructor && dontEnums[k] === 'constructor') && has.call(object, dontEnums[k])) {
					theKeys.push(dontEnums[k]);
				}
			}
		}
		return theKeys;
	};
}
module.exports = keysShim;

},{"./isArguments":795}],794:[function(require,module,exports){
'use strict';

var slice = Array.prototype.slice;
var isArgs = require('./isArguments');

var origKeys = Object.keys;
var keysShim = origKeys ? function keys(o) { return origKeys(o); } : require('./implementation');

var originalKeys = Object.keys;

keysShim.shim = function shimObjectKeys() {
	if (Object.keys) {
		var keysWorksWithArguments = (function () {
			// Safari 5.0 bug
			var args = Object.keys(arguments);
			return args && args.length === arguments.length;
		}(1, 2));
		if (!keysWorksWithArguments) {
			Object.keys = function keys(object) { // eslint-disable-line func-name-matching
				if (isArgs(object)) {
					return originalKeys(slice.call(object));
				}
				return originalKeys(object);
			};
		}
	} else {
		Object.keys = keysShim;
	}
	return Object.keys || keysShim;
};

module.exports = keysShim;

},{"./implementation":793,"./isArguments":795}],795:[function(require,module,exports){
'use strict';

var toStr = Object.prototype.toString;

module.exports = function isArguments(value) {
	var str = toStr.call(value);
	var isArgs = str === '[object Arguments]';
	if (!isArgs) {
		isArgs = str !== '[object Array]' &&
			value !== null &&
			typeof value === 'object' &&
			typeof value.length === 'number' &&
			value.length >= 0 &&
			toStr.call(value.callee) === '[object Function]';
	}
	return isArgs;
};

},{}],796:[function(require,module,exports){
'use strict';

var ES = require('es-abstract/es7');
var has = require('has');
var bind = require('function-bind');
var isEnumerable = bind.call(Function.call, Object.prototype.propertyIsEnumerable);

module.exports = function values(O) {
	var obj = ES.RequireObjectCoercible(O);
	var vals = [];
	for (var key in obj) {
		if (has(obj, key) && isEnumerable(obj, key)) {
			vals.push(obj[key]);
		}
	}
	return vals;
};

},{"es-abstract/es7":700,"function-bind":715,"has":720}],797:[function(require,module,exports){
'use strict';

var define = require('define-properties');

var implementation = require('./implementation');
var getPolyfill = require('./polyfill');
var shim = require('./shim');

var polyfill = getPolyfill();

define(polyfill, {
	getPolyfill: getPolyfill,
	implementation: implementation,
	shim: shim
});

module.exports = polyfill;

},{"./implementation":796,"./polyfill":798,"./shim":799,"define-properties":674}],798:[function(require,module,exports){
'use strict';

var implementation = require('./implementation');

module.exports = function getPolyfill() {
	return typeof Object.values === 'function' ? Object.values : implementation;
};

},{"./implementation":796}],799:[function(require,module,exports){
'use strict';

var getPolyfill = require('./polyfill');
var define = require('define-properties');

module.exports = function shimValues() {
	var polyfill = getPolyfill();
	define(Object, { values: polyfill }, {
		values: function testValues() {
			return Object.values !== polyfill;
		}
	});
	return polyfill;
};

},{"./polyfill":798,"define-properties":674}],800:[function(require,module,exports){
exports.endianness = function () { return 'LE' };

exports.hostname = function () {
    if (typeof location !== 'undefined') {
        return location.hostname
    }
    else return '';
};

exports.loadavg = function () { return [] };

exports.uptime = function () { return 0 };

exports.freemem = function () {
    return Number.MAX_VALUE;
};

exports.totalmem = function () {
    return Number.MAX_VALUE;
};

exports.cpus = function () { return [] };

exports.type = function () { return 'Browser' };

exports.release = function () {
    if (typeof navigator !== 'undefined') {
        return navigator.appVersion;
    }
    return '';
};

exports.networkInterfaces
= exports.getNetworkInterfaces
= function () { return {} };

exports.arch = function () { return 'javascript' };

exports.platform = function () { return 'browser' };

exports.tmpdir = exports.tmpDir = function () {
    return '/tmp';
};

exports.EOL = '\n';

exports.homedir = function () {
	return '/'
};

},{}],801:[function(require,module,exports){
'use strict';
const errorEx = require('error-ex');
const fallback = require('json-parse-better-errors');

const JSONError = errorEx('JSONError', {
	fileName: errorEx.append('in %s')
});

module.exports = (input, reviver, filename) => {
	if (typeof reviver === 'string') {
		filename = reviver;
		reviver = null;
	}

	try {
		try {
			return JSON.parse(input, reviver);
		} catch (err) {
			fallback(input, reviver);

			throw err;
		}
	} catch (err) {
		err.message = err.message.replace(/\n/g, '');

		const jsonErr = new JSONError(err);
		if (filename) {
			jsonErr.fileName = filename;
		}

		throw jsonErr;
	}
};

},{"error-ex":695,"json-parse-better-errors":783}],802:[function(require,module,exports){
(function (process){
// .dirname, .basename, and .extname methods are extracted from Node.js v8.11.1,
// backported and transplited with Babel, with backwards-compat fixes

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function (path) {
  if (typeof path !== 'string') path = path + '';
  if (path.length === 0) return '.';
  var code = path.charCodeAt(0);
  var hasRoot = code === 47 /*/*/;
  var end = -1;
  var matchedSlash = true;
  for (var i = path.length - 1; i >= 1; --i) {
    code = path.charCodeAt(i);
    if (code === 47 /*/*/) {
        if (!matchedSlash) {
          end = i;
          break;
        }
      } else {
      // We saw the first non-path separator
      matchedSlash = false;
    }
  }

  if (end === -1) return hasRoot ? '/' : '.';
  if (hasRoot && end === 1) {
    // return '//';
    // Backwards-compat fix:
    return '/';
  }
  return path.slice(0, end);
};

function basename(path) {
  if (typeof path !== 'string') path = path + '';

  var start = 0;
  var end = -1;
  var matchedSlash = true;
  var i;

  for (i = path.length - 1; i >= 0; --i) {
    if (path.charCodeAt(i) === 47 /*/*/) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else if (end === -1) {
      // We saw the first non-path separator, mark this as the end of our
      // path component
      matchedSlash = false;
      end = i + 1;
    }
  }

  if (end === -1) return '';
  return path.slice(start, end);
}

// Uses a mixed approach for backwards-compatibility, as ext behavior changed
// in new Node.js versions, so only basename() above is backported here
exports.basename = function (path, ext) {
  var f = basename(path);
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};

exports.extname = function (path) {
  if (typeof path !== 'string') path = path + '';
  var startDot = -1;
  var startPart = 0;
  var end = -1;
  var matchedSlash = true;
  // Track the state of characters (if any) we see before our first dot and
  // after any path separator we find
  var preDotState = 0;
  for (var i = path.length - 1; i >= 0; --i) {
    var code = path.charCodeAt(i);
    if (code === 47 /*/*/) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }
        continue;
      }
    if (end === -1) {
      // We saw the first non-path separator, mark this as the end of our
      // extension
      matchedSlash = false;
      end = i + 1;
    }
    if (code === 46 /*.*/) {
        // If this is our first dot, mark it as the start of our extension
        if (startDot === -1)
          startDot = i;
        else if (preDotState !== 1)
          preDotState = 1;
    } else if (startDot !== -1) {
      // We saw a non-dot and non-path separator before our dot, so we should
      // have a good chance at having a non-empty extension
      preDotState = -1;
    }
  }

  if (startDot === -1 || end === -1 ||
      // We saw a non-dot character immediately before the dot
      preDotState === 0 ||
      // The (right-most) trimmed path component is exactly '..'
      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    return '';
  }
  return path.slice(startDot, end);
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

}).call(this,require('_process'))
},{"_process":1098}],803:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.default = applyCompact;

var _commentRegex = require('comment-regex');

var _postcssValueParser = require('postcss-value-parser');

var _postcssValueParser2 = _interopRequireDefault(_postcssValueParser);

var _applyTransformFeatures = require('./applyTransformFeatures');

var _applyTransformFeatures2 = _interopRequireDefault(_applyTransformFeatures);

var _blank = require('./blank');

var _blank2 = _interopRequireDefault(_blank);

var _deeplyNested = require('./deeplyNested');

var _deeplyNested2 = _interopRequireDefault(_deeplyNested);

var _getIndent = require('./getIndent');

var _getIndent2 = _interopRequireDefault(_getIndent);

var _isSassVariable = require('./isSassVariable');

var _isSassVariable2 = _interopRequireDefault(_isSassVariable);

var _maxSelectorLength = require('./maxSelectorLength');

var _walk = require('./walk');

var _walk2 = _interopRequireDefault(_walk);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function applyCompact(css, opts) {
    css.walk(function (rule) {
        if (rule.type === 'decl') {
            if (rule.raws.value) {
                rule.value = rule.raws.value.raw.trim();
            }
            // Format sass variable `$size: 30em;`
            if ((0, _isSassVariable2.default)(rule)) {
                rule.raws.before = '';
                rule.raws.between = ': ';
            }

            var ast = (0, _postcssValueParser2.default)(rule.value);

            (0, _walk2.default)(ast, function (node, index, parent) {
                var next = parent.nodes[index + 1];
                if (node.type === 'div' && node.value === ',') {
                    node.before = '';
                    node.after = ' ';
                }
                if (node.type === 'function') {
                    node.before = node.after = ' ';
                }
                if (node.type === 'space') {
                    node.value = ' ';
                }
                if (node.type === 'word' && node.value === '!' && parent.nodes[index + 2] && next.type === 'space' && parent.nodes[index + 2].type === 'word') {
                    next.type = 'word';
                    next.value = '';
                }
                if (node.type === 'word') {
                    (0, _applyTransformFeatures2.default)(node, opts);
                }
            });

            rule.value = ast.toString();

            // Format `!important`
            if (rule.important) {
                rule.raws.important = ' !important';
            }

            if (rule.raws.value) {
                rule.raws.value.raw = rule.value;
            }
        }
        opts.indentSize = 1;
        if (rule.type === 'comment') {
            if (rule.raws.inline) {
                rule.raws.inline = null;
            }
            var prev = rule.prev();
            if (prev && prev.type === 'decl') {
                rule.raws.before = ' ' + (0, _blank2.default)(rule.raws.before);
            }
            if (rule.parent && rule.parent.type === 'root') {
                var next = rule.next();
                if (next) {
                    next.raws.before = '\n';
                }
                if (rule !== css.first) {
                    rule.raws.before = '\n';
                }
            }
            return;
        }
        var indent = (0, _getIndent2.default)(rule, opts.indentChar, opts.indentSize);
        var deep = (0, _deeplyNested2.default)(rule);
        if (rule.type === 'rule' || rule.type === 'atrule') {
            if (!rule.nodes) {
                rule.raws.between = '';
            } else {
                rule.raws.between = ' ';
            }
            rule.raws.after = ' ';
            rule.raws.before = indent + (0, _blank2.default)(rule.raws.before);
            rule.raws.semicolon = true;
        }
        if (rule.raws.selector && rule.raws.selector.raw) {
            rule.selector = rule.raws.selector.raw;
        }
        (0, _maxSelectorLength.maxSelectorLength)(rule, opts);
        if (rule.type === 'decl') {
            if ((0, _deeplyNested2.default)(rule.parent)) {
                var newline = rule === css.first ? '' : '\n';
                rule.raws.before = newline + indent + (0, _blank2.default)(rule.raws.before);
            } else {
                rule.raws.before = ' ' + (0, _blank2.default)(rule.raws.before);
            }
            if (!(0, _commentRegex.block)().test(rule.raws.between)) {
                rule.raws.between = ': ';
            }
        }
        if ((deep || rule.nodes) && rule !== css.first) {
            rule.raws.before = '\n ';
        }
        if (deep) {
            rule.raws.after = '\n' + indent;
        }
        if (rule.parent && rule !== rule.parent.first && (rule.type === 'rule' || rule.type === 'atrule')) {
            rule.raws.before = '\n' + indent;
        }
    });
    css.raws.after = '\n';
}
module.exports = exports['default'];
},{"./applyTransformFeatures":806,"./blank":807,"./deeplyNested":808,"./getIndent":809,"./isSassVariable":811,"./maxSelectorLength":813,"./walk":817,"comment-regex":542,"postcss-value-parser":1057}],804:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.default = applyCompressed;

var _commentRegex = require('comment-regex');

var _postcssValueParser = require('postcss-value-parser');

var _postcssValueParser2 = _interopRequireDefault(_postcssValueParser);

var _applyTransformFeatures = require('./applyTransformFeatures');

var _applyTransformFeatures2 = _interopRequireDefault(_applyTransformFeatures);

var _isSassVariable = require('./isSassVariable');

var _isSassVariable2 = _interopRequireDefault(_isSassVariable);

var _walk = require('./walk');

var _walk2 = _interopRequireDefault(_walk);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function applyCompressed(css, opts) {
    css.walk(function (rule) {
        var raws = rule.raws,
            type = rule.type;

        rule.raws.semicolon = false;
        if (type === 'comment' && raws.inline) {
            rule.raws.inline = null;
        }
        if (type === 'rule' || type === 'atrule') {
            rule.raws.between = rule.raws.after = '';
        }
        if (type === 'decl' && !(0, _commentRegex.block)().test(raws.between)) {
            rule.raws.between = ':';
        }
        if (rule.type === 'decl') {
            if (raws.value) {
                rule.value = raws.value.raw.trim();
            }

            var ast = (0, _postcssValueParser2.default)(rule.value);

            (0, _walk2.default)(ast, function (node, index, parent) {
                var next = parent.nodes[index + 1];
                if (node.type === 'div' && node.value === ',' || node.type === 'function') {
                    node.before = node.after = '';
                }
                if (node.type === 'space') {
                    node.value = ' ';
                    if (next.type === 'word' && next.value[0] === '!') {
                        node.value = '';
                    }
                }
                if (node.type === 'word' && node.value === '!' && parent.nodes[index + 2] && next.type === 'space' && parent.nodes[index + 2].type === 'word') {
                    next.type = 'word';
                    next.value = '';
                }
                if (node.type === 'word') {
                    (0, _applyTransformFeatures2.default)(node, opts);
                }
            });

            rule.value = ast.toString();

            if ((0, _isSassVariable2.default)(rule)) {
                rule.raws.before = '';
            }

            // Format `!important`
            if (rule.important) {
                rule.raws.important = '!important';
            }

            if (raws.value) {
                rule.raws.value.raw = rule.value;
            }
        }
    });
    // Remove final newline
    css.raws.after = '';
}
module.exports = exports['default'];
},{"./applyTransformFeatures":806,"./isSassVariable":811,"./walk":817,"comment-regex":542,"postcss-value-parser":1057}],805:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.default = applyExpanded;

var _postcss = require('postcss');

var _postcss2 = _interopRequireDefault(_postcss);

var _postcssValueParser = require('postcss-value-parser');

var _postcssValueParser2 = _interopRequireDefault(_postcssValueParser);

var _commentRegex = require('comment-regex');

var _applyTransformFeatures = require('./applyTransformFeatures');

var _applyTransformFeatures2 = _interopRequireDefault(_applyTransformFeatures);

var _blank = require('./blank');

var _blank2 = _interopRequireDefault(_blank);

var _getIndent = require('./getIndent');

var _getIndent2 = _interopRequireDefault(_getIndent);

var _isSassVariable = require('./isSassVariable');

var _isSassVariable2 = _interopRequireDefault(_isSassVariable);

var _longest = require('./longest');

var _longest2 = _interopRequireDefault(_longest);

var _maxSelectorLength = require('./maxSelectorLength');

var _prefixedDecls = require('./prefixedDecls');

var _prefixedDecls2 = _interopRequireDefault(_prefixedDecls);

var _space = require('./space');

var _space2 = _interopRequireDefault(_space);

var _sameLine = require('./sameLine');

var _sameLine2 = _interopRequireDefault(_sameLine);

var _walk = require('./walk');

var _walk2 = _interopRequireDefault(_walk);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var unprefixed = _postcss2.default.vendor.unprefixed;
function applyExpanded(css, opts) {
    css.walk(function (rule) {
        var raws = rule.raws,
            type = rule.type;

        if (type === 'decl') {
            if (raws.value) {
                rule.value = raws.value.raw.trim();
            }
            // Format sass variable `$size: 30em;`
            if ((0, _isSassVariable2.default)(rule)) {
                if (rule !== css.first) {
                    rule.raws.before = '\n';
                }
                rule.raws.between = ': ';
            }

            var ast = (0, _postcssValueParser2.default)(rule.value);

            (0, _walk2.default)(ast, function (node, index, parent) {
                var next = parent.nodes[index + 1];
                if (node.type === 'function') {
                    node.before = node.after = '';
                }
                if (node.type === 'div' && node.value === ',') {
                    node.before = '';
                    node.after = ' ';
                }
                if (node.type === 'space') {
                    node.value = ' ';
                }
                if (node.type === 'word' && node.value === '!' && parent.nodes[index + 2] && next.type === 'space' && parent.nodes[index + 2].type === 'word') {
                    next.type = 'word';
                    next.value = '';
                }
                if (node.type === 'word') {
                    (0, _applyTransformFeatures2.default)(node, opts);
                }
            });

            rule.value = ast.toString();

            // Format `!important`
            if (rule.important) {
                rule.raws.important = ' !important';
            }

            if (raws.value) {
                rule.raws.value.raw = rule.value;
            }
        }
        var indent = (0, _getIndent2.default)(rule, opts.indentChar, opts.indentSize);
        if (type === 'comment') {
            var prev = rule.prev();
            if (prev && prev.type === 'decl') {
                if ((0, _sameLine2.default)(prev, rule)) {
                    rule.raws.before = ' ' + (0, _blank2.default)(rule.raws.before);
                } else {
                    rule.raws.before = '\n' + indent + (0, _blank2.default)(rule.raws.before);
                }
            }
            if (!prev && rule !== css.first) {
                rule.raws.before = '\n' + indent + (0, _blank2.default)(rule.raws.before);
            }
            if (rule.parent && rule.parent.type === 'root') {
                var next = rule.next();
                if (next) {
                    next.raws.before = '\n\n';
                }
                if (rule !== css.first) {
                    rule.raws.before = '\n\n';
                }
            }
            return;
        }
        rule.raws.before = indent + (0, _blank2.default)(rule.raws.before);
        if (type === 'rule' || type === 'atrule') {
            if (!rule.nodes) {
                rule.raws.between = '';
            } else {
                rule.raws.between = ' ';
            }
            rule.raws.semicolon = true;
            if (rule.nodes) {
                rule.raws.after = '\n';
            }
        }
        // visual cascade of vendor prefixed properties
        if (opts.cascade && type === 'rule' && rule.nodes.length > 1) {
            (function () {
                var props = [];
                var prefixed = (0, _prefixedDecls2.default)(rule).sort(_longest2.default).filter(function (_ref) {
                    var prop = _ref.prop;

                    var base = unprefixed(prop);
                    if (!~props.indexOf(base)) {
                        return props.push(base);
                    }
                    return false;
                });
                prefixed.forEach(function (prefix) {
                    var base = unprefixed(prefix.prop);
                    var vendor = prefix.prop.replace(base, '').length;
                    rule.nodes.filter(function (_ref2) {
                        var prop = _ref2.prop;
                        return prop && ~prop.indexOf(base);
                    }).forEach(function (decl) {
                        var thisVendor = decl.prop.replace(base, '').length;
                        var extraSpace = vendor - thisVendor;
                        if (extraSpace > 0) {
                            decl.raws.before = (0, _space2.default)(extraSpace) + (0, _blank2.default)(decl.raws.before);
                        }
                    });
                });
            })();
        }
        if (raws.selector && raws.selector.raw) {
            rule.selector = rule.raws.selector.raw;
        }
        (0, _maxSelectorLength.maxSelectorLength)(rule, opts);
        if (type === 'atrule') {
            if (rule.params) {
                rule.raws.afterName = ' ';
            }
            (0, _maxSelectorLength.maxAtRuleLength)(rule, opts);
        }
        if (type === 'decl') {
            if (!(0, _commentRegex.block)().test(rule.raws.between)) {
                rule.raws.between = ': ';
            }
            (0, _maxSelectorLength.maxValueLength)(rule, opts);
        }
        if (rule.parent && rule.parent.type !== 'root') {
            rule.raws.before = '\n' + (0, _blank2.default)(rule.raws.before);
            rule.raws.after = '\n' + indent;
        }
        if (rule.parent && rule !== rule.parent.first && (type === 'rule' || type === 'atrule')) {
            if (type === 'atrule' && !rule.nodes) {
                rule.raws.before = '\n' + indent;
                return;
            }
            rule.raws.before = '\n\n' + indent;
        }
    });
    css.raws.after = '\n';
}
module.exports = exports['default'];
},{"./applyTransformFeatures":806,"./blank":807,"./getIndent":809,"./isSassVariable":811,"./longest":812,"./maxSelectorLength":813,"./prefixedDecls":814,"./sameLine":815,"./space":816,"./walk":817,"comment-regex":542,"postcss":834,"postcss-value-parser":1057}],806:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.default = applyTransformFeatures;

var _postcssValueParser = require('postcss-value-parser');

function isHex(node) {
    if (node.value[0] !== '#') {
        return false;
    }
    var range = node.value.slice(1);
    return ~[3, 4, 6, 8].indexOf(range.length) && !isNaN(parseInt(range, 16));
}

function toShorthand(hex) {
    if (hex.length === 7 && hex[1] === hex[2] && hex[3] === hex[4] && hex[5] === hex[6]) {
        return '#' + hex[2] + hex[4] + hex[6];
    }
    return hex;
}

function toLonghand(hex) {
    if (hex.length !== 4) {
        return hex;
    }

    var r = hex[1];
    var g = hex[2];
    var b = hex[3];
    return '#' + r + r + g + g + b + b;
};

var lengths = ['px', 'em', 'rem', 'ex', 'ch', 'vh', 'vw', 'cm', 'mm', 'in', 'pt', 'pc', 'vmin', 'vmax'];

function applyTransformFeatures(node, opts) {
    if (isHex(node)) {
        if (opts.colorCase === 'upper') {
            node.value = node.value.toUpperCase();
        }
        if (opts.colorCase === 'lower') {
            node.value = node.value.toLowerCase();
        }
        if (opts.colorShorthand === true) {
            node.value = toShorthand(node.value);
        }
        if (opts.colorShorthand === false) {
            node.value = toLonghand(node.value);
        }
    }
    var pair = (0, _postcssValueParser.unit)(node.value);
    if (pair) {
        if (opts.zeroLengthNoUnit === true && ~lengths.indexOf(pair.unit.toLowerCase()) && Number(pair.number) === 0) {
            node.value = '0';
            return;
        }

        var parts = pair.number.split('.');
        var pre = parts[0];
        var post = parts.slice(1).join('.');

        if (opts.trimLeadingZero === true && parts[1]) {
            pre = pre.replace(/^0+/, '');
        } else if (opts.trimLeadingZero === false && !pre.length) {
            pre = 0;
        }

        if (opts.trimTrailingZeros === true && parts[1]) {
            var rounded = String(Number(pre + '.' + post)).split('.')[1];
            post = rounded ? '.' + rounded : '';
        } else if (opts.trimTrailingZeros === false && parts[1]) {
            post = '.' + parts[1];
        }

        node.value = pre + post + pair.unit;
    }
}
module.exports = exports['default'];
},{"postcss-value-parser":1057}],807:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.default = blank;

var _defined = require('defined');

var _defined2 = _interopRequireDefault(_defined);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function blank(value) {
    return (0, _defined2.default)(value, '');
}
module.exports = exports['default'];
},{"defined":675}],808:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports.default = deeplyNested;
function deeplyNested(_ref) {
    var nodes = _ref.nodes;

    return nodes && nodes.some(function (_ref2) {
        var children = _ref2.nodes;
        return children;
    });
}
module.exports = exports["default"];
},{}],809:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.default = getIndent;

var _space = require('./space');

var _space2 = _interopRequireDefault(_space);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getIndent(node) {
    var indent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ' ';
    var base = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 4;

    var level = 0;
    var parent = node.parent;

    while (parent && parent.type !== 'root') {
        level++;
        parent = parent.parent;
    }
    return (0, _space2.default)(level * base, indent);
}
module.exports = exports['default'];
},{"./space":816}],810:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _postcss = require('postcss');

var _postcss2 = _interopRequireDefault(_postcss);

var _applyCompact = require('./applyCompact');

var _applyCompact2 = _interopRequireDefault(_applyCompact);

var _applyCompressed = require('./applyCompressed');

var _applyCompressed2 = _interopRequireDefault(_applyCompressed);

var _applyExpanded = require('./applyExpanded');

var _applyExpanded2 = _interopRequireDefault(_applyExpanded);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var perfectionist = _postcss2.default.plugin('perfectionist', function (opts) {
    opts = _extends({
        format: 'expanded',
        indentSize: 4,
        indentChar: ' ',
        maxAtRuleLength: 80,
        maxSelectorLength: 80,
        maxValueLength: 80,
        trimLeadingZero: true,
        trimTrailingZeros: true,
        cascade: true,
        colorCase: 'lower',
        colorShorthand: true,
        zeroLengthNoUnit: true
    }, opts);

    return function (css) {
        css.walk(function (node) {
            if (node.raws.before) {
                node.raws.before = node.raws.before.replace(/[;\s]/g, '');
            }
        });
        switch (opts.format) {
            case 'compact':
                (0, _applyCompact2.default)(css, opts);
                break;
            case 'compressed':
                (0, _applyCompressed2.default)(css, opts);
                break;
            case 'expanded':
            default:
                (0, _applyExpanded2.default)(css, opts);
                break;
        }
    };
});

perfectionist.process = function (css) {
    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    opts.map = opts.map || (opts.sourcemap ? true : null);
    if (opts.syntax === 'scss') {
        opts.syntax = require('postcss-scss');
    }
    var processor = (0, _postcss2.default)([perfectionist(opts)]);
    return processor.process(css, opts);
};

exports.default = perfectionist;
module.exports = exports['default'];
},{"./applyCompact":803,"./applyCompressed":804,"./applyExpanded":805,"postcss":834,"postcss-scss":993}],811:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.default = isSassVariable;
function isSassVariable(_ref) {
    var parent = _ref.parent,
        prop = _ref.prop;

    return parent.type === 'root' && prop[0] === '$';
}
module.exports = exports['default'];
},{}],812:[function(require,module,exports){
"use strict";

exports.__esModule = true;

exports.default = function (a, b) {
  return b.prop.length - a.prop.length;
};

module.exports = exports["default"];
},{}],813:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.maxAtRuleLength = maxAtRuleLength;
exports.maxSelectorLength = maxSelectorLength;
exports.maxValueLength = maxValueLength;

var _postcss = require('postcss');

var _space = require('./space');

var _space2 = _interopRequireDefault(_space);

var _getIndent = require('./getIndent');

var _getIndent2 = _interopRequireDefault(_getIndent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function splitProperty(rule, prop, opts) {
    var _reindent$opts = _extends({
        reindent: false
    }, opts),
        breakEvery = _reindent$opts.breakEvery,
        reindent = _reindent$opts.reindent,
        reduce = _reindent$opts.reduce,
        max = _reindent$opts.max;

    var property = rule[prop];
    if (!max || !property) {
        return;
    }
    var exploded = _postcss.list.comma(property);
    if (property.length > max || reduce) {
        (function () {
            var indent = 0;
            if (typeof reindent === 'function') {
                indent = reindent(rule);
            }
            rule[prop] = exploded.reduce(function (lines, chunk) {
                if (breakEvery) {
                    lines.push(chunk);
                    return lines;
                }
                if (lines[lines.length - 1].length + indent <= max) {
                    var merged = lines[lines.length - 1] + ', ' + chunk;
                    if (indent + merged.length <= max) {
                        lines[lines.length - 1] = merged;
                        return lines;
                    }
                }
                lines.push(chunk);
                return lines;
            }, [exploded.shift()]).join(',\n' + (0, _space2.default)(indent));
        })();
    }
}

function maxAtRuleLength(rule, _ref) {
    var max = _ref.maxAtRuleLength;

    return splitProperty(rule, 'params', {
        max: max,
        breakEvery: true,
        reindent: function reindent(r) {
            return r.name.length + 2;
        }
    });
}

function maxSelectorLength(rule, opts) {
    return splitProperty(rule, 'selector', {
        max: opts.maxSelectorLength,
        reduce: true, // where possible reduce to one line
        reindent: function reindent(r) {
            return (0, _getIndent2.default)(r, opts.indentChar, opts.indentSize).length;
        }
    });
}

function maxValueLength(rule, _ref2) {
    var max = _ref2.maxValueLength;

    if (rule.raws.value && rule.raws.value.raw) {
        rule.value = rule.raws.value.raw;
    }
    return splitProperty(rule, 'value', {
        max: max,
        breakEvery: true,
        reindent: function reindent(r) {
            return (0, _getIndent2.default)(r).length + r.prop.length + 2;
        }
    });
}
},{"./getIndent":809,"./space":816,"postcss":834}],814:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.default = prefixedDeclarations;

var _vendors = require('vendors');

var _vendors2 = _interopRequireDefault(_vendors);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var prefixes = _vendors2.default.map(function (vendor) {
    return '-' + vendor + '-';
});

function prefixedDeclarations(_ref) {
    var nodes = _ref.nodes;

    var prefix = function prefix(node) {
        return prefixes.some(function (p) {
            return node.prop && !node.prop.indexOf(p);
        });
    };
    return nodes.filter(prefix);
}
module.exports = exports['default'];
},{"vendors":1205}],815:[function(require,module,exports){
"use strict";

exports.__esModule = true;

exports.default = function (a, b) {
  return a.source.end.line === b.source.start.line;
};

module.exports = exports["default"];
},{}],816:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.default = space;

require('string.prototype.repeat');

function space(amount) {
    var indent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ' ';

    return indent.repeat(amount);
}
module.exports = exports['default'];
},{"string.prototype.repeat":1135}],817:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports.default = walk;
function walk(parent, callback) {
    parent.nodes.forEach(function (node, index) {
        var bubble = callback(node, index, parent);
        if (node.nodes && bubble !== false) {
            walk(node, callback);
        }
    });
}
module.exports = exports["default"];
},{}],818:[function(require,module,exports){
arguments[4][717][0].apply(exports,arguments)
},{"dup":717}],819:[function(require,module,exports){
'use strict';

function assembleStyles () {
	var styles = {
		modifiers: {
			reset: [0, 0],
			bold: [1, 22], // 21 isn't widely supported and 22 does the same thing
			dim: [2, 22],
			italic: [3, 23],
			underline: [4, 24],
			inverse: [7, 27],
			hidden: [8, 28],
			strikethrough: [9, 29]
		},
		colors: {
			black: [30, 39],
			red: [31, 39],
			green: [32, 39],
			yellow: [33, 39],
			blue: [34, 39],
			magenta: [35, 39],
			cyan: [36, 39],
			white: [37, 39],
			gray: [90, 39]
		},
		bgColors: {
			bgBlack: [40, 49],
			bgRed: [41, 49],
			bgGreen: [42, 49],
			bgYellow: [43, 49],
			bgBlue: [44, 49],
			bgMagenta: [45, 49],
			bgCyan: [46, 49],
			bgWhite: [47, 49]
		}
	};

	// fix humans
	styles.colors.grey = styles.colors.gray;

	Object.keys(styles).forEach(function (groupName) {
		var group = styles[groupName];

		Object.keys(group).forEach(function (styleName) {
			var style = group[styleName];

			styles[styleName] = group[styleName] = {
				open: '\u001b[' + style[0] + 'm',
				close: '\u001b[' + style[1] + 'm'
			};
		});

		Object.defineProperty(styles, groupName, {
			value: group,
			enumerable: false
		});
	});

	return styles;
}

Object.defineProperty(module, 'exports', {
	enumerable: true,
	get: assembleStyles
});

},{}],820:[function(require,module,exports){
(function (process){
'use strict';
var escapeStringRegexp = require('escape-string-regexp');
var ansiStyles = require('ansi-styles');
var stripAnsi = require('strip-ansi');
var hasAnsi = require('has-ansi');
var supportsColor = require('supports-color');
var defineProps = Object.defineProperties;
var isSimpleWindowsTerm = process.platform === 'win32' && !/^xterm/i.test(process.env.TERM);

function Chalk(options) {
	// detect mode if not set manually
	this.enabled = !options || options.enabled === undefined ? supportsColor : options.enabled;
}

// use bright blue on Windows as the normal blue color is illegible
if (isSimpleWindowsTerm) {
	ansiStyles.blue.open = '\u001b[94m';
}

var styles = (function () {
	var ret = {};

	Object.keys(ansiStyles).forEach(function (key) {
		ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), 'g');

		ret[key] = {
			get: function () {
				return build.call(this, this._styles.concat(key));
			}
		};
	});

	return ret;
})();

var proto = defineProps(function chalk() {}, styles);

function build(_styles) {
	var builder = function () {
		return applyStyle.apply(builder, arguments);
	};

	builder._styles = _styles;
	builder.enabled = this.enabled;
	// __proto__ is used because we must return a function, but there is
	// no way to create a function with a different prototype.
	/* eslint-disable no-proto */
	builder.__proto__ = proto;

	return builder;
}

function applyStyle() {
	// support varags, but simply cast to string in case there's only one arg
	var args = arguments;
	var argsLen = args.length;
	var str = argsLen !== 0 && String(arguments[0]);

	if (argsLen > 1) {
		// don't slice `arguments`, it prevents v8 optimizations
		for (var a = 1; a < argsLen; a++) {
			str += ' ' + args[a];
		}
	}

	if (!this.enabled || !str) {
		return str;
	}

	var nestedStyles = this._styles;
	var i = nestedStyles.length;

	// Turns out that on Windows dimmed gray text becomes invisible in cmd.exe,
	// see https://github.com/chalk/chalk/issues/58
	// If we're on Windows and we're dealing with a gray color, temporarily make 'dim' a noop.
	var originalDim = ansiStyles.dim.open;
	if (isSimpleWindowsTerm && (nestedStyles.indexOf('gray') !== -1 || nestedStyles.indexOf('grey') !== -1)) {
		ansiStyles.dim.open = '';
	}

	while (i--) {
		var code = ansiStyles[nestedStyles[i]];

		// Replace any instances already present with a re-opening code
		// otherwise only the part of the string until said closing code
		// will be colored, and the rest will simply be 'plain'.
		str = code.open + str.replace(code.closeRe, code.open) + code.close;
	}

	// Reset the original 'dim' if we changed it to work around the Windows dimmed gray issue.
	ansiStyles.dim.open = originalDim;

	return str;
}

function init() {
	var ret = {};

	Object.keys(styles).forEach(function (name) {
		ret[name] = {
			get: function () {
				return build.call(this, [name]);
			}
		};
	});

	return ret;
}

defineProps(Chalk.prototype, init());

module.exports = new Chalk();
module.exports.styles = ansiStyles;
module.exports.hasColor = hasAnsi;
module.exports.stripColor = stripAnsi;
module.exports.supportsColor = supportsColor;

}).call(this,require('_process'))
},{"_process":1098,"ansi-styles":819,"escape-string-regexp":712,"has-ansi":716,"strip-ansi":847,"supports-color":821}],821:[function(require,module,exports){
(function (process){
'use strict';
var argv = process.argv;

var terminator = argv.indexOf('--');
var hasFlag = function (flag) {
	flag = '--' + flag;
	var pos = argv.indexOf(flag);
	return pos !== -1 && (terminator !== -1 ? pos < terminator : true);
};

module.exports = (function () {
	if ('FORCE_COLOR' in process.env) {
		return true;
	}

	if (hasFlag('no-color') ||
		hasFlag('no-colors') ||
		hasFlag('color=false')) {
		return false;
	}

	if (hasFlag('color') ||
		hasFlag('colors') ||
		hasFlag('color=true') ||
		hasFlag('color=always')) {
		return true;
	}

	if (process.stdout && !process.stdout.isTTY) {
		return false;
	}

	if (process.platform === 'win32') {
		return true;
	}

	if ('COLORTERM' in process.env) {
		return true;
	}

	if (process.env.TERM === 'dumb') {
		return false;
	}

	if (/^screen|^xterm|^vt100|color|ansi|cygwin|linux/i.test(process.env.TERM)) {
		return true;
	}

	return false;
})();

}).call(this,require('_process'))
},{"_process":1098}],822:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _container = require('./container');

var _container2 = _interopRequireDefault(_container);

var _warnOnce = require('./warn-once');

var _warnOnce2 = _interopRequireDefault(_warnOnce);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Represents an at-rule.
 *
 * If its followed in the CSS by a {} block, this node will have
 * a nodes property representing its children.
 *
 * @extends Container
 *
 * @example
 * const root = postcss.parse('@charset "UTF-8"; @media print {}');
 *
 * const charset = root.first;
 * charset.type  //=> 'atrule'
 * charset.nodes //=> undefined
 *
 * const media = root.last;
 * media.nodes   //=> []
 */
var AtRule = function (_Container) {
    _inherits(AtRule, _Container);

    function AtRule(defaults) {
        _classCallCheck(this, AtRule);

        var _this = _possibleConstructorReturn(this, _Container.call(this, defaults));

        _this.type = 'atrule';
        return _this;
    }

    AtRule.prototype.append = function append() {
        var _Container$prototype$;

        if (!this.nodes) this.nodes = [];

        for (var _len = arguments.length, children = Array(_len), _key = 0; _key < _len; _key++) {
            children[_key] = arguments[_key];
        }

        return (_Container$prototype$ = _Container.prototype.append).call.apply(_Container$prototype$, [this].concat(children));
    };

    AtRule.prototype.prepend = function prepend() {
        var _Container$prototype$2;

        if (!this.nodes) this.nodes = [];

        for (var _len2 = arguments.length, children = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            children[_key2] = arguments[_key2];
        }

        return (_Container$prototype$2 = _Container.prototype.prepend).call.apply(_Container$prototype$2, [this].concat(children));
    };

    _createClass(AtRule, [{
        key: 'afterName',
        get: function get() {
            (0, _warnOnce2.default)('AtRule#afterName was deprecated. Use AtRule#raws.afterName');
            return this.raws.afterName;
        },
        set: function set(val) {
            (0, _warnOnce2.default)('AtRule#afterName was deprecated. Use AtRule#raws.afterName');
            this.raws.afterName = val;
        }
    }, {
        key: '_params',
        get: function get() {
            (0, _warnOnce2.default)('AtRule#_params was deprecated. Use AtRule#raws.params');
            return this.raws.params;
        },
        set: function set(val) {
            (0, _warnOnce2.default)('AtRule#_params was deprecated. Use AtRule#raws.params');
            this.raws.params = val;
        }

        /**
         * @memberof AtRule#
         * @member {string} name - the at-rules name immediately follows the `@`
         *
         * @example
         * const root  = postcss.parse('@media print {}');
         * media.name //=> 'media'
         * const media = root.first;
         */

        /**
         * @memberof AtRule#
         * @member {string} params - the at-rules parameters, the values
         *                           that follow the at-rules name but precede
         *                           any {} block
         *
         * @example
         * const root  = postcss.parse('@media print, screen {}');
         * const media = root.first;
         * media.params //=> 'print, screen'
         */

        /**
         * @memberof AtRule#
         * @member {object} raws - Information to generate byte-to-byte equal
         *                         node string as it was in the origin input.
         *
         * Every parser saves its own properties,
         * but the default CSS parser uses:
         *
         * * `before`: the space symbols before the node. It also stores `*`
         *   and `_` symbols before the declaration (IE hack).
         * * `after`: the space symbols after the last child of the node
         *   to the end of the node.
         * * `between`: the symbols between the property and value
         *   for declarations, selector and `{` for rules, or last parameter
         *   and `{` for at-rules.
         * * `semicolon`: contains true if the last child has
         *   an (optional) semicolon.
         * * `afterName`: the space between the at-rule name and its parameters.
         *
         * PostCSS cleans at-rule parameters from comments and extra spaces,
         * but it stores origin content in raws properties.
         * As such, if you dont change a declarations value,
         * PostCSS will use the raw value with comments.
         *
         * @example
         * const root = postcss.parse('  @media\nprint {\n}')
         * root.first.first.raws //=> { before: '  ',
         *                       //     between: ' ',
         *                       //     afterName: '\n',
         *                       //     after: '\n' }
         */

    }]);

    return AtRule;
}(_container2.default);

exports.default = AtRule;
module.exports = exports['default'];


},{"./container":824,"./warn-once":845}],823:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _warnOnce = require('./warn-once');

var _warnOnce2 = _interopRequireDefault(_warnOnce);

var _node = require('./node');

var _node2 = _interopRequireDefault(_node);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Represents a comment between declarations or statements (rule and at-rules).
 *
 * Comments inside selectors, at-rule parameters, or declaration values
 * will be stored in the `raws` properties explained above.
 *
 * @extends Node
 */
var Comment = function (_Node) {
    _inherits(Comment, _Node);

    function Comment(defaults) {
        _classCallCheck(this, Comment);

        var _this = _possibleConstructorReturn(this, _Node.call(this, defaults));

        _this.type = 'comment';
        return _this;
    }

    _createClass(Comment, [{
        key: 'left',
        get: function get() {
            (0, _warnOnce2.default)('Comment#left was deprecated. Use Comment#raws.left');
            return this.raws.left;
        },
        set: function set(val) {
            (0, _warnOnce2.default)('Comment#left was deprecated. Use Comment#raws.left');
            this.raws.left = val;
        }
    }, {
        key: 'right',
        get: function get() {
            (0, _warnOnce2.default)('Comment#right was deprecated. Use Comment#raws.right');
            return this.raws.right;
        },
        set: function set(val) {
            (0, _warnOnce2.default)('Comment#right was deprecated. Use Comment#raws.right');
            this.raws.right = val;
        }

        /**
         * @memberof Comment#
         * @member {string} text - the comments text
         */

        /**
         * @memberof Comment#
         * @member {object} raws - Information to generate byte-to-byte equal
         *                         node string as it was in the origin input.
         *
         * Every parser saves its own properties,
         * but the default CSS parser uses:
         *
         * * `before`: the space symbols before the node.
         * * `left`: the space symbols between `/*` and the comments text.
         * * `right`: the space symbols between the comments text.
         */

    }]);

    return Comment;
}(_node2.default);

exports.default = Comment;
module.exports = exports['default'];


},{"./node":831,"./warn-once":845}],824:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _declaration = require('./declaration');

var _declaration2 = _interopRequireDefault(_declaration);

var _warnOnce = require('./warn-once');

var _warnOnce2 = _interopRequireDefault(_warnOnce);

var _comment = require('./comment');

var _comment2 = _interopRequireDefault(_comment);

var _node = require('./node');

var _node2 = _interopRequireDefault(_node);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function cleanSource(nodes) {
    return nodes.map(function (i) {
        if (i.nodes) i.nodes = cleanSource(i.nodes);
        delete i.source;
        return i;
    });
}

/**
 * The {@link Root}, {@link AtRule}, and {@link Rule} container nodes
 * inherit some common methods to help work with their children.
 *
 * Note that all containers can store any content. If you write a rule inside
 * a rule, PostCSS will parse it.
 *
 * @extends Node
 * @abstract
 */

var Container = function (_Node) {
    _inherits(Container, _Node);

    function Container() {
        _classCallCheck(this, Container);

        return _possibleConstructorReturn(this, _Node.apply(this, arguments));
    }

    Container.prototype.push = function push(child) {
        child.parent = this;
        this.nodes.push(child);
        return this;
    };

    /**
     * Iterates through the containers immediate children,
     * calling `callback` for each child.
     *
     * Returning `false` in the callback will break iteration.
     *
     * This method only iterates through the containers immediate children.
     * If you need to recursively iterate through all the containers descendant
     * nodes, use {@link Container#walk}.
     *
     * Unlike the for `{}`-cycle or `Array#forEach` this iterator is safe
     * if you are mutating the array of child nodes during iteration.
     * PostCSS will adjust the current index to match the mutations.
     *
     * @param {childIterator} callback - iterator receives each node and index
     *
     * @return {false|undefined} returns `false` if iteration was broke
     *
     * @example
     * const root = postcss.parse('a { color: black; z-index: 1 }');
     * const rule = root.first;
     *
     * for ( let decl of rule.nodes ) {
     *     decl.cloneBefore({ prop: '-webkit-' + decl.prop });
     *     // Cycle will be infinite, because cloneBefore moves the current node
     *     // to the next index
     * }
     *
     * rule.each(decl => {
     *     decl.cloneBefore({ prop: '-webkit-' + decl.prop });
     *     // Will be executed only for color and z-index
     * });
     */


    Container.prototype.each = function each(callback) {
        if (!this.lastEach) this.lastEach = 0;
        if (!this.indexes) this.indexes = {};

        this.lastEach += 1;
        var id = this.lastEach;
        this.indexes[id] = 0;

        if (!this.nodes) return undefined;

        var index = void 0,
            result = void 0;
        while (this.indexes[id] < this.nodes.length) {
            index = this.indexes[id];
            result = callback(this.nodes[index], index);
            if (result === false) break;

            this.indexes[id] += 1;
        }

        delete this.indexes[id];

        return result;
    };

    /**
     * Traverses the containers descendant nodes, calling callback
     * for each node.
     *
     * Like container.each(), this method is safe to use
     * if you are mutating arrays during iteration.
     *
     * If you only need to iterate through the containers immediate children,
     * use {@link Container#each}.
     *
     * @param {childIterator} callback - iterator receives each node and index
     *
     * @return {false|undefined} returns `false` if iteration was broke
     *
     * @example
     * root.walk(node => {
     *   // Traverses all descendant nodes.
     * });
     */


    Container.prototype.walk = function walk(callback) {
        return this.each(function (child, i) {
            var result = callback(child, i);
            if (result !== false && child.walk) {
                result = child.walk(callback);
            }
            return result;
        });
    };

    /**
     * Traverses the containers descendant nodes, calling callback
     * for each declaration node.
     *
     * If you pass a filter, iteration will only happen over declarations
     * with matching properties.
     *
     * Like {@link Container#each}, this method is safe
     * to use if you are mutating arrays during iteration.
     *
     * @param {string|RegExp} [prop]   - string or regular expression
     *                                   to filter declarations by property name
     * @param {childIterator} callback - iterator receives each node and index
     *
     * @return {false|undefined} returns `false` if iteration was broke
     *
     * @example
     * root.walkDecls(decl => {
     *   checkPropertySupport(decl.prop);
     * });
     *
     * root.walkDecls('border-radius', decl => {
     *   decl.remove();
     * });
     *
     * root.walkDecls(/^background/, decl => {
     *   decl.value = takeFirstColorFromGradient(decl.value);
     * });
     */


    Container.prototype.walkDecls = function walkDecls(prop, callback) {
        if (!callback) {
            callback = prop;
            return this.walk(function (child, i) {
                if (child.type === 'decl') {
                    return callback(child, i);
                }
            });
        } else if (prop instanceof RegExp) {
            return this.walk(function (child, i) {
                if (child.type === 'decl' && prop.test(child.prop)) {
                    return callback(child, i);
                }
            });
        } else {
            return this.walk(function (child, i) {
                if (child.type === 'decl' && child.prop === prop) {
                    return callback(child, i);
                }
            });
        }
    };

    /**
     * Traverses the containers descendant nodes, calling callback
     * for each rule node.
     *
     * If you pass a filter, iteration will only happen over rules
     * with matching selectors.
     *
     * Like {@link Container#each}, this method is safe
     * to use if you are mutating arrays during iteration.
     *
     * @param {string|RegExp} [selector] - string or regular expression
     *                                     to filter rules by selector
     * @param {childIterator} callback   - iterator receives each node and index
     *
     * @return {false|undefined} returns `false` if iteration was broke
     *
     * @example
     * const selectors = [];
     * root.walkRules(rule => {
     *   selectors.push(rule.selector);
     * });
     * console.log(`Your CSS uses ${selectors.length} selectors`);
     */


    Container.prototype.walkRules = function walkRules(selector, callback) {
        if (!callback) {
            callback = selector;

            return this.walk(function (child, i) {
                if (child.type === 'rule') {
                    return callback(child, i);
                }
            });
        } else if (selector instanceof RegExp) {
            return this.walk(function (child, i) {
                if (child.type === 'rule' && selector.test(child.selector)) {
                    return callback(child, i);
                }
            });
        } else {
            return this.walk(function (child, i) {
                if (child.type === 'rule' && child.selector === selector) {
                    return callback(child, i);
                }
            });
        }
    };

    /**
     * Traverses the containers descendant nodes, calling callback
     * for each at-rule node.
     *
     * If you pass a filter, iteration will only happen over at-rules
     * that have matching names.
     *
     * Like {@link Container#each}, this method is safe
     * to use if you are mutating arrays during iteration.
     *
     * @param {string|RegExp} [name]   - string or regular expression
     *                                   to filter at-rules by name
     * @param {childIterator} callback - iterator receives each node and index
     *
     * @return {false|undefined} returns `false` if iteration was broke
     *
     * @example
     * root.walkAtRules(rule => {
     *   if ( isOld(rule.name) ) rule.remove();
     * });
     *
     * let first = false;
     * root.walkAtRules('charset', rule => {
     *   if ( !first ) {
     *     first = true;
     *   } else {
     *     rule.remove();
     *   }
     * });
     */


    Container.prototype.walkAtRules = function walkAtRules(name, callback) {
        if (!callback) {
            callback = name;
            return this.walk(function (child, i) {
                if (child.type === 'atrule') {
                    return callback(child, i);
                }
            });
        } else if (name instanceof RegExp) {
            return this.walk(function (child, i) {
                if (child.type === 'atrule' && name.test(child.name)) {
                    return callback(child, i);
                }
            });
        } else {
            return this.walk(function (child, i) {
                if (child.type === 'atrule' && child.name === name) {
                    return callback(child, i);
                }
            });
        }
    };

    /**
     * Traverses the containers descendant nodes, calling callback
     * for each comment node.
     *
     * Like {@link Container#each}, this method is safe
     * to use if you are mutating arrays during iteration.
     *
     * @param {childIterator} callback - iterator receives each node and index
     *
     * @return {false|undefined} returns `false` if iteration was broke
     *
     * @example
     * root.walkComments(comment => {
     *   comment.remove();
     * });
     */


    Container.prototype.walkComments = function walkComments(callback) {
        return this.walk(function (child, i) {
            if (child.type === 'comment') {
                return callback(child, i);
            }
        });
    };

    /**
     * Inserts new nodes to the end of the container.
     *
     * @param {...(Node|object|string|Node[])} children - new nodes
     *
     * @return {Node} this node for methods chain
     *
     * @example
     * const decl1 = postcss.decl({ prop: 'color', value: 'black' });
     * const decl2 = postcss.decl({ prop: 'background-color', value: 'white' });
     * rule.append(decl1, decl2);
     *
     * root.append({ name: 'charset', params: '"UTF-8"' });  // at-rule
     * root.append({ selector: 'a' });                       // rule
     * rule.append({ prop: 'color', value: 'black' });       // declaration
     * rule.append({ text: 'Comment' })                      // comment
     *
     * root.append('a {}');
     * root.first.append('color: black; z-index: 1');
     */


    Container.prototype.append = function append() {
        for (var _len = arguments.length, children = Array(_len), _key = 0; _key < _len; _key++) {
            children[_key] = arguments[_key];
        }

        for (var _iterator = children, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
            var _ref;

            if (_isArray) {
                if (_i >= _iterator.length) break;
                _ref = _iterator[_i++];
            } else {
                _i = _iterator.next();
                if (_i.done) break;
                _ref = _i.value;
            }

            var child = _ref;

            var nodes = this.normalize(child, this.last);
            for (var _iterator2 = nodes, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
                var _ref2;

                if (_isArray2) {
                    if (_i2 >= _iterator2.length) break;
                    _ref2 = _iterator2[_i2++];
                } else {
                    _i2 = _iterator2.next();
                    if (_i2.done) break;
                    _ref2 = _i2.value;
                }

                var node = _ref2;
                this.nodes.push(node);
            }
        }
        return this;
    };

    /**
     * Inserts new nodes to the start of the container.
     *
     * @param {...(Node|object|string|Node[])} children - new nodes
     *
     * @return {Node} this node for methods chain
     *
     * @example
     * const decl1 = postcss.decl({ prop: 'color', value: 'black' });
     * const decl2 = postcss.decl({ prop: 'background-color', value: 'white' });
     * rule.prepend(decl1, decl2);
     *
     * root.append({ name: 'charset', params: '"UTF-8"' });  // at-rule
     * root.append({ selector: 'a' });                       // rule
     * rule.append({ prop: 'color', value: 'black' });       // declaration
     * rule.append({ text: 'Comment' })                      // comment
     *
     * root.append('a {}');
     * root.first.append('color: black; z-index: 1');
     */


    Container.prototype.prepend = function prepend() {
        for (var _len2 = arguments.length, children = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            children[_key2] = arguments[_key2];
        }

        children = children.reverse();
        for (var _iterator3 = children, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {
            var _ref3;

            if (_isArray3) {
                if (_i3 >= _iterator3.length) break;
                _ref3 = _iterator3[_i3++];
            } else {
                _i3 = _iterator3.next();
                if (_i3.done) break;
                _ref3 = _i3.value;
            }

            var child = _ref3;

            var nodes = this.normalize(child, this.first, 'prepend').reverse();
            for (var _iterator4 = nodes, _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator]();;) {
                var _ref4;

                if (_isArray4) {
                    if (_i4 >= _iterator4.length) break;
                    _ref4 = _iterator4[_i4++];
                } else {
                    _i4 = _iterator4.next();
                    if (_i4.done) break;
                    _ref4 = _i4.value;
                }

                var node = _ref4;
                this.nodes.unshift(node);
            }for (var id in this.indexes) {
                this.indexes[id] = this.indexes[id] + nodes.length;
            }
        }
        return this;
    };

    Container.prototype.cleanRaws = function cleanRaws(keepBetween) {
        _Node.prototype.cleanRaws.call(this, keepBetween);
        if (this.nodes) {
            for (var _iterator5 = this.nodes, _isArray5 = Array.isArray(_iterator5), _i5 = 0, _iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator]();;) {
                var _ref5;

                if (_isArray5) {
                    if (_i5 >= _iterator5.length) break;
                    _ref5 = _iterator5[_i5++];
                } else {
                    _i5 = _iterator5.next();
                    if (_i5.done) break;
                    _ref5 = _i5.value;
                }

                var node = _ref5;
                node.cleanRaws(keepBetween);
            }
        }
    };

    /**
     * Insert new node before old node within the container.
     *
     * @param {Node|number} exist             - child or childs index.
     * @param {Node|object|string|Node[]} add - new node
     *
     * @return {Node} this node for methods chain
     *
     * @example
     * rule.insertBefore(decl, decl.clone({ prop: '-webkit-' + decl.prop }));
     */


    Container.prototype.insertBefore = function insertBefore(exist, add) {
        exist = this.index(exist);

        var type = exist === 0 ? 'prepend' : false;
        var nodes = this.normalize(add, this.nodes[exist], type).reverse();
        for (var _iterator6 = nodes, _isArray6 = Array.isArray(_iterator6), _i6 = 0, _iterator6 = _isArray6 ? _iterator6 : _iterator6[Symbol.iterator]();;) {
            var _ref6;

            if (_isArray6) {
                if (_i6 >= _iterator6.length) break;
                _ref6 = _iterator6[_i6++];
            } else {
                _i6 = _iterator6.next();
                if (_i6.done) break;
                _ref6 = _i6.value;
            }

            var node = _ref6;
            this.nodes.splice(exist, 0, node);
        }var index = void 0;
        for (var id in this.indexes) {
            index = this.indexes[id];
            if (exist <= index) {
                this.indexes[id] = index + nodes.length;
            }
        }

        return this;
    };

    /**
     * Insert new node after old node within the container.
     *
     * @param {Node|number} exist             - child or childs index
     * @param {Node|object|string|Node[]} add - new node
     *
     * @return {Node} this node for methods chain
     */


    Container.prototype.insertAfter = function insertAfter(exist, add) {
        exist = this.index(exist);

        var nodes = this.normalize(add, this.nodes[exist]).reverse();
        for (var _iterator7 = nodes, _isArray7 = Array.isArray(_iterator7), _i7 = 0, _iterator7 = _isArray7 ? _iterator7 : _iterator7[Symbol.iterator]();;) {
            var _ref7;

            if (_isArray7) {
                if (_i7 >= _iterator7.length) break;
                _ref7 = _iterator7[_i7++];
            } else {
                _i7 = _iterator7.next();
                if (_i7.done) break;
                _ref7 = _i7.value;
            }

            var node = _ref7;
            this.nodes.splice(exist + 1, 0, node);
        }var index = void 0;
        for (var id in this.indexes) {
            index = this.indexes[id];
            if (exist < index) {
                this.indexes[id] = index + nodes.length;
            }
        }

        return this;
    };

    Container.prototype.remove = function remove(child) {
        if (typeof child !== 'undefined') {
            (0, _warnOnce2.default)('Container#remove is deprecated. ' + 'Use Container#removeChild');
            this.removeChild(child);
        } else {
            _Node.prototype.remove.call(this);
        }
        return this;
    };

    /**
     * Removes node from the container and cleans the parent properties
     * from the node and its children.
     *
     * @param {Node|number} child - child or childs index
     *
     * @return {Node} this node for methods chain
     *
     * @example
     * rule.nodes.length  //=> 5
     * rule.removeChild(decl);
     * rule.nodes.length  //=> 4
     * decl.parent        //=> undefined
     */


    Container.prototype.removeChild = function removeChild(child) {
        child = this.index(child);
        this.nodes[child].parent = undefined;
        this.nodes.splice(child, 1);

        var index = void 0;
        for (var id in this.indexes) {
            index = this.indexes[id];
            if (index >= child) {
                this.indexes[id] = index - 1;
            }
        }

        return this;
    };

    /**
     * Removes all children from the container
     * and cleans their parent properties.
     *
     * @return {Node} this node for methods chain
     *
     * @example
     * rule.removeAll();
     * rule.nodes.length //=> 0
     */


    Container.prototype.removeAll = function removeAll() {
        for (var _iterator8 = this.nodes, _isArray8 = Array.isArray(_iterator8), _i8 = 0, _iterator8 = _isArray8 ? _iterator8 : _iterator8[Symbol.iterator]();;) {
            var _ref8;

            if (_isArray8) {
                if (_i8 >= _iterator8.length) break;
                _ref8 = _iterator8[_i8++];
            } else {
                _i8 = _iterator8.next();
                if (_i8.done) break;
                _ref8 = _i8.value;
            }

            var node = _ref8;
            node.parent = undefined;
        }this.nodes = [];
        return this;
    };

    /**
     * Passes all declaration values within the container that match pattern
     * through callback, replacing those values with the returned result
     * of callback.
     *
     * This method is useful if you are using a custom unit or function
     * and need to iterate through all values.
     *
     * @param {string|RegExp} pattern      - replace pattern
     * @param {object} opts                - options to speed up the search
     * @param {string|string[]} opts.props - an array of property names
     * @param {string} opts.fast           - string thats used
     *                                       to narrow down values and speed up
                                             the regexp search
     * @param {function|string} callback   - string to replace pattern
     *                                       or callback that returns a new
     *                                       value.
     *                                       The callback will receive
     *                                       the same arguments as those
     *                                       passed to a function parameter
     *                                       of `String#replace`.
     *
     * @return {Node} this node for methods chain
     *
     * @example
     * root.replaceValues(/\d+rem/, { fast: 'rem' }, string => {
     *   return 15 * parseInt(string) + 'px';
     * });
     */


    Container.prototype.replaceValues = function replaceValues(pattern, opts, callback) {
        if (!callback) {
            callback = opts;
            opts = {};
        }

        this.walkDecls(function (decl) {
            if (opts.props && opts.props.indexOf(decl.prop) === -1) return;
            if (opts.fast && decl.value.indexOf(opts.fast) === -1) return;

            decl.value = decl.value.replace(pattern, callback);
        });

        return this;
    };

    /**
     * Returns `true` if callback returns `true`
     * for all of the containers children.
     *
     * @param {childCondition} condition - iterator returns true or false.
     *
     * @return {boolean} is every child pass condition
     *
     * @example
     * const noPrefixes = rule.every(i => i.prop[0] !== '-');
     */


    Container.prototype.every = function every(condition) {
        return this.nodes.every(condition);
    };

    /**
     * Returns `true` if callback returns `true` for (at least) one
     * of the containers children.
     *
     * @param {childCondition} condition - iterator returns true or false.
     *
     * @return {boolean} is some child pass condition
     *
     * @example
     * const hasPrefix = rule.some(i => i.prop[0] === '-');
     */


    Container.prototype.some = function some(condition) {
        return this.nodes.some(condition);
    };

    /**
     * Returns a `child`s index within the {@link Container#nodes} array.
     *
     * @param {Node} child - child of the current container.
     *
     * @return {number} child index
     *
     * @example
     * rule.index( rule.nodes[2] ) //=> 2
     */


    Container.prototype.index = function index(child) {
        if (typeof child === 'number') {
            return child;
        } else {
            return this.nodes.indexOf(child);
        }
    };

    /**
     * The containers first child.
     *
     * @type {Node}
     *
     * @example
     * rule.first == rules.nodes[0];
     */


    Container.prototype.normalize = function normalize(nodes, sample) {
        var _this2 = this;

        if (typeof nodes === 'string') {
            var parse = require('./parse');
            nodes = cleanSource(parse(nodes).nodes);
        } else if (!Array.isArray(nodes)) {
            if (nodes.type === 'root') {
                nodes = nodes.nodes;
            } else if (nodes.type) {
                nodes = [nodes];
            } else if (nodes.prop) {
                if (typeof nodes.value === 'undefined') {
                    throw new Error('Value field is missed in node creation');
                } else if (typeof nodes.value !== 'string') {
                    nodes.value = String(nodes.value);
                }
                nodes = [new _declaration2.default(nodes)];
            } else if (nodes.selector) {
                var Rule = require('./rule');
                nodes = [new Rule(nodes)];
            } else if (nodes.name) {
                var AtRule = require('./at-rule');
                nodes = [new AtRule(nodes)];
            } else if (nodes.text) {
                nodes = [new _comment2.default(nodes)];
            } else {
                throw new Error('Unknown node type in node creation');
            }
        }

        var processed = nodes.map(function (i) {
            if (typeof i.raws === 'undefined') i = _this2.rebuild(i);

            if (i.parent) i = i.clone();
            if (typeof i.raws.before === 'undefined') {
                if (sample && typeof sample.raws.before !== 'undefined') {
                    i.raws.before = sample.raws.before.replace(/[^\s]/g, '');
                }
            }
            i.parent = _this2;
            return i;
        });

        return processed;
    };

    Container.prototype.rebuild = function rebuild(node, parent) {
        var _this3 = this;

        var fix = void 0;
        if (node.type === 'root') {
            var Root = require('./root');
            fix = new Root();
        } else if (node.type === 'atrule') {
            var AtRule = require('./at-rule');
            fix = new AtRule();
        } else if (node.type === 'rule') {
            var Rule = require('./rule');
            fix = new Rule();
        } else if (node.type === 'decl') {
            fix = new _declaration2.default();
        } else if (node.type === 'comment') {
            fix = new _comment2.default();
        }

        for (var i in node) {
            if (i === 'nodes') {
                fix.nodes = node.nodes.map(function (j) {
                    return _this3.rebuild(j, fix);
                });
            } else if (i === 'parent' && parent) {
                fix.parent = parent;
            } else if (node.hasOwnProperty(i)) {
                fix[i] = node[i];
            }
        }

        return fix;
    };

    Container.prototype.eachInside = function eachInside(callback) {
        (0, _warnOnce2.default)('Container#eachInside is deprecated. ' + 'Use Container#walk instead.');
        return this.walk(callback);
    };

    Container.prototype.eachDecl = function eachDecl(prop, callback) {
        (0, _warnOnce2.default)('Container#eachDecl is deprecated. ' + 'Use Container#walkDecls instead.');
        return this.walkDecls(prop, callback);
    };

    Container.prototype.eachRule = function eachRule(selector, callback) {
        (0, _warnOnce2.default)('Container#eachRule is deprecated. ' + 'Use Container#walkRules instead.');
        return this.walkRules(selector, callback);
    };

    Container.prototype.eachAtRule = function eachAtRule(name, callback) {
        (0, _warnOnce2.default)('Container#eachAtRule is deprecated. ' + 'Use Container#walkAtRules instead.');
        return this.walkAtRules(name, callback);
    };

    Container.prototype.eachComment = function eachComment(callback) {
        (0, _warnOnce2.default)('Container#eachComment is deprecated. ' + 'Use Container#walkComments instead.');
        return this.walkComments(callback);
    };

    _createClass(Container, [{
        key: 'first',
        get: function get() {
            if (!this.nodes) return undefined;
            return this.nodes[0];
        }

        /**
         * The containers last child.
         *
         * @type {Node}
         *
         * @example
         * rule.last == rule.nodes[rule.nodes.length - 1];
         */

    }, {
        key: 'last',
        get: function get() {
            if (!this.nodes) return undefined;
            return this.nodes[this.nodes.length - 1];
        }
    }, {
        key: 'semicolon',
        get: function get() {
            (0, _warnOnce2.default)('Node#semicolon is deprecated. Use Node#raws.semicolon');
            return this.raws.semicolon;
        },
        set: function set(val) {
            (0, _warnOnce2.default)('Node#semicolon is deprecated. Use Node#raws.semicolon');
            this.raws.semicolon = val;
        }
    }, {
        key: 'after',
        get: function get() {
            (0, _warnOnce2.default)('Node#after is deprecated. Use Node#raws.after');
            return this.raws.after;
        },
        set: function set(val) {
            (0, _warnOnce2.default)('Node#after is deprecated. Use Node#raws.after');
            this.raws.after = val;
        }

        /**
         * @memberof Container#
         * @member {Node[]} nodes - an array containing the containers children
         *
         * @example
         * const root = postcss.parse('a { color: black }');
         * root.nodes.length           //=> 1
         * root.nodes[0].selector      //=> 'a'
         * root.nodes[0].nodes[0].prop //=> 'color'
         */

    }]);

    return Container;
}(_node2.default);

exports.default = Container;

/**
 * @callback childCondition
 * @param {Node} node    - container child
 * @param {number} index - child index
 * @param {Node[]} nodes - all container children
 * @return {boolean}
 */

/**
 * @callback childIterator
 * @param {Node} node    - container child
 * @param {number} index - child index
 * @return {false|undefined} returning `false` will break iteration
 */

module.exports = exports['default'];


},{"./at-rule":822,"./comment":823,"./declaration":826,"./node":831,"./parse":832,"./root":838,"./rule":839,"./warn-once":845}],825:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _supportsColor = require('supports-color');

var _supportsColor2 = _interopRequireDefault(_supportsColor);

var _chalk = require('chalk');

var _chalk2 = _interopRequireDefault(_chalk);

var _terminalHighlight = require('./terminal-highlight');

var _terminalHighlight2 = _interopRequireDefault(_terminalHighlight);

var _warnOnce = require('./warn-once');

var _warnOnce2 = _interopRequireDefault(_warnOnce);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * The CSS parser throws this error for broken CSS.
 *
 * Custom parsers can throw this error for broken custom syntax using
 * the {@link Node#error} method.
 *
 * PostCSS will use the input source map to detect the original error location.
 * If you wrote a Sass file, compiled it to CSS and then parsed it with PostCSS,
 * PostCSS will show the original position in the Sass file.
 *
 * If you need the position in the PostCSS input
 * (e.g., to debug the previous compiler), use `error.input.file`.
 *
 * @example
 * // Catching and checking syntax error
 * try {
 *   postcss.parse('a{')
 * } catch (error) {
 *   if ( error.name === 'CssSyntaxError' ) {
 *     error //=> CssSyntaxError
 *   }
 * }
 *
 * @example
 * // Raising error from plugin
 * throw node.error('Unknown variable', { plugin: 'postcss-vars' });
 */
var CssSyntaxError = function () {

    /**
     * @param {string} message  - error message
     * @param {number} [line]   - source line of the error
     * @param {number} [column] - source column of the error
     * @param {string} [source] - source code of the broken file
     * @param {string} [file]   - absolute path to the broken file
     * @param {string} [plugin] - PostCSS plugin name, if error came from plugin
     */
    function CssSyntaxError(message, line, column, source, file, plugin) {
        _classCallCheck(this, CssSyntaxError);

        /**
         * @member {string} - Always equal to `'CssSyntaxError'`. You should
         *                    always check error type
         *                    by `error.name === 'CssSyntaxError'` instead of
         *                    `error instanceof CssSyntaxError`, because
         *                    npm could have several PostCSS versions.
         *
         * @example
         * if ( error.name === 'CssSyntaxError' ) {
         *   error //=> CssSyntaxError
         * }
         */
        this.name = 'CssSyntaxError';
        /**
         * @member {string} - Error message.
         *
         * @example
         * error.message //=> 'Unclosed block'
         */
        this.reason = message;

        if (file) {
            /**
             * @member {string} - Absolute path to the broken file.
             *
             * @example
             * error.file       //=> 'a.sass'
             * error.input.file //=> 'a.css'
             */
            this.file = file;
        }
        if (source) {
            /**
             * @member {string} - Source code of the broken file.
             *
             * @example
             * error.source       //=> 'a { b {} }'
             * error.input.column //=> 'a b { }'
             */
            this.source = source;
        }
        if (plugin) {
            /**
             * @member {string} - Plugin name, if error came from plugin.
             *
             * @example
             * error.plugin //=> 'postcss-vars'
             */
            this.plugin = plugin;
        }
        if (typeof line !== 'undefined' && typeof column !== 'undefined') {
            /**
             * @member {number} - Source line of the error.
             *
             * @example
             * error.line       //=> 2
             * error.input.line //=> 4
             */
            this.line = line;
            /**
             * @member {number} - Source column of the error.
             *
             * @example
             * error.column       //=> 1
             * error.input.column //=> 4
             */
            this.column = column;
        }

        this.setMessage();

        if (Error.captureStackTrace) {
            Error.captureStackTrace(this, CssSyntaxError);
        }
    }

    CssSyntaxError.prototype.setMessage = function setMessage() {
        /**
         * @member {string} - Full error text in the GNU error format
         *                    with plugin, file, line and column.
         *
         * @example
         * error.message //=> 'a.css:1:1: Unclosed block'
         */
        this.message = this.plugin ? this.plugin + ': ' : '';
        this.message += this.file ? this.file : '<css input>';
        if (typeof this.line !== 'undefined') {
            this.message += ':' + this.line + ':' + this.column;
        }
        this.message += ': ' + this.reason;
    };

    /**
     * Returns a few lines of CSS source that caused the error.
     *
     * If the CSS has an input source map without `sourceContent`,
     * this method will return an empty string.
     *
     * @param {boolean} [color] whether arrow will be colored red by terminal
     *                          color codes. By default, PostCSS will detect
     *                          color support by `process.stdout.isTTY`
     *                          and `process.env.NODE_DISABLE_COLORS`.
     *
     * @example
     * error.showSourceCode() //=> "  4 | }
     *                        //      5 | a {
     *                        //    > 6 |   bad
     *                        //        |   ^
     *                        //      7 | }
     *                        //      8 | b {"
     *
     * @return {string} few lines of CSS source that caused the error
     */


    CssSyntaxError.prototype.showSourceCode = function showSourceCode(color) {
        var _this = this;

        if (!this.source) return '';

        var css = this.source;
        if (typeof color === 'undefined') color = _supportsColor2.default;
        if (color) css = (0, _terminalHighlight2.default)(css);

        var lines = css.split(/\r?\n/);
        var start = Math.max(this.line - 3, 0);
        var end = Math.min(this.line + 2, lines.length);

        var maxWidth = String(end).length;
        var colors = new _chalk2.default.constructor({ enabled: true });

        function mark(text) {
            if (color) {
                return colors.red.bold(text);
            } else {
                return text;
            }
        }
        function aside(text) {
            if (color) {
                return colors.gray(text);
            } else {
                return text;
            }
        }

        return lines.slice(start, end).map(function (line, index) {
            var number = start + 1 + index;
            var gutter = ' ' + (' ' + number).slice(-maxWidth) + ' | ';
            if (number === _this.line) {
                var spacing = aside(gutter.replace(/\d/g, ' ')) + line.slice(0, _this.column - 1).replace(/[^\t]/g, ' ');
                return mark('>') + aside(gutter) + line + '\n ' + spacing + mark('^');
            } else {
                return ' ' + aside(gutter) + line;
            }
        }).join('\n');
    };

    /**
     * Returns error position, message and source code of the broken part.
     *
     * @example
     * error.toString() //=> "CssSyntaxError: app.css:1:1: Unclosed block
     *                  //    > 1 | a {
     *                  //        | ^"
     *
     * @return {string} error position, message and source code
     */


    CssSyntaxError.prototype.toString = function toString() {
        var code = this.showSourceCode();
        if (code) {
            code = '\n\n' + code + '\n';
        }
        return this.name + ': ' + this.message + code;
    };

    _createClass(CssSyntaxError, [{
        key: 'generated',
        get: function get() {
            (0, _warnOnce2.default)('CssSyntaxError#generated is deprecated. Use input instead.');
            return this.input;
        }

        /**
         * @memberof CssSyntaxError#
         * @member {Input} input - Input object with PostCSS internal information
         *                         about input file. If input has source map
         *                         from previous tool, PostCSS will use origin
         *                         (for example, Sass) source. You can use this
         *                         object to get PostCSS input source.
         *
         * @example
         * error.input.file //=> 'a.css'
         * error.file       //=> 'a.sass'
         */

    }]);

    return CssSyntaxError;
}();

exports.default = CssSyntaxError;
module.exports = exports['default'];


},{"./terminal-highlight":842,"./warn-once":845,"chalk":820,"supports-color":848}],826:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _warnOnce = require('./warn-once');

var _warnOnce2 = _interopRequireDefault(_warnOnce);

var _node = require('./node');

var _node2 = _interopRequireDefault(_node);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Represents a CSS declaration.
 *
 * @extends Node
 *
 * @example
 * const root = postcss.parse('a { color: black }');
 * const decl = root.first.first;
 * decl.type       //=> 'decl'
 * decl.toString() //=> ' color: black'
 */
var Declaration = function (_Node) {
    _inherits(Declaration, _Node);

    function Declaration(defaults) {
        _classCallCheck(this, Declaration);

        var _this = _possibleConstructorReturn(this, _Node.call(this, defaults));

        _this.type = 'decl';
        return _this;
    }

    _createClass(Declaration, [{
        key: '_value',
        get: function get() {
            (0, _warnOnce2.default)('Node#_value was deprecated. Use Node#raws.value');
            return this.raws.value;
        },
        set: function set(val) {
            (0, _warnOnce2.default)('Node#_value was deprecated. Use Node#raws.value');
            this.raws.value = val;
        }
    }, {
        key: '_important',
        get: function get() {
            (0, _warnOnce2.default)('Node#_important was deprecated. Use Node#raws.important');
            return this.raws.important;
        },
        set: function set(val) {
            (0, _warnOnce2.default)('Node#_important was deprecated. Use Node#raws.important');
            this.raws.important = val;
        }

        /**
         * @memberof Declaration#
         * @member {string} prop - the declarations property name
         *
         * @example
         * const root = postcss.parse('a { color: black }');
         * const decl = root.first.first;
         * decl.prop //=> 'color'
         */

        /**
         * @memberof Declaration#
         * @member {string} value - the declarations value
         *
         * @example
         * const root = postcss.parse('a { color: black }');
         * const decl = root.first.first;
         * decl.value //=> 'black'
         */

        /**
         * @memberof Declaration#
         * @member {boolean} important - `true` if the declaration
         *                               has an !important annotation.
         *
         * @example
         * const root = postcss.parse('a { color: black !important; color: red }');
         * root.first.first.important //=> true
         * root.first.last.important  //=> undefined
         */

        /**
         * @memberof Declaration#
         * @member {object} raws - Information to generate byte-to-byte equal
         *                         node string as it was in the origin input.
         *
         * Every parser saves its own properties,
         * but the default CSS parser uses:
         *
         * * `before`: the space symbols before the node. It also stores `*`
         *   and `_` symbols before the declaration (IE hack).
         * * `between`: the symbols between the property and value
         *   for declarations.
         * * `important`: the content of the important statement,
         *   if it is not just `!important`.
         *
         * PostCSS cleans declaration from comments and extra spaces,
         * but it stores origin content in raws properties.
         * As such, if you dont change a declarations value,
         * PostCSS will use the raw value with comments.
         *
         * @example
         * const root = postcss.parse('a {\n  color:black\n}')
         * root.first.first.raws //=> { before: '\n  ', between: ':' }
         */

    }]);

    return Declaration;
}(_node2.default);

exports.default = Declaration;
module.exports = exports['default'];


},{"./node":831,"./warn-once":845}],827:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cssSyntaxError = require('./css-syntax-error');

var _cssSyntaxError2 = _interopRequireDefault(_cssSyntaxError);

var _previousMap = require('./previous-map');

var _previousMap2 = _interopRequireDefault(_previousMap);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var sequence = 0;

/**
 * Represents the source CSS.
 *
 * @example
 * const root  = postcss.parse(css, { from: file });
 * const input = root.source.input;
 */

var Input = function () {

    /**
     * @param {string} css    - input CSS source
     * @param {object} [opts] - {@link Processor#process} options
     */
    function Input(css) {
        var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        _classCallCheck(this, Input);

        /**
         * @member {string} - input CSS source
         *
         * @example
         * const input = postcss.parse('a{}', { from: file }).input;
         * input.css //=> "a{}";
         */
        this.css = css.toString();

        if (this.css[0] === '\uFEFF' || this.css[0] === '\uFFFE') {
            this.css = this.css.slice(1);
        }

        if (opts.from) {
            if (/^\w+:\/\//.test(opts.from)) {
                /**
                 * @member {string} - The absolute path to the CSS source file
                 *                    defined with the `from` option.
                 *
                 * @example
                 * const root = postcss.parse(css, { from: 'a.css' });
                 * root.source.input.file //=> '/home/ai/a.css'
                 */
                this.file = opts.from;
            } else {
                this.file = _path2.default.resolve(opts.from);
            }
        }

        var map = new _previousMap2.default(this.css, opts);
        if (map.text) {
            /**
             * @member {PreviousMap} - The input source map passed from
             *                         a compilation step before PostCSS
             *                         (for example, from Sass compiler).
             *
             * @example
             * root.source.input.map.consumer().sources //=> ['a.sass']
             */
            this.map = map;
            var file = map.consumer().file;
            if (!this.file && file) this.file = this.mapResolve(file);
        }

        if (!this.file) {
            sequence += 1;
            /**
             * @member {string} - The unique ID of the CSS source. It will be
             *                    created if `from` option is not provided
             *                    (because PostCSS does not know the file path).
             *
             * @example
             * const root = postcss.parse(css);
             * root.source.input.file //=> undefined
             * root.source.input.id   //=> "<input css 1>"
             */
            this.id = '<input css ' + sequence + '>';
        }
        if (this.map) this.map.file = this.from;
    }

    Input.prototype.error = function error(message, line, column) {
        var opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

        var result = void 0;
        var origin = this.origin(line, column);
        if (origin) {
            result = new _cssSyntaxError2.default(message, origin.line, origin.column, origin.source, origin.file, opts.plugin);
        } else {
            result = new _cssSyntaxError2.default(message, line, column, this.css, this.file, opts.plugin);
        }

        result.input = { line: line, column: column, source: this.css };
        if (this.file) result.input.file = this.file;

        return result;
    };

    /**
     * Reads the input source map and returns a symbol position
     * in the input source (e.g., in a Sass file that was compiled
     * to CSS before being passed to PostCSS).
     *
     * @param {number} line   - line in input CSS
     * @param {number} column - column in input CSS
     *
     * @return {filePosition} position in input source
     *
     * @example
     * root.source.input.origin(1, 1) //=> { file: 'a.css', line: 3, column: 1 }
     */


    Input.prototype.origin = function origin(line, column) {
        if (!this.map) return false;
        var consumer = this.map.consumer();

        var from = consumer.originalPositionFor({ line: line, column: column });
        if (!from.source) return false;

        var result = {
            file: this.mapResolve(from.source),
            line: from.line,
            column: from.column
        };

        var source = consumer.sourceContentFor(from.source);
        if (source) result.source = source;

        return result;
    };

    Input.prototype.mapResolve = function mapResolve(file) {
        if (/^\w+:\/\//.test(file)) {
            return file;
        } else {
            return _path2.default.resolve(this.map.consumer().sourceRoot || '.', file);
        }
    };

    /**
     * The CSS source identifier. Contains {@link Input#file} if the user
     * set the `from` option, or {@link Input#id} if they did not.
     * @type {string}
     *
     * @example
     * const root = postcss.parse(css, { from: 'a.css' });
     * root.source.input.from //=> "/home/ai/a.css"
     *
     * const root = postcss.parse(css);
     * root.source.input.from //=> "<input css 1>"
     */


    _createClass(Input, [{
        key: 'from',
        get: function get() {
            return this.file || this.id;
        }
    }]);

    return Input;
}();

exports.default = Input;

/**
 * @typedef  {object} filePosition
 * @property {string} file   - path to file
 * @property {number} line   - source line in file
 * @property {number} column - source column in file
 */

module.exports = exports['default'];


},{"./css-syntax-error":825,"./previous-map":835,"path":802}],828:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _mapGenerator = require('./map-generator');

var _mapGenerator2 = _interopRequireDefault(_mapGenerator);

var _stringify2 = require('./stringify');

var _stringify3 = _interopRequireDefault(_stringify2);

var _warnOnce = require('./warn-once');

var _warnOnce2 = _interopRequireDefault(_warnOnce);

var _result = require('./result');

var _result2 = _interopRequireDefault(_result);

var _parse = require('./parse');

var _parse2 = _interopRequireDefault(_parse);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function isPromise(obj) {
    return (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object' && typeof obj.then === 'function';
}

/**
 * A Promise proxy for the result of PostCSS transformations.
 *
 * A `LazyResult` instance is returned by {@link Processor#process}.
 *
 * @example
 * const lazy = postcss([cssnext]).process(css);
 */

var LazyResult = function () {
    function LazyResult(processor, css, opts) {
        _classCallCheck(this, LazyResult);

        this.stringified = false;
        this.processed = false;

        var root = void 0;
        if ((typeof css === 'undefined' ? 'undefined' : _typeof(css)) === 'object' && css.type === 'root') {
            root = css;
        } else if (css instanceof LazyResult || css instanceof _result2.default) {
            root = css.root;
            if (css.map) {
                if (typeof opts.map === 'undefined') opts.map = {};
                if (!opts.map.inline) opts.map.inline = false;
                opts.map.prev = css.map;
            }
        } else {
            var parser = _parse2.default;
            if (opts.syntax) parser = opts.syntax.parse;
            if (opts.parser) parser = opts.parser;
            if (parser.parse) parser = parser.parse;

            try {
                root = parser(css, opts);
            } catch (error) {
                this.error = error;
            }
        }

        this.result = new _result2.default(processor, root, opts);
    }

    /**
     * Returns a {@link Processor} instance, which will be used
     * for CSS transformations.
     * @type {Processor}
     */


    /**
     * Processes input CSS through synchronous plugins
     * and calls {@link Result#warnings()}.
     *
     * @return {Warning[]} warnings from plugins
     */
    LazyResult.prototype.warnings = function warnings() {
        return this.sync().warnings();
    };

    /**
     * Alias for the {@link LazyResult#css} property.
     *
     * @example
     * lazy + '' === lazy.css;
     *
     * @return {string} output CSS
     */


    LazyResult.prototype.toString = function toString() {
        return this.css;
    };

    /**
     * Processes input CSS through synchronous and asynchronous plugins
     * and calls `onFulfilled` with a Result instance. If a plugin throws
     * an error, the `onRejected` callback will be executed.
     *
     * It implements standard Promise API.
     *
     * @param {onFulfilled} onFulfilled - callback will be executed
     *                                    when all plugins will finish work
     * @param {onRejected}  onRejected  - callback will be executed on any error
     *
     * @return {Promise} Promise API to make queue
     *
     * @example
     * postcss([cssnext]).process(css).then(result => {
     *   console.log(result.css);
     * });
     */


    LazyResult.prototype.then = function then(onFulfilled, onRejected) {
        return this.async().then(onFulfilled, onRejected);
    };

    /**
     * Processes input CSS through synchronous and asynchronous plugins
     * and calls onRejected for each error thrown in any plugin.
     *
     * It implements standard Promise API.
     *
     * @param {onRejected} onRejected - callback will be executed on any error
     *
     * @return {Promise} Promise API to make queue
     *
     * @example
     * postcss([cssnext]).process(css).then(result => {
     *   console.log(result.css);
     * }).catch(error => {
     *   console.error(error);
     * });
     */


    LazyResult.prototype.catch = function _catch(onRejected) {
        return this.async().catch(onRejected);
    };

    LazyResult.prototype.handleError = function handleError(error, plugin) {
        try {
            this.error = error;
            if (error.name === 'CssSyntaxError' && !error.plugin) {
                error.plugin = plugin.postcssPlugin;
                error.setMessage();
            } else if (plugin.postcssVersion) {
                var pluginName = plugin.postcssPlugin;
                var pluginVer = plugin.postcssVersion;
                var runtimeVer = this.result.processor.version;
                var a = pluginVer.split('.');
                var b = runtimeVer.split('.');

                if (a[0] !== b[0] || parseInt(a[1]) > parseInt(b[1])) {
                    (0, _warnOnce2.default)('Your current PostCSS version ' + 'is ' + runtimeVer + ', but ' + pluginName + ' ' + 'uses ' + pluginVer + '. Perhaps this is ' + 'the source of the error below.');
                }
            }
        } catch (err) {
            if (console && console.error) console.error(err);
        }
    };

    LazyResult.prototype.asyncTick = function asyncTick(resolve, reject) {
        var _this = this;

        if (this.plugin >= this.processor.plugins.length) {
            this.processed = true;
            return resolve();
        }

        try {
            var plugin = this.processor.plugins[this.plugin];
            var promise = this.run(plugin);
            this.plugin += 1;

            if (isPromise(promise)) {
                promise.then(function () {
                    _this.asyncTick(resolve, reject);
                }).catch(function (error) {
                    _this.handleError(error, plugin);
                    _this.processed = true;
                    reject(error);
                });
            } else {
                this.asyncTick(resolve, reject);
            }
        } catch (error) {
            this.processed = true;
            reject(error);
        }
    };

    LazyResult.prototype.async = function async() {
        var _this2 = this;

        if (this.processed) {
            return new Promise(function (resolve, reject) {
                if (_this2.error) {
                    reject(_this2.error);
                } else {
                    resolve(_this2.stringify());
                }
            });
        }
        if (this.processing) {
            return this.processing;
        }

        this.processing = new Promise(function (resolve, reject) {
            if (_this2.error) return reject(_this2.error);
            _this2.plugin = 0;
            _this2.asyncTick(resolve, reject);
        }).then(function () {
            _this2.processed = true;
            return _this2.stringify();
        });

        return this.processing;
    };

    LazyResult.prototype.sync = function sync() {
        if (this.processed) return this.result;
        this.processed = true;

        if (this.processing) {
            throw new Error('Use process(css).then(cb) to work with async plugins');
        }

        if (this.error) throw this.error;

        for (var _iterator = this.result.processor.plugins, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
            var _ref;

            if (_isArray) {
                if (_i >= _iterator.length) break;
                _ref = _iterator[_i++];
            } else {
                _i = _iterator.next();
                if (_i.done) break;
                _ref = _i.value;
            }

            var plugin = _ref;

            var promise = this.run(plugin);
            if (isPromise(promise)) {
                throw new Error('Use process(css).then(cb) to work with async plugins');
            }
        }

        return this.result;
    };

    LazyResult.prototype.run = function run(plugin) {
        this.result.lastPlugin = plugin;

        try {
            return plugin(this.result.root, this.result);
        } catch (error) {
            this.handleError(error, plugin);
            throw error;
        }
    };

    LazyResult.prototype.stringify = function stringify() {
        if (this.stringified) return this.result;
        this.stringified = true;

        this.sync();

        var opts = this.result.opts;
        var str = _stringify3.default;
        if (opts.syntax) str = opts.syntax.stringify;
        if (opts.stringifier) str = opts.stringifier;
        if (str.stringify) str = str.stringify;

        var map = new _mapGenerator2.default(str, this.result.root, this.result.opts);
        var data = map.generate();
        this.result.css = data[0];
        this.result.map = data[1];

        return this.result;
    };

    _createClass(LazyResult, [{
        key: 'processor',
        get: function get() {
            return this.result.processor;
        }

        /**
         * Options from the {@link Processor#process} call.
         * @type {processOptions}
         */

    }, {
        key: 'opts',
        get: function get() {
            return this.result.opts;
        }

        /**
         * Processes input CSS through synchronous plugins, converts `Root`
         * to a CSS string and returns {@link Result#css}.
         *
         * This property will only work with synchronous plugins.
         * If the processor contains any asynchronous plugins
         * it will throw an error. This is why this method is only
         * for debug purpose, you should always use {@link LazyResult#then}.
         *
         * @type {string}
         * @see Result#css
         */

    }, {
        key: 'css',
        get: function get() {
            return this.stringify().css;
        }

        /**
         * An alias for the `css` property. Use it with syntaxes
         * that generate non-CSS output.
         *
         * This property will only work with synchronous plugins.
         * If the processor contains any asynchronous plugins
         * it will throw an error. This is why this method is only
         * for debug purpose, you should always use {@link LazyResult#then}.
         *
         * @type {string}
         * @see Result#content
         */

    }, {
        key: 'content',
        get: function get() {
            return this.stringify().content;
        }

        /**
         * Processes input CSS through synchronous plugins
         * and returns {@link Result#map}.
         *
         * This property will only work with synchronous plugins.
         * If the processor contains any asynchronous plugins
         * it will throw an error. This is why this method is only
         * for debug purpose, you should always use {@link LazyResult#then}.
         *
         * @type {SourceMapGenerator}
         * @see Result#map
         */

    }, {
        key: 'map',
        get: function get() {
            return this.stringify().map;
        }

        /**
         * Processes input CSS through synchronous plugins
         * and returns {@link Result#root}.
         *
         * This property will only work with synchronous plugins. If the processor
         * contains any asynchronous plugins it will throw an error.
         *
         * This is why this method is only for debug purpose,
         * you should always use {@link LazyResult#then}.
         *
         * @type {Root}
         * @see Result#root
         */

    }, {
        key: 'root',
        get: function get() {
            return this.sync().root;
        }

        /**
         * Processes input CSS through synchronous plugins
         * and returns {@link Result#messages}.
         *
         * This property will only work with synchronous plugins. If the processor
         * contains any asynchronous plugins it will throw an error.
         *
         * This is why this method is only for debug purpose,
         * you should always use {@link LazyResult#then}.
         *
         * @type {Message[]}
         * @see Result#messages
         */

    }, {
        key: 'messages',
        get: function get() {
            return this.sync().messages;
        }
    }]);

    return LazyResult;
}();

exports.default = LazyResult;

/**
 * @callback onFulfilled
 * @param {Result} result
 */

/**
 * @callback onRejected
 * @param {Error} error
 */

module.exports = exports['default'];


},{"./map-generator":830,"./parse":832,"./result":837,"./stringify":841,"./warn-once":845}],829:[function(require,module,exports){
'use strict';

exports.__esModule = true;
/**
 * Contains helpers for safely splitting lists of CSS values,
 * preserving parentheses and quotes.
 *
 * @example
 * const list = postcss.list;
 *
 * @namespace list
 */
var list = {
    split: function split(string, separators, last) {
        var array = [];
        var current = '';
        var split = false;

        var func = 0;
        var quote = false;
        var escape = false;

        for (var i = 0; i < string.length; i++) {
            var letter = string[i];

            if (quote) {
                if (escape) {
                    escape = false;
                } else if (letter === '\\') {
                    escape = true;
                } else if (letter === quote) {
                    quote = false;
                }
            } else if (letter === '"' || letter === '\'') {
                quote = letter;
            } else if (letter === '(') {
                func += 1;
            } else if (letter === ')') {
                if (func > 0) func -= 1;
            } else if (func === 0) {
                if (separators.indexOf(letter) !== -1) split = true;
            }

            if (split) {
                if (current !== '') array.push(current.trim());
                current = '';
                split = false;
            } else {
                current += letter;
            }
        }

        if (last || current !== '') array.push(current.trim());
        return array;
    },


    /**
     * Safely splits space-separated values (such as those for `background`,
     * `border-radius`, and other shorthand properties).
     *
     * @param {string} string - space-separated values
     *
     * @return {string[]} split values
     *
     * @example
     * postcss.list.space('1px calc(10% + 1px)') //=> ['1px', 'calc(10% + 1px)']
     */
    space: function space(string) {
        var spaces = [' ', '\n', '\t'];
        return list.split(string, spaces);
    },


    /**
     * Safely splits comma-separated values (such as those for `transition-*`
     * and `background` properties).
     *
     * @param {string} string - comma-separated values
     *
     * @return {string[]} split values
     *
     * @example
     * postcss.list.comma('black, linear-gradient(white, black)')
     * //=> ['black', 'linear-gradient(white, black)']
     */
    comma: function comma(string) {
        var comma = ',';
        return list.split(string, [comma], true);
    }
};

exports.default = list;
module.exports = exports['default'];


},{}],830:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _jsBase = require('js-base64');

var _sourceMap = require('source-map');

var _sourceMap2 = _interopRequireDefault(_sourceMap);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var MapGenerator = function () {
    function MapGenerator(stringify, root, opts) {
        _classCallCheck(this, MapGenerator);

        this.stringify = stringify;
        this.mapOpts = opts.map || {};
        this.root = root;
        this.opts = opts;
    }

    MapGenerator.prototype.isMap = function isMap() {
        if (typeof this.opts.map !== 'undefined') {
            return !!this.opts.map;
        } else {
            return this.previous().length > 0;
        }
    };

    MapGenerator.prototype.previous = function previous() {
        var _this = this;

        if (!this.previousMaps) {
            this.previousMaps = [];
            this.root.walk(function (node) {
                if (node.source && node.source.input.map) {
                    var map = node.source.input.map;
                    if (_this.previousMaps.indexOf(map) === -1) {
                        _this.previousMaps.push(map);
                    }
                }
            });
        }

        return this.previousMaps;
    };

    MapGenerator.prototype.isInline = function isInline() {
        if (typeof this.mapOpts.inline !== 'undefined') {
            return this.mapOpts.inline;
        }

        var annotation = this.mapOpts.annotation;
        if (typeof annotation !== 'undefined' && annotation !== true) {
            return false;
        }

        if (this.previous().length) {
            return this.previous().some(function (i) {
                return i.inline;
            });
        } else {
            return true;
        }
    };

    MapGenerator.prototype.isSourcesContent = function isSourcesContent() {
        if (typeof this.mapOpts.sourcesContent !== 'undefined') {
            return this.mapOpts.sourcesContent;
        }
        if (this.previous().length) {
            return this.previous().some(function (i) {
                return i.withContent();
            });
        } else {
            return true;
        }
    };

    MapGenerator.prototype.clearAnnotation = function clearAnnotation() {
        if (this.mapOpts.annotation === false) return;

        var node = void 0;
        for (var i = this.root.nodes.length - 1; i >= 0; i--) {
            node = this.root.nodes[i];
            if (node.type !== 'comment') continue;
            if (node.text.indexOf('# sourceMappingURL=') === 0) {
                this.root.removeChild(i);
            }
        }
    };

    MapGenerator.prototype.setSourcesContent = function setSourcesContent() {
        var _this2 = this;

        var already = {};
        this.root.walk(function (node) {
            if (node.source) {
                var from = node.source.input.from;
                if (from && !already[from]) {
                    already[from] = true;
                    var relative = _this2.relative(from);
                    _this2.map.setSourceContent(relative, node.source.input.css);
                }
            }
        });
    };

    MapGenerator.prototype.applyPrevMaps = function applyPrevMaps() {
        for (var _iterator = this.previous(), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
            var _ref;

            if (_isArray) {
                if (_i >= _iterator.length) break;
                _ref = _iterator[_i++];
            } else {
                _i = _iterator.next();
                if (_i.done) break;
                _ref = _i.value;
            }

            var prev = _ref;

            var from = this.relative(prev.file);
            var root = prev.root || _path2.default.dirname(prev.file);
            var map = void 0;

            if (this.mapOpts.sourcesContent === false) {
                map = new _sourceMap2.default.SourceMapConsumer(prev.text);
                if (map.sourcesContent) {
                    map.sourcesContent = map.sourcesContent.map(function () {
                        return null;
                    });
                }
            } else {
                map = prev.consumer();
            }

            this.map.applySourceMap(map, from, this.relative(root));
        }
    };

    MapGenerator.prototype.isAnnotation = function isAnnotation() {
        if (this.isInline()) {
            return true;
        } else if (typeof this.mapOpts.annotation !== 'undefined') {
            return this.mapOpts.annotation;
        } else if (this.previous().length) {
            return this.previous().some(function (i) {
                return i.annotation;
            });
        } else {
            return true;
        }
    };

    MapGenerator.prototype.addAnnotation = function addAnnotation() {
        var content = void 0;

        if (this.isInline()) {
            content = 'data:application/json;base64,' + _jsBase.Base64.encode(this.map.toString());
        } else if (typeof this.mapOpts.annotation === 'string') {
            content = this.mapOpts.annotation;
        } else {
            content = this.outputFile() + '.map';
        }

        var eol = '\n';
        if (this.css.indexOf('\r\n') !== -1) eol = '\r\n';

        this.css += eol + '/*# sourceMappingURL=' + content + ' */';
    };

    MapGenerator.prototype.outputFile = function outputFile() {
        if (this.opts.to) {
            return this.relative(this.opts.to);
        } else if (this.opts.from) {
            return this.relative(this.opts.from);
        } else {
            return 'to.css';
        }
    };

    MapGenerator.prototype.generateMap = function generateMap() {
        this.generateString();
        if (this.isSourcesContent()) this.setSourcesContent();
        if (this.previous().length > 0) this.applyPrevMaps();
        if (this.isAnnotation()) this.addAnnotation();

        if (this.isInline()) {
            return [this.css];
        } else {
            return [this.css, this.map];
        }
    };

    MapGenerator.prototype.relative = function relative(file) {
        if (file.indexOf('<') === 0) return file;
        if (/^\w+:\/\//.test(file)) return file;

        var from = this.opts.to ? _path2.default.dirname(this.opts.to) : '.';

        if (typeof this.mapOpts.annotation === 'string') {
            from = _path2.default.dirname(_path2.default.resolve(from, this.mapOpts.annotation));
        }

        file = _path2.default.relative(from, file);
        if (_path2.default.sep === '\\') {
            return file.replace(/\\/g, '/');
        } else {
            return file;
        }
    };

    MapGenerator.prototype.sourcePath = function sourcePath(node) {
        if (this.mapOpts.from) {
            return this.mapOpts.from;
        } else {
            return this.relative(node.source.input.from);
        }
    };

    MapGenerator.prototype.generateString = function generateString() {
        var _this3 = this;

        this.css = '';
        this.map = new _sourceMap2.default.SourceMapGenerator({ file: this.outputFile() });

        var line = 1;
        var column = 1;

        var lines = void 0,
            last = void 0;
        this.stringify(this.root, function (str, node, type) {
            _this3.css += str;

            if (node && type !== 'end') {
                if (node.source && node.source.start) {
                    _this3.map.addMapping({
                        source: _this3.sourcePath(node),
                        generated: { line: line, column: column - 1 },
                        original: {
                            line: node.source.start.line,
                            column: node.source.start.column - 1
                        }
                    });
                } else {
                    _this3.map.addMapping({
                        source: '<no source>',
                        original: { line: 1, column: 0 },
                        generated: { line: line, column: column - 1 }
                    });
                }
            }

            lines = str.match(/\n/g);
            if (lines) {
                line += lines.length;
                last = str.lastIndexOf('\n');
                column = str.length - last;
            } else {
                column += str.length;
            }

            if (node && type !== 'start') {
                if (node.source && node.source.end) {
                    _this3.map.addMapping({
                        source: _this3.sourcePath(node),
                        generated: { line: line, column: column - 1 },
                        original: {
                            line: node.source.end.line,
                            column: node.source.end.column
                        }
                    });
                } else {
                    _this3.map.addMapping({
                        source: '<no source>',
                        original: { line: 1, column: 0 },
                        generated: { line: line, column: column - 1 }
                    });
                }
            }
        });
    };

    MapGenerator.prototype.generate = function generate() {
        this.clearAnnotation();

        if (this.isMap()) {
            return this.generateMap();
        } else {
            var result = '';
            this.stringify(this.root, function (i) {
                result += i;
            });
            return [result];
        }
    };

    return MapGenerator;
}();

exports.default = MapGenerator;
module.exports = exports['default'];


},{"js-base64":752,"path":802,"source-map":1132}],831:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _cssSyntaxError = require('./css-syntax-error');

var _cssSyntaxError2 = _interopRequireDefault(_cssSyntaxError);

var _stringifier = require('./stringifier');

var _stringifier2 = _interopRequireDefault(_stringifier);

var _stringify = require('./stringify');

var _stringify2 = _interopRequireDefault(_stringify);

var _warnOnce = require('./warn-once');

var _warnOnce2 = _interopRequireDefault(_warnOnce);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var cloneNode = function cloneNode(obj, parent) {
    var cloned = new obj.constructor();

    for (var i in obj) {
        if (!obj.hasOwnProperty(i)) continue;
        var value = obj[i];
        var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);

        if (i === 'parent' && type === 'object') {
            if (parent) cloned[i] = parent;
        } else if (i === 'source') {
            cloned[i] = value;
        } else if (value instanceof Array) {
            cloned[i] = value.map(function (j) {
                return cloneNode(j, cloned);
            });
        } else if (i !== 'before' && i !== 'after' && i !== 'between' && i !== 'semicolon') {
            if (type === 'object' && value !== null) value = cloneNode(value);
            cloned[i] = value;
        }
    }

    return cloned;
};

/**
 * All node classes inherit the following common methods.
 *
 * @abstract
 */

var Node = function () {

    /**
     * @param {object} [defaults] - value for node properties
     */
    function Node() {
        var defaults = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        _classCallCheck(this, Node);

        this.raws = {};
        if ((typeof defaults === 'undefined' ? 'undefined' : _typeof(defaults)) !== 'object' && typeof defaults !== 'undefined') {
            throw new Error('PostCSS nodes constructor accepts object, not ' + JSON.stringify(defaults));
        }
        for (var name in defaults) {
            this[name] = defaults[name];
        }
    }

    /**
     * Returns a CssSyntaxError instance containing the original position
     * of the node in the source, showing line and column numbers and also
     * a small excerpt to facilitate debugging.
     *
     * If present, an input source map will be used to get the original position
     * of the source, even from a previous compilation step
     * (e.g., from Sass compilation).
     *
     * This method produces very useful error messages.
     *
     * @param {string} message     - error description
     * @param {object} [opts]      - options
     * @param {string} opts.plugin - plugin name that created this error.
     *                               PostCSS will set it automatically.
     * @param {string} opts.word   - a word inside a nodes string that should
     *                               be highlighted as the source of the error
     * @param {number} opts.index  - an index inside a nodes string that should
     *                               be highlighted as the source of the error
     *
     * @return {CssSyntaxError} error object to throw it
     *
     * @example
     * if ( !variables[name] ) {
     *   throw decl.error('Unknown variable ' + name, { word: name });
     *   // CssSyntaxError: postcss-vars:a.sass:4:3: Unknown variable $black
     *   //   color: $black
     *   // a
     *   //          ^
     *   //   background: white
     * }
     */


    Node.prototype.error = function error(message) {
        var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        if (this.source) {
            var pos = this.positionBy(opts);
            return this.source.input.error(message, pos.line, pos.column, opts);
        } else {
            return new _cssSyntaxError2.default(message);
        }
    };

    /**
     * This method is provided as a convenience wrapper for {@link Result#warn}.
     *
     * @param {Result} result      - the {@link Result} instance
     *                               that will receive the warning
     * @param {string} text        - warning message
     * @param {object} [opts]      - options
     * @param {string} opts.plugin - plugin name that created this warning.
     *                               PostCSS will set it automatically.
     * @param {string} opts.word   - a word inside a nodes string that should
     *                               be highlighted as the source of the warning
     * @param {number} opts.index  - an index inside a nodes string that should
     *                               be highlighted as the source of the warning
     *
     * @return {Warning} created warning object
     *
     * @example
     * const plugin = postcss.plugin('postcss-deprecated', () => {
     *   return (root, result) => {
     *     root.walkDecls('bad', decl => {
     *       decl.warn(result, 'Deprecated property bad');
     *     });
     *   };
     * });
     */


    Node.prototype.warn = function warn(result, text, opts) {
        var data = { node: this };
        for (var i in opts) {
            data[i] = opts[i];
        }return result.warn(text, data);
    };

    /**
     * Removes the node from its parent and cleans the parent properties
     * from the node and its children.
     *
     * @example
     * if ( decl.prop.match(/^-webkit-/) ) {
     *   decl.remove();
     * }
     *
     * @return {Node} node to make calls chain
     */


    Node.prototype.remove = function remove() {
        if (this.parent) {
            this.parent.removeChild(this);
        }
        this.parent = undefined;
        return this;
    };

    /**
     * Returns a CSS string representing the node.
     *
     * @param {stringifier|syntax} [stringifier] - a syntax to use
     *                                             in string generation
     *
     * @return {string} CSS string of this node
     *
     * @example
     * postcss.rule({ selector: 'a' }).toString() //=> "a {}"
     */


    Node.prototype.toString = function toString() {
        var stringifier = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _stringify2.default;

        if (stringifier.stringify) stringifier = stringifier.stringify;
        var result = '';
        stringifier(this, function (i) {
            result += i;
        });
        return result;
    };

    /**
     * Returns a clone of the node.
     *
     * The resulting cloned node and its (cloned) children will have
     * a clean parent and code style properties.
     *
     * @param {object} [overrides] - new properties to override in the clone.
     *
     * @example
     * const cloned = decl.clone({ prop: '-moz-' + decl.prop });
     * cloned.raws.before  //=> undefined
     * cloned.parent       //=> undefined
     * cloned.toString()   //=> -moz-transform: scale(0)
     *
     * @return {Node} clone of the node
     */


    Node.prototype.clone = function clone() {
        var overrides = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        var cloned = cloneNode(this);
        for (var name in overrides) {
            cloned[name] = overrides[name];
        }
        return cloned;
    };

    /**
     * Shortcut to clone the node and insert the resulting cloned node
     * before the current node.
     *
     * @param {object} [overrides] - new properties to override in the clone.
     *
     * @example
     * decl.cloneBefore({ prop: '-moz-' + decl.prop });
     *
     * @return {Node} - new node
     */


    Node.prototype.cloneBefore = function cloneBefore() {
        var overrides = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        var cloned = this.clone(overrides);
        this.parent.insertBefore(this, cloned);
        return cloned;
    };

    /**
     * Shortcut to clone the node and insert the resulting cloned node
     * after the current node.
     *
     * @param {object} [overrides] - new properties to override in the clone.
     *
     * @return {Node} - new node
     */


    Node.prototype.cloneAfter = function cloneAfter() {
        var overrides = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        var cloned = this.clone(overrides);
        this.parent.insertAfter(this, cloned);
        return cloned;
    };

    /**
     * Inserts node(s) before the current node and removes the current node.
     *
     * @param {...Node} nodes - node(s) to replace current one
     *
     * @example
     * if ( atrule.name == 'mixin' ) {
     *   atrule.replaceWith(mixinRules[atrule.params]);
     * }
     *
     * @return {Node} current node to methods chain
     */


    Node.prototype.replaceWith = function replaceWith() {
        if (this.parent) {
            for (var _len = arguments.length, nodes = Array(_len), _key = 0; _key < _len; _key++) {
                nodes[_key] = arguments[_key];
            }

            for (var _iterator = nodes, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
                var _ref;

                if (_isArray) {
                    if (_i >= _iterator.length) break;
                    _ref = _iterator[_i++];
                } else {
                    _i = _iterator.next();
                    if (_i.done) break;
                    _ref = _i.value;
                }

                var node = _ref;

                this.parent.insertBefore(this, node);
            }

            this.remove();
        }

        return this;
    };

    /**
     * Removes the node from its current parent and inserts it
     * at the end of `newParent`.
     *
     * This will clean the `before` and `after` code {@link Node#raws} data
     * from the node and replace them with the indentation style of `newParent`.
     * It will also clean the `between` property
     * if `newParent` is in another {@link Root}.
     *
     * @param {Container} newParent - container node where the current node
     *                                will be moved
     *
     * @example
     * atrule.moveTo(atrule.root());
     *
     * @return {Node} current node to methods chain
     */


    Node.prototype.moveTo = function moveTo(newParent) {
        this.cleanRaws(this.root() === newParent.root());
        this.remove();
        newParent.append(this);
        return this;
    };

    /**
     * Removes the node from its current parent and inserts it into
     * a new parent before `otherNode`.
     *
     * This will also clean the nodes code style properties just as it would
     * in {@link Node#moveTo}.
     *
     * @param {Node} otherNode - node that will be before current node
     *
     * @return {Node} current node to methods chain
     */


    Node.prototype.moveBefore = function moveBefore(otherNode) {
        this.cleanRaws(this.root() === otherNode.root());
        this.remove();
        otherNode.parent.insertBefore(otherNode, this);
        return this;
    };

    /**
     * Removes the node from its current parent and inserts it into
     * a new parent after `otherNode`.
     *
     * This will also clean the nodes code style properties just as it would
     * in {@link Node#moveTo}.
     *
     * @param {Node} otherNode - node that will be after current node
     *
     * @return {Node} current node to methods chain
     */


    Node.prototype.moveAfter = function moveAfter(otherNode) {
        this.cleanRaws(this.root() === otherNode.root());
        this.remove();
        otherNode.parent.insertAfter(otherNode, this);
        return this;
    };

    /**
     * Returns the next child of the nodes parent.
     * Returns `undefined` if the current node is the last child.
     *
     * @return {Node|undefined} next node
     *
     * @example
     * if ( comment.text === 'delete next' ) {
     *   const next = comment.next();
     *   if ( next ) {
     *     next.remove();
     *   }
     * }
     */


    Node.prototype.next = function next() {
        var index = this.parent.index(this);
        return this.parent.nodes[index + 1];
    };

    /**
     * Returns the previous child of the nodes parent.
     * Returns `undefined` if the current node is the first child.
     *
     * @return {Node|undefined} previous node
     *
     * @example
     * const annotation = decl.prev();
     * if ( annotation.type == 'comment' ) {
     *  readAnnotation(annotation.text);
     * }
     */


    Node.prototype.prev = function prev() {
        var index = this.parent.index(this);
        return this.parent.nodes[index - 1];
    };

    Node.prototype.toJSON = function toJSON() {
        var fixed = {};

        for (var name in this) {
            if (!this.hasOwnProperty(name)) continue;
            if (name === 'parent') continue;
            var value = this[name];

            if (value instanceof Array) {
                fixed[name] = value.map(function (i) {
                    if ((typeof i === 'undefined' ? 'undefined' : _typeof(i)) === 'object' && i.toJSON) {
                        return i.toJSON();
                    } else {
                        return i;
                    }
                });
            } else if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && value.toJSON) {
                fixed[name] = value.toJSON();
            } else {
                fixed[name] = value;
            }
        }

        return fixed;
    };

    /**
     * Returns a {@link Node#raws} value. If the node is missing
     * the code style property (because the node was manually built or cloned),
     * PostCSS will try to autodetect the code style property by looking
     * at other nodes in the tree.
     *
     * @param {string} prop          - name of code style property
     * @param {string} [defaultType] - name of default value, it can be missed
     *                                 if the value is the same as prop
     *
     * @example
     * const root = postcss.parse('a { background: white }');
     * root.nodes[0].append({ prop: 'color', value: 'black' });
     * root.nodes[0].nodes[1].raws.before   //=> undefined
     * root.nodes[0].nodes[1].raw('before') //=> ' '
     *
     * @return {string} code style value
     */


    Node.prototype.raw = function raw(prop, defaultType) {
        var str = new _stringifier2.default();
        return str.raw(this, prop, defaultType);
    };

    /**
     * Finds the Root instance of the nodes tree.
     *
     * @example
     * root.nodes[0].nodes[0].root() === root
     *
     * @return {Root} root parent
     */


    Node.prototype.root = function root() {
        var result = this;
        while (result.parent) {
            result = result.parent;
        }return result;
    };

    Node.prototype.cleanRaws = function cleanRaws(keepBetween) {
        delete this.raws.before;
        delete this.raws.after;
        if (!keepBetween) delete this.raws.between;
    };

    Node.prototype.positionInside = function positionInside(index) {
        var string = this.toString();
        var column = this.source.start.column;
        var line = this.source.start.line;

        for (var i = 0; i < index; i++) {
            if (string[i] === '\n') {
                column = 1;
                line += 1;
            } else {
                column += 1;
            }
        }

        return { line: line, column: column };
    };

    Node.prototype.positionBy = function positionBy(opts) {
        var pos = this.source.start;
        if (opts.index) {
            pos = this.positionInside(opts.index);
        } else if (opts.word) {
            var index = this.toString().indexOf(opts.word);
            if (index !== -1) pos = this.positionInside(index);
        }
        return pos;
    };

    Node.prototype.removeSelf = function removeSelf() {
        (0, _warnOnce2.default)('Node#removeSelf is deprecated. Use Node#remove.');
        return this.remove();
    };

    Node.prototype.replace = function replace(nodes) {
        (0, _warnOnce2.default)('Node#replace is deprecated. Use Node#replaceWith');
        return this.replaceWith(nodes);
    };

    Node.prototype.style = function style(own, detect) {
        (0, _warnOnce2.default)('Node#style() is deprecated. Use Node#raw()');
        return this.raw(own, detect);
    };

    Node.prototype.cleanStyles = function cleanStyles(keepBetween) {
        (0, _warnOnce2.default)('Node#cleanStyles() is deprecated. Use Node#cleanRaws()');
        return this.cleanRaws(keepBetween);
    };

    _createClass(Node, [{
        key: 'before',
        get: function get() {
            (0, _warnOnce2.default)('Node#before is deprecated. Use Node#raws.before');
            return this.raws.before;
        },
        set: function set(val) {
            (0, _warnOnce2.default)('Node#before is deprecated. Use Node#raws.before');
            this.raws.before = val;
        }
    }, {
        key: 'between',
        get: function get() {
            (0, _warnOnce2.default)('Node#between is deprecated. Use Node#raws.between');
            return this.raws.between;
        },
        set: function set(val) {
            (0, _warnOnce2.default)('Node#between is deprecated. Use Node#raws.between');
            this.raws.between = val;
        }

        /**
         * @memberof Node#
         * @member {string} type - String representing the nodes type.
         *                         Possible values are `root`, `atrule`, `rule`,
         *                         `decl`, or `comment`.
         *
         * @example
         * postcss.decl({ prop: 'color', value: 'black' }).type //=> 'decl'
         */

        /**
         * @memberof Node#
         * @member {Container} parent - the nodes parent node.
         *
         * @example
         * root.nodes[0].parent == root;
         */

        /**
         * @memberof Node#
         * @member {source} source - the input source of the node
         *
         * The property is used in source map generation.
         *
         * If you create a node manually (e.g., with `postcss.decl()`),
         * that node will not have a `source` property and will be absent
         * from the source map. For this reason, the plugin developer should
         * consider cloning nodes to create new ones (in which case the new nodes
         * source will reference the original, cloned node) or setting
         * the `source` property manually.
         *
         * ```js
         * // Bad
         * const prefixed = postcss.decl({
         *   prop: '-moz-' + decl.prop,
         *   value: decl.value
         * });
         *
         * // Good
         * const prefixed = decl.clone({ prop: '-moz-' + decl.prop });
         * ```
         *
         * ```js
         * if ( atrule.name == 'add-link' ) {
         *   const rule = postcss.rule({ selector: 'a', source: atrule.source });
         *   atrule.parent.insertBefore(atrule, rule);
         * }
         * ```
         *
         * @example
         * decl.source.input.from //=> '/home/ai/a.sass'
         * decl.source.start      //=> { line: 10, column: 2 }
         * decl.source.end        //=> { line: 10, column: 12 }
         */

        /**
         * @memberof Node#
         * @member {object} raws - Information to generate byte-to-byte equal
         *                         node string as it was in the origin input.
         *
         * Every parser saves its own properties,
         * but the default CSS parser uses:
         *
         * * `before`: the space symbols before the node. It also stores `*`
         *   and `_` symbols before the declaration (IE hack).
         * * `after`: the space symbols after the last child of the node
         *   to the end of the node.
         * * `between`: the symbols between the property and value
         *   for declarations, selector and `{` for rules, or last parameter
         *   and `{` for at-rules.
         * * `semicolon`: contains true if the last child has
         *   an (optional) semicolon.
         * * `afterName`: the space between the at-rule name and its parameters.
         * * `left`: the space symbols between `/*` and the comments text.
         * * `right`: the space symbols between the comments text
         *   and <code>*&#47;</code>.
         * * `important`: the content of the important statement,
         *   if it is not just `!important`.
         *
         * PostCSS cleans selectors, declaration values and at-rule parameters
         * from comments and extra spaces, but it stores origin content in raws
         * properties. As such, if you dont change a declarations value,
         * PostCSS will use the raw value with comments.
         *
         * @example
         * const root = postcss.parse('a {\n  color:black\n}')
         * root.first.first.raws //=> { before: '\n  ', between: ':' }
         */

    }]);

    return Node;
}();

exports.default = Node;

/**
 * @typedef {object} position
 * @property {number} line   - source line in file
 * @property {number} column - source column in file
 */

/**
 * @typedef {object} source
 * @property {Input} input    - {@link Input} with input file
 * @property {position} start - The starting position of the nodes source
 * @property {position} end   - The ending position of the nodes source
 */

module.exports = exports['default'];


},{"./css-syntax-error":825,"./stringifier":840,"./stringify":841,"./warn-once":845}],832:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.default = parse;

var _parser = require('./parser');

var _parser2 = _interopRequireDefault(_parser);

var _input = require('./input');

var _input2 = _interopRequireDefault(_input);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function parse(css, opts) {
    if (opts && opts.safe) {
        throw new Error('Option safe was removed. ' + 'Use parser: require("postcss-safe-parser")');
    }

    var input = new _input2.default(css, opts);

    var parser = new _parser2.default(input);
    try {
        parser.tokenize();
        parser.loop();
    } catch (e) {
        if (e.name === 'CssSyntaxError' && opts && opts.from) {
            if (/\.scss$/i.test(opts.from)) {
                e.message += '\nYou tried to parse SCSS with ' + 'the standard CSS parser; ' + 'try again with the postcss-scss parser';
            } else if (/\.sass/i.test(opts.from)) {
                e.message += '\nYou tried to parse Sass with ' + 'the standard CSS parser; ' + 'try again with the postcss-sass parser';
            } else if (/\.less$/i.test(opts.from)) {
                e.message += '\nYou tried to parse Less with ' + 'the standard CSS parser; ' + 'try again with the postcss-less parser';
            }
        }
        throw e;
    }

    return parser.root;
}
module.exports = exports['default'];


},{"./input":827,"./parser":833}],833:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _declaration = require('./declaration');

var _declaration2 = _interopRequireDefault(_declaration);

var _tokenize = require('./tokenize');

var _tokenize2 = _interopRequireDefault(_tokenize);

var _comment = require('./comment');

var _comment2 = _interopRequireDefault(_comment);

var _atRule = require('./at-rule');

var _atRule2 = _interopRequireDefault(_atRule);

var _root = require('./root');

var _root2 = _interopRequireDefault(_root);

var _rule = require('./rule');

var _rule2 = _interopRequireDefault(_rule);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Parser = function () {
    function Parser(input) {
        _classCallCheck(this, Parser);

        this.input = input;

        this.pos = 0;
        this.root = new _root2.default();
        this.current = this.root;
        this.spaces = '';
        this.semicolon = false;

        this.root.source = { input: input, start: { line: 1, column: 1 } };
    }

    Parser.prototype.tokenize = function tokenize() {
        this.tokens = (0, _tokenize2.default)(this.input);
    };

    Parser.prototype.loop = function loop() {
        var token = void 0;
        while (this.pos < this.tokens.length) {
            token = this.tokens[this.pos];

            switch (token[0]) {

                case 'space':
                case ';':
                    this.spaces += token[1];
                    break;

                case '}':
                    this.end(token);
                    break;

                case 'comment':
                    this.comment(token);
                    break;

                case 'at-word':
                    this.atrule(token);
                    break;

                case '{':
                    this.emptyRule(token);
                    break;

                default:
                    this.other();
                    break;
            }

            this.pos += 1;
        }
        this.endFile();
    };

    Parser.prototype.comment = function comment(token) {
        var node = new _comment2.default();
        this.init(node, token[2], token[3]);
        node.source.end = { line: token[4], column: token[5] };

        var text = token[1].slice(2, -2);
        if (/^\s*$/.test(text)) {
            node.text = '';
            node.raws.left = text;
            node.raws.right = '';
        } else {
            var match = text.match(/^(\s*)([^]*[^\s])(\s*)$/);
            node.text = match[2];
            node.raws.left = match[1];
            node.raws.right = match[3];
        }
    };

    Parser.prototype.emptyRule = function emptyRule(token) {
        var node = new _rule2.default();
        this.init(node, token[2], token[3]);
        node.selector = '';
        node.raws.between = '';
        this.current = node;
    };

    Parser.prototype.other = function other() {
        var token = void 0;
        var end = false;
        var type = null;
        var colon = false;
        var bracket = null;
        var brackets = [];

        var start = this.pos;
        while (this.pos < this.tokens.length) {
            token = this.tokens[this.pos];
            type = token[0];

            if (type === '(' || type === '[') {
                if (!bracket) bracket = token;
                brackets.push(type === '(' ? ')' : ']');
            } else if (brackets.length === 0) {
                if (type === ';') {
                    if (colon) {
                        this.decl(this.tokens.slice(start, this.pos + 1));
                        return;
                    } else {
                        break;
                    }
                } else if (type === '{') {
                    this.rule(this.tokens.slice(start, this.pos + 1));
                    return;
                } else if (type === '}') {
                    this.pos -= 1;
                    end = true;
                    break;
                } else if (type === ':') {
                    colon = true;
                }
            } else if (type === brackets[brackets.length - 1]) {
                brackets.pop();
                if (brackets.length === 0) bracket = null;
            }

            this.pos += 1;
        }
        if (this.pos === this.tokens.length) {
            this.pos -= 1;
            end = true;
        }

        if (brackets.length > 0) this.unclosedBracket(bracket);

        if (end && colon) {
            while (this.pos > start) {
                token = this.tokens[this.pos][0];
                if (token !== 'space' && token !== 'comment') break;
                this.pos -= 1;
            }
            this.decl(this.tokens.slice(start, this.pos + 1));
            return;
        }

        this.unknownWord(start);
    };

    Parser.prototype.rule = function rule(tokens) {
        tokens.pop();

        var node = new _rule2.default();
        this.init(node, tokens[0][2], tokens[0][3]);

        node.raws.between = this.spacesAndCommentsFromEnd(tokens);
        this.raw(node, 'selector', tokens);
        this.current = node;
    };

    Parser.prototype.decl = function decl(tokens) {
        var node = new _declaration2.default();
        this.init(node);

        var last = tokens[tokens.length - 1];
        if (last[0] === ';') {
            this.semicolon = true;
            tokens.pop();
        }
        if (last[4]) {
            node.source.end = { line: last[4], column: last[5] };
        } else {
            node.source.end = { line: last[2], column: last[3] };
        }

        while (tokens[0][0] !== 'word') {
            node.raws.before += tokens.shift()[1];
        }
        node.source.start = { line: tokens[0][2], column: tokens[0][3] };

        node.prop = '';
        while (tokens.length) {
            var type = tokens[0][0];
            if (type === ':' || type === 'space' || type === 'comment') {
                break;
            }
            node.prop += tokens.shift()[1];
        }

        node.raws.between = '';

        var token = void 0;
        while (tokens.length) {
            token = tokens.shift();

            if (token[0] === ':') {
                node.raws.between += token[1];
                break;
            } else {
                node.raws.between += token[1];
            }
        }

        if (node.prop[0] === '_' || node.prop[0] === '*') {
            node.raws.before += node.prop[0];
            node.prop = node.prop.slice(1);
        }
        node.raws.between += this.spacesAndCommentsFromStart(tokens);
        this.precheckMissedSemicolon(tokens);

        for (var i = tokens.length - 1; i > 0; i--) {
            token = tokens[i];
            if (token[1] === '!important') {
                node.important = true;
                var string = this.stringFrom(tokens, i);
                string = this.spacesFromEnd(tokens) + string;
                if (string !== ' !important') node.raws.important = string;
                break;
            } else if (token[1] === 'important') {
                var cache = tokens.slice(0);
                var str = '';
                for (var j = i; j > 0; j--) {
                    var _type = cache[j][0];
                    if (str.trim().indexOf('!') === 0 && _type !== 'space') {
                        break;
                    }
                    str = cache.pop()[1] + str;
                }
                if (str.trim().indexOf('!') === 0) {
                    node.important = true;
                    node.raws.important = str;
                    tokens = cache;
                }
            }

            if (token[0] !== 'space' && token[0] !== 'comment') {
                break;
            }
        }

        this.raw(node, 'value', tokens);

        if (node.value.indexOf(':') !== -1) this.checkMissedSemicolon(tokens);
    };

    Parser.prototype.atrule = function atrule(token) {
        var node = new _atRule2.default();
        node.name = token[1].slice(1);
        if (node.name === '') {
            this.unnamedAtrule(node, token);
        }
        this.init(node, token[2], token[3]);

        var last = false;
        var open = false;
        var params = [];

        this.pos += 1;
        while (this.pos < this.tokens.length) {
            token = this.tokens[this.pos];

            if (token[0] === ';') {
                node.source.end = { line: token[2], column: token[3] };
                this.semicolon = true;
                break;
            } else if (token[0] === '{') {
                open = true;
                break;
            } else if (token[0] === '}') {
                this.end(token);
                break;
            } else {
                params.push(token);
            }

            this.pos += 1;
        }
        if (this.pos === this.tokens.length) {
            last = true;
        }

        node.raws.between = this.spacesAndCommentsFromEnd(params);
        if (params.length) {
            node.raws.afterName = this.spacesAndCommentsFromStart(params);
            this.raw(node, 'params', params);
            if (last) {
                token = params[params.length - 1];
                node.source.end = { line: token[4], column: token[5] };
                this.spaces = node.raws.between;
                node.raws.between = '';
            }
        } else {
            node.raws.afterName = '';
            node.params = '';
        }

        if (open) {
            node.nodes = [];
            this.current = node;
        }
    };

    Parser.prototype.end = function end(token) {
        if (this.current.nodes && this.current.nodes.length) {
            this.current.raws.semicolon = this.semicolon;
        }
        this.semicolon = false;

        this.current.raws.after = (this.current.raws.after || '') + this.spaces;
        this.spaces = '';

        if (this.current.parent) {
            this.current.source.end = { line: token[2], column: token[3] };
            this.current = this.current.parent;
        } else {
            this.unexpectedClose(token);
        }
    };

    Parser.prototype.endFile = function endFile() {
        if (this.current.parent) this.unclosedBlock();
        if (this.current.nodes && this.current.nodes.length) {
            this.current.raws.semicolon = this.semicolon;
        }
        this.current.raws.after = (this.current.raws.after || '') + this.spaces;
    };

    // Helpers

    Parser.prototype.init = function init(node, line, column) {
        this.current.push(node);

        node.source = { start: { line: line, column: column }, input: this.input };
        node.raws.before = this.spaces;
        this.spaces = '';
        if (node.type !== 'comment') this.semicolon = false;
    };

    Parser.prototype.raw = function raw(node, prop, tokens) {
        var token = void 0,
            type = void 0;
        var length = tokens.length;
        var value = '';
        var clean = true;
        for (var i = 0; i < length; i += 1) {
            token = tokens[i];
            type = token[0];
            if (type === 'comment' || type === 'space' && i === length - 1) {
                clean = false;
            } else {
                value += token[1];
            }
        }
        if (!clean) {
            var raw = tokens.reduce(function (all, i) {
                return all + i[1];
            }, '');
            node.raws[prop] = { value: value, raw: raw };
        }
        node[prop] = value;
    };

    Parser.prototype.spacesAndCommentsFromEnd = function spacesAndCommentsFromEnd(tokens) {
        var lastTokenType = void 0;
        var spaces = '';
        while (tokens.length) {
            lastTokenType = tokens[tokens.length - 1][0];
            if (lastTokenType !== 'space' && lastTokenType !== 'comment') break;
            spaces = tokens.pop()[1] + spaces;
        }
        return spaces;
    };

    Parser.prototype.spacesAndCommentsFromStart = function spacesAndCommentsFromStart(tokens) {
        var next = void 0;
        var spaces = '';
        while (tokens.length) {
            next = tokens[0][0];
            if (next !== 'space' && next !== 'comment') break;
            spaces += tokens.shift()[1];
        }
        return spaces;
    };

    Parser.prototype.spacesFromEnd = function spacesFromEnd(tokens) {
        var lastTokenType = void 0;
        var spaces = '';
        while (tokens.length) {
            lastTokenType = tokens[tokens.length - 1][0];
            if (lastTokenType !== 'space') break;
            spaces = tokens.pop()[1] + spaces;
        }
        return spaces;
    };

    Parser.prototype.stringFrom = function stringFrom(tokens, from) {
        var result = '';
        for (var i = from; i < tokens.length; i++) {
            result += tokens[i][1];
        }
        tokens.splice(from, tokens.length - from);
        return result;
    };

    Parser.prototype.colon = function colon(tokens) {
        var brackets = 0;
        var token = void 0,
            type = void 0,
            prev = void 0;
        for (var i = 0; i < tokens.length; i++) {
            token = tokens[i];
            type = token[0];

            if (type === '(') {
                brackets += 1;
            } else if (type === ')') {
                brackets -= 1;
            } else if (brackets === 0 && type === ':') {
                if (!prev) {
                    this.doubleColon(token);
                } else if (prev[0] === 'word' && prev[1] === 'progid') {
                    continue;
                } else {
                    return i;
                }
            }

            prev = token;
        }
        return false;
    };

    // Errors

    Parser.prototype.unclosedBracket = function unclosedBracket(bracket) {
        throw this.input.error('Unclosed bracket', bracket[2], bracket[3]);
    };

    Parser.prototype.unknownWord = function unknownWord(start) {
        var token = this.tokens[start];
        throw this.input.error('Unknown word', token[2], token[3]);
    };

    Parser.prototype.unexpectedClose = function unexpectedClose(token) {
        throw this.input.error('Unexpected }', token[2], token[3]);
    };

    Parser.prototype.unclosedBlock = function unclosedBlock() {
        var pos = this.current.source.start;
        throw this.input.error('Unclosed block', pos.line, pos.column);
    };

    Parser.prototype.doubleColon = function doubleColon(token) {
        throw this.input.error('Double colon', token[2], token[3]);
    };

    Parser.prototype.unnamedAtrule = function unnamedAtrule(node, token) {
        throw this.input.error('At-rule without name', token[2], token[3]);
    };

    Parser.prototype.precheckMissedSemicolon = function precheckMissedSemicolon(tokens) {
        // Hook for Safe Parser
        tokens;
    };

    Parser.prototype.checkMissedSemicolon = function checkMissedSemicolon(tokens) {
        var colon = this.colon(tokens);
        if (colon === false) return;

        var founded = 0;
        var token = void 0;
        for (var j = colon - 1; j >= 0; j--) {
            token = tokens[j];
            if (token[0] !== 'space') {
                founded += 1;
                if (founded === 2) break;
            }
        }
        throw this.input.error('Missed semicolon', token[2], token[3]);
    };

    return Parser;
}();

exports.default = Parser;
module.exports = exports['default'];


},{"./at-rule":822,"./comment":823,"./declaration":826,"./root":838,"./rule":839,"./tokenize":843}],834:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _declaration = require('./declaration');

var _declaration2 = _interopRequireDefault(_declaration);

var _processor = require('./processor');

var _processor2 = _interopRequireDefault(_processor);

var _stringify = require('./stringify');

var _stringify2 = _interopRequireDefault(_stringify);

var _comment = require('./comment');

var _comment2 = _interopRequireDefault(_comment);

var _atRule = require('./at-rule');

var _atRule2 = _interopRequireDefault(_atRule);

var _vendor = require('./vendor');

var _vendor2 = _interopRequireDefault(_vendor);

var _parse = require('./parse');

var _parse2 = _interopRequireDefault(_parse);

var _list = require('./list');

var _list2 = _interopRequireDefault(_list);

var _rule = require('./rule');

var _rule2 = _interopRequireDefault(_rule);

var _root = require('./root');

var _root2 = _interopRequireDefault(_root);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Create a new {@link Processor} instance that will apply `plugins`
 * as CSS processors.
 *
 * @param {Array.<Plugin|pluginFunction>|Processor} plugins - PostCSS
 *        plugins. See {@link Processor#use} for plugin format.
 *
 * @return {Processor} Processor to process multiple CSS
 *
 * @example
 * import postcss from 'postcss';
 *
 * postcss(plugins).process(css, { from, to }).then(result => {
 *   console.log(result.css);
 * });
 *
 * @namespace postcss
 */
function postcss() {
  for (var _len = arguments.length, plugins = Array(_len), _key = 0; _key < _len; _key++) {
    plugins[_key] = arguments[_key];
  }

  if (plugins.length === 1 && Array.isArray(plugins[0])) {
    plugins = plugins[0];
  }
  return new _processor2.default(plugins);
}

/**
 * Creates a PostCSS plugin with a standard API.
 *
 * The newly-wrapped function will provide both the name and PostCSS
 * version of the plugin.
 *
 * ```js
 *  const processor = postcss([replace]);
 *  processor.plugins[0].postcssPlugin  //=> 'postcss-replace'
 *  processor.plugins[0].postcssVersion //=> '5.1.0'
 * ```
 *
 * The plugin function receives 2 arguments: {@link Root}
 * and {@link Result} instance. The function should mutate the provided
 * `Root` node. Alternatively, you can create a new `Root` node
 * and override the `result.root` property.
 *
 * ```js
 * const cleaner = postcss.plugin('postcss-cleaner', () => {
 *   return (root, result) => {
 *     result.root = postcss.root();
 *   };
 * });
 * ```
 *
 * As a convenience, plugins also expose a `process` method so that you can use
 * them as standalone tools.
 *
 * ```js
 * cleaner.process(css, options);
 * // This is equivalent to:
 * postcss([ cleaner(options) ]).process(css);
 * ```
 *
 * Asynchronous plugins should return a `Promise` instance.
 *
 * ```js
 * postcss.plugin('postcss-import', () => {
 *   return (root, result) => {
 *     return new Promise( (resolve, reject) => {
 *       fs.readFile('base.css', (base) => {
 *         root.prepend(base);
 *         resolve();
 *       });
 *     });
 *   };
 * });
 * ```
 *
 * Add warnings using the {@link Node#warn} method.
 * Send data to other plugins using the {@link Result#messages} array.
 *
 * ```js
 * postcss.plugin('postcss-caniuse-test', () => {
 *   return (root, result) => {
 *     css.walkDecls(decl => {
 *       if ( !caniuse.support(decl.prop) ) {
 *         decl.warn(result, 'Some browsers do not support ' + decl.prop);
 *       }
 *     });
 *   };
 * });
 * ```
 *
 * @param {string} name          - PostCSS plugin name. Same as in `name`
 *                                 property in `package.json`. It will be saved
 *                                 in `plugin.postcssPlugin` property.
 * @param {function} initializer - will receive plugin options
 *                                 and should return {@link pluginFunction}
 *
 * @return {Plugin} PostCSS plugin
 */
postcss.plugin = function plugin(name, initializer) {
  var creator = function creator() {
    var transformer = initializer.apply(undefined, arguments);
    transformer.postcssPlugin = name;
    transformer.postcssVersion = new _processor2.default().version;
    return transformer;
  };

  var cache = void 0;
  Object.defineProperty(creator, 'postcss', {
    get: function get() {
      if (!cache) cache = creator();
      return cache;
    }
  });

  creator.process = function (root, opts) {
    return postcss([creator(opts)]).process(root, opts);
  };

  return creator;
};

/**
 * Default function to convert a node tree into a CSS string.
 *
 * @param {Node} node       - start node for stringifing. Usually {@link Root}.
 * @param {builder} builder - function to concatenate CSS from nodes parts
 *                            or generate string and source map
 *
 * @return {void}
 *
 * @function
 */
postcss.stringify = _stringify2.default;

/**
 * Parses source css and returns a new {@link Root} node,
 * which contains the source CSS nodes.
 *
 * @param {string|toString} css   - string with input CSS or any object
 *                                  with toString() method, like a Buffer
 * @param {processOptions} [opts] - options with only `from` and `map` keys
 *
 * @return {Root} PostCSS AST
 *
 * @example
 * // Simple CSS concatenation with source map support
 * const root1 = postcss.parse(css1, { from: file1 });
 * const root2 = postcss.parse(css2, { from: file2 });
 * root1.append(root2).toResult().css;
 *
 * @function
 */
postcss.parse = _parse2.default;

/**
 * @member {vendor} - Contains the {@link vendor} module.
 *
 * @example
 * postcss.vendor.unprefixed('-moz-tab') //=> ['tab']
 */
postcss.vendor = _vendor2.default;

/**
 * @member {list} - Contains the {@link list} module.
 *
 * @example
 * postcss.list.space('5px calc(10% + 5px)') //=> ['5px', 'calc(10% + 5px)']
 */
postcss.list = _list2.default;

/**
 * Creates a new {@link Comment} node.
 *
 * @param {object} [defaults] - properties for the new node.
 *
 * @return {Comment} new Comment node
 *
 * @example
 * postcss.comment({ text: 'test' })
 */
postcss.comment = function (defaults) {
  return new _comment2.default(defaults);
};

/**
 * Creates a new {@link AtRule} node.
 *
 * @param {object} [defaults] - properties for the new node.
 *
 * @return {AtRule} new AtRule node
 *
 * @example
 * postcss.atRule({ name: 'charset' }).toString() //=> "@charset"
 */
postcss.atRule = function (defaults) {
  return new _atRule2.default(defaults);
};

/**
 * Creates a new {@link Declaration} node.
 *
 * @param {object} [defaults] - properties for the new node.
 *
 * @return {Declaration} new Declaration node
 *
 * @example
 * postcss.decl({ prop: 'color', value: 'red' }).toString() //=> "color: red"
 */
postcss.decl = function (defaults) {
  return new _declaration2.default(defaults);
};

/**
 * Creates a new {@link Rule} node.
 *
 * @param {object} [defaults] - properties for the new node.
 *
 * @return {AtRule} new Rule node
 *
 * @example
 * postcss.rule({ selector: 'a' }).toString() //=> "a {\n}"
 */
postcss.rule = function (defaults) {
  return new _rule2.default(defaults);
};

/**
 * Creates a new {@link Root} node.
 *
 * @param {object} [defaults] - properties for the new node.
 *
 * @return {Root} new Root node
 *
 * @example
 * postcss.root({ after: '\n' }).toString() //=> "\n"
 */
postcss.root = function (defaults) {
  return new _root2.default(defaults);
};

exports.default = postcss;
module.exports = exports['default'];


},{"./at-rule":822,"./comment":823,"./declaration":826,"./list":829,"./parse":832,"./processor":836,"./root":838,"./rule":839,"./stringify":841,"./vendor":844}],835:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _jsBase = require('js-base64');

var _sourceMap = require('source-map');

var _sourceMap2 = _interopRequireDefault(_sourceMap);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Source map information from input CSS.
 * For example, source map after Sass compiler.
 *
 * This class will automatically find source map in input CSS or in file system
 * near input file (according `from` option).
 *
 * @example
 * const root = postcss.parse(css, { from: 'a.sass.css' });
 * root.input.map //=> PreviousMap
 */
var PreviousMap = function () {

    /**
     * @param {string}         css    - input CSS source
     * @param {processOptions} [opts] - {@link Processor#process} options
     */
    function PreviousMap(css, opts) {
        _classCallCheck(this, PreviousMap);

        this.loadAnnotation(css);
        /**
         * @member {boolean} - Was source map inlined by data-uri to input CSS.
         */
        this.inline = this.startWith(this.annotation, 'data:');

        var prev = opts.map ? opts.map.prev : undefined;
        var text = this.loadMap(opts.from, prev);
        if (text) this.text = text;
    }

    /**
     * Create a instance of `SourceMapGenerator` class
     * from the `source-map` library to work with source map information.
     *
     * It is lazy method, so it will create object only on first call
     * and then it will use cache.
     *
     * @return {SourceMapGenerator} object with source map information
     */


    PreviousMap.prototype.consumer = function consumer() {
        if (!this.consumerCache) {
            this.consumerCache = new _sourceMap2.default.SourceMapConsumer(this.text);
        }
        return this.consumerCache;
    };

    /**
     * Does source map contains `sourcesContent` with input source text.
     *
     * @return {boolean} Is `sourcesContent` present
     */


    PreviousMap.prototype.withContent = function withContent() {
        return !!(this.consumer().sourcesContent && this.consumer().sourcesContent.length > 0);
    };

    PreviousMap.prototype.startWith = function startWith(string, start) {
        if (!string) return false;
        return string.substr(0, start.length) === start;
    };

    PreviousMap.prototype.loadAnnotation = function loadAnnotation(css) {
        var match = css.match(/\/\*\s*# sourceMappingURL=(.*)\s*\*\//);
        if (match) this.annotation = match[1].trim();
    };

    PreviousMap.prototype.decodeInline = function decodeInline(text) {
        var utfd64 = 'data:application/json;charset=utf-8;base64,';
        var utf64 = 'data:application/json;charset=utf8;base64,';
        var b64 = 'data:application/json;base64,';
        var uri = 'data:application/json,';

        if (this.startWith(text, uri)) {
            return decodeURIComponent(text.substr(uri.length));
        } else if (this.startWith(text, b64)) {
            return _jsBase.Base64.decode(text.substr(b64.length));
        } else if (this.startWith(text, utf64)) {
            return _jsBase.Base64.decode(text.substr(utf64.length));
        } else if (this.startWith(text, utfd64)) {
            return _jsBase.Base64.decode(text.substr(utfd64.length));
        } else {
            var encoding = text.match(/data:application\/json;([^,]+),/)[1];
            throw new Error('Unsupported source map encoding ' + encoding);
        }
    };

    PreviousMap.prototype.loadMap = function loadMap(file, prev) {
        if (prev === false) return false;

        if (prev) {
            if (typeof prev === 'string') {
                return prev;
            } else if (typeof prev === 'function') {
                var prevPath = prev(file);
                if (prevPath && _fs2.default.existsSync && _fs2.default.existsSync(prevPath)) {
                    return _fs2.default.readFileSync(prevPath, 'utf-8').toString().trim();
                } else {
                    throw new Error('Unable to load previous source map: ' + prevPath.toString());
                }
            } else if (prev instanceof _sourceMap2.default.SourceMapConsumer) {
                return _sourceMap2.default.SourceMapGenerator.fromSourceMap(prev).toString();
            } else if (prev instanceof _sourceMap2.default.SourceMapGenerator) {
                return prev.toString();
            } else if (this.isMap(prev)) {
                return JSON.stringify(prev);
            } else {
                throw new Error('Unsupported previous source map format: ' + prev.toString());
            }
        } else if (this.inline) {
            return this.decodeInline(this.annotation);
        } else if (this.annotation) {
            var map = this.annotation;
            if (file) map = _path2.default.join(_path2.default.dirname(file), map);

            this.root = _path2.default.dirname(map);
            if (_fs2.default.existsSync && _fs2.default.existsSync(map)) {
                return _fs2.default.readFileSync(map, 'utf-8').toString().trim();
            } else {
                return false;
            }
        }
    };

    PreviousMap.prototype.isMap = function isMap(map) {
        if ((typeof map === 'undefined' ? 'undefined' : _typeof(map)) !== 'object') return false;
        return typeof map.mappings === 'string' || typeof map._mappings === 'string';
    };

    return PreviousMap;
}();

exports.default = PreviousMap;
module.exports = exports['default'];


},{"fs":7,"js-base64":752,"path":802,"source-map":1132}],836:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _lazyResult = require('./lazy-result');

var _lazyResult2 = _interopRequireDefault(_lazyResult);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Contains plugins to process CSS. Create one `Processor` instance,
 * initialize its plugins, and then use that instance on numerous CSS files.
 *
 * @example
 * const processor = postcss([autoprefixer, precss]);
 * processor.process(css1).then(result => console.log(result.css));
 * processor.process(css2).then(result => console.log(result.css));
 */
var Processor = function () {

  /**
   * @param {Array.<Plugin|pluginFunction>|Processor} plugins - PostCSS
   *        plugins. See {@link Processor#use} for plugin format.
   */
  function Processor() {
    var plugins = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

    _classCallCheck(this, Processor);

    /**
     * @member {string} - Current PostCSS version.
     *
     * @example
     * if ( result.processor.version.split('.')[0] !== '5' ) {
     *   throw new Error('This plugin works only with PostCSS 5');
     * }
     */
    this.version = '5.2.18';
    /**
     * @member {pluginFunction[]} - Plugins added to this processor.
     *
     * @example
     * const processor = postcss([autoprefixer, precss]);
     * processor.plugins.length //=> 2
     */
    this.plugins = this.normalize(plugins);
  }

  /**
   * Adds a plugin to be used as a CSS processor.
   *
   * PostCSS plugin can be in 4 formats:
   * * A plugin created by {@link postcss.plugin} method.
   * * A function. PostCSS will pass the function a @{link Root}
   *   as the first argument and current {@link Result} instance
   *   as the second.
   * * An object with a `postcss` method. PostCSS will use that method
   *   as described in #2.
   * * Another {@link Processor} instance. PostCSS will copy plugins
   *   from that instance into this one.
   *
   * Plugins can also be added by passing them as arguments when creating
   * a `postcss` instance (see [`postcss(plugins)`]).
   *
   * Asynchronous plugins should return a `Promise` instance.
   *
   * @param {Plugin|pluginFunction|Processor} plugin - PostCSS plugin
   *                                                   or {@link Processor}
   *                                                   with plugins
   *
   * @example
   * const processor = postcss()
   *   .use(autoprefixer)
   *   .use(precss);
   *
   * @return {Processes} current processor to make methods chain
   */


  Processor.prototype.use = function use(plugin) {
    this.plugins = this.plugins.concat(this.normalize([plugin]));
    return this;
  };

  /**
   * Parses source CSS and returns a {@link LazyResult} Promise proxy.
   * Because some plugins can be asynchronous it doesnt make
   * any transformations. Transformations will be applied
   * in the {@link LazyResult} methods.
   *
   * @param {string|toString|Result} css - String with input CSS or
   *                                       any object with a `toString()`
   *                                       method, like a Buffer.
   *                                       Optionally, send a {@link Result}
   *                                       instance and the processor will
   *                                       take the {@link Root} from it.
   * @param {processOptions} [opts]      - options
   *
   * @return {LazyResult} Promise proxy
   *
   * @example
   * processor.process(css, { from: 'a.css', to: 'a.out.css' })
   *   .then(result => {
   *      console.log(result.css);
   *   });
   */


  Processor.prototype.process = function process(css) {
    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    return new _lazyResult2.default(this, css, opts);
  };

  Processor.prototype.normalize = function normalize(plugins) {
    var normalized = [];
    for (var _iterator = plugins, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var i = _ref;

      if (i.postcss) i = i.postcss;

      if ((typeof i === 'undefined' ? 'undefined' : _typeof(i)) === 'object' && Array.isArray(i.plugins)) {
        normalized = normalized.concat(i.plugins);
      } else if (typeof i === 'function') {
        normalized.push(i);
      } else if ((typeof i === 'undefined' ? 'undefined' : _typeof(i)) === 'object' && (i.parse || i.stringify)) {
        throw new Error('PostCSS syntaxes cannot be used as plugins. ' + 'Instead, please use one of the ' + 'syntax/parser/stringifier options as ' + 'outlined in your PostCSS ' + 'runner documentation.');
      } else {
        throw new Error(i + ' is not a PostCSS plugin');
      }
    }
    return normalized;
  };

  return Processor;
}();

exports.default = Processor;

/**
 * @callback builder
 * @param {string} part          - part of generated CSS connected to this node
 * @param {Node}   node          - AST node
 * @param {"start"|"end"} [type] - nodes part type
 */

/**
 * @callback parser
 *
 * @param {string|toString} css   - string with input CSS or any object
 *                                  with toString() method, like a Buffer
 * @param {processOptions} [opts] - options with only `from` and `map` keys
 *
 * @return {Root} PostCSS AST
 */

/**
 * @callback stringifier
 *
 * @param {Node} node       - start node for stringifing. Usually {@link Root}.
 * @param {builder} builder - function to concatenate CSS from nodes parts
 *                            or generate string and source map
 *
 * @return {void}
 */

/**
 * @typedef {object} syntax
 * @property {parser} parse          - function to generate AST by string
 * @property {stringifier} stringify - function to generate string by AST
 */

/**
 * @typedef {object} toString
 * @property {function} toString
 */

/**
 * @callback pluginFunction
 * @param {Root} root     - parsed input CSS
 * @param {Result} result - result to set warnings or check other plugins
 */

/**
 * @typedef {object} Plugin
 * @property {function} postcss - PostCSS plugin function
 */

/**
 * @typedef {object} processOptions
 * @property {string} from             - the path of the CSS source file.
 *                                       You should always set `from`,
 *                                       because it is used in source map
 *                                       generation and syntax error messages.
 * @property {string} to               - the path where youll put the output
 *                                       CSS file. You should always set `to`
 *                                       to generate correct source maps.
 * @property {parser} parser           - function to generate AST by string
 * @property {stringifier} stringifier - class to generate string by AST
 * @property {syntax} syntax           - object with `parse` and `stringify`
 * @property {object} map              - source map options
 * @property {boolean} map.inline                    - does source map should
 *                                                     be embedded in the output
 *                                                     CSS as a base64-encoded
 *                                                     comment
 * @property {string|object|false|function} map.prev - source map content
 *                                                     from a previous
 *                                                     processing step
 *                                                     (for example, Sass).
 *                                                     PostCSS will try to find
 *                                                     previous map
 *                                                     automatically, so you
 *                                                     could disable it by
 *                                                     `false` value.
 * @property {boolean} map.sourcesContent            - does PostCSS should set
 *                                                     the origin content to map
 * @property {string|false} map.annotation           - does PostCSS should set
 *                                                     annotation comment to map
 * @property {string} map.from                       - override `from` in maps
 *                                                     `sources`
 */

module.exports = exports['default'];


},{"./lazy-result":828}],837:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _warning = require('./warning');

var _warning2 = _interopRequireDefault(_warning);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Provides the result of the PostCSS transformations.
 *
 * A Result instance is returned by {@link LazyResult#then}
 * or {@link Root#toResult} methods.
 *
 * @example
 * postcss([cssnext]).process(css).then(function (result) {
 *    console.log(result.css);
 * });
 *
 * @example
 * var result2 = postcss.parse(css).toResult();
 */
var Result = function () {

  /**
   * @param {Processor} processor - processor used for this transformation.
   * @param {Root}      root      - Root node after all transformations.
   * @param {processOptions} opts - options from the {@link Processor#process}
   *                                or {@link Root#toResult}
   */
  function Result(processor, root, opts) {
    _classCallCheck(this, Result);

    /**
     * @member {Processor} - The Processor instance used
     *                       for this transformation.
     *
     * @example
     * for ( let plugin of result.processor.plugins) {
     *   if ( plugin.postcssPlugin === 'postcss-bad' ) {
     *     throw 'postcss-good is incompatible with postcss-bad';
     *   }
     * });
     */
    this.processor = processor;
    /**
     * @member {Message[]} - Contains messages from plugins
     *                       (e.g., warnings or custom messages).
     *                       Each message should have type
     *                       and plugin properties.
     *
     * @example
     * postcss.plugin('postcss-min-browser', () => {
     *   return (root, result) => {
     *     var browsers = detectMinBrowsersByCanIUse(root);
     *     result.messages.push({
     *       type:    'min-browser',
     *       plugin:  'postcss-min-browser',
     *       browsers: browsers
     *     });
     *   };
     * });
     */
    this.messages = [];
    /**
     * @member {Root} - Root node after all transformations.
     *
     * @example
     * root.toResult().root == root;
     */
    this.root = root;
    /**
     * @member {processOptions} - Options from the {@link Processor#process}
     *                            or {@link Root#toResult} call
     *                            that produced this Result instance.
     *
     * @example
     * root.toResult(opts).opts == opts;
     */
    this.opts = opts;
    /**
     * @member {string} - A CSS string representing of {@link Result#root}.
     *
     * @example
     * postcss.parse('a{}').toResult().css //=> "a{}"
     */
    this.css = undefined;
    /**
     * @member {SourceMapGenerator} - An instance of `SourceMapGenerator`
     *                                class from the `source-map` library,
     *                                representing changes
     *                                to the {@link Result#root} instance.
     *
     * @example
     * result.map.toJSON() //=> { version: 3, file: 'a.css',  }
     *
     * @example
     * if ( result.map ) {
     *   fs.writeFileSync(result.opts.to + '.map', result.map.toString());
     * }
     */
    this.map = undefined;
  }

  /**
   * Returns for @{link Result#css} content.
   *
   * @example
   * result + '' === result.css
   *
   * @return {string} string representing of {@link Result#root}
   */


  Result.prototype.toString = function toString() {
    return this.css;
  };

  /**
   * Creates an instance of {@link Warning} and adds it
   * to {@link Result#messages}.
   *
   * @param {string} text        - warning message
   * @param {Object} [opts]      - warning options
   * @param {Node}   opts.node   - CSS node that caused the warning
   * @param {string} opts.word   - word in CSS source that caused the warning
   * @param {number} opts.index  - index in CSS node string that caused
   *                               the warning
   * @param {string} opts.plugin - name of the plugin that created
   *                               this warning. {@link Result#warn} fills
   *                               this property automatically.
   *
   * @return {Warning} created warning
   */


  Result.prototype.warn = function warn(text) {
    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (!opts.plugin) {
      if (this.lastPlugin && this.lastPlugin.postcssPlugin) {
        opts.plugin = this.lastPlugin.postcssPlugin;
      }
    }

    var warning = new _warning2.default(text, opts);
    this.messages.push(warning);

    return warning;
  };

  /**
   * Returns warnings from plugins. Filters {@link Warning} instances
   * from {@link Result#messages}.
   *
   * @example
   * result.warnings().forEach(warn => {
   *   console.warn(warn.toString());
   * });
   *
   * @return {Warning[]} warnings from plugins
   */


  Result.prototype.warnings = function warnings() {
    return this.messages.filter(function (i) {
      return i.type === 'warning';
    });
  };

  /**
   * An alias for the {@link Result#css} property.
   * Use it with syntaxes that generate non-CSS output.
   * @type {string}
   *
   * @example
   * result.css === result.content;
   */


  _createClass(Result, [{
    key: 'content',
    get: function get() {
      return this.css;
    }
  }]);

  return Result;
}();

exports.default = Result;

/**
 * @typedef  {object} Message
 * @property {string} type   - message type
 * @property {string} plugin - source PostCSS plugin name
 */

module.exports = exports['default'];


},{"./warning":846}],838:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _container = require('./container');

var _container2 = _interopRequireDefault(_container);

var _warnOnce = require('./warn-once');

var _warnOnce2 = _interopRequireDefault(_warnOnce);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Represents a CSS file and contains all its parsed nodes.
 *
 * @extends Container
 *
 * @example
 * const root = postcss.parse('a{color:black} b{z-index:2}');
 * root.type         //=> 'root'
 * root.nodes.length //=> 2
 */
var Root = function (_Container) {
    _inherits(Root, _Container);

    function Root(defaults) {
        _classCallCheck(this, Root);

        var _this = _possibleConstructorReturn(this, _Container.call(this, defaults));

        _this.type = 'root';
        if (!_this.nodes) _this.nodes = [];
        return _this;
    }

    Root.prototype.removeChild = function removeChild(child) {
        child = this.index(child);

        if (child === 0 && this.nodes.length > 1) {
            this.nodes[1].raws.before = this.nodes[child].raws.before;
        }

        return _Container.prototype.removeChild.call(this, child);
    };

    Root.prototype.normalize = function normalize(child, sample, type) {
        var nodes = _Container.prototype.normalize.call(this, child);

        if (sample) {
            if (type === 'prepend') {
                if (this.nodes.length > 1) {
                    sample.raws.before = this.nodes[1].raws.before;
                } else {
                    delete sample.raws.before;
                }
            } else if (this.first !== sample) {
                for (var _iterator = nodes, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
                    var _ref;

                    if (_isArray) {
                        if (_i >= _iterator.length) break;
                        _ref = _iterator[_i++];
                    } else {
                        _i = _iterator.next();
                        if (_i.done) break;
                        _ref = _i.value;
                    }

                    var node = _ref;

                    node.raws.before = sample.raws.before;
                }
            }
        }

        return nodes;
    };

    /**
     * Returns a {@link Result} instance representing the roots CSS.
     *
     * @param {processOptions} [opts] - options with only `to` and `map` keys
     *
     * @return {Result} result with current roots CSS
     *
     * @example
     * const root1 = postcss.parse(css1, { from: 'a.css' });
     * const root2 = postcss.parse(css2, { from: 'b.css' });
     * root1.append(root2);
     * const result = root1.toResult({ to: 'all.css', map: true });
     */


    Root.prototype.toResult = function toResult() {
        var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        var LazyResult = require('./lazy-result');
        var Processor = require('./processor');

        var lazy = new LazyResult(new Processor(), this, opts);
        return lazy.stringify();
    };

    Root.prototype.remove = function remove(child) {
        (0, _warnOnce2.default)('Root#remove is deprecated. Use Root#removeChild');
        this.removeChild(child);
    };

    Root.prototype.prevMap = function prevMap() {
        (0, _warnOnce2.default)('Root#prevMap is deprecated. Use Root#source.input.map');
        return this.source.input.map;
    };

    /**
     * @memberof Root#
     * @member {object} raws - Information to generate byte-to-byte equal
     *                         node string as it was in the origin input.
     *
     * Every parser saves its own properties,
     * but the default CSS parser uses:
     *
     * * `after`: the space symbols after the last child to the end of file.
     * * `semicolon`: is the last child has an (optional) semicolon.
     *
     * @example
     * postcss.parse('a {}\n').raws //=> { after: '\n' }
     * postcss.parse('a {}').raws   //=> { after: '' }
     */

    return Root;
}(_container2.default);

exports.default = Root;
module.exports = exports['default'];


},{"./container":824,"./lazy-result":828,"./processor":836,"./warn-once":845}],839:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _container = require('./container');

var _container2 = _interopRequireDefault(_container);

var _warnOnce = require('./warn-once');

var _warnOnce2 = _interopRequireDefault(_warnOnce);

var _list = require('./list');

var _list2 = _interopRequireDefault(_list);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Represents a CSS rule: a selector followed by a declaration block.
 *
 * @extends Container
 *
 * @example
 * const root = postcss.parse('a{}');
 * const rule = root.first;
 * rule.type       //=> 'rule'
 * rule.toString() //=> 'a{}'
 */
var Rule = function (_Container) {
    _inherits(Rule, _Container);

    function Rule(defaults) {
        _classCallCheck(this, Rule);

        var _this = _possibleConstructorReturn(this, _Container.call(this, defaults));

        _this.type = 'rule';
        if (!_this.nodes) _this.nodes = [];
        return _this;
    }

    /**
     * An array containing the rules individual selectors.
     * Groups of selectors are split at commas.
     *
     * @type {string[]}
     *
     * @example
     * const root = postcss.parse('a, b { }');
     * const rule = root.first;
     *
     * rule.selector  //=> 'a, b'
     * rule.selectors //=> ['a', 'b']
     *
     * rule.selectors = ['a', 'strong'];
     * rule.selector //=> 'a, strong'
     */


    _createClass(Rule, [{
        key: 'selectors',
        get: function get() {
            return _list2.default.comma(this.selector);
        },
        set: function set(values) {
            var match = this.selector ? this.selector.match(/,\s*/) : null;
            var sep = match ? match[0] : ',' + this.raw('between', 'beforeOpen');
            this.selector = values.join(sep);
        }
    }, {
        key: '_selector',
        get: function get() {
            (0, _warnOnce2.default)('Rule#_selector is deprecated. Use Rule#raws.selector');
            return this.raws.selector;
        },
        set: function set(val) {
            (0, _warnOnce2.default)('Rule#_selector is deprecated. Use Rule#raws.selector');
            this.raws.selector = val;
        }

        /**
         * @memberof Rule#
         * @member {string} selector - the rules full selector represented
         *                             as a string
         *
         * @example
         * const root = postcss.parse('a, b { }');
         * const rule = root.first;
         * rule.selector //=> 'a, b'
         */

        /**
         * @memberof Rule#
         * @member {object} raws - Information to generate byte-to-byte equal
         *                         node string as it was in the origin input.
         *
         * Every parser saves its own properties,
         * but the default CSS parser uses:
         *
         * * `before`: the space symbols before the node. It also stores `*`
         *   and `_` symbols before the declaration (IE hack).
         * * `after`: the space symbols after the last child of the node
         *   to the end of the node.
         * * `between`: the symbols between the property and value
         *   for declarations, selector and `{` for rules, or last parameter
         *   and `{` for at-rules.
         * * `semicolon`: contains true if the last child has
         *   an (optional) semicolon.
         *
         * PostCSS cleans selectors from comments and extra spaces,
         * but it stores origin content in raws properties.
         * As such, if you dont change a declarations value,
         * PostCSS will use the raw value with comments.
         *
         * @example
         * const root = postcss.parse('a {\n  color:black\n}')
         * root.first.first.raws //=> { before: '', between: ' ', after: '\n' }
         */

    }]);

    return Rule;
}(_container2.default);

exports.default = Rule;
module.exports = exports['default'];


},{"./container":824,"./list":829,"./warn-once":845}],840:[function(require,module,exports){
'use strict';

exports.__esModule = true;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var defaultRaw = {
    colon: ': ',
    indent: '    ',
    beforeDecl: '\n',
    beforeRule: '\n',
    beforeOpen: ' ',
    beforeClose: '\n',
    beforeComment: '\n',
    after: '\n',
    emptyBody: '',
    commentLeft: ' ',
    commentRight: ' '
};

function capitalize(str) {
    return str[0].toUpperCase() + str.slice(1);
}

var Stringifier = function () {
    function Stringifier(builder) {
        _classCallCheck(this, Stringifier);

        this.builder = builder;
    }

    Stringifier.prototype.stringify = function stringify(node, semicolon) {
        this[node.type](node, semicolon);
    };

    Stringifier.prototype.root = function root(node) {
        this.body(node);
        if (node.raws.after) this.builder(node.raws.after);
    };

    Stringifier.prototype.comment = function comment(node) {
        var left = this.raw(node, 'left', 'commentLeft');
        var right = this.raw(node, 'right', 'commentRight');
        this.builder('/*' + left + node.text + right + '*/', node);
    };

    Stringifier.prototype.decl = function decl(node, semicolon) {
        var between = this.raw(node, 'between', 'colon');
        var string = node.prop + between + this.rawValue(node, 'value');

        if (node.important) {
            string += node.raws.important || ' !important';
        }

        if (semicolon) string += ';';
        this.builder(string, node);
    };

    Stringifier.prototype.rule = function rule(node) {
        this.block(node, this.rawValue(node, 'selector'));
    };

    Stringifier.prototype.atrule = function atrule(node, semicolon) {
        var name = '@' + node.name;
        var params = node.params ? this.rawValue(node, 'params') : '';

        if (typeof node.raws.afterName !== 'undefined') {
            name += node.raws.afterName;
        } else if (params) {
            name += ' ';
        }

        if (node.nodes) {
            this.block(node, name + params);
        } else {
            var end = (node.raws.between || '') + (semicolon ? ';' : '');
            this.builder(name + params + end, node);
        }
    };

    Stringifier.prototype.body = function body(node) {
        var last = node.nodes.length - 1;
        while (last > 0) {
            if (node.nodes[last].type !== 'comment') break;
            last -= 1;
        }

        var semicolon = this.raw(node, 'semicolon');
        for (var i = 0; i < node.nodes.length; i++) {
            var child = node.nodes[i];
            var before = this.raw(child, 'before');
            if (before) this.builder(before);
            this.stringify(child, last !== i || semicolon);
        }
    };

    Stringifier.prototype.block = function block(node, start) {
        var between = this.raw(node, 'between', 'beforeOpen');
        this.builder(start + between + '{', node, 'start');

        var after = void 0;
        if (node.nodes && node.nodes.length) {
            this.body(node);
            after = this.raw(node, 'after');
        } else {
            after = this.raw(node, 'after', 'emptyBody');
        }

        if (after) this.builder(after);
        this.builder('}', node, 'end');
    };

    Stringifier.prototype.raw = function raw(node, own, detect) {
        var value = void 0;
        if (!detect) detect = own;

        // Already had
        if (own) {
            value = node.raws[own];
            if (typeof value !== 'undefined') return value;
        }

        var parent = node.parent;

        // Hack for first rule in CSS
        if (detect === 'before') {
            if (!parent || parent.type === 'root' && parent.first === node) {
                return '';
            }
        }

        // Floating child without parent
        if (!parent) return defaultRaw[detect];

        // Detect style by other nodes
        var root = node.root();
        if (!root.rawCache) root.rawCache = {};
        if (typeof root.rawCache[detect] !== 'undefined') {
            return root.rawCache[detect];
        }

        if (detect === 'before' || detect === 'after') {
            return this.beforeAfter(node, detect);
        } else {
            var method = 'raw' + capitalize(detect);
            if (this[method]) {
                value = this[method](root, node);
            } else {
                root.walk(function (i) {
                    value = i.raws[own];
                    if (typeof value !== 'undefined') return false;
                });
            }
        }

        if (typeof value === 'undefined') value = defaultRaw[detect];

        root.rawCache[detect] = value;
        return value;
    };

    Stringifier.prototype.rawSemicolon = function rawSemicolon(root) {
        var value = void 0;
        root.walk(function (i) {
            if (i.nodes && i.nodes.length && i.last.type === 'decl') {
                value = i.raws.semicolon;
                if (typeof value !== 'undefined') return false;
            }
        });
        return value;
    };

    Stringifier.prototype.rawEmptyBody = function rawEmptyBody(root) {
        var value = void 0;
        root.walk(function (i) {
            if (i.nodes && i.nodes.length === 0) {
                value = i.raws.after;
                if (typeof value !== 'undefined') return false;
            }
        });
        return value;
    };

    Stringifier.prototype.rawIndent = function rawIndent(root) {
        if (root.raws.indent) return root.raws.indent;
        var value = void 0;
        root.walk(function (i) {
            var p = i.parent;
            if (p && p !== root && p.parent && p.parent === root) {
                if (typeof i.raws.before !== 'undefined') {
                    var parts = i.raws.before.split('\n');
                    value = parts[parts.length - 1];
                    value = value.replace(/[^\s]/g, '');
                    return false;
                }
            }
        });
        return value;
    };

    Stringifier.prototype.rawBeforeComment = function rawBeforeComment(root, node) {
        var value = void 0;
        root.walkComments(function (i) {
            if (typeof i.raws.before !== 'undefined') {
                value = i.raws.before;
                if (value.indexOf('\n') !== -1) {
                    value = value.replace(/[^\n]+$/, '');
                }
                return false;
            }
        });
        if (typeof value === 'undefined') {
            value = this.raw(node, null, 'beforeDecl');
        }
        return value;
    };

    Stringifier.prototype.rawBeforeDecl = function rawBeforeDecl(root, node) {
        var value = void 0;
        root.walkDecls(function (i) {
            if (typeof i.raws.before !== 'undefined') {
                value = i.raws.before;
                if (value.indexOf('\n') !== -1) {
                    value = value.replace(/[^\n]+$/, '');
                }
                return false;
            }
        });
        if (typeof value === 'undefined') {
            value = this.raw(node, null, 'beforeRule');
        }
        return value;
    };

    Stringifier.prototype.rawBeforeRule = function rawBeforeRule(root) {
        var value = void 0;
        root.walk(function (i) {
            if (i.nodes && (i.parent !== root || root.first !== i)) {
                if (typeof i.raws.before !== 'undefined') {
                    value = i.raws.before;
                    if (value.indexOf('\n') !== -1) {
                        value = value.replace(/[^\n]+$/, '');
                    }
                    return false;
                }
            }
        });
        return value;
    };

    Stringifier.prototype.rawBeforeClose = function rawBeforeClose(root) {
        var value = void 0;
        root.walk(function (i) {
            if (i.nodes && i.nodes.length > 0) {
                if (typeof i.raws.after !== 'undefined') {
                    value = i.raws.after;
                    if (value.indexOf('\n') !== -1) {
                        value = value.replace(/[^\n]+$/, '');
                    }
                    return false;
                }
            }
        });
        return value;
    };

    Stringifier.prototype.rawBeforeOpen = function rawBeforeOpen(root) {
        var value = void 0;
        root.walk(function (i) {
            if (i.type !== 'decl') {
                value = i.raws.between;
                if (typeof value !== 'undefined') return false;
            }
        });
        return value;
    };

    Stringifier.prototype.rawColon = function rawColon(root) {
        var value = void 0;
        root.walkDecls(function (i) {
            if (typeof i.raws.between !== 'undefined') {
                value = i.raws.between.replace(/[^\s:]/g, '');
                return false;
            }
        });
        return value;
    };

    Stringifier.prototype.beforeAfter = function beforeAfter(node, detect) {
        var value = void 0;
        if (node.type === 'decl') {
            value = this.raw(node, null, 'beforeDecl');
        } else if (node.type === 'comment') {
            value = this.raw(node, null, 'beforeComment');
        } else if (detect === 'before') {
            value = this.raw(node, null, 'beforeRule');
        } else {
            value = this.raw(node, null, 'beforeClose');
        }

        var buf = node.parent;
        var depth = 0;
        while (buf && buf.type !== 'root') {
            depth += 1;
            buf = buf.parent;
        }

        if (value.indexOf('\n') !== -1) {
            var indent = this.raw(node, null, 'indent');
            if (indent.length) {
                for (var step = 0; step < depth; step++) {
                    value += indent;
                }
            }
        }

        return value;
    };

    Stringifier.prototype.rawValue = function rawValue(node, prop) {
        var value = node[prop];
        var raw = node.raws[prop];
        if (raw && raw.value === value) {
            return raw.raw;
        } else {
            return value;
        }
    };

    return Stringifier;
}();

exports.default = Stringifier;
module.exports = exports['default'];


},{}],841:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.default = stringify;

var _stringifier = require('./stringifier');

var _stringifier2 = _interopRequireDefault(_stringifier);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function stringify(node, builder) {
    var str = new _stringifier2.default(builder);
    str.stringify(node);
}
module.exports = exports['default'];


},{"./stringifier":840}],842:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _chalk = require('chalk');

var _chalk2 = _interopRequireDefault(_chalk);

var _tokenize = require('./tokenize');

var _tokenize2 = _interopRequireDefault(_tokenize);

var _input = require('./input');

var _input2 = _interopRequireDefault(_input);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var colors = new _chalk2.default.constructor({ enabled: true });

var HIGHLIGHT_THEME = {
    'brackets': colors.cyan,
    'at-word': colors.cyan,
    'call': colors.cyan,
    'comment': colors.gray,
    'string': colors.green,
    'class': colors.yellow,
    'hash': colors.magenta,
    '(': colors.cyan,
    ')': colors.cyan,
    '{': colors.yellow,
    '}': colors.yellow,
    '[': colors.yellow,
    ']': colors.yellow,
    ':': colors.yellow,
    ';': colors.yellow
};

function getTokenType(_ref, index, tokens) {
    var type = _ref[0],
        value = _ref[1];

    if (type === 'word') {
        if (value[0] === '.') {
            return 'class';
        }
        if (value[0] === '#') {
            return 'hash';
        }
    }

    var nextToken = tokens[index + 1];
    if (nextToken && (nextToken[0] === 'brackets' || nextToken[0] === '(')) {
        return 'call';
    }

    return type;
}

function terminalHighlight(css) {
    var tokens = (0, _tokenize2.default)(new _input2.default(css), { ignoreErrors: true });
    return tokens.map(function (token, index) {
        var color = HIGHLIGHT_THEME[getTokenType(token, index, tokens)];
        if (color) {
            return token[1].split(/\r?\n/).map(function (i) {
                return color(i);
            }).join('\n');
        } else {
            return token[1];
        }
    }).join('');
}

exports.default = terminalHighlight;
module.exports = exports['default'];


},{"./input":827,"./tokenize":843,"chalk":820}],843:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.default = tokenize;
var SINGLE_QUOTE = 39;
var DOUBLE_QUOTE = 34;
var BACKSLASH = 92;
var SLASH = 47;
var NEWLINE = 10;
var SPACE = 32;
var FEED = 12;
var TAB = 9;
var CR = 13;
var OPEN_SQUARE = 91;
var CLOSE_SQUARE = 93;
var OPEN_PARENTHESES = 40;
var CLOSE_PARENTHESES = 41;
var OPEN_CURLY = 123;
var CLOSE_CURLY = 125;
var SEMICOLON = 59;
var ASTERISK = 42;
var COLON = 58;
var AT = 64;

var RE_AT_END = /[ \n\t\r\f\{\(\)'"\\;/\[\]#]/g;
var RE_WORD_END = /[ \n\t\r\f\(\)\{\}:;@!'"\\\]\[#]|\/(?=\*)/g;
var RE_BAD_BRACKET = /.[\\\/\("'\n]/;

function tokenize(input) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    var tokens = [];
    var css = input.css.valueOf();

    var ignore = options.ignoreErrors;

    var code = void 0,
        next = void 0,
        quote = void 0,
        lines = void 0,
        last = void 0,
        content = void 0,
        escape = void 0,
        nextLine = void 0,
        nextOffset = void 0,
        escaped = void 0,
        escapePos = void 0,
        prev = void 0,
        n = void 0;

    var length = css.length;
    var offset = -1;
    var line = 1;
    var pos = 0;

    function unclosed(what) {
        throw input.error('Unclosed ' + what, line, pos - offset);
    }

    while (pos < length) {
        code = css.charCodeAt(pos);

        if (code === NEWLINE || code === FEED || code === CR && css.charCodeAt(pos + 1) !== NEWLINE) {
            offset = pos;
            line += 1;
        }

        switch (code) {
            case NEWLINE:
            case SPACE:
            case TAB:
            case CR:
            case FEED:
                next = pos;
                do {
                    next += 1;
                    code = css.charCodeAt(next);
                    if (code === NEWLINE) {
                        offset = next;
                        line += 1;
                    }
                } while (code === SPACE || code === NEWLINE || code === TAB || code === CR || code === FEED);

                tokens.push(['space', css.slice(pos, next)]);
                pos = next - 1;
                break;

            case OPEN_SQUARE:
                tokens.push(['[', '[', line, pos - offset]);
                break;

            case CLOSE_SQUARE:
                tokens.push([']', ']', line, pos - offset]);
                break;

            case OPEN_CURLY:
                tokens.push(['{', '{', line, pos - offset]);
                break;

            case CLOSE_CURLY:
                tokens.push(['}', '}', line, pos - offset]);
                break;

            case COLON:
                tokens.push([':', ':', line, pos - offset]);
                break;

            case SEMICOLON:
                tokens.push([';', ';', line, pos - offset]);
                break;

            case OPEN_PARENTHESES:
                prev = tokens.length ? tokens[tokens.length - 1][1] : '';
                n = css.charCodeAt(pos + 1);
                if (prev === 'url' && n !== SINGLE_QUOTE && n !== DOUBLE_QUOTE && n !== SPACE && n !== NEWLINE && n !== TAB && n !== FEED && n !== CR) {
                    next = pos;
                    do {
                        escaped = false;
                        next = css.indexOf(')', next + 1);
                        if (next === -1) {
                            if (ignore) {
                                next = pos;
                                break;
                            } else {
                                unclosed('bracket');
                            }
                        }
                        escapePos = next;
                        while (css.charCodeAt(escapePos - 1) === BACKSLASH) {
                            escapePos -= 1;
                            escaped = !escaped;
                        }
                    } while (escaped);

                    tokens.push(['brackets', css.slice(pos, next + 1), line, pos - offset, line, next - offset]);
                    pos = next;
                } else {
                    next = css.indexOf(')', pos + 1);
                    content = css.slice(pos, next + 1);

                    if (next === -1 || RE_BAD_BRACKET.test(content)) {
                        tokens.push(['(', '(', line, pos - offset]);
                    } else {
                        tokens.push(['brackets', content, line, pos - offset, line, next - offset]);
                        pos = next;
                    }
                }

                break;

            case CLOSE_PARENTHESES:
                tokens.push([')', ')', line, pos - offset]);
                break;

            case SINGLE_QUOTE:
            case DOUBLE_QUOTE:
                quote = code === SINGLE_QUOTE ? '\'' : '"';
                next = pos;
                do {
                    escaped = false;
                    next = css.indexOf(quote, next + 1);
                    if (next === -1) {
                        if (ignore) {
                            next = pos + 1;
                            break;
                        } else {
                            unclosed('string');
                        }
                    }
                    escapePos = next;
                    while (css.charCodeAt(escapePos - 1) === BACKSLASH) {
                        escapePos -= 1;
                        escaped = !escaped;
                    }
                } while (escaped);

                content = css.slice(pos, next + 1);
                lines = content.split('\n');
                last = lines.length - 1;

                if (last > 0) {
                    nextLine = line + last;
                    nextOffset = next - lines[last].length;
                } else {
                    nextLine = line;
                    nextOffset = offset;
                }

                tokens.push(['string', css.slice(pos, next + 1), line, pos - offset, nextLine, next - nextOffset]);

                offset = nextOffset;
                line = nextLine;
                pos = next;
                break;

            case AT:
                RE_AT_END.lastIndex = pos + 1;
                RE_AT_END.test(css);
                if (RE_AT_END.lastIndex === 0) {
                    next = css.length - 1;
                } else {
                    next = RE_AT_END.lastIndex - 2;
                }
                tokens.push(['at-word', css.slice(pos, next + 1), line, pos - offset, line, next - offset]);
                pos = next;
                break;

            case BACKSLASH:
                next = pos;
                escape = true;
                while (css.charCodeAt(next + 1) === BACKSLASH) {
                    next += 1;
                    escape = !escape;
                }
                code = css.charCodeAt(next + 1);
                if (escape && code !== SLASH && code !== SPACE && code !== NEWLINE && code !== TAB && code !== CR && code !== FEED) {
                    next += 1;
                }
                tokens.push(['word', css.slice(pos, next + 1), line, pos - offset, line, next - offset]);
                pos = next;
                break;

            default:
                if (code === SLASH && css.charCodeAt(pos + 1) === ASTERISK) {
                    next = css.indexOf('*/', pos + 2) + 1;
                    if (next === 0) {
                        if (ignore) {
                            next = css.length;
                        } else {
                            unclosed('comment');
                        }
                    }

                    content = css.slice(pos, next + 1);
                    lines = content.split('\n');
                    last = lines.length - 1;

                    if (last > 0) {
                        nextLine = line + last;
                        nextOffset = next - lines[last].length;
                    } else {
                        nextLine = line;
                        nextOffset = offset;
                    }

                    tokens.push(['comment', content, line, pos - offset, nextLine, next - nextOffset]);

                    offset = nextOffset;
                    line = nextLine;
                    pos = next;
                } else {
                    RE_WORD_END.lastIndex = pos + 1;
                    RE_WORD_END.test(css);
                    if (RE_WORD_END.lastIndex === 0) {
                        next = css.length - 1;
                    } else {
                        next = RE_WORD_END.lastIndex - 2;
                    }

                    tokens.push(['word', css.slice(pos, next + 1), line, pos - offset, line, next - offset]);
                    pos = next;
                }

                break;
        }

        pos++;
    }

    return tokens;
}
module.exports = exports['default'];


},{}],844:[function(require,module,exports){
'use strict';

exports.__esModule = true;
/**
 * Contains helpers for working with vendor prefixes.
 *
 * @example
 * const vendor = postcss.vendor;
 *
 * @namespace vendor
 */
var vendor = {

    /**
     * Returns the vendor prefix extracted from an input string.
     *
     * @param {string} prop - string with or without vendor prefix
     *
     * @return {string} vendor prefix or empty string
     *
     * @example
     * postcss.vendor.prefix('-moz-tab-size') //=> '-moz-'
     * postcss.vendor.prefix('tab-size')      //=> ''
     */
    prefix: function prefix(prop) {
        var match = prop.match(/^(-\w+-)/);
        if (match) {
            return match[0];
        } else {
            return '';
        }
    },


    /**
     * Returns the input string stripped of its vendor prefix.
     *
     * @param {string} prop - string with or without vendor prefix
     *
     * @return {string} string name without vendor prefixes
     *
     * @example
     * postcss.vendor.unprefixed('-moz-tab-size') //=> 'tab-size'
     */
    unprefixed: function unprefixed(prop) {
        return prop.replace(/^-\w+-/, '');
    }
};

exports.default = vendor;
module.exports = exports['default'];


},{}],845:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.default = warnOnce;
var printed = {};

function warnOnce(message) {
    if (printed[message]) return;
    printed[message] = true;

    if (typeof console !== 'undefined' && console.warn) console.warn(message);
}
module.exports = exports['default'];


},{}],846:[function(require,module,exports){
'use strict';

exports.__esModule = true;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Represents a plugins warning. It can be created using {@link Node#warn}.
 *
 * @example
 * if ( decl.important ) {
 *     decl.warn(result, 'Avoid !important', { word: '!important' });
 * }
 */
var Warning = function () {

  /**
   * @param {string} text        - warning message
   * @param {Object} [opts]      - warning options
   * @param {Node}   opts.node   - CSS node that caused the warning
   * @param {string} opts.word   - word in CSS source that caused the warning
   * @param {number} opts.index  - index in CSS node string that caused
   *                               the warning
   * @param {string} opts.plugin - name of the plugin that created
   *                               this warning. {@link Result#warn} fills
   *                               this property automatically.
   */
  function Warning(text) {
    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, Warning);

    /**
     * @member {string} - Type to filter warnings from
     *                    {@link Result#messages}. Always equal
     *                    to `"warning"`.
     *
     * @example
     * const nonWarning = result.messages.filter(i => i.type !== 'warning')
     */
    this.type = 'warning';
    /**
     * @member {string} - The warning message.
     *
     * @example
     * warning.text //=> 'Try to avoid !important'
     */
    this.text = text;

    if (opts.node && opts.node.source) {
      var pos = opts.node.positionBy(opts);
      /**
       * @member {number} - Line in the input file
       *                    with this warnings source
       *
       * @example
       * warning.line //=> 5
       */
      this.line = pos.line;
      /**
       * @member {number} - Column in the input file
       *                    with this warnings source.
       *
       * @example
       * warning.column //=> 6
       */
      this.column = pos.column;
    }

    for (var opt in opts) {
      this[opt] = opts[opt];
    }
  }

  /**
   * Returns a warning position and message.
   *
   * @example
   * warning.toString() //=> 'postcss-lint:a.css:10:14: Avoid !important'
   *
   * @return {string} warning position and message
   */


  Warning.prototype.toString = function toString() {
    if (this.node) {
      return this.node.error(this.text, {
        plugin: this.plugin,
        index: this.index,
        word: this.word
      }).message;
    } else if (this.plugin) {
      return this.plugin + ': ' + this.text;
    } else {
      return this.text;
    }
  };

  /**
   * @memberof Warning#
   * @member {string} plugin - The name of the plugin that created
   *                           it will fill this property automatically.
   *                           this warning. When you call {@link Node#warn}
   *
   * @example
   * warning.plugin //=> 'postcss-important'
   */

  /**
   * @memberof Warning#
   * @member {Node} node - Contains the CSS node that caused the warning.
   *
   * @example
   * warning.node.toString() //=> 'color: white !important'
   */

  return Warning;
}();

exports.default = Warning;
module.exports = exports['default'];


},{}],847:[function(require,module,exports){
'use strict';
var ansiRegex = require('ansi-regex')();

module.exports = function (str) {
	return typeof str === 'string' ? str.replace(ansiRegex, '') : str;
};

},{"ansi-regex":818}],848:[function(require,module,exports){
'use strict';
module.exports = false;

},{}],849:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _postcss = require("postcss");

var _transform = _interopRequireDefault(require("./lib/transform"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _default = (0, _postcss.plugin)('postcss-calc', function (opts) {
  var options = Object.assign({
    precision: 5,
    preserve: false,
    warnWhenCannotResolve: false,
    mediaQueries: false,
    selectors: false
  }, opts);
  return function (css, result) {
    css.walk(function (node) {
      var type = node.type;
      if (type === 'decl') (0, _transform.default)(node, "value", options, result);
      if (type === 'atrule' && options.mediaQueries) (0, _transform.default)(node, "params", options, result);
      if (type === 'rule' && options.selectors) (0, _transform.default)(node, "selector", options, result);
    });
  };
});

exports.default = _default;
module.exports = exports.default;
},{"./lib/transform":853,"postcss":1074}],850:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _cssUnitConverter = _interopRequireDefault(require("css-unit-converter"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function convertNodes(left, right, precision) {
  switch (left.type) {
    case 'LengthValue':
    case 'AngleValue':
    case 'TimeValue':
    case 'FrequencyValue':
    case 'ResolutionValue':
      return convertAbsoluteLength(left, right, precision);

    default:
      return {
        left,
        right
      };
  }
}

function convertAbsoluteLength(left, right, precision) {
  if (right.type === left.type) {
    right = {
      type: left.type,
      value: (0, _cssUnitConverter.default)(right.value, right.unit, left.unit, precision),
      unit: left.unit
    };
  }

  return {
    left,
    right
  };
}

var _default = convertNodes;
exports.default = _default;
module.exports = exports.default;
},{"css-unit-converter":664}],851:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _convert = _interopRequireDefault(require("./convert"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function reduce(node, precision) {
  if (node.type === "MathExpression") return reduceMathExpression(node, precision);
  return node;
}

function isEqual(left, right) {
  return left.type === right.type && left.value === right.value;
}

function isValueType(type) {
  switch (type) {
    case 'LengthValue':
    case 'AngleValue':
    case 'TimeValue':
    case 'FrequencyValue':
    case 'ResolutionValue':
    case 'EmValue':
    case 'ExValue':
    case 'ChValue':
    case 'RemValue':
    case 'VhValue':
    case 'VwValue':
    case 'VminValue':
    case 'VmaxValue':
    case 'PercentageValue':
    case 'Value':
      return true;
  }

  return false;
}

function convertMathExpression(node, precision) {
  var nodes = (0, _convert.default)(node.left, node.right, precision);
  var left = reduce(nodes.left, precision);
  var right = reduce(nodes.right, precision);

  if (left.type === "MathExpression" && right.type === "MathExpression") {
    if (left.operator === '/' && right.operator === '*' || left.operator === '-' && right.operator === '+' || left.operator === '*' && right.operator === '/' || left.operator === '+' && right.operator === '-') {
      if (isEqual(left.right, right.right)) nodes = (0, _convert.default)(left.left, right.left, precision);else if (isEqual(left.right, right.left)) nodes = (0, _convert.default)(left.left, right.right, precision);
      left = reduce(nodes.left, precision);
      right = reduce(nodes.right, precision);
    }
  }

  node.left = left;
  node.right = right;
  return node;
}

function flip(operator) {
  return operator === '+' ? '-' : '+';
}

function flipValue(node) {
  if (isValueType(node.type)) node.value = -node.value;else if (node.type == 'MathExpression') {
    node.left = flipValue(node.left);
    node.right = flipValue(node.right);
  }
  return node;
}

function reduceAddSubExpression(node, precision) {
  var _node = node,
      left = _node.left,
      right = _node.right,
      op = _node.operator;
  if (left.type === 'Function' || right.type === 'Function') return node; // something + 0 => something
  // something - 0 => something

  if (right.value === 0) return left; // 0 + something => something

  if (left.value === 0 && op === "+") return right; // 0 - something => -something

  if (left.value === 0 && op === "-") return flipValue(right); // value + value
  // value - value

  if (left.type === right.type && isValueType(left.type)) {
    node = Object.assign({}, left);
    if (op === "+") node.value = left.value + right.value;else node.value = left.value - right.value;
  } // value <op> (expr)


  if (isValueType(left.type) && (right.operator === '+' || right.operator === '-') && right.type === 'MathExpression') {
    // value + (value + something) => (value + value) + something
    // value + (value - something) => (value + value) - something
    // value - (value + something) => (value - value) - something
    // value - (value - something) => (value - value) + something
    if (left.type === right.left.type) {
      node = Object.assign({}, node);
      node.left = reduce({
        type: 'MathExpression',
        operator: op,
        left: left,
        right: right.left
      }, precision);
      node.right = right.right;
      node.operator = op === '-' ? flip(right.operator) : right.operator;
      return reduce(node, precision);
    } // value + (something + value) => (value + value) + something
    // value + (something - value) => (value - value) + something
    // value - (something + value) => (value - value) - something
    // value - (something - value) => (value + value) - something
    else if (left.type === right.right.type) {
        node = Object.assign({}, node);
        node.left = reduce({
          type: 'MathExpression',
          operator: op === '-' ? flip(right.operator) : right.operator,
          left: left,
          right: right.right
        }, precision);
        node.right = right.left;
        return reduce(node, precision);
      } // value - (something + something) => value - something - something
      else if (op === '-' && right.operator === '+') {
          node = Object.assign({}, node);
          node.right.operator = '-';
          return reduce(node, precision);
        }
  } // (expr) <op> value


  if (left.type === 'MathExpression' && (left.operator === '+' || left.operator === '-') && isValueType(right.type)) {
    // (value + something) + value => (value + value) + something
    // (value - something) + value => (value + value) - something
    // (value + something) - value => (value - value) + something
    // (value - something) - value => (value - value) - something
    if (right.type === left.left.type) {
      node = Object.assign({}, left);
      node.left = reduce({
        type: 'MathExpression',
        operator: op,
        left: left.left,
        right: right
      }, precision);
      return reduce(node, precision);
    } // (something + value) + value => something + (value + value)
    // (something - value1) + value2 => something - (value2 - value1)
    // (something + value) - value => something + (value - value)
    // (something - value) - value => something - (value + value)
    else if (right.type === left.right.type) {
        node = Object.assign({}, left);

        if (left.operator === '-') {
          node.right = reduce({
            type: 'MathExpression',
            operator: flip(op),
            left: left.right,
            right: right
          }, precision);

          if (node.right.value && node.right.value < 0) {
            node.right.value = Math.abs(node.right.value);
            node.operator = '+';
          } else {
            node.operator = left.operator;
          }
        } else {
          node.right = reduce({
            type: 'MathExpression',
            operator: op,
            left: left.right,
            right: right
          }, precision);
        }

        if (node.right.value < 0) {
          node.right.value *= -1;
          node.operator = node.operator === '-' ? '+' : '-';
        }

        return reduce(node, precision);
      }
  }

  if (left.type === 'MathExpression' && right.type === 'MathExpression' && op === '-' && right.operator === '-') {
    node.right.operator = flip(node.right.operator);
  }

  return node;
}

function reduceDivisionExpression(node) {
  if (!isValueType(node.right.type)) return node;
  if (node.right.type !== 'Value') throw new Error(`Cannot divide by "${node.right.unit}", number expected`);
  if (node.right.value === 0) throw new Error('Cannot divide by zero'); // something / value

  if (isValueType(node.left.type)) {
    node.left.value /= node.right.value;
    return node.left;
  }

  return node;
}

function reduceMultiplicationExpression(node) {
  // (expr) * value
  if (node.left.type === 'MathExpression' && node.right.type === 'Value') {
    if (isValueType(node.left.left.type) && isValueType(node.left.right.type)) {
      node.left.left.value *= node.right.value;
      node.left.right.value *= node.right.value;
      return node.left;
    }
  } // something * value
  else if (isValueType(node.left.type) && node.right.type === 'Value') {
      node.left.value *= node.right.value;
      return node.left;
    } // value * (expr)
    else if (node.left.type === 'Value' && node.right.type === 'MathExpression') {
        if (isValueType(node.right.left.type) && isValueType(node.right.right.type)) {
          node.right.left.value *= node.left.value;
          node.right.right.value *= node.left.value;
          return node.right;
        }
      } // value * something
      else if (node.left.type === 'Value' && isValueType(node.right.type)) {
          node.right.value *= node.left.value;
          return node.right;
        }

  return node;
}

function reduceMathExpression(node, precision) {
  node = convertMathExpression(node, precision);

  switch (node.operator) {
    case "+":
    case "-":
      return reduceAddSubExpression(node, precision);

    case "/":
      return reduceDivisionExpression(node, precision);

    case "*":
      return reduceMultiplicationExpression(node);
  }

  return node;
}

var _default = reduce;
exports.default = _default;
module.exports = exports.default;
},{"./convert":850}],852:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
var order = {
  "*": 0,
  "/": 0,
  "+": 1,
  "-": 1
};

function round(value, prec) {
  if (prec !== false) {
    var precision = Math.pow(10, prec);
    return Math.round(value * precision) / precision;
  }

  return value;
}

function stringify(node, prec) {
  switch (node.type) {
    case "MathExpression":
      {
        var left = node.left,
            right = node.right,
            op = node.operator;
        var str = "";
        if (left.type === 'MathExpression' && order[op] < order[left.operator]) str += `(${stringify(left, prec)})`;else str += stringify(left, prec);
        str += order[op] ? ` ${node.operator} ` : node.operator;
        if (right.type === 'MathExpression' && order[op] < order[right.operator]) str += `(${stringify(right, prec)})`;else str += stringify(right, prec);
        return str;
      }

    case "Value":
      return round(node.value, prec);

    case 'Function':
      return node.value;

    default:
      return round(node.value, prec) + node.unit;
  }
}

function _default(calc, node, originalValue, options, result, item) {
  var str = stringify(node, options.precision);

  if (node.type === "MathExpression") {
    // if calc expression couldn't be resolved to a single value, re-wrap it as
    // a calc()
    str = `${calc}(${str})`; // if the warnWhenCannotResolve option is on, inform the user that the calc
    // expression could not be resolved to a single value

    if (options.warnWhenCannotResolve) {
      result.warn("Could not reduce expression: " + originalValue, {
        plugin: 'postcss-calc',
        node: item
      });
    }
  }

  return str;
}

module.exports = exports.default;
},{}],853:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _postcssSelectorParser = _interopRequireDefault(require("postcss-selector-parser"));

var _postcssValueParser = _interopRequireDefault(require("postcss-value-parser"));

var _parser = require("../parser");

var _reducer = _interopRequireDefault(require("./reducer"));

var _stringifier = _interopRequireDefault(require("./stringifier"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// eslint-disable-next-line import/no-unresolved
var MATCH_CALC = /((?:-(moz|webkit)-)?calc)/i;

function transformValue(value, options, result, item) {
  return (0, _postcssValueParser.default)(value).walk(function (node) {
    // skip anything which isn't a calc() function
    if (node.type !== 'function' || !MATCH_CALC.test(node.value)) return node; // stringify calc expression and produce an AST

    var contents = _postcssValueParser.default.stringify(node.nodes);

    var ast = _parser.parser.parse(contents); // reduce AST to its simplest form, that is, either to a single value
    // or a simplified calc expression


    var reducedAst = (0, _reducer.default)(ast, options.precision, item); // stringify AST and write it back

    node.type = 'word';
    node.value = (0, _stringifier.default)(node.value, reducedAst, value, options, result, item);
  }, true).toString();
}

function transformSelector(value, options, result, item) {
  return (0, _postcssSelectorParser.default)(function (selectors) {
    selectors.walk(function (node) {
      // attribute value
      // e.g. the "calc(3*3)" part of "div[data-size="calc(3*3)"]"
      if (node.type === 'attribute' && node.value) {
        node.setValue(transformValue(node.value, options, result, item));
      } // tag value
      // e.g. the "calc(3*3)" part of "div:nth-child(2n + calc(3*3))"


      if (node.type === 'tag') node.value = transformValue(node.value, options, result, item);
      return;
    });
  }).processSync(value);
}

var _default = function _default(node, property, options, result) {
  var value = property === "selector" ? transformSelector(node[property], options, result, node) : transformValue(node[property], options, result, node); // if the preserve option is enabled and the value has changed, write the
  // transformed value into a cloned node which is inserted before the current
  // node, preserving the original value. Otherwise, overwrite the original
  // value.

  if (options.preserve && node[property] !== value) {
    var clone = node.clone();
    clone[property] = value;
    node.parent.insertBefore(node, clone);
  } else node[property] = value;
};

exports.default = _default;
module.exports = exports.default;
},{"../parser":854,"./reducer":851,"./stringifier":852,"postcss-selector-parser":1024,"postcss-value-parser":1057}],854:[function(require,module,exports){

/* parser generated by jison 0.6.1-215 */

/*
 * Returns a Parser object of the following structure:
 *
 *  Parser: {
 *    yy: {}     The so-called "shared state" or rather the *source* of it;
 *               the real "shared state" `yy` passed around to
 *               the rule actions, etc. is a derivative/copy of this one,
 *               not a direct reference!
 *  }
 *
 *  Parser.prototype: {
 *    yy: {},
 *    EOF: 1,
 *    TERROR: 2,
 *
 *    trace: function(errorMessage, ...),
 *
 *    JisonParserError: function(msg, hash),
 *
 *    quoteName: function(name),
 *               Helper function which can be overridden by user code later on: put suitable
 *               quotes around literal IDs in a description string.
 *
 *    originalQuoteName: function(name),
 *               The basic quoteName handler provided by JISON.
 *               `cleanupAfterParse()` will clean up and reset `quoteName()` to reference this function
 *               at the end of the `parse()`.
 *
 *    describeSymbol: function(symbol),
 *               Return a more-or-less human-readable description of the given symbol, when
 *               available, or the symbol itself, serving as its own 'description' for lack
 *               of something better to serve up.
 *
 *               Return NULL when the symbol is unknown to the parser.
 *
 *    symbols_: {associative list: name ==> number},
 *    terminals_: {associative list: number ==> name},
 *    nonterminals: {associative list: rule-name ==> {associative list: number ==> rule-alt}},
 *    terminal_descriptions_: (if there are any) {associative list: number ==> description},
 *    productions_: [...],
 *
 *    performAction: function parser__performAction(yytext, yyleng, yylineno, yyloc, yystate, yysp, yyvstack, yylstack, yystack, yysstack),
 *
 *               The function parameters and `this` have the following value/meaning:
 *               - `this`    : reference to the `yyval` internal object, which has members (`$` and `_$`)
 *                             to store/reference the rule value `$$` and location info `@$`.
 *
 *                 One important thing to note about `this` a.k.a. `yyval`: every *reduce* action gets
 *                 to see the same object via the `this` reference, i.e. if you wish to carry custom
 *                 data from one reduce action through to the next within a single parse run, then you
 *                 may get nasty and use `yyval` a.k.a. `this` for storing you own semi-permanent data.
 *
 *                 `this.yy` is a direct reference to the `yy` shared state object.
 *
 *                 `%parse-param`-specified additional `parse()` arguments have been added to this `yy`
 *                 object at `parse()` start and are therefore available to the action code via the
 *                 same named `yy.xxxx` attributes (where `xxxx` represents a identifier name from
 *                 the %parse-param` list.
 *
 *               - `yytext`  : reference to the lexer value which belongs to the last lexer token used
 *                             to match this rule. This is *not* the look-ahead token, but the last token
 *                             that's actually part of this rule.
 *
 *                 Formulated another way, `yytext` is the value of the token immediately preceeding
 *                 the current look-ahead token.
 *                 Caveats apply for rules which don't require look-ahead, such as epsilon rules.
 *
 *               - `yyleng`  : ditto as `yytext`, only now for the lexer.yyleng value.
 *
 *               - `yylineno`: ditto as `yytext`, only now for the lexer.yylineno value.
 *
 *               - `yyloc`   : ditto as `yytext`, only now for the lexer.yylloc lexer token location info.
 *
 *                               WARNING: since jison 0.4.18-186 this entry may be NULL/UNDEFINED instead
 *                               of an empty object when no suitable location info can be provided.
 *
 *               - `yystate` : the current parser state number, used internally for dispatching and
 *                               executing the action code chunk matching the rule currently being reduced.
 *
 *               - `yysp`    : the current state stack position (a.k.a. 'stack pointer')
 *
 *                 This one comes in handy when you are going to do advanced things to the parser
 *                 stacks, all of which are accessible from your action code (see the next entries below).
 *
 *                 Also note that you can access this and other stack index values using the new double-hash
 *                 syntax, i.e. `##$ === ##0 === yysp`, while `##1` is the stack index for all things
 *                 related to the first rule term, just like you have `$1`, `@1` and `#1`.
 *                 This is made available to write very advanced grammar action rules, e.g. when you want
 *                 to investigate the parse state stack in your action code, which would, for example,
 *                 be relevant when you wish to implement error diagnostics and reporting schemes similar
 *                 to the work described here:
 *
 *                 + Pottier, F., 2016. Reachability and error diagnosis in LR(1) automata.
 *                   In Journes Francophones des Languages Applicatifs.
 *
 *                 + Jeffery, C.L., 2003. Generating LR syntax error messages from examples.
 *                   ACM Transactions on Programming Languages and Systems (TOPLAS), 25(5), pp.631640.
 *
 *               - `yyrulelength`: the current rule's term count, i.e. the number of entries occupied on the stack.
 *
 *                 This one comes in handy when you are going to do advanced things to the parser
 *                 stacks, all of which are accessible from your action code (see the next entries below).
 *
 *               - `yyvstack`: reference to the parser value stack. Also accessed via the `$1` etc.
 *                             constructs.
 *
 *               - `yylstack`: reference to the parser token location stack. Also accessed via
 *                             the `@1` etc. constructs.
 *
 *                             WARNING: since jison 0.4.18-186 this array MAY contain slots which are
 *                             UNDEFINED rather than an empty (location) object, when the lexer/parser
 *                             action code did not provide a suitable location info object when such a
 *                             slot was filled!
 *
 *               - `yystack` : reference to the parser token id stack. Also accessed via the
 *                             `#1` etc. constructs.
 *
 *                 Note: this is a bit of a **white lie** as we can statically decode any `#n` reference to
 *                 its numeric token id value, hence that code wouldn't need the `yystack` but *you* might
 *                 want access this array for your own purposes, such as error analysis as mentioned above!
 *
 *                 Note that this stack stores the current stack of *tokens*, that is the sequence of
 *                 already parsed=reduced *nonterminals* (tokens representing rules) and *terminals*
 *                 (lexer tokens *shifted* onto the stack until the rule they belong to is found and
 *                 *reduced*.
 *
 *               - `yysstack`: reference to the parser state stack. This one carries the internal parser
 *                             *states* such as the one in `yystate`, which are used to represent
 *                             the parser state machine in the *parse table*. *Very* *internal* stuff,
 *                             what can I say? If you access this one, you're clearly doing wicked things
 *
 *               - `...`     : the extra arguments you specified in the `%parse-param` statement in your
 *                             grammar definition file.
 *
 *    table: [...],
 *               State transition table
 *               ----------------------
 *
 *               index levels are:
 *               - `state`  --> hash table
 *               - `symbol` --> action (number or array)
 *
 *                 If the `action` is an array, these are the elements' meaning:
 *                 - index [0]: 1 = shift, 2 = reduce, 3 = accept
 *                 - index [1]: GOTO `state`
 *
 *                 If the `action` is a number, it is the GOTO `state`
 *
 *    defaultActions: {...},
 *
 *    parseError: function(str, hash, ExceptionClass),
 *    yyError: function(str, ...),
 *    yyRecovering: function(),
 *    yyErrOk: function(),
 *    yyClearIn: function(),
 *
 *    constructParseErrorInfo: function(error_message, exception_object, expected_token_set, is_recoverable),
 *               Helper function **which will be set up during the first invocation of the `parse()` method**.
 *               Produces a new errorInfo 'hash object' which can be passed into `parseError()`.
 *               See it's use in this parser kernel in many places; example usage:
 *
 *                   var infoObj = parser.constructParseErrorInfo('fail!', null,
 *                                     parser.collect_expected_token_set(state), true);
 *                   var retVal = parser.parseError(infoObj.errStr, infoObj, parser.JisonParserError);
 *
 *    originalParseError: function(str, hash, ExceptionClass),
 *               The basic `parseError` handler provided by JISON.
 *               `cleanupAfterParse()` will clean up and reset `parseError()` to reference this function
 *               at the end of the `parse()`.
 *
 *    options: { ... parser %options ... },
 *
 *    parse: function(input[, args...]),
 *               Parse the given `input` and return the parsed value (or `true` when none was provided by
 *               the root action, in which case the parser is acting as a *matcher*).
 *               You MAY use the additional `args...` parameters as per `%parse-param` spec of this grammar:
 *               these extra `args...` are added verbatim to the `yy` object reference as member variables.
 *
 *               WARNING:
 *               Parser's additional `args...` parameters (via `%parse-param`) MAY conflict with
 *               any attributes already added to `yy` by the jison run-time;
 *               when such a collision is detected an exception is thrown to prevent the generated run-time
 *               from silently accepting this confusing and potentially hazardous situation!
 *
 *               The lexer MAY add its own set of additional parameters (via the `%parse-param` line in
 *               the lexer section of the grammar spec): these will be inserted in the `yy` shared state
 *               object and any collision with those will be reported by the lexer via a thrown exception.
 *
 *    cleanupAfterParse: function(resultValue, invoke_post_methods, do_not_nuke_errorinfos),
 *               Helper function **which will be set up during the first invocation of the `parse()` method**.
 *               This helper API is invoked at the end of the `parse()` call, unless an exception was thrown
 *               and `%options no-try-catch` has been defined for this grammar: in that case this helper MAY
 *               be invoked by calling user code to ensure the `post_parse` callbacks are invoked and
 *               the internal parser gets properly garbage collected under these particular circumstances.
 *
 *    yyMergeLocationInfo: function(first_index, last_index, first_yylloc, last_yylloc, dont_look_back),
 *               Helper function **which will be set up during the first invocation of the `parse()` method**.
 *               This helper API can be invoked to calculate a spanning `yylloc` location info object.
 *
 *               Note: %epsilon rules MAY specify no `first_index` and `first_yylloc`, in which case
 *               this function will attempt to obtain a suitable location marker by inspecting the location stack
 *               backwards.
 *
 *               For more info see the documentation comment further below, immediately above this function's
 *               implementation.
 *
 *    lexer: {
 *        yy: {...},           A reference to the so-called "shared state" `yy` once
 *                             received via a call to the `.setInput(input, yy)` lexer API.
 *        EOF: 1,
 *        ERROR: 2,
 *        JisonLexerError: function(msg, hash),
 *        parseError: function(str, hash, ExceptionClass),
 *        setInput: function(input, [yy]),
 *        input: function(),
 *        unput: function(str),
 *        more: function(),
 *        reject: function(),
 *        less: function(n),
 *        pastInput: function(n),
 *        upcomingInput: function(n),
 *        showPosition: function(),
 *        test_match: function(regex_match_array, rule_index, ...),
 *        next: function(...),
 *        lex: function(...),
 *        begin: function(condition),
 *        pushState: function(condition),
 *        popState: function(),
 *        topState: function(),
 *        _currentRules: function(),
 *        stateStackSize: function(),
 *        cleanupAfterLex: function()
 *
 *        options: { ... lexer %options ... },
 *
 *        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START, ...),
 *        rules: [...],
 *        conditions: {associative list: name ==> set},
 *    }
 *  }
 *
 *
 *  token location info (@$, _$, etc.): {
 *    first_line: n,
 *    last_line: n,
 *    first_column: n,
 *    last_column: n,
 *    range: [start_number, end_number]
 *               (where the numbers are indexes into the input string, zero-based)
 *  }
 *
 * ---
 *
 * The `parseError` function receives a 'hash' object with these members for lexer and
 * parser errors:
 *
 *  {
 *    text:        (matched text)
 *    token:       (the produced terminal token, if any)
 *    token_id:    (the produced terminal token numeric ID, if any)
 *    line:        (yylineno)
 *    loc:         (yylloc)
 *  }
 *
 * parser (grammar) errors will also provide these additional members:
 *
 *  {
 *    expected:    (array describing the set of expected tokens;
 *                  may be UNDEFINED when we cannot easily produce such a set)
 *    state:       (integer (or array when the table includes grammar collisions);
 *                  represents the current internal state of the parser kernel.
 *                  can, for example, be used to pass to the `collect_expected_token_set()`
 *                  API to obtain the expected token set)
 *    action:      (integer; represents the current internal action which will be executed)
 *    new_state:   (integer; represents the next/planned internal state, once the current
 *                  action has executed)
 *    recoverable: (boolean: TRUE when the parser MAY have an error recovery rule
 *                  available for this particular error)
 *    state_stack: (array: the current parser LALR/LR internal state stack; this can be used,
 *                  for instance, for advanced error analysis and reporting)
 *    value_stack: (array: the current parser LALR/LR internal `$$` value stack; this can be used,
 *                  for instance, for advanced error analysis and reporting)
 *    location_stack: (array: the current parser LALR/LR internal location stack; this can be used,
 *                  for instance, for advanced error analysis and reporting)
 *    yy:          (object: the current parser internal "shared state" `yy`
 *                  as is also available in the rule actions; this can be used,
 *                  for instance, for advanced error analysis and reporting)
 *    lexer:       (reference to the current lexer instance used by the parser)
 *    parser:      (reference to the current parser instance)
 *  }
 *
 * while `this` will reference the current parser instance.
 *
 * When `parseError` is invoked by the lexer, `this` will still reference the related *parser*
 * instance, while these additional `hash` fields will also be provided:
 *
 *  {
 *    lexer:       (reference to the current lexer instance which reported the error)
 *  }
 *
 * When `parseError` is invoked by the parser due to a **JavaScript exception** being fired
 * from either the parser or lexer, `this` will still reference the related *parser*
 * instance, while these additional `hash` fields will also be provided:
 *
 *  {
 *    exception:   (reference to the exception thrown)
 *  }
 *
 * Please do note that in the latter situation, the `expected` field will be omitted as
 * this type of failure is assumed not to be due to *parse errors* but rather due to user
 * action code in either parser or lexer failing unexpectedly.
 *
 * ---
 *
 * You can specify parser options by setting / modifying the `.yy` object of your Parser instance.
 * These options are available:
 *
 * ### options which are global for all parser instances
 *
 *  Parser.pre_parse: function(yy)
 *                 optional: you can specify a pre_parse() function in the chunk following
 *                 the grammar, i.e. after the last `%%`.
 *  Parser.post_parse: function(yy, retval, parseInfo) { return retval; }
 *                 optional: you can specify a post_parse() function in the chunk following
 *                 the grammar, i.e. after the last `%%`. When it does not return any value,
 *                 the parser will return the original `retval`.
 *
 * ### options which can be set up per parser instance
 *
 *  yy: {
 *      pre_parse:  function(yy)
 *                 optional: is invoked before the parse cycle starts (and before the first
 *                 invocation of `lex()`) but immediately after the invocation of
 *                 `parser.pre_parse()`).
 *      post_parse: function(yy, retval, parseInfo) { return retval; }
 *                 optional: is invoked when the parse terminates due to success ('accept')
 *                 or failure (even when exceptions are thrown).
 *                 `retval` contains the return value to be produced by `Parser.parse()`;
 *                 this function can override the return value by returning another.
 *                 When it does not return any value, the parser will return the original
 *                 `retval`.
 *                 This function is invoked immediately before `parser.post_parse()`.
 *
 *      parseError: function(str, hash, ExceptionClass)
 *                 optional: overrides the default `parseError` function.
 *      quoteName: function(name),
 *                 optional: overrides the default `quoteName` function.
 *  }
 *
 *  parser.lexer.options: {
 *      pre_lex:  function()
 *                 optional: is invoked before the lexer is invoked to produce another token.
 *                 `this` refers to the Lexer object.
 *      post_lex: function(token) { return token; }
 *                 optional: is invoked when the lexer has produced a token `token`;
 *                 this function can override the returned token value by returning another.
 *                 When it does not return any (truthy) value, the lexer will return
 *                 the original `token`.
 *                 `this` refers to the Lexer object.
 *
 *      ranges: boolean
 *                 optional: `true` ==> token location info will include a .range[] member.
 *      flex: boolean
 *                 optional: `true` ==> flex-like lexing behaviour where the rules are tested
 *                 exhaustively to find the longest match.
 *      backtrack_lexer: boolean
 *                 optional: `true` ==> lexer regexes are tested in order and for invoked;
 *                 the lexer terminates the scan when a token is returned by the action code.
 *      xregexp: boolean
 *                 optional: `true` ==> lexer rule regexes are "extended regex format" requiring the
 *                 `XRegExp` library. When this `%option` has not been specified at compile time, all lexer
 *                 rule regexes have been written as standard JavaScript RegExp expressions.
 *  }
 */

        
    
            var parser = (function () {


// See also:
// http://stackoverflow.com/questions/1382107/whats-a-good-way-to-extend-error-in-javascript/#35881508
// but we keep the prototype.constructor and prototype.name assignment lines too for compatibility
// with userland code which might access the derived class in a 'classic' way.
function JisonParserError(msg, hash) {
    Object.defineProperty(this, 'name', {
        enumerable: false,
        writable: false,
        value: 'JisonParserError'
    });

    if (msg == null) msg = '???';

    Object.defineProperty(this, 'message', {
        enumerable: false,
        writable: true,
        value: msg
    });

    this.hash = hash;

    var stacktrace;
    if (hash && hash.exception instanceof Error) {
        var ex2 = hash.exception;
        this.message = ex2.message || msg;
        stacktrace = ex2.stack;
    }
    if (!stacktrace) {
        if (Error.hasOwnProperty('captureStackTrace')) {        // V8/Chrome engine
            Error.captureStackTrace(this, this.constructor);
        } else {
            stacktrace = (new Error(msg)).stack;
        }
    }
    if (stacktrace) {
        Object.defineProperty(this, 'stack', {
            enumerable: false,
            writable: false,
            value: stacktrace
        });
    }
}

if (typeof Object.setPrototypeOf === 'function') {
    Object.setPrototypeOf(JisonParserError.prototype, Error.prototype);
} else {
    JisonParserError.prototype = Object.create(Error.prototype);
}
JisonParserError.prototype.constructor = JisonParserError;
JisonParserError.prototype.name = 'JisonParserError';




        // helper: reconstruct the productions[] table
        function bp(s) {
            var rv = [];
            var p = s.pop;
            var r = s.rule;
            for (var i = 0, l = p.length; i < l; i++) {
                rv.push([
                    p[i],
                    r[i]
                ]);
            }
            return rv;
        }
    


        // helper: reconstruct the defaultActions[] table
        function bda(s) {
            var rv = {};
            var d = s.idx;
            var g = s.goto;
            for (var i = 0, l = d.length; i < l; i++) {
                var j = d[i];
                rv[j] = g[i];
            }
            return rv;
        }
    


        // helper: reconstruct the 'goto' table
        function bt(s) {
            var rv = [];
            var d = s.len;
            var y = s.symbol;
            var t = s.type;
            var a = s.state;
            var m = s.mode;
            var g = s.goto;
            for (var i = 0, l = d.length; i < l; i++) {
                var n = d[i];
                var q = {};
                for (var j = 0; j < n; j++) {
                    var z = y.shift();
                    switch (t.shift()) {
                    case 2:
                        q[z] = [
                            m.shift(),
                            g.shift()
                        ];
                        break;

                    case 0:
                        q[z] = a.shift();
                        break;

                    default:
                        // type === 1: accept
                        q[z] = [
                            3
                        ];
                    }
                }
                rv.push(q);
            }
            return rv;
        }
    


        // helper: runlength encoding with increment step: code, length: step (default step = 0)
        // `this` references an array
        function s(c, l, a) {
            a = a || 0;
            for (var i = 0; i < l; i++) {
                this.push(c);
                c += a;
            }
        }

        // helper: duplicate sequence from *relative* offset and length.
        // `this` references an array
        function c(i, l) {
            i = this.length - i;
            for (l += i; i < l; i++) {
                this.push(this[i]);
            }
        }

        // helper: unpack an array using helpers and data, all passed in an array argument 'a'.
        function u(a) {
            var rv = [];
            for (var i = 0, l = a.length; i < l; i++) {
                var e = a[i];
                // Is this entry a helper function?
                if (typeof e === 'function') {
                    i++;
                    e.apply(rv, a[i]);
                } else {
                    rv.push(e);
                }
            }
            return rv;
        }
    

var parser = {
    // Code Generator Information Report
    // ---------------------------------
    //
    // Options:
    //
    //   default action mode: ............. ["classic","merge"]
    //   test-compile action mode: ........ "parser:*,lexer:*"
    //   try..catch: ...................... true
    //   default resolve on conflict: ..... true
    //   on-demand look-ahead: ............ false
    //   error recovery token skip maximum: 3
    //   yyerror in parse actions is: ..... NOT recoverable,
    //   yyerror in lexer actions and other non-fatal lexer are:
    //   .................................. NOT recoverable,
    //   debug grammar/output: ............ false
    //   has partial LR conflict upgrade:   true
    //   rudimentary token-stack support:   false
    //   parser table compression mode: ... 2
    //   export debug tables: ............. false
    //   export *all* tables: ............. false
    //   module type: ..................... commonjs
    //   parser engine type: .............. lalr
    //   output main() in the module: ..... true
    //   has user-specified main(): ....... false
    //   has user-specified require()/import modules for main():
    //   .................................. false
    //   number of expected conflicts: .... 0
    //
    //
    // Parser Analysis flags:
    //
    //   no significant actions (parser is a language matcher only):
    //   .................................. false
    //   uses yyleng: ..................... false
    //   uses yylineno: ................... false
    //   uses yytext: ..................... false
    //   uses yylloc: ..................... false
    //   uses ParseError API: ............. false
    //   uses YYERROR: .................... false
    //   uses YYRECOVERING: ............... false
    //   uses YYERROK: .................... false
    //   uses YYCLEARIN: .................. false
    //   tracks rule values: .............. true
    //   assigns rule values: ............. true
    //   uses location tracking: .......... false
    //   assigns location: ................ false
    //   uses yystack: .................... false
    //   uses yysstack: ................... false
    //   uses yysp: ....................... true
    //   uses yyrulelength: ............... false
    //   uses yyMergeLocationInfo API: .... false
    //   has error recovery: .............. false
    //   has error reporting: ............. false
    //
    // --------- END OF REPORT -----------

trace: function no_op_trace() { },
JisonParserError: JisonParserError,
yy: {},
options: {
  type: "lalr",
  hasPartialLrUpgradeOnConflict: true,
  errorRecoveryTokenDiscardCount: 3
},
symbols_: {
  "$accept": 0,
  "$end": 1,
  "ADD": 6,
  "ANGLE": 13,
  "CALC": 3,
  "CHS": 19,
  "DIV": 9,
  "EMS": 17,
  "EOF": 1,
  "EXS": 18,
  "FREQ": 15,
  "FUNCTION": 11,
  "LENGTH": 12,
  "LPAREN": 4,
  "MUL": 8,
  "NUMBER": 10,
  "PERCENTAGE": 25,
  "REMS": 20,
  "RES": 16,
  "RPAREN": 5,
  "SUB": 7,
  "TIME": 14,
  "VHS": 21,
  "VMAXS": 24,
  "VMINS": 23,
  "VWS": 22,
  "css_value": 30,
  "error": 2,
  "expression": 26,
  "function": 29,
  "math_expression": 27,
  "value": 28
},
terminals_: {
  1: "EOF",
  2: "error",
  3: "CALC",
  4: "LPAREN",
  5: "RPAREN",
  6: "ADD",
  7: "SUB",
  8: "MUL",
  9: "DIV",
  10: "NUMBER",
  11: "FUNCTION",
  12: "LENGTH",
  13: "ANGLE",
  14: "TIME",
  15: "FREQ",
  16: "RES",
  17: "EMS",
  18: "EXS",
  19: "CHS",
  20: "REMS",
  21: "VHS",
  22: "VWS",
  23: "VMINS",
  24: "VMAXS",
  25: "PERCENTAGE"
},
TERROR: 2,
    EOF: 1,

    // internals: defined here so the object *structure* doesn't get modified by parse() et al,
    // thus helping JIT compilers like Chrome V8.
    originalQuoteName: null,
    originalParseError: null,
    cleanupAfterParse: null,
    constructParseErrorInfo: null,
    yyMergeLocationInfo: null,

    __reentrant_call_depth: 0,      // INTERNAL USE ONLY
    __error_infos: [],              // INTERNAL USE ONLY: the set of parseErrorInfo objects created since the last cleanup
    __error_recovery_infos: [],     // INTERNAL USE ONLY: the set of parseErrorInfo objects created since the last cleanup

    // APIs which will be set up depending on user action code analysis:
    //yyRecovering: 0,
    //yyErrOk: 0,
    //yyClearIn: 0,

    // Helper APIs
    // -----------

    // Helper function which can be overridden by user code later on: put suitable quotes around
    // literal IDs in a description string.
    quoteName: function parser_quoteName(id_str) {
        return '"' + id_str + '"';
    },

    // Return the name of the given symbol (terminal or non-terminal) as a string, when available.
    //
    // Return NULL when the symbol is unknown to the parser.
    getSymbolName: function parser_getSymbolName(symbol) {
        if (this.terminals_[symbol]) {
            return this.terminals_[symbol];
        }

        // Otherwise... this might refer to a RULE token i.e. a non-terminal: see if we can dig that one up.
        //
        // An example of this may be where a rule's action code contains a call like this:
        //
        //      parser.getSymbolName(#$)
        //
        // to obtain a human-readable name of the current grammar rule.
        var s = this.symbols_;
        for (var key in s) {
            if (s[key] === symbol) {
                return key;
            }
        }
        return null;
    },

    // Return a more-or-less human-readable description of the given symbol, when available,
    // or the symbol itself, serving as its own 'description' for lack of something better to serve up.
    //
    // Return NULL when the symbol is unknown to the parser.
    describeSymbol: function parser_describeSymbol(symbol) {
        if (symbol !== this.EOF && this.terminal_descriptions_ && this.terminal_descriptions_[symbol]) {
            return this.terminal_descriptions_[symbol];
        }
        else if (symbol === this.EOF) {
            return 'end of input';
        }
        var id = this.getSymbolName(symbol);
        if (id) {
            return this.quoteName(id);
        }
        return null;
    },

    // Produce a (more or less) human-readable list of expected tokens at the point of failure.
    //
    // The produced list may contain token or token set descriptions instead of the tokens
    // themselves to help turning this output into something that easier to read by humans
    // unless `do_not_describe` parameter is set, in which case a list of the raw, *numeric*,
    // expected terminals and nonterminals is produced.
    //
    // The returned list (array) will not contain any duplicate entries.
    collect_expected_token_set: function parser_collect_expected_token_set(state, do_not_describe) {
        var TERROR = this.TERROR;
        var tokenset = [];
        var check = {};
        // Has this (error?) state been outfitted with a custom expectations description text for human consumption?
        // If so, use that one instead of the less palatable token set.
        if (!do_not_describe && this.state_descriptions_ && this.state_descriptions_[state]) {
            return [
                this.state_descriptions_[state]
            ];
        }
        for (var p in this.table[state]) {
            p = +p;
            if (p !== TERROR) {
                var d = do_not_describe ? p : this.describeSymbol(p);
                if (d && !check[d]) {
                    tokenset.push(d);
                    check[d] = true;        // Mark this token description as already mentioned to prevent outputting duplicate entries.
                }
            }
        }
        return tokenset;
    },
productions_: bp({
  pop: u([
  26,
  s,
  [27, 9],
  28,
  28,
  29,
  s,
  [30, 15]
]),
  rule: u([
  2,
  4,
  s,
  [3, 5],
  s,
  [1, 4],
  2,
  s,
  [1, 15],
  2
])
}),
performAction: function parser__PerformAction(yystate /* action[1] */, yysp, yyvstack) {

          /* this == yyval */

          // the JS engine itself can go and remove these statements when `yy` turns out to be unused in any action code!
          var yy = this.yy;
          var yyparser = yy.parser;
          var yylexer = yy.lexer;

          

          switch (yystate) {
case 0:
    /*! Production::    $accept : expression $end */

    // default action (generated by JISON mode classic/merge :: 1,VT,VA,-,-,-,-,-,-):
    this.$ = yyvstack[yysp - 1];
    // END of default action (generated by JISON mode classic/merge :: 1,VT,VA,-,-,-,-,-,-)
    break;

case 1:
    /*! Production::    expression : math_expression EOF */

    // default action (generated by JISON mode classic/merge :: 2,VT,VA,-,-,-,-,-,-):
    this.$ = yyvstack[yysp - 1];
    // END of default action (generated by JISON mode classic/merge :: 2,VT,VA,-,-,-,-,-,-)
    
    
    return yyvstack[yysp - 1];
    break;

case 2:
    /*! Production::    math_expression : CALC LPAREN math_expression RPAREN */
case 7:
    /*! Production::    math_expression : LPAREN math_expression RPAREN */

    this.$ = yyvstack[yysp - 1];
    break;

case 3:
    /*! Production::    math_expression : math_expression ADD math_expression */
case 4:
    /*! Production::    math_expression : math_expression SUB math_expression */
case 5:
    /*! Production::    math_expression : math_expression MUL math_expression */
case 6:
    /*! Production::    math_expression : math_expression DIV math_expression */

    this.$ = { type: 'MathExpression', operator: yyvstack[yysp - 1], left: yyvstack[yysp - 2], right: yyvstack[yysp] };
    break;

case 8:
    /*! Production::    math_expression : function */
case 9:
    /*! Production::    math_expression : css_value */
case 10:
    /*! Production::    math_expression : value */

    this.$ = yyvstack[yysp];
    break;

case 11:
    /*! Production::    value : NUMBER */

    this.$ = { type: 'Value', value: parseFloat(yyvstack[yysp]) };
    break;

case 12:
    /*! Production::    value : SUB NUMBER */

    this.$ = { type: 'Value', value: parseFloat(yyvstack[yysp]) * -1 };
    break;

case 13:
    /*! Production::    function : FUNCTION */

    this.$ = { type: 'Function', value: yyvstack[yysp] };
    break;

case 14:
    /*! Production::    css_value : LENGTH */

    this.$ = { type: 'LengthValue', value: parseFloat(yyvstack[yysp]), unit: /[a-z]+/.exec(yyvstack[yysp])[0] };
    break;

case 15:
    /*! Production::    css_value : ANGLE */

    this.$ = { type: 'AngleValue', value: parseFloat(yyvstack[yysp]), unit: /[a-z]+/.exec(yyvstack[yysp])[0] };
    break;

case 16:
    /*! Production::    css_value : TIME */

    this.$ = { type: 'TimeValue', value: parseFloat(yyvstack[yysp]), unit: /[a-z]+/.exec(yyvstack[yysp])[0] };
    break;

case 17:
    /*! Production::    css_value : FREQ */

    this.$ = { type: 'FrequencyValue', value: parseFloat(yyvstack[yysp]), unit: /[a-z]+/.exec(yyvstack[yysp])[0] };
    break;

case 18:
    /*! Production::    css_value : RES */

    this.$ = { type: 'ResolutionValue', value: parseFloat(yyvstack[yysp]), unit: /[a-z]+/.exec(yyvstack[yysp])[0] };
    break;

case 19:
    /*! Production::    css_value : EMS */

    this.$ = { type: 'EmValue', value: parseFloat(yyvstack[yysp]), unit: 'em' };
    break;

case 20:
    /*! Production::    css_value : EXS */

    this.$ = { type: 'ExValue', value: parseFloat(yyvstack[yysp]), unit: 'ex' };
    break;

case 21:
    /*! Production::    css_value : CHS */

    this.$ = { type: 'ChValue', value: parseFloat(yyvstack[yysp]), unit: 'ch' };
    break;

case 22:
    /*! Production::    css_value : REMS */

    this.$ = { type: 'RemValue', value: parseFloat(yyvstack[yysp]), unit: 'rem' };
    break;

case 23:
    /*! Production::    css_value : VHS */

    this.$ = { type: 'VhValue', value: parseFloat(yyvstack[yysp]), unit: 'vh' };
    break;

case 24:
    /*! Production::    css_value : VWS */

    this.$ = { type: 'VwValue', value: parseFloat(yyvstack[yysp]), unit: 'vw' };
    break;

case 25:
    /*! Production::    css_value : VMINS */

    this.$ = { type: 'VminValue', value: parseFloat(yyvstack[yysp]), unit: 'vmin' };
    break;

case 26:
    /*! Production::    css_value : VMAXS */

    this.$ = { type: 'VmaxValue', value: parseFloat(yyvstack[yysp]), unit: 'vmax' };
    break;

case 27:
    /*! Production::    css_value : PERCENTAGE */

    this.$ = { type: 'PercentageValue', value: parseFloat(yyvstack[yysp]), unit: '%' };
    break;

case 28:
    /*! Production::    css_value : SUB css_value */

    var prev = yyvstack[yysp]; prev.value *= -1; this.$ = prev;
    break;

}
},
table: bt({
  len: u([
  24,
  1,
  5,
  1,
  23,
  s,
  [0, 18],
  17,
  0,
  0,
  s,
  [23, 5],
  5,
  0,
  0,
  16,
  6,
  6,
  0,
  0,
  c,
  [8, 3]
]),
  symbol: u([
  3,
  4,
  7,
  s,
  [10, 21, 1],
  1,
  1,
  s,
  [6, 4, 1],
  4,
  c,
  [31, 19],
  c,
  [30, 4],
  7,
  10,
  c,
  [20, 14],
  30,
  c,
  [40, 23],
  c,
  [23, 92],
  s,
  [5, 5, 1],
  7,
  c,
  [136, 15],
  1,
  c,
  [22, 5],
  c,
  [6, 6],
  c,
  [5, 5]
]),
  type: u([
  s,
  [2, 19],
  s,
  [0, 5],
  1,
  s,
  [2, 25],
  s,
  [0, 4],
  c,
  [20, 17],
  c,
  [40, 39],
  c,
  [23, 95],
  c,
  [136, 19]
]),
  state: u([
  1,
  2,
  7,
  5,
  6,
  31,
  c,
  [4, 3],
  32,
  35,
  c,
  [5, 3],
  36,
  c,
  [4, 3],
  37,
  c,
  [4, 3],
  38,
  c,
  [4, 3],
  39,
  c,
  [21, 4]
]),
  mode: u([
  s,
  [1, 175],
  s,
  [2, 4],
  c,
  [6, 8],
  s,
  [1, 5]
]),
  goto: u([
  3,
  4,
  23,
  24,
  s,
  [8, 15, 1],
  s,
  [25, 6, 1],
  c,
  [25, 19],
  34,
  33,
  c,
  [16, 14],
  c,
  [35, 19],
  c,
  [19, 76],
  40,
  c,
  [136, 4],
  34,
  c,
  [39, 15],
  s,
  [3, 3],
  28,
  29,
  s,
  [4, 4],
  28,
  29,
  41,
  c,
  [32, 4]
])
}),
defaultActions: bda({
  idx: u([
  s,
  [5, 18, 1],
  24,
  25,
  32,
  33,
  37,
  38,
  40,
  41
]),
  goto: u([
  8,
  9,
  10,
  s,
  [13, 15, 1],
  11,
  1,
  28,
  12,
  5,
  6,
  7,
  2
])
}),
parseError: function parseError(str, hash, ExceptionClass) {
    if (hash.recoverable) {
        if (typeof this.trace === 'function') {
            this.trace(str);
        }
        hash.destroy();             // destroy... well, *almost*!
    } else {
        if (typeof this.trace === 'function') {
            this.trace(str);
        }
        if (!ExceptionClass) {
            ExceptionClass = this.JisonParserError;
        }
        throw new ExceptionClass(str, hash);
    }
},
parse: function parse(input) {
    var self = this;
    var stack = new Array(128);         // token stack: stores token which leads to state at the same index (column storage)
    var sstack = new Array(128);        // state stack: stores states (column storage)

    var vstack = new Array(128);        // semantic value stack

    var table = this.table;
    var sp = 0;                         // 'stack pointer': index into the stacks


    


    var symbol = 0;



    var TERROR = this.TERROR;
    var EOF = this.EOF;
    var ERROR_RECOVERY_TOKEN_DISCARD_COUNT = (this.options.errorRecoveryTokenDiscardCount | 0) || 3;
    var NO_ACTION = [0, 42 /* === table.length :: ensures that anyone using this new state will fail dramatically! */];

    var lexer;
    if (this.__lexer__) {
        lexer = this.__lexer__;
    } else {
        lexer = this.__lexer__ = Object.create(this.lexer);
    }

    var sharedState_yy = {
        parseError: undefined,
        quoteName: undefined,
        lexer: undefined,
        parser: undefined,
        pre_parse: undefined,
        post_parse: undefined,
        pre_lex: undefined,
        post_lex: undefined      // WARNING: must be written this way for the code expanders to work correctly in both ES5 and ES6 modes!
    };

    var ASSERT;
    if (typeof assert !== 'function') {
        ASSERT = function JisonAssert(cond, msg) {
            if (!cond) {
                throw new Error('assertion failed: ' + (msg || '***'));
            }
        };
    } else {
        ASSERT = assert;
    }

    this.yyGetSharedState = function yyGetSharedState() {
        return sharedState_yy;
    };








    function shallow_copy_noclobber(dst, src) {
        for (var k in src) {
            if (typeof dst[k] === 'undefined' && Object.prototype.hasOwnProperty.call(src, k)) {
                dst[k] = src[k];
            }
        }
    }

    // copy state
    shallow_copy_noclobber(sharedState_yy, this.yy);

    sharedState_yy.lexer = lexer;
    sharedState_yy.parser = this;






    // Does the shared state override the default `parseError` that already comes with this instance?
    if (typeof sharedState_yy.parseError === 'function') {
        this.parseError = function parseErrorAlt(str, hash, ExceptionClass) {
            if (!ExceptionClass) {
                ExceptionClass = this.JisonParserError;
            }
            return sharedState_yy.parseError.call(this, str, hash, ExceptionClass);
        };
    } else {
        this.parseError = this.originalParseError;
    }

    // Does the shared state override the default `quoteName` that already comes with this instance?
    if (typeof sharedState_yy.quoteName === 'function') {
        this.quoteName = function quoteNameAlt(id_str) {
            return sharedState_yy.quoteName.call(this, id_str);
        };
    } else {
        this.quoteName = this.originalQuoteName;
    }

    // set up the cleanup function; make it an API so that external code can re-use this one in case of
    // calamities or when the `%options no-try-catch` option has been specified for the grammar, in which
    // case this parse() API method doesn't come with a `finally { ... }` block any more!
    //
    // NOTE: as this API uses parse() as a closure, it MUST be set again on every parse() invocation,
    //       or else your `sharedState`, etc. references will be *wrong*!
    this.cleanupAfterParse = function parser_cleanupAfterParse(resultValue, invoke_post_methods, do_not_nuke_errorinfos) {
        var rv;

        if (invoke_post_methods) {
            var hash;

            if (sharedState_yy.post_parse || this.post_parse) {
                // create an error hash info instance: we re-use this API in a **non-error situation**
                // as this one delivers all parser internals ready for access by userland code.
                hash = this.constructParseErrorInfo(null /* no error! */, null /* no exception! */, null, false);
            }

            if (sharedState_yy.post_parse) {
                rv = sharedState_yy.post_parse.call(this, sharedState_yy, resultValue, hash);
                if (typeof rv !== 'undefined') resultValue = rv;
            }
            if (this.post_parse) {
                rv = this.post_parse.call(this, sharedState_yy, resultValue, hash);
                if (typeof rv !== 'undefined') resultValue = rv;
            }

            // cleanup:
            if (hash && hash.destroy) {
                hash.destroy();
            }
        }

        if (this.__reentrant_call_depth > 1) return resultValue;        // do not (yet) kill the sharedState when this is a reentrant run.

        // clean up the lingering lexer structures as well:
        if (lexer.cleanupAfterLex) {
            lexer.cleanupAfterLex(do_not_nuke_errorinfos);
        }

        // prevent lingering circular references from causing memory leaks:
        if (sharedState_yy) {
            sharedState_yy.lexer = undefined;
            sharedState_yy.parser = undefined;
            if (lexer.yy === sharedState_yy) {
                lexer.yy = undefined;
            }
        }
        sharedState_yy = undefined;
        this.parseError = this.originalParseError;
        this.quoteName = this.originalQuoteName;

        // nuke the vstack[] array at least as that one will still reference obsoleted user values.
        // To be safe, we nuke the other internal stack columns as well...
        stack.length = 0;               // fastest way to nuke an array without overly bothering the GC
        sstack.length = 0;

        vstack.length = 0;
        sp = 0;

        // nuke the error hash info instances created during this run.
        // Userland code must COPY any data/references
        // in the error hash instance(s) it is more permanently interested in.
        if (!do_not_nuke_errorinfos) {
            for (var i = this.__error_infos.length - 1; i >= 0; i--) {
                var el = this.__error_infos[i];
                if (el && typeof el.destroy === 'function') {
                    el.destroy();
                }
            }
            this.__error_infos.length = 0;


        }

        return resultValue;
    };






































































































































    // NOTE: as this API uses parse() as a closure, it MUST be set again on every parse() invocation,
    //       or else your `lexer`, `sharedState`, etc. references will be *wrong*!
    this.constructParseErrorInfo = function parser_constructParseErrorInfo(msg, ex, expected, recoverable) {
        var pei = {
            errStr: msg,
            exception: ex,
            text: lexer.match,
            value: lexer.yytext,
            token: this.describeSymbol(symbol) || symbol,
            token_id: symbol,
            line: lexer.yylineno,

            expected: expected,
            recoverable: recoverable,
            state: state,
            action: action,
            new_state: newState,
            symbol_stack: stack,
            state_stack: sstack,
            value_stack: vstack,

            stack_pointer: sp,
            yy: sharedState_yy,
            lexer: lexer,
            parser: this,

            // and make sure the error info doesn't stay due to potential
            // ref cycle via userland code manipulations.
            // These would otherwise all be memory leak opportunities!
            //
            // Note that only array and object references are nuked as those
            // constitute the set of elements which can produce a cyclic ref.
            // The rest of the members is kept intact as they are harmless.
            destroy: function destructParseErrorInfo() {
                // remove cyclic references added to error info:
                // info.yy = null;
                // info.lexer = null;
                // info.value = null;
                // info.value_stack = null;
                // ...
                var rec = !!this.recoverable;
                for (var key in this) {
                    if (this.hasOwnProperty(key) && typeof key === 'object') {
                        this[key] = undefined;
                    }
                }
                this.recoverable = rec;
            }
        };
        // track this instance so we can `destroy()` it once we deem it superfluous and ready for garbage collection!
        this.__error_infos.push(pei);
        return pei;
    };













    function getNonTerminalFromCode(symbol) {
        var tokenName = self.getSymbolName(symbol);
        if (!tokenName) {
            tokenName = symbol;
        }
        return tokenName;
    }


    function stdLex() {
        var token = lexer.lex();
        // if token isn't its numeric value, convert
        if (typeof token !== 'number') {
            token = self.symbols_[token] || token;
        }

        return token || EOF;
    }

    function fastLex() {
        var token = lexer.fastLex();
        // if token isn't its numeric value, convert
        if (typeof token !== 'number') {
            token = self.symbols_[token] || token;
        }

        return token || EOF;
    }

    var lex = stdLex;


    var state, action, r, t;
    var yyval = {
        $: true,
        _$: undefined,
        yy: sharedState_yy
    };
    var p;
    var yyrulelen;
    var this_production;
    var newState;
    var retval = false;


    try {
        this.__reentrant_call_depth++;

        lexer.setInput(input, sharedState_yy);

        // NOTE: we *assume* no lexer pre/post handlers are set up *after* 
        // this initial `setInput()` call: hence we can now check and decide
        // whether we'll go with the standard, slower, lex() API or the
        // `fast_lex()` one:
        if (typeof lexer.canIUse === 'function') {
            var lexerInfo = lexer.canIUse();
            if (lexerInfo.fastLex && typeof fastLex === 'function') {
                lex = fastLex;
            }
        } 



        vstack[sp] = null;
        sstack[sp] = 0;
        stack[sp] = 0;
        ++sp;





        if (this.pre_parse) {
            this.pre_parse.call(this, sharedState_yy);
        }
        if (sharedState_yy.pre_parse) {
            sharedState_yy.pre_parse.call(this, sharedState_yy);
        }

        newState = sstack[sp - 1];
        for (;;) {
            // retrieve state number from top of stack
            state = newState;               // sstack[sp - 1];

            // use default actions if available
            if (this.defaultActions[state]) {
                action = 2;
                newState = this.defaultActions[state];
            } else {
                // The single `==` condition below covers both these `===` comparisons in a single
                // operation:
                //
                //     if (symbol === null || typeof symbol === 'undefined') ...
                if (!symbol) {
                    symbol = lex();
                }
                // read action for current state and first input
                t = (table[state] && table[state][symbol]) || NO_ACTION;
                newState = t[1];
                action = t[0];











                // handle parse error
                if (!action) {
                    var errStr;
                    var errSymbolDescr = (this.describeSymbol(symbol) || symbol);
                    var expected = this.collect_expected_token_set(state);

                    // Report error
                    if (typeof lexer.yylineno === 'number') {
                        errStr = 'Parse error on line ' + (lexer.yylineno + 1) + ': ';
                    } else {
                        errStr = 'Parse error: ';
                    }
                    if (typeof lexer.showPosition === 'function') {
                        errStr += '\n' + lexer.showPosition(79 - 10, 10) + '\n';
                    }
                    if (expected.length) {
                        errStr += 'Expecting ' + expected.join(', ') + ', got unexpected ' + errSymbolDescr;
                    } else {
                        errStr += 'Unexpected ' + errSymbolDescr;
                    }
                    // we cannot recover from the error!
                    p = this.constructParseErrorInfo(errStr, null, expected, false);
                    r = this.parseError(p.errStr, p, this.JisonParserError);
                    if (typeof r !== 'undefined') {
                        retval = r;
                    }
                    break;
                }


            }










            switch (action) {
            // catch misc. parse failures:
            default:
                // this shouldn't happen, unless resolve defaults are off
                if (action instanceof Array) {
                    p = this.constructParseErrorInfo('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol, null, null, false);
                    r = this.parseError(p.errStr, p, this.JisonParserError);
                    if (typeof r !== 'undefined') {
                        retval = r;
                    }
                    break;
                }
                // Another case of better safe than sorry: in case state transitions come out of another error recovery process
                // or a buggy LUT (LookUp Table):
                p = this.constructParseErrorInfo('Parsing halted. No viable error recovery approach available due to internal system failure.', null, null, false);
                r = this.parseError(p.errStr, p, this.JisonParserError);
                if (typeof r !== 'undefined') {
                    retval = r;
                }
                break;

            // shift:
            case 1:
                stack[sp] = symbol;
                vstack[sp] = lexer.yytext;

                sstack[sp] = newState; // push state

                ++sp;
                symbol = 0;




                // Pick up the lexer details for the current symbol as that one is not 'look-ahead' any more:




                continue;

            // reduce:
            case 2:



                this_production = this.productions_[newState - 1];  // `this.productions_[]` is zero-based indexed while states start from 1 upwards...
                yyrulelen = this_production[1];










                r = this.performAction.call(yyval, newState, sp - 1, vstack);

                if (typeof r !== 'undefined') {
                    retval = r;
                    break;
                }

                // pop off stack
                sp -= yyrulelen;

                // don't overwrite the `symbol` variable: use a local var to speed things up:
                var ntsymbol = this_production[0];    // push nonterminal (reduce)
                stack[sp] = ntsymbol;
                vstack[sp] = yyval.$;

                // goto new state = table[STATE][NONTERMINAL]
                newState = table[sstack[sp - 1]][ntsymbol];
                sstack[sp] = newState;
                ++sp;









                continue;

            // accept:
            case 3:
                if (sp !== -2) {
                    retval = true;
                    // Return the `$accept` rule's `$$` result, if available.
                    //
                    // Also note that JISON always adds this top-most `$accept` rule (with implicit,
                    // default, action):
                    //
                    //     $accept: <startSymbol> $end
                    //                  %{ $$ = $1; @$ = @1; %}
                    //
                    // which, combined with the parse kernel's `$accept` state behaviour coded below,
                    // will produce the `$$` value output of the <startSymbol> rule as the parse result,
                    // IFF that result is *not* `undefined`. (See also the parser kernel code.)
                    //
                    // In code:
                    //
                    //                  %{
                    //                      @$ = @1;            // if location tracking support is included
                    //                      if (typeof $1 !== 'undefined')
                    //                          return $1;
                    //                      else
                    //                          return true;           // the default parse result if the rule actions don't produce anything
                    //                  %}
                    sp--;
                    if (typeof vstack[sp] !== 'undefined') {
                        retval = vstack[sp];
                    }
                }
                break;
            }

            // break out of loop: we accept or fail with error
            break;
        }
    } catch (ex) {
        // report exceptions through the parseError callback too, but keep the exception intact
        // if it is a known parser or lexer error which has been thrown by parseError() already:
        if (ex instanceof this.JisonParserError) {
            throw ex;
        }
        else if (lexer && typeof lexer.JisonLexerError === 'function' && ex instanceof lexer.JisonLexerError) {
            throw ex;
        }

        p = this.constructParseErrorInfo('Parsing aborted due to exception.', ex, null, false);
        retval = false;
        r = this.parseError(p.errStr, p, this.JisonParserError);
        if (typeof r !== 'undefined') {
            retval = r;
        }
    } finally {
        retval = this.cleanupAfterParse(retval, true, true);
        this.__reentrant_call_depth--;
    }   // /finally

    return retval;
}
};
parser.originalParseError = parser.parseError;
parser.originalQuoteName = parser.quoteName;
/* lexer generated by jison-lex 0.6.1-215 */

/*
 * Returns a Lexer object of the following structure:
 *
 *  Lexer: {
 *    yy: {}     The so-called "shared state" or rather the *source* of it;
 *               the real "shared state" `yy` passed around to
 *               the rule actions, etc. is a direct reference!
 *
 *               This "shared context" object was passed to the lexer by way of 
 *               the `lexer.setInput(str, yy)` API before you may use it.
 *
 *               This "shared context" object is passed to the lexer action code in `performAction()`
 *               so userland code in the lexer actions may communicate with the outside world 
 *               and/or other lexer rules' actions in more or less complex ways.
 *
 *  }
 *
 *  Lexer.prototype: {
 *    EOF: 1,
 *    ERROR: 2,
 *
 *    yy:        The overall "shared context" object reference.
 *
 *    JisonLexerError: function(msg, hash),
 *
 *    performAction: function lexer__performAction(yy, yyrulenumber, YY_START),
 *
 *               The function parameters and `this` have the following value/meaning:
 *               - `this`    : reference to the `lexer` instance. 
 *                               `yy_` is an alias for `this` lexer instance reference used internally.
 *
 *               - `yy`      : a reference to the `yy` "shared state" object which was passed to the lexer
 *                             by way of the `lexer.setInput(str, yy)` API before.
 *
 *                             Note:
 *                             The extra arguments you specified in the `%parse-param` statement in your
 *                             **parser** grammar definition file are passed to the lexer via this object
 *                             reference as member variables.
 *
 *               - `yyrulenumber`   : index of the matched lexer rule (regex), used internally.
 *
 *               - `YY_START`: the current lexer "start condition" state.
 *
 *    parseError: function(str, hash, ExceptionClass),
 *
 *    constructLexErrorInfo: function(error_message, is_recoverable),
 *               Helper function.
 *               Produces a new errorInfo 'hash object' which can be passed into `parseError()`.
 *               See it's use in this lexer kernel in many places; example usage:
 *
 *                   var infoObj = lexer.constructParseErrorInfo('fail!', true);
 *                   var retVal = lexer.parseError(infoObj.errStr, infoObj, lexer.JisonLexerError);
 *
 *    options: { ... lexer %options ... },
 *
 *    lex: function(),
 *               Produce one token of lexed input, which was passed in earlier via the `lexer.setInput()` API.
 *               You MAY use the additional `args...` parameters as per `%parse-param` spec of the **lexer** grammar:
 *               these extra `args...` are added verbatim to the `yy` object reference as member variables.
 *
 *               WARNING:
 *               Lexer's additional `args...` parameters (via lexer's `%parse-param`) MAY conflict with
 *               any attributes already added to `yy` by the **parser** or the jison run-time; 
 *               when such a collision is detected an exception is thrown to prevent the generated run-time 
 *               from silently accepting this confusing and potentially hazardous situation! 
 *
 *    cleanupAfterLex: function(do_not_nuke_errorinfos),
 *               Helper function.
 *
 *               This helper API is invoked when the **parse process** has completed: it is the responsibility
 *               of the **parser** (or the calling userland code) to invoke this method once cleanup is desired. 
 *
 *               This helper may be invoked by user code to ensure the internal lexer gets properly garbage collected.
 *
 *    setInput: function(input, [yy]),
 *
 *
 *    input: function(),
 *
 *
 *    unput: function(str),
 *
 *
 *    more: function(),
 *
 *
 *    reject: function(),
 *
 *
 *    less: function(n),
 *
 *
 *    pastInput: function(n),
 *
 *
 *    upcomingInput: function(n),
 *
 *
 *    showPosition: function(),
 *
 *
 *    test_match: function(regex_match_array, rule_index),
 *
 *
 *    next: function(),
 *
 *
 *    begin: function(condition),
 *
 *
 *    pushState: function(condition),
 *
 *
 *    popState: function(),
 *
 *
 *    topState: function(),
 *
 *
 *    _currentRules: function(),
 *
 *
 *    stateStackSize: function(),
 *
 *
 *    performAction: function(yy, yy_, yyrulenumber, YY_START),
 *
 *
 *    rules: [...],
 *
 *
 *    conditions: {associative list: name ==> set},
 *  }
 *
 *
 *  token location info (`yylloc`): {
 *    first_line: n,
 *    last_line: n,
 *    first_column: n,
 *    last_column: n,
 *    range: [start_number, end_number]
 *               (where the numbers are indexes into the input string, zero-based)
 *  }
 *
 * ---
 *
 * The `parseError` function receives a 'hash' object with these members for lexer errors:
 *
 *  {
 *    text:        (matched text)
 *    token:       (the produced terminal token, if any)
 *    token_id:    (the produced terminal token numeric ID, if any)
 *    line:        (yylineno)
 *    loc:         (yylloc)
 *    recoverable: (boolean: TRUE when the parser MAY have an error recovery rule
 *                  available for this particular error)
 *    yy:          (object: the current parser internal "shared state" `yy`
 *                  as is also available in the rule actions; this can be used,
 *                  for instance, for advanced error analysis and reporting)
 *    lexer:       (reference to the current lexer instance used by the parser)
 *  }
 *
 * while `this` will reference the current lexer instance.
 *
 * When `parseError` is invoked by the lexer, the default implementation will
 * attempt to invoke `yy.parser.parseError()`; when this callback is not provided
 * it will try to invoke `yy.parseError()` instead. When that callback is also not
 * provided, a `JisonLexerError` exception will be thrown containing the error
 * message and `hash`, as constructed by the `constructLexErrorInfo()` API.
 *
 * Note that the lexer's `JisonLexerError` error class is passed via the
 * `ExceptionClass` argument, which is invoked to construct the exception
 * instance to be thrown, so technically `parseError` will throw the object
 * produced by the `new ExceptionClass(str, hash)` JavaScript expression.
 *
 * ---
 *
 * You can specify lexer options by setting / modifying the `.options` object of your Lexer instance.
 * These options are available:
 *
 * (Options are permanent.)
 *  
 *  yy: {
 *      parseError: function(str, hash, ExceptionClass)
 *                 optional: overrides the default `parseError` function.
 *  }
 *
 *  lexer.options: {
 *      pre_lex:  function()
 *                 optional: is invoked before the lexer is invoked to produce another token.
 *                 `this` refers to the Lexer object.
 *      post_lex: function(token) { return token; }
 *                 optional: is invoked when the lexer has produced a token `token`;
 *                 this function can override the returned token value by returning another.
 *                 When it does not return any (truthy) value, the lexer will return
 *                 the original `token`.
 *                 `this` refers to the Lexer object.
 *
 * WARNING: the next set of options are not meant to be changed. They echo the abilities of
 * the lexer as per when it was compiled!
 *
 *      ranges: boolean
 *                 optional: `true` ==> token location info will include a .range[] member.
 *      flex: boolean
 *                 optional: `true` ==> flex-like lexing behaviour where the rules are tested
 *                 exhaustively to find the longest match.
 *      backtrack_lexer: boolean
 *                 optional: `true` ==> lexer regexes are tested in order and for invoked;
 *                 the lexer terminates the scan when a token is returned by the action code.
 *      xregexp: boolean
 *                 optional: `true` ==> lexer rule regexes are "extended regex format" requiring the
 *                 `XRegExp` library. When this %option has not been specified at compile time, all lexer
 *                 rule regexes have been written as standard JavaScript RegExp expressions.
 *  }
 */


var lexer = function() {
  /**
   * See also:
   * http://stackoverflow.com/questions/1382107/whats-a-good-way-to-extend-error-in-javascript/#35881508
   * but we keep the prototype.constructor and prototype.name assignment lines too for compatibility
   * with userland code which might access the derived class in a 'classic' way.
   *
   * @public
   * @constructor
   * @nocollapse
   */
  function JisonLexerError(msg, hash) {
    Object.defineProperty(this, 'name', {
      enumerable: false,
      writable: false,
      value: 'JisonLexerError'
    });

    if (msg == null)
      msg = '???';

    Object.defineProperty(this, 'message', {
      enumerable: false,
      writable: true,
      value: msg
    });

    this.hash = hash;
    var stacktrace;

    if (hash && hash.exception instanceof Error) {
      var ex2 = hash.exception;
      this.message = ex2.message || msg;
      stacktrace = ex2.stack;
    }

    if (!stacktrace) {
      if (Error.hasOwnProperty('captureStackTrace')) {
        // V8
        Error.captureStackTrace(this, this.constructor);
      } else {
        stacktrace = new Error(msg).stack;
      }
    }

    if (stacktrace) {
      Object.defineProperty(this, 'stack', {
        enumerable: false,
        writable: false,
        value: stacktrace
      });
    }
  }

  if (typeof Object.setPrototypeOf === 'function') {
    Object.setPrototypeOf(JisonLexerError.prototype, Error.prototype);
  } else {
    JisonLexerError.prototype = Object.create(Error.prototype);
  }

  JisonLexerError.prototype.constructor = JisonLexerError;
  JisonLexerError.prototype.name = 'JisonLexerError';

  var lexer = {
    
// Code Generator Information Report
// ---------------------------------
//
// Options:
//
//   backtracking: .................... false
//   location.ranges: ................. false
//   location line+column tracking: ... true
//
//
// Forwarded Parser Analysis flags:
//
//   uses yyleng: ..................... false
//   uses yylineno: ................... false
//   uses yytext: ..................... false
//   uses yylloc: ..................... false
//   uses lexer values: ............... true / true
//   location tracking: ............... false
//   location assignment: ............. false
//
//
// Lexer Analysis flags:
//
//   uses yyleng: ..................... ???
//   uses yylineno: ................... ???
//   uses yytext: ..................... ???
//   uses yylloc: ..................... ???
//   uses ParseError API: ............. ???
//   uses yyerror: .................... ???
//   uses location tracking & editing:  ???
//   uses more() API: ................. ???
//   uses unput() API: ................ ???
//   uses reject() API: ............... ???
//   uses less() API: ................. ???
//   uses display APIs pastInput(), upcomingInput(), showPosition():
//        ............................. ???
//   uses describeYYLLOC() API: ....... ???
//
// --------- END OF REPORT -----------

EOF: 1,
    ERROR: 2,

    // JisonLexerError: JisonLexerError,        /// <-- injected by the code generator

    // options: {},                             /// <-- injected by the code generator

    // yy: ...,                                 /// <-- injected by setInput()

    __currentRuleSet__: null,                   /// INTERNAL USE ONLY: internal rule set cache for the current lexer state  

    __error_infos: [],                          /// INTERNAL USE ONLY: the set of lexErrorInfo objects created since the last cleanup  
    __decompressed: false,                      /// INTERNAL USE ONLY: mark whether the lexer instance has been 'unfolded' completely and is now ready for use  
    done: false,                                /// INTERNAL USE ONLY  
    _backtrack: false,                          /// INTERNAL USE ONLY  
    _input: '',                                 /// INTERNAL USE ONLY  
    _more: false,                               /// INTERNAL USE ONLY  
    _signaled_error_token: false,               /// INTERNAL USE ONLY  
    conditionStack: [],                         /// INTERNAL USE ONLY; managed via `pushState()`, `popState()`, `topState()` and `stateStackSize()`  
    match: '',                                  /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks input which has been matched so far for the lexer token under construction. `match` is identical to `yytext` except that this one still contains the matched input string after `lexer.performAction()` has been invoked, where userland code MAY have changed/replaced the `yytext` value entirely!  
    matched: '',                                /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks entire input which has been matched so far  
    matches: false,                             /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks RE match result for last (successful) match attempt  
    yytext: '',                                 /// ADVANCED USE ONLY: tracks input which has been matched so far for the lexer token under construction; this value is transferred to the parser as the 'token value' when the parser consumes the lexer token produced through a call to the `lex()` API.  
    offset: 0,                                  /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks the 'cursor position' in the input string, i.e. the number of characters matched so far  
    yyleng: 0,                                  /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: length of matched input for the token under construction (`yytext`)  
    yylineno: 0,                                /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: 'line number' at which the token under construction is located  
    yylloc: null,                               /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks location info (lines + columns) for the token under construction  

    /**
     * INTERNAL USE: construct a suitable error info hash object instance for `parseError`.
     * 
     * @public
     * @this {RegExpLexer}
     */
    constructLexErrorInfo: function lexer_constructLexErrorInfo(msg, recoverable, show_input_position) {
      msg = '' + msg;

      // heuristic to determine if the error message already contains a (partial) source code dump
      // as produced by either `showPosition()` or `prettyPrintRange()`:
      if (show_input_position == undefined) {
        show_input_position = !(msg.indexOf('\n') > 0 && msg.indexOf('^') > 0);
      }

      if (this.yylloc && show_input_position) {
        if (typeof this.prettyPrintRange === 'function') {
          var pretty_src = this.prettyPrintRange(this.yylloc);

          if (!/\n\s*$/.test(msg)) {
            msg += '\n';
          }

          msg += '\n  Erroneous area:\n' + this.prettyPrintRange(this.yylloc);
        } else if (typeof this.showPosition === 'function') {
          var pos_str = this.showPosition();

          if (pos_str) {
            if (msg.length && msg[msg.length - 1] !== '\n' && pos_str[0] !== '\n') {
              msg += '\n' + pos_str;
            } else {
              msg += pos_str;
            }
          }
        }
      }

      /** @constructor */
      var pei = {
        errStr: msg,
        recoverable: !!recoverable,
        text: this.match,           // This one MAY be empty; userland code should use the `upcomingInput` API to obtain more text which follows the 'lexer cursor position'...  
        token: null,
        line: this.yylineno,
        loc: this.yylloc,
        yy: this.yy,
        lexer: this,

        /**
         * and make sure the error info doesn't stay due to potential
         * ref cycle via userland code manipulations.
         * These would otherwise all be memory leak opportunities!
         * 
         * Note that only array and object references are nuked as those
         * constitute the set of elements which can produce a cyclic ref.
         * The rest of the members is kept intact as they are harmless.
         * 
         * @public
         * @this {LexErrorInfo}
         */
        destroy: function destructLexErrorInfo() {
          // remove cyclic references added to error info:
          // info.yy = null;
          // info.lexer = null;
          // ...
          var rec = !!this.recoverable;

          for (var key in this) {
            if (this.hasOwnProperty(key) && typeof key === 'object') {
              this[key] = undefined;
            }
          }

          this.recoverable = rec;
        }
      };

      // track this instance so we can `destroy()` it once we deem it superfluous and ready for garbage collection!
      this.__error_infos.push(pei);

      return pei;
    },

    /**
     * handler which is invoked when a lexer error occurs.
     * 
     * @public
     * @this {RegExpLexer}
     */
    parseError: function lexer_parseError(str, hash, ExceptionClass) {
      if (!ExceptionClass) {
        ExceptionClass = this.JisonLexerError;
      }

      if (this.yy) {
        if (this.yy.parser && typeof this.yy.parser.parseError === 'function') {
          return this.yy.parser.parseError.call(this, str, hash, ExceptionClass) || this.ERROR;
        } else if (typeof this.yy.parseError === 'function') {
          return this.yy.parseError.call(this, str, hash, ExceptionClass) || this.ERROR;
        }
      }

      throw new ExceptionClass(str, hash);
    },

    /**
     * method which implements `yyerror(str, ...args)` functionality for use inside lexer actions.
     * 
     * @public
     * @this {RegExpLexer}
     */
    yyerror: function yyError(str /*, ...args */) {
      var lineno_msg = '';

      if (this.yylloc) {
        lineno_msg = ' on line ' + (this.yylineno + 1);
      }

      var p = this.constructLexErrorInfo(
        'Lexical error' + lineno_msg + ': ' + str,
        this.options.lexerErrorsAreRecoverable
      );

      // Add any extra args to the hash under the name `extra_error_attributes`:
      var args = Array.prototype.slice.call(arguments, 1);

      if (args.length) {
        p.extra_error_attributes = args;
      }

      return this.parseError(p.errStr, p, this.JisonLexerError) || this.ERROR;
    },

    /**
     * final cleanup function for when we have completed lexing the input;
     * make it an API so that external code can use this one once userland
     * code has decided it's time to destroy any lingering lexer error
     * hash object instances and the like: this function helps to clean
     * up these constructs, which *may* carry cyclic references which would
     * otherwise prevent the instances from being properly and timely
     * garbage-collected, i.e. this function helps prevent memory leaks!
     * 
     * @public
     * @this {RegExpLexer}
     */
    cleanupAfterLex: function lexer_cleanupAfterLex(do_not_nuke_errorinfos) {
      // prevent lingering circular references from causing memory leaks:
      this.setInput('', {});

      // nuke the error hash info instances created during this run.
      // Userland code must COPY any data/references
      // in the error hash instance(s) it is more permanently interested in.
      if (!do_not_nuke_errorinfos) {
        for (var i = this.__error_infos.length - 1; i >= 0; i--) {
          var el = this.__error_infos[i];

          if (el && typeof el.destroy === 'function') {
            el.destroy();
          }
        }

        this.__error_infos.length = 0;
      }

      return this;
    },

    /**
     * clear the lexer token context; intended for internal use only
     * 
     * @public
     * @this {RegExpLexer}
     */
    clear: function lexer_clear() {
      this.yytext = '';
      this.yyleng = 0;
      this.match = '';

      // - DO NOT reset `this.matched`
      this.matches = false;

      this._more = false;
      this._backtrack = false;
      var col = (this.yylloc ? this.yylloc.last_column : 0);

      this.yylloc = {
        first_line: this.yylineno + 1,
        first_column: col,
        last_line: this.yylineno + 1,
        last_column: col,
        range: [this.offset, this.offset]
      };
    },

    /**
     * resets the lexer, sets new input
     * 
     * @public
     * @this {RegExpLexer}
     */
    setInput: function lexer_setInput(input, yy) {
      this.yy = yy || this.yy || {};

      // also check if we've fully initialized the lexer instance,
      // including expansion work to be done to go from a loaded
      // lexer to a usable lexer:
      if (!this.__decompressed) {
        // step 1: decompress the regex list:
        var rules = this.rules;

        for (var i = 0, len = rules.length; i < len; i++) {
          var rule_re = rules[i];

          // compression: is the RE an xref to another RE slot in the rules[] table?
          if (typeof rule_re === 'number') {
            rules[i] = rules[rule_re];
          }
        }

        // step 2: unfold the conditions[] set to make these ready for use:
        var conditions = this.conditions;

        for (var k in conditions) {
          var spec = conditions[k];
          var rule_ids = spec.rules;
          var len = rule_ids.length;
          var rule_regexes = new Array(len + 1);             // slot 0 is unused; we use a 1-based index approach here to keep the hottest code in `lexer_next()` fast and simple! 
          var rule_new_ids = new Array(len + 1);

          for (var i = 0; i < len; i++) {
            var idx = rule_ids[i];
            var rule_re = rules[idx];
            rule_regexes[i + 1] = rule_re;
            rule_new_ids[i + 1] = idx;
          }

          spec.rules = rule_new_ids;
          spec.__rule_regexes = rule_regexes;
          spec.__rule_count = len;
        }

        this.__decompressed = true;
      }

      this._input = input || '';
      this.clear();
      this._signaled_error_token = false;
      this.done = false;
      this.yylineno = 0;
      this.matched = '';
      this.conditionStack = ['INITIAL'];
      this.__currentRuleSet__ = null;

      this.yylloc = {
        first_line: 1,
        first_column: 0,
        last_line: 1,
        last_column: 0,
        range: [0, 0]
      };

      this.offset = 0;
      return this;
    },

    /**
     * edit the remaining input via user-specified callback.
     * This can be used to forward-adjust the input-to-parse, 
     * e.g. inserting macro expansions and alike in the
     * input which has yet to be lexed.
     * The behaviour of this API contrasts the `unput()` et al
     * APIs as those act on the *consumed* input, while this
     * one allows one to manipulate the future, without impacting
     * the current `yyloc` cursor location or any history. 
     * 
     * Use this API to help implement C-preprocessor-like
     * `#include` statements, etc.
     * 
     * The provided callback must be synchronous and is
     * expected to return the edited input (string).
     *
     * The `cpsArg` argument value is passed to the callback
     * as-is.
     *
     * `callback` interface: 
     * `function callback(input, cpsArg)`
     * 
     * - `input` will carry the remaining-input-to-lex string
     *   from the lexer.
     * - `cpsArg` is `cpsArg` passed into this API.
     * 
     * The `this` reference for the callback will be set to
     * reference this lexer instance so that userland code
     * in the callback can easily and quickly access any lexer
     * API. 
     *
     * When the callback returns a non-string-type falsey value,
     * we assume the callback did not edit the input and we
     * will using the input as-is.
     *
     * When the callback returns a non-string-type value, it
     * is converted to a string for lexing via the `"" + retval`
     * operation. (See also why: http://2ality.com/2012/03/converting-to-string.html 
     * -- that way any returned object's `toValue()` and `toString()`
     * methods will be invoked in a proper/desirable order.)
     * 
     * @public
     * @this {RegExpLexer}
     */
    editRemainingInput: function lexer_editRemainingInput(callback, cpsArg) {
      var rv = callback.call(this, this._input, cpsArg);

      if (typeof rv !== 'string') {
        if (rv) {
          this._input = '' + rv;
        } 
        // else: keep `this._input` as is.  
      } else {
        this._input = rv;
      }

      return this;
    },

    /**
     * consumes and returns one char from the input
     * 
     * @public
     * @this {RegExpLexer}
     */
    input: function lexer_input() {
      if (!this._input) {
        //this.done = true;    -- don't set `done` as we want the lex()/next() API to be able to produce one custom EOF token match after this anyhow. (lexer can match special <<EOF>> tokens and perform user action code for a <<EOF>> match, but only does so *once*)
        return null;
      }

      var ch = this._input[0];
      this.yytext += ch;
      this.yyleng++;
      this.offset++;
      this.match += ch;
      this.matched += ch;

      // Count the linenumber up when we hit the LF (or a stand-alone CR).
      // On CRLF, the linenumber is incremented when you fetch the CR or the CRLF combo
      // and we advance immediately past the LF as well, returning both together as if
      // it was all a single 'character' only.
      var slice_len = 1;

      var lines = false;

      if (ch === '\n') {
        lines = true;
      } else if (ch === '\r') {
        lines = true;
        var ch2 = this._input[1];

        if (ch2 === '\n') {
          slice_len++;
          ch += ch2;
          this.yytext += ch2;
          this.yyleng++;
          this.offset++;
          this.match += ch2;
          this.matched += ch2;
          this.yylloc.range[1]++;
        }
      }

      if (lines) {
        this.yylineno++;
        this.yylloc.last_line++;
        this.yylloc.last_column = 0;
      } else {
        this.yylloc.last_column++;
      }

      this.yylloc.range[1]++;
      this._input = this._input.slice(slice_len);
      return ch;
    },

    /**
     * unshifts one char (or an entire string) into the input
     * 
     * @public
     * @this {RegExpLexer}
     */
    unput: function lexer_unput(ch) {
      var len = ch.length;
      var lines = ch.split(/(?:\r\n?|\n)/g);
      this._input = ch + this._input;
      this.yytext = this.yytext.substr(0, this.yytext.length - len);
      this.yyleng = this.yytext.length;
      this.offset -= len;
      this.match = this.match.substr(0, this.match.length - len);
      this.matched = this.matched.substr(0, this.matched.length - len);

      if (lines.length > 1) {
        this.yylineno -= lines.length - 1;
        this.yylloc.last_line = this.yylineno + 1;

        // Get last entirely matched line into the `pre_lines[]` array's
        // last index slot; we don't mind when other previously 
        // matched lines end up in the array too. 
        var pre = this.match;

        var pre_lines = pre.split(/(?:\r\n?|\n)/g);

        if (pre_lines.length === 1) {
          pre = this.matched;
          pre_lines = pre.split(/(?:\r\n?|\n)/g);
        }

        this.yylloc.last_column = pre_lines[pre_lines.length - 1].length;
      } else {
        this.yylloc.last_column -= len;
      }

      this.yylloc.range[1] = this.yylloc.range[0] + this.yyleng;
      this.done = false;
      return this;
    },

    /**
     * cache matched text and append it on next action
     * 
     * @public
     * @this {RegExpLexer}
     */
    more: function lexer_more() {
      this._more = true;
      return this;
    },

    /**
     * signal the lexer that this rule fails to match the input, so the
     * next matching rule (regex) should be tested instead.
     * 
     * @public
     * @this {RegExpLexer}
     */
    reject: function lexer_reject() {
      if (this.options.backtrack_lexer) {
        this._backtrack = true;
      } else {
        // when the `parseError()` call returns, we MUST ensure that the error is registered.
        // We accomplish this by signaling an 'error' token to be produced for the current
        // `.lex()` run.
        var lineno_msg = '';

        if (this.yylloc) {
          lineno_msg = ' on line ' + (this.yylineno + 1);
        }

        var p = this.constructLexErrorInfo(
          'Lexical error' + lineno_msg + ': You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).',
          false
        );

        this._signaled_error_token = this.parseError(p.errStr, p, this.JisonLexerError) || this.ERROR;
      }

      return this;
    },

    /**
     * retain first n characters of the match
     * 
     * @public
     * @this {RegExpLexer}
     */
    less: function lexer_less(n) {
      return this.unput(this.match.slice(n));
    },

    /**
     * return (part of the) already matched input, i.e. for error
     * messages.
     * 
     * Limit the returned string length to `maxSize` (default: 20).
     * 
     * Limit the returned string to the `maxLines` number of lines of
     * input (default: 1).
     * 
     * Negative limit values equal *unlimited*.
     * 
     * @public
     * @this {RegExpLexer}
     */
    pastInput: function lexer_pastInput(maxSize, maxLines) {
      var past = this.matched.substring(0, this.matched.length - this.match.length);

      if (maxSize < 0)
        maxSize = past.length;
      else if (!maxSize)
        maxSize = 20;

      if (maxLines < 0)
        maxLines = past.length;          // can't ever have more input lines than this! 
      else if (!maxLines)
        maxLines = 1;

      // `substr` anticipation: treat \r\n as a single character and take a little
      // more than necessary so that we can still properly check against maxSize
      // after we've transformed and limited the newLines in here:
      past = past.substr(-maxSize * 2 - 2);

      // now that we have a significantly reduced string to process, transform the newlines
      // and chop them, then limit them:
      var a = past.replace(/\r\n|\r/g, '\n').split('\n');

      a = a.slice(-maxLines);
      past = a.join('\n');

      // When, after limiting to maxLines, we still have too much to return,
      // do add an ellipsis prefix...
      if (past.length > maxSize) {
        past = '...' + past.substr(-maxSize);
      }

      return past;
    },

    /**
     * return (part of the) upcoming input, i.e. for error messages.
     * 
     * Limit the returned string length to `maxSize` (default: 20).
     * 
     * Limit the returned string to the `maxLines` number of lines of input (default: 1).
     * 
     * Negative limit values equal *unlimited*.
     *
     * > ### NOTE ###
     * >
     * > *"upcoming input"* is defined as the whole of the both
     * > the *currently lexed* input, together with any remaining input
     * > following that. *"currently lexed"* input is the input 
     * > already recognized by the lexer but not yet returned with
     * > the lexer token. This happens when you are invoking this API
     * > from inside any lexer rule action code block. 
     * >
     * 
     * @public
     * @this {RegExpLexer}
     */
    upcomingInput: function lexer_upcomingInput(maxSize, maxLines) {
      var next = this.match;

      if (maxSize < 0)
        maxSize = next.length + this._input.length;
      else if (!maxSize)
        maxSize = 20;

      if (maxLines < 0)
        maxLines = maxSize;          // can't ever have more input lines than this! 
      else if (!maxLines)
        maxLines = 1;

      // `substring` anticipation: treat \r\n as a single character and take a little
      // more than necessary so that we can still properly check against maxSize
      // after we've transformed and limited the newLines in here:
      if (next.length < maxSize * 2 + 2) {
        next += this._input.substring(0, maxSize * 2 + 2);   // substring is faster on Chrome/V8 
      }

      // now that we have a significantly reduced string to process, transform the newlines
      // and chop them, then limit them:
      var a = next.replace(/\r\n|\r/g, '\n').split('\n');

      a = a.slice(0, maxLines);
      next = a.join('\n');

      // When, after limiting to maxLines, we still have too much to return,
      // do add an ellipsis postfix...
      if (next.length > maxSize) {
        next = next.substring(0, maxSize) + '...';
      }

      return next;
    },

    /**
     * return a string which displays the character position where the
     * lexing error occurred, i.e. for error messages
     * 
     * @public
     * @this {RegExpLexer}
     */
    showPosition: function lexer_showPosition(maxPrefix, maxPostfix) {
      var pre = this.pastInput(maxPrefix).replace(/\s/g, ' ');
      var c = new Array(pre.length + 1).join('-');
      return pre + this.upcomingInput(maxPostfix).replace(/\s/g, ' ') + '\n' + c + '^';
    },

    /**
     * return an YYLLOC info object derived off the given context (actual, preceding, following, current).
     * Use this method when the given `actual` location is not guaranteed to exist (i.e. when
     * it MAY be NULL) and you MUST have a valid location info object anyway:
     * then we take the given context of the `preceding` and `following` locations, IFF those are available,
     * and reconstruct the `actual` location info from those.
     * If this fails, the heuristic is to take the `current` location, IFF available.
     * If this fails as well, we assume the sought location is at/around the current lexer position
     * and then produce that one as a response. DO NOTE that these heuristic/derived location info
     * values MAY be inaccurate!
     *
     * NOTE: `deriveLocationInfo()` ALWAYS produces a location info object *copy* of `actual`, not just
     * a *reference* hence all input location objects can be assumed to be 'constant' (function has no side-effects).
     * 
     * @public
     * @this {RegExpLexer}
     */
    deriveLocationInfo: function lexer_deriveYYLLOC(actual, preceding, following, current) {
      var loc = {
        first_line: 1,
        first_column: 0,
        last_line: 1,
        last_column: 0,
        range: [0, 0]
      };

      if (actual) {
        loc.first_line = actual.first_line | 0;
        loc.last_line = actual.last_line | 0;
        loc.first_column = actual.first_column | 0;
        loc.last_column = actual.last_column | 0;

        if (actual.range) {
          loc.range[0] = actual.range[0] | 0;
          loc.range[1] = actual.range[1] | 0;
        }
      }

      if (loc.first_line <= 0 || loc.last_line < loc.first_line) {
        // plan B: heuristic using preceding and following:
        if (loc.first_line <= 0 && preceding) {
          loc.first_line = preceding.last_line | 0;
          loc.first_column = preceding.last_column | 0;

          if (preceding.range) {
            loc.range[0] = actual.range[1] | 0;
          }
        }

        if ((loc.last_line <= 0 || loc.last_line < loc.first_line) && following) {
          loc.last_line = following.first_line | 0;
          loc.last_column = following.first_column | 0;

          if (following.range) {
            loc.range[1] = actual.range[0] | 0;
          }
        }

        // plan C?: see if the 'current' location is useful/sane too:
        if (loc.first_line <= 0 && current && (loc.last_line <= 0 || current.last_line <= loc.last_line)) {
          loc.first_line = current.first_line | 0;
          loc.first_column = current.first_column | 0;

          if (current.range) {
            loc.range[0] = current.range[0] | 0;
          }
        }

        if (loc.last_line <= 0 && current && (loc.first_line <= 0 || current.first_line >= loc.first_line)) {
          loc.last_line = current.last_line | 0;
          loc.last_column = current.last_column | 0;

          if (current.range) {
            loc.range[1] = current.range[1] | 0;
          }
        }
      }

      // sanitize: fix last_line BEFORE we fix first_line as we use the 'raw' value of the latter
      // or plan D heuristics to produce a 'sensible' last_line value:
      if (loc.last_line <= 0) {
        if (loc.first_line <= 0) {
          loc.first_line = this.yylloc.first_line;
          loc.last_line = this.yylloc.last_line;
          loc.first_column = this.yylloc.first_column;
          loc.last_column = this.yylloc.last_column;
          loc.range[0] = this.yylloc.range[0];
          loc.range[1] = this.yylloc.range[1];
        } else {
          loc.last_line = this.yylloc.last_line;
          loc.last_column = this.yylloc.last_column;
          loc.range[1] = this.yylloc.range[1];
        }
      }

      if (loc.first_line <= 0) {
        loc.first_line = loc.last_line;
        loc.first_column = 0;  // loc.last_column; 
        loc.range[1] = loc.range[0];
      }

      if (loc.first_column < 0) {
        loc.first_column = 0;
      }

      if (loc.last_column < 0) {
        loc.last_column = (loc.first_column > 0 ? loc.first_column : 80);
      }

      return loc;
    },

    /**
     * return a string which displays the lines & columns of input which are referenced 
     * by the given location info range, plus a few lines of context.
     * 
     * This function pretty-prints the indicated section of the input, with line numbers 
     * and everything!
     * 
     * This function is very useful to provide highly readable error reports, while
     * the location range may be specified in various flexible ways:
     * 
     * - `loc` is the location info object which references the area which should be
     *   displayed and 'marked up': these lines & columns of text are marked up by `^`
     *   characters below each character in the entire input range.
     * 
     * - `context_loc` is the *optional* location info object which instructs this
     *   pretty-printer how much *leading* context should be displayed alongside
     *   the area referenced by `loc`. This can help provide context for the displayed
     *   error, etc.
     * 
     *   When this location info is not provided, a default context of 3 lines is
     *   used.
     * 
     * - `context_loc2` is another *optional* location info object, which serves
     *   a similar purpose to `context_loc`: it specifies the amount of *trailing*
     *   context lines to display in the pretty-print output.
     * 
     *   When this location info is not provided, a default context of 1 line only is
     *   used.
     * 
     * Special Notes:
     * 
     * - when the `loc`-indicated range is very large (about 5 lines or more), then
     *   only the first and last few lines of this block are printed while a
     *   `...continued...` message will be printed between them.
     * 
     *   This serves the purpose of not printing a huge amount of text when the `loc`
     *   range happens to be huge: this way a manageable & readable output results
     *   for arbitrary large ranges.
     * 
     * - this function can display lines of input which whave not yet been lexed.
     *   `prettyPrintRange()` can access the entire input!
     * 
     * @public
     * @this {RegExpLexer}
     */
    prettyPrintRange: function lexer_prettyPrintRange(loc, context_loc, context_loc2) {
      loc = this.deriveLocationInfo(loc, context_loc, context_loc2);
      const CONTEXT = 3;
      const CONTEXT_TAIL = 1;
      const MINIMUM_VISIBLE_NONEMPTY_LINE_COUNT = 2;
      var input = this.matched + this._input;
      var lines = input.split('\n');
      var l0 = Math.max(1, (context_loc ? context_loc.first_line : loc.first_line - CONTEXT));
      var l1 = Math.max(1, (context_loc2 ? context_loc2.last_line : loc.last_line + CONTEXT_TAIL));
      var lineno_display_width = 1 + Math.log10(l1 | 1) | 0;
      var ws_prefix = new Array(lineno_display_width).join(' ');
      var nonempty_line_indexes = [];

      var rv = lines.slice(l0 - 1, l1 + 1).map(function injectLineNumber(line, index) {
        var lno = index + l0;
        var lno_pfx = (ws_prefix + lno).substr(-lineno_display_width);
        var rv = lno_pfx + ': ' + line;
        var errpfx = new Array(lineno_display_width + 1).join('^');
        var offset = 2 + 1;
        var len = 0;

        if (lno === loc.first_line) {
          offset += loc.first_column;

          len = Math.max(
            2,
            ((lno === loc.last_line ? loc.last_column : line.length)) - loc.first_column + 1
          );
        } else if (lno === loc.last_line) {
          len = Math.max(2, loc.last_column + 1);
        } else if (lno > loc.first_line && lno < loc.last_line) {
          len = Math.max(2, line.length + 1);
        }

        if (len) {
          var lead = new Array(offset).join('.');
          var mark = new Array(len).join('^');
          rv += '\n' + errpfx + lead + mark;

          if (line.trim().length > 0) {
            nonempty_line_indexes.push(index);
          }
        }

        rv = rv.replace(/\t/g, ' ');
        return rv;
      });

      // now make sure we don't print an overly large amount of error area: limit it 
      // to the top and bottom line count:
      if (nonempty_line_indexes.length > 2 * MINIMUM_VISIBLE_NONEMPTY_LINE_COUNT) {
        var clip_start = nonempty_line_indexes[MINIMUM_VISIBLE_NONEMPTY_LINE_COUNT - 1] + 1;
        var clip_end = nonempty_line_indexes[nonempty_line_indexes.length - MINIMUM_VISIBLE_NONEMPTY_LINE_COUNT] - 1;
        var intermediate_line = new Array(lineno_display_width + 1).join(' ') + '  (...continued...)';
        intermediate_line += '\n' + new Array(lineno_display_width + 1).join('-') + '  (---------------)';
        rv.splice(clip_start, clip_end - clip_start + 1, intermediate_line);
      }

      return rv.join('\n');
    },

    /**
     * helper function, used to produce a human readable description as a string, given
     * the input `yylloc` location object.
     * 
     * Set `display_range_too` to TRUE to include the string character index position(s)
     * in the description if the `yylloc.range` is available.
     * 
     * @public
     * @this {RegExpLexer}
     */
    describeYYLLOC: function lexer_describe_yylloc(yylloc, display_range_too) {
      var l1 = yylloc.first_line;
      var l2 = yylloc.last_line;
      var c1 = yylloc.first_column;
      var c2 = yylloc.last_column;
      var dl = l2 - l1;
      var dc = c2 - c1;
      var rv;

      if (dl === 0) {
        rv = 'line ' + l1 + ', ';

        if (dc <= 1) {
          rv += 'column ' + c1;
        } else {
          rv += 'columns ' + c1 + ' .. ' + c2;
        }
      } else {
        rv = 'lines ' + l1 + '(column ' + c1 + ') .. ' + l2 + '(column ' + c2 + ')';
      }

      if (yylloc.range && display_range_too) {
        var r1 = yylloc.range[0];
        var r2 = yylloc.range[1] - 1;

        if (r2 <= r1) {
          rv += ' {String Offset: ' + r1 + '}';
        } else {
          rv += ' {String Offset range: ' + r1 + ' .. ' + r2 + '}';
        }
      }

      return rv;
    },

    /**
     * test the lexed token: return FALSE when not a match, otherwise return token.
     * 
     * `match` is supposed to be an array coming out of a regex match, i.e. `match[0]`
     * contains the actually matched text string.
     * 
     * Also move the input cursor forward and update the match collectors:
     * 
     * - `yytext`
     * - `yyleng`
     * - `match`
     * - `matches`
     * - `yylloc`
     * - `offset`
     * 
     * @public
     * @this {RegExpLexer}
     */
    test_match: function lexer_test_match(match, indexed_rule) {
      var token, lines, backup, match_str, match_str_len;

      if (this.options.backtrack_lexer) {
        // save context
        backup = {
          yylineno: this.yylineno,

          yylloc: {
            first_line: this.yylloc.first_line,
            last_line: this.yylloc.last_line,
            first_column: this.yylloc.first_column,
            last_column: this.yylloc.last_column,
            range: this.yylloc.range.slice(0)
          },

          yytext: this.yytext,
          match: this.match,
          matches: this.matches,
          matched: this.matched,
          yyleng: this.yyleng,
          offset: this.offset,
          _more: this._more,
          _input: this._input,

          //_signaled_error_token: this._signaled_error_token,
          yy: this.yy,

          conditionStack: this.conditionStack.slice(0),
          done: this.done
        };
      }

      match_str = match[0];
      match_str_len = match_str.length;

      // if (match_str.indexOf('\n') !== -1 || match_str.indexOf('\r') !== -1) {
      lines = match_str.split(/(?:\r\n?|\n)/g);

      if (lines.length > 1) {
        this.yylineno += lines.length - 1;
        this.yylloc.last_line = this.yylineno + 1;
        this.yylloc.last_column = lines[lines.length - 1].length;
      } else {
        this.yylloc.last_column += match_str_len;
      }

      // }
      this.yytext += match_str;

      this.match += match_str;
      this.matched += match_str;
      this.matches = match;
      this.yyleng = this.yytext.length;
      this.yylloc.range[1] += match_str_len;

      // previous lex rules MAY have invoked the `more()` API rather than producing a token:
      // those rules will already have moved this `offset` forward matching their match lengths,
      // hence we must only add our own match length now:
      this.offset += match_str_len;

      this._more = false;
      this._backtrack = false;
      this._input = this._input.slice(match_str_len);

      // calling this method:
      //
      //   function lexer__performAction(yy, yyrulenumber, YY_START) {...}
      token = this.performAction.call(
        this,
        this.yy,
        indexed_rule,
        this.conditionStack[this.conditionStack.length - 1] /* = YY_START */
      );

      // otherwise, when the action codes are all simple return token statements:
      //token = this.simpleCaseActionClusters[indexed_rule];

      if (this.done && this._input) {
        this.done = false;
      }

      if (token) {
        return token;
      } else if (this._backtrack) {
        // recover context
        for (var k in backup) {
          this[k] = backup[k];
        }

        this.__currentRuleSet__ = null;
        return false;  // rule action called reject() implying the next rule should be tested instead. 
      } else if (this._signaled_error_token) {
        // produce one 'error' token as `.parseError()` in `reject()`
        // did not guarantee a failure signal by throwing an exception!
        token = this._signaled_error_token;

        this._signaled_error_token = false;
        return token;
      }

      return false;
    },

    /**
     * return next match in input
     * 
     * @public
     * @this {RegExpLexer}
     */
    next: function lexer_next() {
      if (this.done) {
        this.clear();
        return this.EOF;
      }

      if (!this._input) {
        this.done = true;
      }

      var token, match, tempMatch, index;

      if (!this._more) {
        this.clear();
      }

      var spec = this.__currentRuleSet__;

      if (!spec) {
        // Update the ruleset cache as we apparently encountered a state change or just started lexing.
        // The cache is set up for fast lookup -- we assume a lexer will switch states much less often than it will
        // invoke the `lex()` token-producing API and related APIs, hence caching the set for direct access helps
        // speed up those activities a tiny bit.
        spec = this.__currentRuleSet__ = this._currentRules();

        // Check whether a *sane* condition has been pushed before: this makes the lexer robust against
        // user-programmer bugs such as https://github.com/zaach/jison-lex/issues/19
        if (!spec || !spec.rules) {
          var lineno_msg = '';

          if (this.options.trackPosition) {
            lineno_msg = ' on line ' + (this.yylineno + 1);
          }

          var p = this.constructLexErrorInfo(
            'Internal lexer engine error' + lineno_msg + ': The lex grammar programmer pushed a non-existing condition name "' + this.topState() + '"; this is a fatal error and should be reported to the application programmer team!',
            false
          );

          // produce one 'error' token until this situation has been resolved, most probably by parse termination!
          return this.parseError(p.errStr, p, this.JisonLexerError) || this.ERROR;
        }
      }

      var rule_ids = spec.rules;
      var regexes = spec.__rule_regexes;
      var len = spec.__rule_count;

      // Note: the arrays are 1-based, while `len` itself is a valid index,
      // hence the non-standard less-or-equal check in the next loop condition!
      for (var i = 1; i <= len; i++) {
        tempMatch = this._input.match(regexes[i]);

        if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
          match = tempMatch;
          index = i;

          if (this.options.backtrack_lexer) {
            token = this.test_match(tempMatch, rule_ids[i]);

            if (token !== false) {
              return token;
            } else if (this._backtrack) {
              match = undefined;
              continue;  // rule action called reject() implying a rule MISmatch. 
            } else {
              // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
              return false;
            }
          } else if (!this.options.flex) {
            break;
          }
        }
      }

      if (match) {
        token = this.test_match(match, rule_ids[index]);

        if (token !== false) {
          return token;
        }

        // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
        return false;
      }

      if (!this._input) {
        this.done = true;
        this.clear();
        return this.EOF;
      } else {
        var lineno_msg = '';

        if (this.options.trackPosition) {
          lineno_msg = ' on line ' + (this.yylineno + 1);
        }

        var p = this.constructLexErrorInfo(
          'Lexical error' + lineno_msg + ': Unrecognized text.',
          this.options.lexerErrorsAreRecoverable
        );

        var pendingInput = this._input;
        var activeCondition = this.topState();
        var conditionStackDepth = this.conditionStack.length;
        token = this.parseError(p.errStr, p, this.JisonLexerError) || this.ERROR;

        if (token === this.ERROR) {
          // we can try to recover from a lexer error that `parseError()` did not 'recover' for us
          // by moving forward at least one character at a time IFF the (user-specified?) `parseError()`
          // has not consumed/modified any pending input or changed state in the error handler:
          if (!this.matches && // and make sure the input has been modified/consumed ...
          pendingInput === this._input && // ...or the lexer state has been modified significantly enough
          // to merit a non-consuming error handling action right now.
          activeCondition === this.topState() && conditionStackDepth === this.conditionStack.length) {
            this.input();
          }
        }

        return token;
      }
    },

    /**
     * return next match that has a token
     * 
     * @public
     * @this {RegExpLexer}
     */
    lex: function lexer_lex() {
      var r;

      // allow the PRE/POST handlers set/modify the return token for maximum flexibility of the generated lexer:
      if (typeof this.pre_lex === 'function') {
        r = this.pre_lex.call(this, 0);
      }

      if (typeof this.options.pre_lex === 'function') {
        // (also account for a userdef function which does not return any value: keep the token as is)
        r = this.options.pre_lex.call(this, r) || r;
      }

      if (this.yy && typeof this.yy.pre_lex === 'function') {
        // (also account for a userdef function which does not return any value: keep the token as is)
        r = this.yy.pre_lex.call(this, r) || r;
      }

      while (!r) {
        r = this.next();
      }

      if (this.yy && typeof this.yy.post_lex === 'function') {
        // (also account for a userdef function which does not return any value: keep the token as is)
        r = this.yy.post_lex.call(this, r) || r;
      }

      if (typeof this.options.post_lex === 'function') {
        // (also account for a userdef function which does not return any value: keep the token as is)
        r = this.options.post_lex.call(this, r) || r;
      }

      if (typeof this.post_lex === 'function') {
        // (also account for a userdef function which does not return any value: keep the token as is)
        r = this.post_lex.call(this, r) || r;
      }

      return r;
    },

    /**
     * return next match that has a token. Identical to the `lex()` API but does not invoke any of the 
     * `pre_lex()` nor any of the `post_lex()` callbacks.
     * 
     * @public
     * @this {RegExpLexer}
     */
    fastLex: function lexer_fastLex() {
      var r;

      while (!r) {
        r = this.next();
      }

      return r;
    },

    /**
     * return info about the lexer state that can help a parser or other lexer API user to use the
     * most efficient means available. This API is provided to aid run-time performance for larger
     * systems which employ this lexer.
     * 
     * @public
     * @this {RegExpLexer}
     */
    canIUse: function lexer_canIUse() {
      var rv = {
        fastLex: !(typeof this.pre_lex === 'function' || typeof this.options.pre_lex === 'function' || this.yy && typeof this.yy.pre_lex === 'function' || this.yy && typeof this.yy.post_lex === 'function' || typeof this.options.post_lex === 'function' || typeof this.post_lex === 'function') && typeof this.fastLex === 'function'
      };

      return rv;
    },

    /**
     * backwards compatible alias for `pushState()`;
     * the latter is symmetrical with `popState()` and we advise to use
     * those APIs in any modern lexer code, rather than `begin()`.
     * 
     * @public
     * @this {RegExpLexer}
     */
    begin: function lexer_begin(condition) {
      return this.pushState(condition);
    },

    /**
     * activates a new lexer condition state (pushes the new lexer
     * condition state onto the condition stack)
     * 
     * @public
     * @this {RegExpLexer}
     */
    pushState: function lexer_pushState(condition) {
      this.conditionStack.push(condition);
      this.__currentRuleSet__ = null;
      return this;
    },

    /**
     * pop the previously active lexer condition state off the condition
     * stack
     * 
     * @public
     * @this {RegExpLexer}
     */
    popState: function lexer_popState() {
      var n = this.conditionStack.length - 1;

      if (n > 0) {
        this.__currentRuleSet__ = null;
        return this.conditionStack.pop();
      } else {
        return this.conditionStack[0];
      }
    },

    /**
     * return the currently active lexer condition state; when an index
     * argument is provided it produces the N-th previous condition state,
     * if available
     * 
     * @public
     * @this {RegExpLexer}
     */
    topState: function lexer_topState(n) {
      n = this.conditionStack.length - 1 - Math.abs(n || 0);

      if (n >= 0) {
        return this.conditionStack[n];
      } else {
        return 'INITIAL';
      }
    },

    /**
     * (internal) determine the lexer rule set which is active for the
     * currently active lexer condition state
     * 
     * @public
     * @this {RegExpLexer}
     */
    _currentRules: function lexer__currentRules() {
      if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
        return this.conditions[this.conditionStack[this.conditionStack.length - 1]];
      } else {
        return this.conditions['INITIAL'];
      }
    },

    /**
     * return the number of states currently on the stack
     * 
     * @public
     * @this {RegExpLexer}
     */
    stateStackSize: function lexer_stateStackSize() {
      return this.conditionStack.length;
    },

    options: {
      trackPosition: true
    },

    JisonLexerError: JisonLexerError,

    performAction: function lexer__performAction(yy, yyrulenumber, YY_START) {
      var yy_ = this;
      var YYSTATE = YY_START;

      switch (yyrulenumber) {
      case 0:
        /*! Conditions:: INITIAL */
        /*! Rule::       \s+ */
        /* skip whitespace */
        break;

      default:
        return this.simpleCaseActionClusters[yyrulenumber];
      }
    },

    simpleCaseActionClusters: {
      /*! Conditions:: INITIAL */
      /*! Rule::       (-(webkit|moz)-)?calc\b */
      1: 3,

      /*! Conditions:: INITIAL */
      /*! Rule::       [a-z][a-z0-9-]*\s*\((?:(?:"(?:\\.|[^\"\\])*"|'(?:\\.|[^\'\\])*')|\([^)]*\)|[^\(\)]*)*\) */
      2: 11,

      /*! Conditions:: INITIAL */
      /*! Rule::       \* */
      3: 8,

      /*! Conditions:: INITIAL */
      /*! Rule::       \/ */
      4: 9,

      /*! Conditions:: INITIAL */
      /*! Rule::       \+ */
      5: 6,

      /*! Conditions:: INITIAL */
      /*! Rule::       - */
      6: 7,

      /*! Conditions:: INITIAL */
      /*! Rule::       ([0-9]+(\.[0-9]+)?|\.[0-9]+)px\b */
      7: 12,

      /*! Conditions:: INITIAL */
      /*! Rule::       ([0-9]+(\.[0-9]+)?|\.[0-9]+)cm\b */
      8: 12,

      /*! Conditions:: INITIAL */
      /*! Rule::       ([0-9]+(\.[0-9]+)?|\.[0-9]+)mm\b */
      9: 12,

      /*! Conditions:: INITIAL */
      /*! Rule::       ([0-9]+(\.[0-9]+)?|\.[0-9]+)in\b */
      10: 12,

      /*! Conditions:: INITIAL */
      /*! Rule::       ([0-9]+(\.[0-9]+)?|\.[0-9]+)pt\b */
      11: 12,

      /*! Conditions:: INITIAL */
      /*! Rule::       ([0-9]+(\.[0-9]+)?|\.[0-9]+)pc\b */
      12: 12,

      /*! Conditions:: INITIAL */
      /*! Rule::       ([0-9]+(\.[0-9]+)?|\.[0-9]+)deg\b */
      13: 13,

      /*! Conditions:: INITIAL */
      /*! Rule::       ([0-9]+(\.[0-9]+)?|\.[0-9]+)grad\b */
      14: 13,

      /*! Conditions:: INITIAL */
      /*! Rule::       ([0-9]+(\.[0-9]+)?|\.[0-9]+)rad\b */
      15: 13,

      /*! Conditions:: INITIAL */
      /*! Rule::       ([0-9]+(\.[0-9]+)?|\.[0-9]+)turn\b */
      16: 13,

      /*! Conditions:: INITIAL */
      /*! Rule::       ([0-9]+(\.[0-9]+)?|\.[0-9]+)s\b */
      17: 14,

      /*! Conditions:: INITIAL */
      /*! Rule::       ([0-9]+(\.[0-9]+)?|\.[0-9]+)ms\b */
      18: 14,

      /*! Conditions:: INITIAL */
      /*! Rule::       ([0-9]+(\.[0-9]+)?|\.[0-9]+)Hz\b */
      19: 15,

      /*! Conditions:: INITIAL */
      /*! Rule::       ([0-9]+(\.[0-9]+)?|\.[0-9]+)kHz\b */
      20: 15,

      /*! Conditions:: INITIAL */
      /*! Rule::       ([0-9]+(\.[0-9]+)?|\.[0-9]+)dpi\b */
      21: 16,

      /*! Conditions:: INITIAL */
      /*! Rule::       ([0-9]+(\.[0-9]+)?|\.[0-9]+)dpcm\b */
      22: 16,

      /*! Conditions:: INITIAL */
      /*! Rule::       ([0-9]+(\.[0-9]+)?|\.[0-9]+)dppx\b */
      23: 16,

      /*! Conditions:: INITIAL */
      /*! Rule::       ([0-9]+(\.[0-9]+)?|\.[0-9]+)em\b */
      24: 17,

      /*! Conditions:: INITIAL */
      /*! Rule::       ([0-9]+(\.[0-9]+)?|\.[0-9]+)ex\b */
      25: 18,

      /*! Conditions:: INITIAL */
      /*! Rule::       ([0-9]+(\.[0-9]+)?|\.[0-9]+)ch\b */
      26: 19,

      /*! Conditions:: INITIAL */
      /*! Rule::       ([0-9]+(\.[0-9]+)?|\.[0-9]+)rem\b */
      27: 20,

      /*! Conditions:: INITIAL */
      /*! Rule::       ([0-9]+(\.[0-9]+)?|\.[0-9]+)vw\b */
      28: 22,

      /*! Conditions:: INITIAL */
      /*! Rule::       ([0-9]+(\.[0-9]+)?|\.[0-9]+)vh\b */
      29: 21,

      /*! Conditions:: INITIAL */
      /*! Rule::       ([0-9]+(\.[0-9]+)?|\.[0-9]+)vmin\b */
      30: 23,

      /*! Conditions:: INITIAL */
      /*! Rule::       ([0-9]+(\.[0-9]+)?|\.[0-9]+)vmax\b */
      31: 24,

      /*! Conditions:: INITIAL */
      /*! Rule::       ([0-9]+(\.[0-9]+)?|\.[0-9]+)% */
      32: 25,

      /*! Conditions:: INITIAL */
      /*! Rule::       ([0-9]+(\.[0-9]+)?|\.[0-9]+)\b */
      33: 10,

      /*! Conditions:: INITIAL */
      /*! Rule::       \( */
      34: 4,

      /*! Conditions:: INITIAL */
      /*! Rule::       \) */
      35: 5,

      /*! Conditions:: INITIAL */
      /*! Rule::       $ */
      36: 1
    },

    rules: [
      /*  0: */  /^(?:\s+)/,
      /*  1: */  /^(?:(-(webkit|moz)-)?calc\b)/,
      /*  2: */  /^(?:[a-z][\d\-a-z]*\s*\((?:(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*')|\([^)]*\)|[^()]*)*\))/,
      /*  3: */  /^(?:\*)/,
      /*  4: */  /^(?:\/)/,
      /*  5: */  /^(?:\+)/,
      /*  6: */  /^(?:-)/,
      /*  7: */  /^(?:(\d+(\.\d+)?|\.\d+)px\b)/,
      /*  8: */  /^(?:(\d+(\.\d+)?|\.\d+)cm\b)/,
      /*  9: */  /^(?:(\d+(\.\d+)?|\.\d+)mm\b)/,
      /* 10: */  /^(?:(\d+(\.\d+)?|\.\d+)in\b)/,
      /* 11: */  /^(?:(\d+(\.\d+)?|\.\d+)pt\b)/,
      /* 12: */  /^(?:(\d+(\.\d+)?|\.\d+)pc\b)/,
      /* 13: */  /^(?:(\d+(\.\d+)?|\.\d+)deg\b)/,
      /* 14: */  /^(?:(\d+(\.\d+)?|\.\d+)grad\b)/,
      /* 15: */  /^(?:(\d+(\.\d+)?|\.\d+)rad\b)/,
      /* 16: */  /^(?:(\d+(\.\d+)?|\.\d+)turn\b)/,
      /* 17: */  /^(?:(\d+(\.\d+)?|\.\d+)s\b)/,
      /* 18: */  /^(?:(\d+(\.\d+)?|\.\d+)ms\b)/,
      /* 19: */  /^(?:(\d+(\.\d+)?|\.\d+)Hz\b)/,
      /* 20: */  /^(?:(\d+(\.\d+)?|\.\d+)kHz\b)/,
      /* 21: */  /^(?:(\d+(\.\d+)?|\.\d+)dpi\b)/,
      /* 22: */  /^(?:(\d+(\.\d+)?|\.\d+)dpcm\b)/,
      /* 23: */  /^(?:(\d+(\.\d+)?|\.\d+)dppx\b)/,
      /* 24: */  /^(?:(\d+(\.\d+)?|\.\d+)em\b)/,
      /* 25: */  /^(?:(\d+(\.\d+)?|\.\d+)ex\b)/,
      /* 26: */  /^(?:(\d+(\.\d+)?|\.\d+)ch\b)/,
      /* 27: */  /^(?:(\d+(\.\d+)?|\.\d+)rem\b)/,
      /* 28: */  /^(?:(\d+(\.\d+)?|\.\d+)vw\b)/,
      /* 29: */  /^(?:(\d+(\.\d+)?|\.\d+)vh\b)/,
      /* 30: */  /^(?:(\d+(\.\d+)?|\.\d+)vmin\b)/,
      /* 31: */  /^(?:(\d+(\.\d+)?|\.\d+)vmax\b)/,
      /* 32: */  /^(?:(\d+(\.\d+)?|\.\d+)%)/,
      /* 33: */  /^(?:(\d+(\.\d+)?|\.\d+)\b)/,
      /* 34: */  /^(?:\()/,
      /* 35: */  /^(?:\))/,
      /* 36: */  /^(?:$)/
    ],

    conditions: {
      'INITIAL': {
        rules: [
          0,
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11,
          12,
          13,
          14,
          15,
          16,
          17,
          18,
          19,
          20,
          21,
          22,
          23,
          24,
          25,
          26,
          27,
          28,
          29,
          30,
          31,
          32,
          33,
          34,
          35,
          36
        ],

        inclusive: true
      }
    }
  };

  return lexer;
}();
parser.lexer = lexer;



function Parser() {
  this.yy = {};
}
Parser.prototype = parser;
parser.Parser = Parser;

return new Parser();
})();

        


if (typeof require !== 'undefined' && typeof exports !== 'undefined') {
  exports.parser = parser;
  exports.Parser = parser.Parser;
  exports.parse = function () {
    return parser.parse.apply(parser, arguments);
  };
  
}

},{}],855:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _color = require('color');

var _color2 = _interopRequireDefault(_color);

var _keywords = require('./keywords.json');

var _keywords2 = _interopRequireDefault(_keywords);

var _toShorthand = require('./lib/toShorthand');

var _toShorthand2 = _interopRequireDefault(_toShorthand);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const shorter = (a, b) => (a && a.length < b.length ? a : b).toLowerCase();

exports.default = (colour, isLegacy = false, cache = false) => {
    const key = colour + "|" + isLegacy;

    if (cache && cache[key]) {
        return cache[key];
    }

    try {
        const parsed = (0, _color2.default)(colour.toLowerCase());
        const alpha = parsed.alpha();

        if (alpha === 1) {
            const toHex = (0, _toShorthand2.default)(parsed.hex().toLowerCase());
            const result = shorter(_keywords2.default[toHex], toHex);

            if (cache) {
                cache[key] = result;
            }

            return result;
        } else {
            const rgb = parsed.rgb();

            if (!isLegacy && !rgb.color[0] && !rgb.color[1] && !rgb.color[2] && !alpha) {
                const result = 'transparent';

                if (cache) {
                    cache[key] = result;
                }

                return result;
            }

            let hsla = parsed.hsl().string();
            let rgba = rgb.string();
            let result = hsla.length < rgba.length ? hsla : rgba;

            if (cache) {
                cache[key] = result;
            }

            return result;
        }
    } catch (e) {
        // Possibly malformed, so pass through
        const result = colour;

        if (cache) {
            cache[key] = result;
        }

        return result;
    }
};
},{"./keywords.json":857,"./lib/toShorthand":858,"color":541}],856:[function(require,module,exports){
(function (__dirname){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _browserslist = require("browserslist");

var _browserslist2 = _interopRequireDefault(_browserslist);

var _postcss = require("postcss");

var _postcss2 = _interopRequireDefault(_postcss);

var _postcssValueParser = require("postcss-value-parser");

var _postcssValueParser2 = _interopRequireDefault(_postcssValueParser);

var _colours = require("./colours");

var _colours2 = _interopRequireDefault(_colours);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function walk(parent, callback) {
    parent.nodes.forEach((node, index) => {
        const bubble = callback(node, index, parent);

        if (node.nodes && bubble !== false) {
            walk(node, callback);
        }
    });
}

/*
 * IE 8 & 9 do not properly handle clicks on elements
 * with a `transparent` `background-color`.
 *
 * https://developer.mozilla.org/en-US/docs/Web/Events/click#Internet_Explorer
 */

function hasTransparentBug(browser) {
    return ~["ie 8", "ie 9"].indexOf(browser);
}

exports.default = _postcss2.default.plugin("postcss-colormin", () => {
    return (css, result) => {
        const resultOpts = result.opts || {};
        const browsers = (0, _browserslist2.default)(null, {
            stats: resultOpts.stats,
            path: __dirname,
            env: resultOpts.env
        });
        const isLegacy = browsers.some(hasTransparentBug);
        const colorminCache = {};
        const cache = {};

        css.walkDecls(decl => {
            if (/^(composes|font|filter|-webkit-tap-highlight-color)/i.test(decl.prop)) {
                return;
            }

            if (cache[decl.value]) {
                decl.value = cache[decl.value];

                return;
            }

            const parsed = (0, _postcssValueParser2.default)(decl.value);

            walk(parsed, (node, index, parent) => {
                if (node.type === "function") {
                    if (/^(rgb|hsl)a?$/i.test(node.value)) {
                        const { value } = node;

                        node.value = (0, _colours2.default)((0, _postcssValueParser.stringify)(node), isLegacy, colorminCache);
                        node.type = "word";

                        const next = parent.nodes[index + 1];

                        if (node.value !== value && next && (next.type === "word" || next.type === "function")) {
                            parent.nodes.splice(index + 1, 0, {
                                type: "space",
                                value: " "
                            });
                        }
                    } else if (node.value.toLowerCase() === "calc") {
                        return false;
                    }
                } else if (node.type === "word") {
                    node.value = (0, _colours2.default)(node.value, isLegacy, colorminCache);
                }
            });

            const optimizedValue = parsed.toString();

            decl.value = optimizedValue;
            cache[decl.value] = optimizedValue;
        });
    };
});
}).call(this,"/node_modules/postcss-colormin/dist")
},{"./colours":855,"browserslist":12,"postcss":1074,"postcss-value-parser":1057}],857:[function(require,module,exports){
module.exports={
  "#f0ffff": "azure",
  "#f5f5dc": "beige",
  "#ffe4c4": "bisque",
  "#a52a2a": "brown",
  "#ff7f50": "coral",
  "#ffd700": "gold",
  "#808080": "grey",
  "#008000": "green",
  "#4b0082": "indigo",
  "#fffff0": "ivory",
  "#f0e68c": "khaki",
  "#faf0e6": "linen",
  "#800000": "maroon",
  "#000080": "navy",
  "#808000": "olive",
  "#ffa500": "orange",
  "#da70d6": "orchid",
  "#cd853f": "peru",
  "#ffc0cb": "pink",
  "#dda0dd": "plum",
  "#800080": "purple",
  "#f00": "red",
  "#fa8072": "salmon",
  "#a0522d": "sienna",
  "#c0c0c0": "silver",
  "#fffafa": "snow",
  "#d2b48c": "tan",
  "#008080": "teal",
  "#ff6347": "tomato",
  "#ee82ee": "violet",
  "#f5deb3": "wheat"
}

},{}],858:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

exports.default = hex => {
    if (hex[1] === hex[2] && hex[3] === hex[4] && hex[5] === hex[6]) {
        return '#' + hex[2] + hex[4] + hex[6];
    }

    return hex;
};
},{}],859:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _postcss = require('postcss');

var _postcss2 = _interopRequireDefault(_postcss);

var _postcssValueParser = require('postcss-value-parser');

var _postcssValueParser2 = _interopRequireDefault(_postcssValueParser);

var _convert = require('./lib/convert');

var _convert2 = _interopRequireDefault(_convert);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const LENGTH_UNITS = ['em', 'ex', 'ch', 'rem', 'vw', 'vh', 'vmin', 'vmax', 'cm', 'mm', 'q', 'in', 'pt', 'pc', 'px'];

function parseWord(node, opts, keepZeroUnit) {
    const pair = (0, _postcssValueParser.unit)(node.value);
    if (pair) {
        const num = Number(pair.number);
        const u = pair.unit;
        if (num === 0) {
            node.value = keepZeroUnit || !~LENGTH_UNITS.indexOf(u.toLowerCase()) && u !== '%' ? 0 + u : 0;
        } else {
            node.value = (0, _convert2.default)(num, u, opts);

            if (typeof opts.precision === 'number' && u.toLowerCase() === 'px' && ~pair.number.indexOf('.')) {
                const precision = Math.pow(10, opts.precision);
                node.value = Math.round(parseFloat(node.value) * precision) / precision + u;
            }
        }
    }
}

function clampOpacity(node) {
    const pair = (0, _postcssValueParser.unit)(node.value);
    if (!pair) {
        return;
    }
    let num = Number(pair.number);
    if (num > 1) {
        node.value = 1 + pair.unit;
    } else if (num < 0) {
        node.value = 0 + pair.unit;
    }
}

function shouldStripPercent(decl) {
    const { parent } = decl;
    const lowerCasedProp = decl.prop.toLowerCase();
    return ~decl.value.indexOf('%') && (lowerCasedProp === 'max-height' || lowerCasedProp === 'height') || parent.parent && parent.parent.name && parent.parent.name.toLowerCase() === 'keyframes' && lowerCasedProp === 'stroke-dasharray' || lowerCasedProp === 'stroke-dashoffset' || lowerCasedProp === 'stroke-width';
}

function transform(opts, decl) {
    const lowerCasedProp = decl.prop.toLowerCase();
    if (~lowerCasedProp.indexOf('flex') || lowerCasedProp.indexOf('--') === 0) {
        return;
    }

    decl.value = (0, _postcssValueParser2.default)(decl.value).walk(node => {
        const lowerCasedValue = node.value.toLowerCase();

        if (node.type === 'word') {
            parseWord(node, opts, shouldStripPercent(decl));
            if (lowerCasedProp === 'opacity' || lowerCasedProp === 'shape-image-threshold') {
                clampOpacity(node);
            }
        } else if (node.type === 'function') {
            if (lowerCasedValue === 'calc' || lowerCasedValue === 'hsl' || lowerCasedValue === 'hsla') {
                (0, _postcssValueParser.walk)(node.nodes, n => {
                    if (n.type === 'word') {
                        parseWord(n, opts, true);
                    }
                });
                return false;
            }
            if (lowerCasedValue === 'url') {
                return false;
            }
        }
    }).toString();
}

const plugin = 'postcss-convert-values';

exports.default = _postcss2.default.plugin(plugin, (opts = { precision: false }) => {
    return css => css.walkDecls(transform.bind(null, opts));
});
module.exports = exports['default'];
},{"./lib/convert":860,"postcss":1074,"postcss-value-parser":1057}],860:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

exports.default = function (number, unit, { time, length, angle }) {
    let value = dropLeadingZero(number) + (unit ? unit : '');
    let converted;

    if (length !== false && unit.toLowerCase() in lengthConv) {
        converted = transform(number, unit, lengthConv);
    }

    if (time !== false && unit.toLowerCase() in timeConv) {
        converted = transform(number, unit, timeConv);
    }

    if (angle !== false && unit.toLowerCase() in angleConv) {
        converted = transform(number, unit, angleConv);
    }

    if (converted && converted.length < value.length) {
        value = converted;
    }

    return value;
};

const lengthConv = {
    in: 96,
    px: 1,
    pt: 4 / 3,
    pc: 16
};

const timeConv = {
    s: 1000,
    ms: 1
};

const angleConv = {
    turn: 360,
    deg: 1
};

function dropLeadingZero(number) {
    const value = String(number);

    if (number % 1) {
        if (value[0] === '0') {
            return value.slice(1);
        }

        if (value[0] === '-' && value[1] === '0') {
            return '-' + value.slice(2);
        }
    }

    return value;
}

function transform(number, unit, conversion) {
    const lowerCasedUnit = unit.toLowerCase();
    let one, base;
    let convertionUnits = Object.keys(conversion).filter(u => {
        if (conversion[u] === 1) {
            one = u;
        }
        return lowerCasedUnit !== u;
    });

    if (lowerCasedUnit === one) {
        base = number / conversion[lowerCasedUnit];
    } else {
        base = number * conversion[lowerCasedUnit];
    }

    return convertionUnits.map(u => dropLeadingZero(base / conversion[u]) + u).reduce((a, b) => a.length < b.length ? a : b);
}

module.exports = exports['default'];
},{}],861:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _postcss = require("postcss");

var _commentRemover = require("./lib/commentRemover");

var _commentRemover2 = _interopRequireDefault(_commentRemover);

var _commentParser = require("./lib/commentParser");

var _commentParser2 = _interopRequireDefault(_commentParser);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const { space } = _postcss.list;

exports.default = (0, _postcss.plugin)("postcss-discard-comments", (opts = {}) => {
    const remover = new _commentRemover2.default(opts);
    const matcherCache = {};
    const replacerCache = {};

    function matchesComments(source) {
        if (matcherCache[source]) {
            return matcherCache[source];
        }

        const result = (0, _commentParser2.default)(source).filter(([type]) => type);

        matcherCache[source] = result;

        return result;
    }

    function replaceComments(source, separator = " ") {
        const key = source + "@|@" + separator;

        if (replacerCache[key]) {
            return replacerCache[key];
        }

        const parsed = (0, _commentParser2.default)(source).reduce((value, [type, start, end]) => {
            const contents = source.slice(start, end);

            if (!type) {
                return value + contents;
            }

            if (remover.canRemove(contents)) {
                return value + separator;
            }

            return `${value}/*${contents}*/`;
        }, "");

        const result = space(parsed).join(" ");

        replacerCache[key] = result;

        return result;
    }

    return css => {
        css.walk(node => {
            if (node.type === "comment" && remover.canRemove(node.text)) {
                node.remove();

                return;
            }

            if (node.raws.between) {
                node.raws.between = replaceComments(node.raws.between);
            }

            if (node.type === "decl") {
                if (node.raws.value && node.raws.value.raw) {
                    if (node.raws.value.value === node.value) {
                        node.value = replaceComments(node.raws.value.raw);
                    } else {
                        node.value = replaceComments(node.value);
                    }

                    node.raws.value = null;
                }

                if (node.raws.important) {
                    node.raws.important = replaceComments(node.raws.important);

                    const b = matchesComments(node.raws.important);

                    node.raws.important = b.length ? node.raws.important : "!important";
                }

                return;
            }

            if (node.type === "rule" && node.raws.selector && node.raws.selector.raw) {
                node.raws.selector.raw = replaceComments(node.raws.selector.raw, "");

                return;
            }

            if (node.type === "atrule") {
                if (node.raws.afterName) {
                    const commentsReplaced = replaceComments(node.raws.afterName);

                    if (!commentsReplaced.length) {
                        node.raws.afterName = commentsReplaced + " ";
                    } else {
                        node.raws.afterName = " " + commentsReplaced + " ";
                    }
                }

                if (node.raws.params && node.raws.params.raw) {
                    node.raws.params.raw = replaceComments(node.raws.params.raw);
                }
            }
        });
    };
});
module.exports = exports["default"];
},{"./lib/commentParser":862,"./lib/commentRemover":863,"postcss":1074}],862:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = commentParser;
function commentParser(input) {
    const tokens = [];
    const length = input.length;
    let pos = 0;
    let next;

    while (pos < length) {
        next = input.indexOf('/*', pos);

        if (~next) {
            tokens.push([0, pos, next]);
            pos = next;

            next = input.indexOf('*/', pos + 2);
            tokens.push([1, pos + 2, next]);
            pos = next + 2;
        } else {
            tokens.push([0, pos, length]);
            pos = length;
        }
    }

    return tokens;
};
module.exports = exports['default'];
},{}],863:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
function CommentRemover(options) {
    this.options = options;
}

CommentRemover.prototype.canRemove = function (comment) {
    const remove = this.options.remove;

    if (remove) {
        return remove(comment);
    } else {
        const isImportant = comment.indexOf('!') === 0;

        if (!isImportant) {
            return true;
        }

        if (this.options.removeAll || this._hasFirst) {
            return true;
        } else if (this.options.removeAllButFirst && !this._hasFirst) {
            this._hasFirst = true;
            return false;
        }
    }
};

exports.default = CommentRemover;
module.exports = exports['default'];
},{}],864:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _postcss = require('postcss');

function noop() {}

function trimValue(value) {
    return value ? value.trim() : value;
}

function empty(node) {
    return !node.nodes.filter(child => child.type !== 'comment').length;
}

function equals(a, b) {
    if (a.type !== b.type) {
        return false;
    }

    if (a.important !== b.important) {
        return false;
    }

    if (a.raws && !b.raws || !a.raws && b.raws) {
        return false;
    }

    switch (a.type) {
        case 'rule':
            if (a.selector !== b.selector) {
                return false;
            }
            break;
        case 'atrule':
            if (a.name !== b.name || a.params !== b.params) {
                return false;
            }

            if (a.raws && trimValue(a.raws.before) !== trimValue(b.raws.before)) {
                return false;
            }

            if (a.raws && trimValue(a.raws.afterName) !== trimValue(b.raws.afterName)) {
                return false;
            }
            break;
        case 'decl':
            if (a.prop !== b.prop || a.value !== b.value) {
                return false;
            }

            if (a.raws && trimValue(a.raws.before) !== trimValue(b.raws.before)) {
                return false;
            }
            break;
    }

    if (a.nodes) {
        if (a.nodes.length !== b.nodes.length) {
            return false;
        }

        for (let i = 0; i < a.nodes.length; i++) {
            if (!equals(a.nodes[i], b.nodes[i])) {
                return false;
            }
        }
    }
    return true;
}

function dedupeRule(last, nodes) {
    let index = nodes.indexOf(last) - 1;
    while (index >= 0) {
        const node = nodes[index--];
        if (node && node.type === 'rule' && node.selector === last.selector) {
            last.each(child => {
                if (child.type === 'decl') {
                    dedupeNode(child, node.nodes);
                }
            });

            if (empty(node)) {
                node.remove();
            }
        }
    }
}

function dedupeNode(last, nodes) {
    let index = !!~nodes.indexOf(last) ? nodes.indexOf(last) - 1 : nodes.length - 1;

    while (index >= 0) {
        const node = nodes[index--];
        if (node && equals(node, last)) {
            node.remove();
        }
    }
}

const handlers = {
    rule: dedupeRule,
    atrule: dedupeNode,
    decl: dedupeNode,
    comment: noop
};

function dedupe(root) {
    const { nodes } = root;

    if (!nodes) {
        return;
    }

    let index = nodes.length - 1;
    while (index >= 0) {
        let last = nodes[index--];
        if (!last || !last.parent) {
            continue;
        }
        dedupe(last);
        handlers[last.type](last, nodes);
    }
}

exports.default = (0, _postcss.plugin)('postcss-discard-duplicates', () => dedupe);
module.exports = exports['default'];
},{"postcss":1074}],865:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _postcss = require('postcss');

var _postcss2 = _interopRequireDefault(_postcss);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const plugin = 'postcss-discard-empty';

function discardAndReport(css, result) {
    function discardEmpty(node) {
        const { type, nodes: sub, params } = node;

        if (sub) {
            node.each(discardEmpty);
        }

        if (type === 'decl' && !node.value || type === 'rule' && !node.selector || sub && !sub.length || type === 'atrule' && (!sub && !params || !params && !sub.length)) {
            node.remove();

            result.messages.push({
                type: 'removal',
                plugin,
                node
            });
        }
    }

    css.each(discardEmpty);
}

exports.default = _postcss2.default.plugin(plugin, () => discardAndReport);
module.exports = exports['default'];
},{"postcss":1074}],866:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _postcss = require('postcss');

var _postcss2 = _interopRequireDefault(_postcss);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const OVERRIDABLE_RULES = ['keyframes', 'counter-style'];
const SCOPE_RULES = ['media', 'supports'];

function isOverridable(name) {
    return ~OVERRIDABLE_RULES.indexOf(_postcss2.default.vendor.unprefixed(name.toLowerCase()));
}

function isScope(name) {
    return ~SCOPE_RULES.indexOf(_postcss2.default.vendor.unprefixed(name.toLowerCase()));
}

function getScope(node) {
    let current = node.parent;
    const chain = [node.name.toLowerCase(), node.params];
    do {
        if (current.type === 'atrule' && isScope(current.name)) {
            chain.unshift(current.name + ' ' + current.params);
        }
        current = current.parent;
    } while (current);
    return chain.join('|');
}

exports.default = _postcss2.default.plugin('postcss-discard-overridden', () => {
    return css => {
        const cache = {};
        const rules = [];
        css.walkAtRules(node => {
            if (isOverridable(node.name)) {
                const scope = getScope(node);
                cache[scope] = node;
                rules.push({
                    node,
                    scope
                });
            }
        });
        rules.forEach(rule => {
            if (cache[rule.scope] !== rule.node) {
                rule.node.remove();
            }
        });
    };
});
module.exports = exports['default'];
},{"postcss":1074}],867:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.postcssToJs = postcssToJs;
exports.jsToPostcss = jsToPostcss;
exports.default = void 0;

var _nodesToJs = require("./nodesToJs");

var _parseNode = require("./parseNode");

var _jsToNodes = require("./jsToNodes");

var _createNode = require("./createNode");

var _root = _interopRequireDefault(require("postcss/lib/root"));

function postcssToJs(postcssNodeOrArray) {
  if (postcssNodeOrArray.type === 'root') {
    postcssNodeOrArray = postcssNodeOrArray.nodes;
  } else if (!Array.isArray(postcssNodeOrArray)) {
    postcssNodeOrArray = [postcssNodeOrArray];
  }

  return (0, _nodesToJs.nodesToJs)(postcssNodeOrArray, _parseNode.parseNode);
}

function jsToPostcss(jsArrayOrObject) {
  const root = new _root.default();
  root.nodes = (0, _jsToNodes.jsToNodes)(jsArrayOrObject, _createNode.createNode);
  root.raws = {
    after: '\n',
    semicolon: false
  };
  root.source = (0, _createNode.createSource)(null, root);
  (0, _jsToNodes.addParentToChildNodes)(root);
  return root;
}

var _default = {
  postcssToJs,
  jsToPostcss
};
exports.default = _default;
},{"./createNode":868,"./jsToNodes":869,"./nodesToJs":870,"./parseNode":871,"@babel/runtime/helpers/interopRequireDefault":2,"postcss/lib/root":1078}],868:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createSource = createSource;
exports.createNode = createNode;
exports.default = void 0;

var _atRule = _interopRequireDefault(require("postcss/lib/at-rule"));

var _rule = _interopRequireDefault(require("postcss/lib/rule"));

var _declaration = _interopRequireDefault(require("postcss/lib/declaration"));

var _comment = _interopRequireDefault(require("postcss/lib/comment"));

/* eslint-disable prefer-template,no-extra-parens */
// eslint-disable-next-line no-unused-vars
function createSource(name, valueOrNodes) {
  // const obj = name
  // 	? {[name]: valueOrNodes}
  // 	: valueOrNodes
  //
  // const css = obj && typeof obj === 'object'
  // 	? JSON.stringify(obj, null, 4)
  // 	: obj
  return {
    input: {
      // css, // disable for improve performance
      hasBOM: false
    },
    start: {
      line: 0,
      column: 0
    },
    end: {
      line: 0,
      column: 0
    }
  };
}

function createComment(str, level) {
  const match = str.match(/^\/[\*\/]([\0-\uFFFF]*)$/);

  if (!match) {
    return null;
  }

  const result = new _comment.default();
  result.type = 'comment';
  result.text = match[1].trim();
  result.raws = {
    before: '\n'.padEnd(level + 1, '\t'),
    left: ' ',
    right: ' '
  };
  return result;
}

function createAtRule(str, level) {
  const match = str.match(/^@([\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uFEFE\uFF00-\uFFFF]+)([\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]+([\0-\uFFFF]*?))?[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]*$/);

  if (!match) {
    return null;
  }

  const result = new _atRule.default();
  result.type = 'atrule';
  result.name = match[1];
  result.raws = {
    before: '\n'.padEnd(level + 1, '\t'),
    after: '\n'.padEnd(level + 1, '\t'),
    afterName: '',
    between: ''
  };

  if (match[3]) {
    result.params = match[3];
    result.raws.afterName = ' ';
  }

  return result;
}

function createRule(name, level) {
  const result = new _rule.default();
  result.type = 'rule';
  result.selector = name;
  result.raws = {
    before: '\n'.padEnd(level + 1, '\t'),
    after: '\n'.padEnd(level + 1, '\t'),
    between: ' ',
    semicolon: false
  };
  return result;
}

function createDeclaration(name, value, level) {
  if (value != null) {
    value = value.toString();
  }

  if (!value && value !== '') {
    return null;
  }

  const match = value.match(/^[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]*([\0-\uFFFF]*?)[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]*(!important)?[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]*$/);
  const result = new _declaration.default();
  result.type = 'decl';
  result.prop = name;
  result.value = match[1];

  if (match[2]) {
    result.important = true;
  }

  result.raws = {
    before: '\n'.padEnd(level + 1, '\t'),
    between: ': '
  };
  return result;
}

function createNode(name, valueOrNodes, level) {
  const node = _createNode(name, valueOrNodes, level);

  if (node) {
    node.source = createSource(name, valueOrNodes);
  }

  return node;
}

function _createNode(name, valueOrNodes, level) {
  if (!name) {
    if (!valueOrNodes) {
      return null;
    }

    if (typeof valueOrNodes !== 'string') {
      valueOrNodes = valueOrNodes.toString();
    }

    valueOrNodes = valueOrNodes.trim();

    if (!valueOrNodes) {
      return null;
    }

    const comment = createComment(valueOrNodes, level);

    if (comment) {
      return comment;
    }

    const atRule = createAtRule(valueOrNodes, level);

    if (atRule) {
      return atRule;
    }

    throw new Error('You should use one of these syntaxes: "//<comment>" or "@<at-rule> params"');
  } else {
    const atRule = createAtRule(name, level);

    if (atRule) {
      if (valueOrNodes) {
        if (!Array.isArray(valueOrNodes)) {
          throw new Error('@at-rule content must be an array or an object, but was specified: ' + valueOrNodes);
        }

        atRule.nodes = valueOrNodes;
        atRule.raws.between = ' ';
      }

      return atRule;
    }

    if (Array.isArray(valueOrNodes)) {
      if (!valueOrNodes.length) {
        return null;
      }

      const rule = createRule(name, level);
      rule.nodes = valueOrNodes;
      return rule;
    }

    return createDeclaration(name, valueOrNodes, level);
  }
}

var _default = {
  createNode
};
exports.default = _default;
},{"@babel/runtime/helpers/interopRequireDefault":2,"postcss/lib/at-rule":1062,"postcss/lib/comment":1063,"postcss/lib/declaration":1066,"postcss/lib/rule":1079}],869:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addParentToChildNodes = addParentToChildNodes;
exports.jsToNodes = jsToNodes;
exports.default = void 0;

/* eslint-disable prefer-template,no-extra-parens */
function addParentToChildNodes(node) {
  if (!node || !node.nodes) {
    return;
  }

  for (const child of node.nodes) {
    if (!child.parent) {
      child.parent = node;
      addParentToChildNodes(child);
    }
  }
}

function jsToNodes(jsObjectOrArray, createNodeFunc, level, addedObjects) {
  const result = Array.from(jsToNodesGenerator(jsObjectOrArray, createNodeFunc, level, addedObjects));

  if (result.length === 1) {
    const value = result[0];

    if (!Array.isArray(value) && (!value || typeof value !== 'object')) {
      addParentToChildNodes(value);
      return value;
    }
  }

  for (const node of result) {
    addParentToChildNodes(node);
  }

  return result;
}

function* jsToNodesGenerator(jsObjectOrArray, createNodeFunc, level, addedObjects) {
  if (jsObjectOrArray == null) {
    yield jsObjectOrArray;
    return;
  }

  if (addedObjects) {
    if (addedObjects.has(jsObjectOrArray)) {
      throw new Error('Detect circular structure on: ' + jsObjectOrArray);
    }
  } else {
    addedObjects = new Set();
  }

  addedObjects.add(jsObjectOrArray);

  try {
    if (!level) {
      level = 0;
    }

    if (Array.isArray(jsObjectOrArray)) {
      for (const item of jsObjectOrArray) {
        if (typeof item === 'string') {
          const node = createNodeFunc(null, item, level);

          if (node) {
            yield node;
          }
        } else if (item) {
          yield* jsToNodesGenerator(item, createNodeFunc, level, addedObjects);
        }
      }

      return;
    }

    if (typeof jsObjectOrArray === 'object') {
      const nextLevel = level + 1;

      for (const name in jsObjectOrArray) {
        if (Object.prototype.hasOwnProperty.call(jsObjectOrArray, name)) {
          const node = createNodeFunc(name, jsToNodes(jsObjectOrArray[name], createNodeFunc, nextLevel, addedObjects), level);

          if (node) {
            yield node;
          }
        }
      }

      return;
    }

    yield jsObjectOrArray;
  } finally {
    addedObjects.delete(jsObjectOrArray);
  }
}

var _default = {
  jsToNodes
};
exports.default = _default;
},{}],870:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.nodesToJs = nodesToJs;
exports.default = void 0;

/* eslint-disable prefer-template,no-extra-parens */
function nodesToJs(nodes, parseNodeFunc) {
  if (!nodes) {
    return null;
  }

  const result = [];
  let currentObject;

  for (const node of nodes) {
    const item = parseNodeFunc(node);

    if (item) {
      let {
        name,
        value
      } = item;

      if (Array.isArray(value)) {
        value = nodesToJs(value, parseNodeFunc);
      } else if (value != null) {
        value = value.trim();
      }

      if (!name) {
        if (value) {
          if (currentObject) {
            result[result.length] = currentObject;
            currentObject = null;
          }

          result[result.length] = value;
        }
      } else if (value == null) {// nothing
      } else if (!currentObject) {
        currentObject = {
          [name]: value
        };
      } else if (currentObject[name]) {
        result[result.length] = currentObject;
        currentObject = {
          [name]: value
        };
      } else {
        currentObject[name] = value;
      }
    }
  }

  if (currentObject) {
    result[result.length] = currentObject;
  }

  if (!result.length) {
    return null;
  }

  if (result.length === 1) {
    const item = result[0];

    if (item && typeof item === 'object') {
      return item;
    }
  }

  return result;
}

var _default = {
  nodesToJs
};
exports.default = _default;
},{}],871:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseNode = parseNode;
exports.default = void 0;

/* eslint-disable prefer-template,no-extra-parens */
function parseNode(node) {
  if (!node) {
    return null;
  }

  switch (node.type) {
    case 'root':
      throw new Error('You should not use this function for Root node');

    case 'atrule':
      {
        var _node$name, _node$params;

        let name = ((((_node$name = node.name) === null || _node$name === void 0 ? void 0 : _node$name.trim()) || '') + ' ' + (((_node$params = node.params) === null || _node$params === void 0 ? void 0 : _node$params.trim()) || '')).trim();

        if (name) {
          name = '@' + name;
        } else {
          name = null;
        }

        if (node.nodes) {
          return {
            name,
            value: node.nodes
          };
        }

        return {
          value: name
        };
      }

    case 'rule':
      {
        var _node$selector;

        return {
          name: ((_node$selector = node.selector) === null || _node$selector === void 0 ? void 0 : _node$selector.trim()) || null,
          value: node.nodes
        };
      }

    case 'comment':
      {
        var _node$text;

        return {
          value: '// ' + (((_node$text = node.text) === null || _node$text === void 0 ? void 0 : _node$text.trim()) || '')
        };
      }

    case 'decl':
      {
        var _node$value, _node$prop;

        const value = (_node$value = node.value) === null || _node$value === void 0 ? void 0 : _node$value.trim();
        return {
          name: ((_node$prop = node.prop) === null || _node$prop === void 0 ? void 0 : _node$prop.trim()) || null,
          value: node.important && value != null ? (value + ' !important').trim() : value
        };
      }

    default:
      return null;
  }
}

var _default = {
  parseNode
};
exports.default = _default;
},{}],872:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _stringify = _interopRequireDefault(require("./stringify"));

var _parse = _interopRequireDefault(require("./parse"));

var _default = {
  parse: _parse.default,
  stringify: _stringify.default
};
exports.default = _default;
},{"./parse":873,"./stringify":874,"@babel/runtime/helpers/interopRequireDefault":2}],873:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parse = parse;
exports.default = void 0;

var _parseNode = require("./helpers/convert/parseNode");

var _convertPostcssJs = require("./helpers/convert/convertPostcssJs");

/* eslint-disable global-require */
function parse(jsContent, options) {
  const jsModuleOrPromise = options.requireFromString ? options.requireFromString(jsContent, options.from) : require(options.from);
  return promiseThenSync(jsModuleOrPromise, jsModule => {
    if (jsModule.__esModule === true && typeof jsModule.default !== 'undefined') {
      return jsModule.default;
    }

    return jsModule;
  }, jsModule => (0, _convertPostcssJs.jsToPostcss)(jsModule, _parseNode.parseNode));
}

function promiseThenSync(promise, ...next) {
  if (promise instanceof Promise) {
    return promise.then(o => promiseThenSync(o, ...next));
  }

  if (next.length) {
    promise = next.shift()(promise);
    return promiseThenSync(promise, ...next);
  }

  return promise;
}

var _default = parse;
exports.default = _default;
},{"./helpers/convert/convertPostcssJs":867,"./helpers/convert/parseNode":871}],874:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.stringify = stringify;
exports.default = void 0;

var _convertPostcssJs = require("./helpers/convert/convertPostcssJs");

function stringify(node, builder) {
  const js = (0, _convertPostcssJs.postcssToJs)(node);
  builder(JSON.stringify(js, null, 4), node);
}

var _default = stringify;
exports.default = _default;
},{"./helpers/convert/convertPostcssJs":867}],875:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _postcss = require('postcss');

var _postcss2 = _interopRequireDefault(_postcss);

var _decl = require('./lib/decl');

var _decl2 = _interopRequireDefault(_decl);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _postcss2.default.plugin('postcss-merge-longhand', () => {
    return css => {
        css.walkRules(rule => {
            _decl2.default.forEach(p => {
                p.explode(rule);
                p.merge(rule);
            });
        });
    };
});
module.exports = exports['default'];
},{"./lib/decl":881,"postcss":1074}],876:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _isCustomProp = require("./isCustomProp");

var _isCustomProp2 = _interopRequireDefault(_isCustomProp);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const hasInherit = node => node.value.toLowerCase().includes("inherit");
const hasInitial = node => node.value.toLowerCase().includes("initial");
const hasUnset = node => node.value.toLowerCase().includes("unset");

exports.default = (prop, includeCustomProps = true) => {
    if (includeCustomProps && (0, _isCustomProp2.default)(prop)) {
        return false;
    }

    return !hasInherit(prop) && !hasInitial(prop) && !hasUnset(prop);
};

module.exports = exports["default"];
},{"./isCustomProp":890}],877:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _isCustomProp = require('./isCustomProp');

var _isCustomProp2 = _interopRequireDefault(_isCustomProp);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const important = node => node.important;
const unimportant = node => !node.important;

const hasInherit = node => node.value.toLowerCase() === 'inherit';
const hasInitial = node => node.value.toLowerCase() === 'initial';
const hasUnset = node => node.value.toLowerCase() === 'unset';

exports.default = (props, includeCustomProps = true) => {
    if (props.some(hasInherit) && !props.every(hasInherit)) {
        return false;
    }

    if (props.some(hasInitial) && !props.every(hasInitial)) {
        return false;
    }

    if (props.some(hasUnset) && !props.every(hasUnset)) {
        return false;
    }

    if (includeCustomProps && props.some(_isCustomProp2.default) && !props.every(_isCustomProp2.default)) {
        return false;
    }

    return props.every(unimportant) || props.every(important);
};

module.exports = exports['default'];
},{"./isCustomProp":890}],878:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _postcss = require('postcss');

var _stylehacks = require('stylehacks');

var _insertCloned = require('../insertCloned');

var _insertCloned2 = _interopRequireDefault(_insertCloned);

var _parseTrbl = require('../parseTrbl');

var _parseTrbl2 = _interopRequireDefault(_parseTrbl);

var _hasAllProps = require('../hasAllProps');

var _hasAllProps2 = _interopRequireDefault(_hasAllProps);

var _getDecls = require('../getDecls');

var _getDecls2 = _interopRequireDefault(_getDecls);

var _getRules = require('../getRules');

var _getRules2 = _interopRequireDefault(_getRules);

var _getValue = require('../getValue');

var _getValue2 = _interopRequireDefault(_getValue);

var _mergeRules = require('../mergeRules');

var _mergeRules2 = _interopRequireDefault(_mergeRules);

var _minifyTrbl = require('../minifyTrbl');

var _minifyTrbl2 = _interopRequireDefault(_minifyTrbl);

var _minifyWsc = require('../minifyWsc');

var _minifyWsc2 = _interopRequireDefault(_minifyWsc);

var _canMerge = require('../canMerge');

var _canMerge2 = _interopRequireDefault(_canMerge);

var _remove = require('../remove');

var _remove2 = _interopRequireDefault(_remove);

var _trbl = require('../trbl');

var _trbl2 = _interopRequireDefault(_trbl);

var _isCustomProp = require('../isCustomProp');

var _isCustomProp2 = _interopRequireDefault(_isCustomProp);

var _canExplode = require('../canExplode');

var _canExplode2 = _interopRequireDefault(_canExplode);

var _getLastNode = require('../getLastNode');

var _getLastNode2 = _interopRequireDefault(_getLastNode);

var _parseWsc = require('../parseWsc');

var _parseWsc2 = _interopRequireDefault(_parseWsc);

var _validateWsc = require('../validateWsc');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const wsc = ['width', 'style', 'color'];
const defaults = ['medium', 'none', 'currentcolor'];

function borderProperty(...parts) {
    return `border-${parts.join('-')}`;
}

function mapBorderProperty(value) {
    return borderProperty(value);
}

const directions = _trbl2.default.map(mapBorderProperty);
const properties = wsc.map(mapBorderProperty);
const directionalProperties = directions.reduce((prev, curr) => prev.concat(wsc.map(prop => `${curr}-${prop}`)), []);

const precedence = [['border'], directions.concat(properties), directionalProperties];

const allProperties = precedence.reduce((a, b) => a.concat(b));

function getLevel(prop) {
    for (let i = 0; i < precedence.length; i++) {
        if (!!~precedence[i].indexOf(prop.toLowerCase())) {
            return i;
        }
    }
}

const isValueCustomProp = value => value && !!~value.search(/var\s*\(\s*--/i);

function canMergeValues(values) {
    return !values.some(isValueCustomProp) || values.every(isValueCustomProp);
}

function getColorValue(decl) {
    if (decl.prop.substr(-5) === 'color') {
        return decl.value;
    }

    return (0, _parseWsc2.default)(decl.value)[2] || defaults[2];
}

function diffingProps(values, nextValues) {
    return wsc.reduce((prev, curr, i) => {
        if (values[i] === nextValues[i]) {
            return prev;
        }

        return [...prev, curr];
    }, []);
}

function mergeRedundant({ values, nextValues, decl, nextDecl, index }) {
    if (!(0, _canMerge2.default)([decl, nextDecl])) {
        return;
    }

    if ((0, _stylehacks.detect)(decl) || (0, _stylehacks.detect)(nextDecl)) {
        return;
    }

    const diff = diffingProps(values, nextValues);

    if (diff.length > 1) {
        return;
    }

    const prop = diff.pop();
    const position = wsc.indexOf(prop);

    const prop1 = `${nextDecl.prop}-${prop}`;
    const prop2 = `border-${prop}`;

    let props = (0, _parseTrbl2.default)(values[position]);

    props[index] = nextValues[position];

    const borderValue2 = values.filter((e, i) => i !== position).join(' ');
    const propValue2 = (0, _minifyTrbl2.default)(props);

    const origLength = ((0, _minifyWsc2.default)(decl.value) + nextDecl.prop + nextDecl.value).length;
    const newLength1 = decl.value.length + prop1.length + (0, _minifyWsc2.default)(nextValues[position]).length;
    const newLength2 = borderValue2.length + prop2.length + propValue2.length;

    if (newLength1 < newLength2 && newLength1 < origLength) {
        nextDecl.prop = prop1;
        nextDecl.value = nextValues[position];
    }

    if (newLength2 < newLength1 && newLength2 < origLength) {
        decl.value = borderValue2;
        nextDecl.prop = prop2;
        nextDecl.value = propValue2;
    }
}

function isCloseEnough(mapped) {
    return mapped[0] === mapped[1] && mapped[1] === mapped[2] || mapped[1] === mapped[2] && mapped[2] === mapped[3] || mapped[2] === mapped[3] && mapped[3] === mapped[0] || mapped[3] === mapped[0] && mapped[0] === mapped[1];
}

function getDistinctShorthands(mapped) {
    return mapped.reduce((a, b) => {
        a = Array.isArray(a) ? a : [a];

        if (!~a.indexOf(b)) {
            a.push(b);
        }

        return a;
    });
}

function explode(rule) {
    rule.walkDecls(/^border/i, decl => {
        if (!(0, _canExplode2.default)(decl, false)) {
            return;
        }

        if ((0, _stylehacks.detect)(decl)) {
            return;
        }

        const prop = decl.prop.toLowerCase();

        // border -> border-trbl
        if (prop === 'border') {
            if ((0, _validateWsc.isValidWsc)((0, _parseWsc2.default)(decl.value))) {
                directions.forEach(direction => {
                    (0, _insertCloned2.default)(decl.parent, decl, { prop: direction });
                });

                return decl.remove();
            }
        }

        // border-trbl -> border-trbl-wsc
        if (directions.some(direction => prop === direction)) {
            let values = (0, _parseWsc2.default)(decl.value);

            if ((0, _validateWsc.isValidWsc)(values)) {
                wsc.forEach((d, i) => {
                    (0, _insertCloned2.default)(decl.parent, decl, {
                        prop: `${prop}-${d}`,
                        value: values[i] || defaults[i]
                    });
                });

                return decl.remove();
            }
        }

        // border-wsc -> border-trbl-wsc
        wsc.some(style => {
            if (prop !== borderProperty(style)) {
                return false;
            }

            (0, _parseTrbl2.default)(decl.value).forEach((value, i) => {
                (0, _insertCloned2.default)(decl.parent, decl, {
                    prop: borderProperty(_trbl2.default[i], style),
                    value
                });
            });

            return decl.remove();
        });
    });
}

function merge(rule) {
    // border-trbl-wsc -> border-trbl
    _trbl2.default.forEach(direction => {
        const prop = borderProperty(direction);

        (0, _mergeRules2.default)(rule, wsc.map(style => borderProperty(direction, style)), (rules, lastNode) => {
            if ((0, _canMerge2.default)(rules, false) && !rules.some(_stylehacks.detect)) {
                (0, _insertCloned2.default)(lastNode.parent, lastNode, {
                    prop,
                    value: rules.map(_getValue2.default).join(' ')
                });

                rules.forEach(_remove2.default);

                return true;
            }
        });
    });

    // border-trbl-wsc -> border-wsc
    wsc.forEach(style => {
        const prop = borderProperty(style);

        (0, _mergeRules2.default)(rule, _trbl2.default.map(direction => borderProperty(direction, style)), (rules, lastNode) => {
            if ((0, _canMerge2.default)(rules) && !rules.some(_stylehacks.detect)) {
                (0, _insertCloned2.default)(lastNode.parent, lastNode, {
                    prop,
                    value: (0, _minifyTrbl2.default)(rules.map(_getValue2.default).join(' '))
                });

                rules.forEach(_remove2.default);

                return true;
            }
        });
    });

    // border-trbl -> border-wsc
    (0, _mergeRules2.default)(rule, directions, (rules, lastNode) => {
        if (rules.some(_stylehacks.detect)) {
            return;
        }

        const values = rules.map(({ value }) => value);

        if (!canMergeValues(values)) {
            return;
        }

        const parsed = values.map(value => (0, _parseWsc2.default)(value));

        if (!parsed.every(_validateWsc.isValidWsc)) {
            return;
        }

        wsc.forEach((d, i) => {
            const value = parsed.map(v => v[i] || defaults[i]);

            if (canMergeValues(value)) {
                (0, _insertCloned2.default)(lastNode.parent, lastNode, {
                    prop: borderProperty(d),
                    value: (0, _minifyTrbl2.default)(value)
                });
            } else {
                (0, _insertCloned2.default)(lastNode.parent, lastNode);
            }
        });

        rules.forEach(_remove2.default);

        return true;
    });

    // border-wsc -> border
    // border-wsc -> border + border-color
    // border-wsc -> border + border-dir
    (0, _mergeRules2.default)(rule, properties, (rules, lastNode) => {
        if (rules.some(_stylehacks.detect)) {
            return;
        }

        const values = rules.map(node => (0, _parseTrbl2.default)(node.value));
        const mapped = [0, 1, 2, 3].map(i => [values[0][i], values[1][i], values[2][i]].join(' '));

        if (!canMergeValues(mapped)) {
            return;
        }

        const [width, style, color] = rules;
        const reduced = getDistinctShorthands(mapped);

        if (isCloseEnough(mapped) && (0, _canMerge2.default)(rules, false)) {
            const first = mapped.indexOf(reduced[0]) !== mapped.lastIndexOf(reduced[0]);

            const border = (0, _insertCloned2.default)(lastNode.parent, lastNode, {
                prop: 'border',
                value: first ? reduced[0] : reduced[1]
            });

            if (reduced[1]) {
                const value = first ? reduced[1] : reduced[0];
                const prop = borderProperty(_trbl2.default[mapped.indexOf(value)]);

                rule.insertAfter(border, Object.assign(lastNode.clone(), {
                    prop,
                    value
                }));
            }
            rules.forEach(_remove2.default);

            return true;
        } else if (reduced.length === 1) {
            rule.insertBefore(color, Object.assign(lastNode.clone(), {
                prop: 'border',
                value: [width, style].map(_getValue2.default).join(' ')
            }));
            rules.filter(node => node.prop.toLowerCase() !== properties[2]).forEach(_remove2.default);

            return true;
        }
    });

    // border-wsc -> border + border-trbl
    (0, _mergeRules2.default)(rule, properties, (rules, lastNode) => {
        if (rules.some(_stylehacks.detect)) {
            return;
        }

        const values = rules.map(node => (0, _parseTrbl2.default)(node.value));
        const mapped = [0, 1, 2, 3].map(i => [values[0][i], values[1][i], values[2][i]].join(' '));
        const reduced = getDistinctShorthands(mapped);
        const none = 'medium none currentcolor';

        if (reduced.length > 1 && reduced.length < 4 && reduced.includes(none)) {
            const filtered = mapped.filter(p => p !== none);
            const mostCommon = reduced.sort((a, b) => mapped.filter(v => v === b).length - mapped.filter(v => v === a).length)[0];
            const borderValue = reduced.length === 2 ? filtered[0] : mostCommon;

            rule.insertBefore(lastNode, Object.assign(lastNode.clone(), {
                prop: 'border',
                value: borderValue
            }));

            directions.forEach((dir, i) => {
                if (mapped[i] !== borderValue) {
                    rule.insertBefore(lastNode, Object.assign(lastNode.clone(), {
                        prop: dir,
                        value: mapped[i]
                    }));
                }
            });

            rules.forEach(_remove2.default);

            return true;
        }
    });

    // border-trbl -> border
    // border-trbl -> border + border-trbl
    (0, _mergeRules2.default)(rule, directions, (rules, lastNode) => {
        if (rules.some(_stylehacks.detect)) {
            return;
        }

        const values = rules.map(node => {
            const wscValue = (0, _parseWsc2.default)(node.value);

            if (!(0, _validateWsc.isValidWsc)(wscValue)) {
                return node.value;
            }

            return wscValue.map((value, i) => value || defaults[i]).join(' ');
        });

        const reduced = getDistinctShorthands(values);

        if (isCloseEnough(values)) {
            const first = values.indexOf(reduced[0]) !== values.lastIndexOf(reduced[0]);

            rule.insertBefore(lastNode, Object.assign(lastNode.clone(), {
                prop: 'border',
                value: (0, _minifyWsc2.default)(first ? values[0] : values[1])
            }));

            if (reduced[1]) {
                const value = first ? reduced[1] : reduced[0];
                const prop = directions[values.indexOf(value)];
                rule.insertBefore(lastNode, Object.assign(lastNode.clone(), {
                    prop: prop,
                    value: (0, _minifyWsc2.default)(value)
                }));
            }

            rules.forEach(_remove2.default);

            return true;
        }
    });

    // border-trbl-wsc + border-trbl (custom prop) -> border-trbl + border-trbl-wsc (custom prop)
    directions.forEach(direction => {
        wsc.forEach((style, i) => {
            const prop = `${direction}-${style}`;

            (0, _mergeRules2.default)(rule, [direction, prop], (rules, lastNode) => {
                if (lastNode.prop !== direction) {
                    return;
                }

                const values = (0, _parseWsc2.default)(lastNode.value);

                if (!(0, _validateWsc.isValidWsc)(values)) {
                    return;
                }

                const wscProp = rules.filter(r => r !== lastNode)[0];

                if (!isValueCustomProp(values[i]) || (0, _isCustomProp2.default)(wscProp)) {
                    return;
                }

                const wscValue = values[i];

                values[i] = wscProp.value;

                if ((0, _canMerge2.default)(rules, false) && !rules.some(_stylehacks.detect)) {
                    (0, _insertCloned2.default)(lastNode.parent, lastNode, {
                        prop,
                        value: wscValue
                    });
                    lastNode.value = (0, _minifyWsc2.default)(values);

                    wscProp.remove();

                    return true;
                }
            });
        });
    });

    // border-wsc + border (custom prop) -> border + border-wsc (custom prop)
    wsc.forEach((style, i) => {
        const prop = borderProperty(style);
        (0, _mergeRules2.default)(rule, ['border', prop], (rules, lastNode) => {
            if (lastNode.prop !== 'border') {
                return;
            }

            const values = (0, _parseWsc2.default)(lastNode.value);

            if (!(0, _validateWsc.isValidWsc)(values)) {
                return;
            }

            const wscProp = rules.filter(r => r !== lastNode)[0];

            if (!isValueCustomProp(values[i]) || (0, _isCustomProp2.default)(wscProp)) {
                return;
            }

            const wscValue = values[i];

            values[i] = wscProp.value;

            if ((0, _canMerge2.default)(rules, false) && !rules.some(_stylehacks.detect)) {
                (0, _insertCloned2.default)(lastNode.parent, lastNode, {
                    prop,
                    value: wscValue
                });
                lastNode.value = (0, _minifyWsc2.default)(values);
                wscProp.remove();

                return true;
            }
        });
    });

    // optimize border-trbl
    let decls = (0, _getDecls2.default)(rule, directions);

    while (decls.length) {
        const lastNode = decls[decls.length - 1];

        wsc.forEach((d, i) => {
            const names = directions.filter(name => name !== lastNode.prop).map(name => `${name}-${d}`);

            let nodes = rule.nodes.slice(0, rule.nodes.indexOf(lastNode));

            const border = (0, _getLastNode2.default)(nodes, 'border');

            if (border) {
                nodes = nodes.slice(nodes.indexOf(border));
            }

            const props = nodes.filter(node => node.prop && ~names.indexOf(node.prop) && node.important === lastNode.important);
            const rules = (0, _getRules2.default)(props, names);

            if ((0, _hasAllProps2.default)(rules, ...names) && !rules.some(_stylehacks.detect)) {
                const values = rules.map(node => node ? node.value : null);
                const filteredValues = values.filter(Boolean);
                const lastNodeValue = _postcss.list.space(lastNode.value)[i];

                values[directions.indexOf(lastNode.prop)] = lastNodeValue;

                let value = (0, _minifyTrbl2.default)(values.join(' '));

                if (filteredValues[0] === filteredValues[1] && filteredValues[1] === filteredValues[2]) {
                    value = filteredValues[0];
                }

                let refNode = props[props.length - 1];

                if (value === lastNodeValue) {
                    refNode = lastNode;
                    let valueArray = _postcss.list.space(lastNode.value);
                    valueArray.splice(i, 1);
                    lastNode.value = valueArray.join(' ');
                }

                (0, _insertCloned2.default)(refNode.parent, refNode, {
                    prop: borderProperty(d),
                    value
                });

                decls = decls.filter(node => !~rules.indexOf(node));
                rules.forEach(_remove2.default);
            }
        });

        decls = decls.filter(node => node !== lastNode);
    }

    rule.walkDecls('border', decl => {
        const nextDecl = decl.next();

        if (!nextDecl || nextDecl.type !== 'decl') {
            return;
        }

        const index = directions.indexOf(nextDecl.prop);

        if (!~index) {
            return;
        }

        const values = (0, _parseWsc2.default)(decl.value);
        const nextValues = (0, _parseWsc2.default)(nextDecl.value);

        if (!(0, _validateWsc.isValidWsc)(values) || !(0, _validateWsc.isValidWsc)(nextValues)) {
            return;
        }

        const config = {
            values,
            nextValues,
            decl,
            nextDecl,
            index
        };

        return mergeRedundant(config);
    });

    rule.walkDecls(/^border($|-(top|right|bottom|left)$)/i, decl => {
        let values = (0, _parseWsc2.default)(decl.value);

        if (!(0, _validateWsc.isValidWsc)(values)) {
            return;
        }

        const position = directions.indexOf(decl.prop);
        let dirs = [...directions];

        dirs.splice(position, 1);
        wsc.forEach((d, i) => {
            const props = dirs.map(dir => `${dir}-${d}`);

            (0, _mergeRules2.default)(rule, [decl.prop, ...props], rules => {
                if (!rules.includes(decl)) {
                    return;
                }

                const longhands = rules.filter(p => p !== decl);

                if (longhands[0].value.toLowerCase() === longhands[1].value.toLowerCase() && longhands[1].value.toLowerCase() === longhands[2].value.toLowerCase() && longhands[0].value.toLowerCase() === values[i].toLowerCase()) {
                    longhands.forEach(_remove2.default);

                    (0, _insertCloned2.default)(decl.parent, decl, {
                        prop: borderProperty(d),
                        value: values[i]
                    });

                    values[i] = null;
                }
            });

            const newValue = values.join(' ');

            if (newValue) {
                decl.value = newValue;
            } else {
                decl.remove();
            }
        });
    });

    // clean-up values
    rule.walkDecls(/^border($|-(top|right|bottom|left)$)/i, decl => {
        decl.value = (0, _minifyWsc2.default)(decl.value);
    });

    // border-spacing-hv -> border-spacing
    rule.walkDecls(/^border-spacing$/i, decl => {
        const value = _postcss.list.space(decl.value);

        // merge vertical and horizontal dups
        if (value.length > 1 && value[0] === value[1]) {
            decl.value = value.slice(1).join(' ');
        }
    });

    // clean-up rules
    decls = (0, _getDecls2.default)(rule, allProperties);

    while (decls.length) {
        const lastNode = decls[decls.length - 1];
        const lastPart = lastNode.prop.split('-').pop();

        // remove properties of lower precedence
        const lesser = decls.filter(node => !(0, _stylehacks.detect)(lastNode) && !(0, _stylehacks.detect)(node) && !(0, _isCustomProp2.default)(lastNode) && node !== lastNode && node.important === lastNode.important && getLevel(node.prop) > getLevel(lastNode.prop) && (!!~node.prop.toLowerCase().indexOf(lastNode.prop) || node.prop.toLowerCase().endsWith(lastPart)));

        lesser.forEach(_remove2.default);
        decls = decls.filter(node => !~lesser.indexOf(node));

        // get duplicate properties
        let duplicates = decls.filter(node => !(0, _stylehacks.detect)(lastNode) && !(0, _stylehacks.detect)(node) && node !== lastNode && node.important === lastNode.important && node.prop === lastNode.prop && !(!(0, _isCustomProp2.default)(node) && (0, _isCustomProp2.default)(lastNode)));

        if (duplicates.length) {
            if (/hsla\(|rgba\(/i.test(getColorValue(lastNode))) {
                const preserve = duplicates.filter(node => !/hsla\(|rgba\(/i.test(getColorValue(node))).pop();

                duplicates = duplicates.filter(node => node !== preserve);
            }

            duplicates.forEach(_remove2.default);
        }

        decls = decls.filter(node => node !== lastNode && !~duplicates.indexOf(node));
    }
}

exports.default = {
    explode,
    merge
};
module.exports = exports['default'];
},{"../canExplode":876,"../canMerge":877,"../getDecls":884,"../getLastNode":885,"../getRules":886,"../getValue":887,"../hasAllProps":888,"../insertCloned":889,"../isCustomProp":890,"../mergeRules":891,"../minifyTrbl":893,"../minifyWsc":894,"../parseTrbl":895,"../parseWsc":896,"../remove":897,"../trbl":898,"../validateWsc":899,"postcss":1074,"stylehacks":1142}],879:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _stylehacks = require('stylehacks');

var _canMerge = require('../canMerge');

var _canMerge2 = _interopRequireDefault(_canMerge);

var _getDecls = require('../getDecls');

var _getDecls2 = _interopRequireDefault(_getDecls);

var _minifyTrbl = require('../minifyTrbl');

var _minifyTrbl2 = _interopRequireDefault(_minifyTrbl);

var _parseTrbl = require('../parseTrbl');

var _parseTrbl2 = _interopRequireDefault(_parseTrbl);

var _insertCloned = require('../insertCloned');

var _insertCloned2 = _interopRequireDefault(_insertCloned);

var _mergeRules = require('../mergeRules');

var _mergeRules2 = _interopRequireDefault(_mergeRules);

var _mergeValues = require('../mergeValues');

var _mergeValues2 = _interopRequireDefault(_mergeValues);

var _remove = require('../remove');

var _remove2 = _interopRequireDefault(_remove);

var _trbl = require('../trbl');

var _trbl2 = _interopRequireDefault(_trbl);

var _isCustomProp = require('../isCustomProp');

var _isCustomProp2 = _interopRequireDefault(_isCustomProp);

var _canExplode = require('../canExplode');

var _canExplode2 = _interopRequireDefault(_canExplode);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = prop => {
    const properties = _trbl2.default.map(direction => `${prop}-${direction}`);

    const cleanup = rule => {
        let decls = (0, _getDecls2.default)(rule, [prop].concat(properties));

        while (decls.length) {
            const lastNode = decls[decls.length - 1];

            // remove properties of lower precedence
            const lesser = decls.filter(node => !(0, _stylehacks.detect)(lastNode) && !(0, _stylehacks.detect)(node) && node !== lastNode && node.important === lastNode.important && lastNode.prop === prop && node.prop !== lastNode.prop);

            lesser.forEach(_remove2.default);
            decls = decls.filter(node => !~lesser.indexOf(node));

            // get duplicate properties
            let duplicates = decls.filter(node => !(0, _stylehacks.detect)(lastNode) && !(0, _stylehacks.detect)(node) && node !== lastNode && node.important === lastNode.important && node.prop === lastNode.prop && !(!(0, _isCustomProp2.default)(node) && (0, _isCustomProp2.default)(lastNode)));

            duplicates.forEach(_remove2.default);
            decls = decls.filter(node => node !== lastNode && !~duplicates.indexOf(node));
        }
    };

    const processor = {
        explode: rule => {
            rule.walkDecls(new RegExp("^" + prop + "$", "i"), decl => {
                if (!(0, _canExplode2.default)(decl)) {
                    return;
                }

                if ((0, _stylehacks.detect)(decl)) {
                    return;
                }

                const values = (0, _parseTrbl2.default)(decl.value);

                _trbl2.default.forEach((direction, index) => {
                    (0, _insertCloned2.default)(decl.parent, decl, {
                        prop: properties[index],
                        value: values[index]
                    });
                });

                decl.remove();
            });
        },
        merge: rule => {
            (0, _mergeRules2.default)(rule, properties, (rules, lastNode) => {
                if ((0, _canMerge2.default)(rules) && !rules.some(_stylehacks.detect)) {
                    (0, _insertCloned2.default)(lastNode.parent, lastNode, {
                        prop,
                        value: (0, _minifyTrbl2.default)((0, _mergeValues2.default)(...rules))
                    });
                    rules.forEach(_remove2.default);

                    return true;
                }
            });

            cleanup(rule);
        }
    };

    return processor;
};

module.exports = exports['default'];
},{"../canExplode":876,"../canMerge":877,"../getDecls":884,"../insertCloned":889,"../isCustomProp":890,"../mergeRules":891,"../mergeValues":892,"../minifyTrbl":893,"../parseTrbl":895,"../remove":897,"../trbl":898,"stylehacks":1142}],880:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _postcss = require('postcss');

var _postcssValueParser = require('postcss-value-parser');

var _stylehacks = require('stylehacks');

var _canMerge = require('../canMerge');

var _canMerge2 = _interopRequireDefault(_canMerge);

var _getDecls = require('../getDecls');

var _getDecls2 = _interopRequireDefault(_getDecls);

var _getValue = require('../getValue');

var _getValue2 = _interopRequireDefault(_getValue);

var _mergeRules = require('../mergeRules');

var _mergeRules2 = _interopRequireDefault(_mergeRules);

var _insertCloned = require('../insertCloned');

var _insertCloned2 = _interopRequireDefault(_insertCloned);

var _remove = require('../remove');

var _remove2 = _interopRequireDefault(_remove);

var _isCustomProp = require('../isCustomProp');

var _isCustomProp2 = _interopRequireDefault(_isCustomProp);

var _canExplode = require('../canExplode');

var _canExplode2 = _interopRequireDefault(_canExplode);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const properties = ['column-width', 'column-count'];
const auto = 'auto';
const inherit = 'inherit';

/**
 * Normalize a columns shorthand definition. Both of the longhand
 * properties' initial values are 'auto', and as per the spec,
 * omitted values are set to their initial values. Thus, we can
 * remove any 'auto' definition when there are two values.
 *
 * Specification link: https://www.w3.org/TR/css3-multicol/
 */

function normalize(values) {
    if (values[0].toLowerCase() === auto) {
        return values[1];
    }

    if (values[1].toLowerCase() === auto) {
        return values[0];
    }

    if (values[0].toLowerCase() === inherit && values[1].toLowerCase() === inherit) {
        return inherit;
    }

    return values.join(' ');
}

function explode(rule) {
    rule.walkDecls(/^columns$/i, decl => {
        if (!(0, _canExplode2.default)(decl)) {
            return;
        }

        if ((0, _stylehacks.detect)(decl)) {
            return;
        }

        let values = _postcss.list.space(decl.value);

        if (values.length === 1) {
            values.push(auto);
        }

        values.forEach((value, i) => {
            let prop = properties[1];

            if (value.toLowerCase() === auto) {
                prop = properties[i];
            } else if ((0, _postcssValueParser.unit)(value).unit) {
                prop = properties[0];
            }

            (0, _insertCloned2.default)(decl.parent, decl, {
                prop,
                value
            });
        });

        decl.remove();
    });
}

function cleanup(rule) {
    let decls = (0, _getDecls2.default)(rule, ['columns'].concat(properties));

    while (decls.length) {
        const lastNode = decls[decls.length - 1];

        // remove properties of lower precedence
        const lesser = decls.filter(node => !(0, _stylehacks.detect)(lastNode) && !(0, _stylehacks.detect)(node) && node !== lastNode && node.important === lastNode.important && lastNode.prop === 'columns' && node.prop !== lastNode.prop);

        lesser.forEach(_remove2.default);
        decls = decls.filter(node => !~lesser.indexOf(node));

        // get duplicate properties
        let duplicates = decls.filter(node => !(0, _stylehacks.detect)(lastNode) && !(0, _stylehacks.detect)(node) && node !== lastNode && node.important === lastNode.important && node.prop === lastNode.prop && !(!(0, _isCustomProp2.default)(node) && (0, _isCustomProp2.default)(lastNode)));

        duplicates.forEach(_remove2.default);
        decls = decls.filter(node => node !== lastNode && !~duplicates.indexOf(node));
    }
}

function merge(rule) {
    (0, _mergeRules2.default)(rule, properties, (rules, lastNode) => {
        if ((0, _canMerge2.default)(rules) && !rules.some(_stylehacks.detect)) {
            (0, _insertCloned2.default)(lastNode.parent, lastNode, {
                prop: 'columns',
                value: normalize(rules.map(_getValue2.default))
            });

            rules.forEach(_remove2.default);

            return true;
        }
    });

    cleanup(rule);
}

exports.default = {
    explode,
    merge
};
module.exports = exports['default'];
},{"../canExplode":876,"../canMerge":877,"../getDecls":884,"../getValue":887,"../insertCloned":889,"../isCustomProp":890,"../mergeRules":891,"../remove":897,"postcss":1074,"postcss-value-parser":1057,"stylehacks":1142}],881:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _borders = require('./borders');

var _borders2 = _interopRequireDefault(_borders);

var _columns = require('./columns');

var _columns2 = _interopRequireDefault(_columns);

var _margin = require('./margin');

var _margin2 = _interopRequireDefault(_margin);

var _padding = require('./padding');

var _padding2 = _interopRequireDefault(_padding);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = [_borders2.default, _columns2.default, _margin2.default, _padding2.default];
module.exports = exports['default'];
},{"./borders":878,"./columns":880,"./margin":882,"./padding":883}],882:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _boxBase = require('./boxBase');

var _boxBase2 = _interopRequireDefault(_boxBase);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = (0, _boxBase2.default)('margin');
module.exports = exports['default'];
},{"./boxBase":879}],883:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _boxBase = require('./boxBase');

var _boxBase2 = _interopRequireDefault(_boxBase);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = (0, _boxBase2.default)('padding');
module.exports = exports['default'];
},{"./boxBase":879}],884:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = getDecls;
function getDecls(rule, properties) {
    return rule.nodes.filter(({ prop }) => prop && ~properties.indexOf(prop.toLowerCase()));
}
module.exports = exports["default"];
},{}],885:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

exports.default = (rule, prop) => {
    return rule.filter(n => n.prop && n.prop.toLowerCase() === prop).pop();
};

module.exports = exports["default"];
},{}],886:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = getRules;

var _getLastNode = require("./getLastNode");

var _getLastNode2 = _interopRequireDefault(_getLastNode);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getRules(props, properties) {
    return properties.map(property => {
        return (0, _getLastNode2.default)(props, property);
    }).filter(Boolean);
}
module.exports = exports["default"];
},{"./getLastNode":885}],887:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = getValue;
function getValue({ value }) {
    return value;
}
module.exports = exports["default"];
},{}],888:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

exports.default = (rule, ...props) => {
    return props.every(p => rule.some(({ prop }) => prop && ~prop.toLowerCase().indexOf(p)));
};

module.exports = exports["default"];
},{}],889:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = insertCloned;
function insertCloned(rule, decl, props) {
    const newNode = Object.assign(decl.clone(), props);

    rule.insertAfter(decl, newNode);

    return newNode;
};
module.exports = exports["default"];
},{}],890:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

exports.default = node => ~node.value.search(/var\s*\(\s*--/i);

module.exports = exports["default"];
},{}],891:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = mergeRules;

var _hasAllProps = require('./hasAllProps');

var _hasAllProps2 = _interopRequireDefault(_hasAllProps);

var _getDecls = require('./getDecls');

var _getDecls2 = _interopRequireDefault(_getDecls);

var _getRules = require('./getRules');

var _getRules2 = _interopRequireDefault(_getRules);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function isConflictingProp(propA, propB) {
    if (!propB.prop || propB.important !== propA.important) {
        return;
    }

    const parts = propA.prop.split('-');

    return parts.some(() => {
        parts.pop();

        return parts.join('-') === propB.prop;
    });
}

function hasConflicts(match, nodes) {
    const firstNode = Math.min.apply(null, match.map(n => nodes.indexOf(n)));
    const lastNode = Math.max.apply(null, match.map(n => nodes.indexOf(n)));
    const between = nodes.slice(firstNode + 1, lastNode);

    return match.some(a => between.some(b => isConflictingProp(a, b)));
}

function mergeRules(rule, properties, callback) {
    let decls = (0, _getDecls2.default)(rule, properties);

    while (decls.length) {
        const last = decls[decls.length - 1];
        const props = decls.filter(node => node.important === last.important);
        const rules = (0, _getRules2.default)(props, properties);

        if ((0, _hasAllProps2.default)(rules, ...properties) && !hasConflicts(rules, rule.nodes)) {
            if (callback(rules, last, props)) {
                decls = decls.filter(node => !~rules.indexOf(node));
            }
        }

        decls = decls.filter(node => node !== last);
    }
}
module.exports = exports['default'];
},{"./getDecls":884,"./getRules":886,"./hasAllProps":888}],892:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getValue = require('./getValue');

var _getValue2 = _interopRequireDefault(_getValue);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = (...rules) => rules.map(_getValue2.default).join(' ');

module.exports = exports['default'];
},{"./getValue":887}],893:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _parseTrbl = require('./parseTrbl');

var _parseTrbl2 = _interopRequireDefault(_parseTrbl);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = v => {
    const value = (0, _parseTrbl2.default)(v);

    if (value[3] === value[1]) {
        value.pop();

        if (value[2] === value[0]) {
            value.pop();

            if (value[0] === value[1]) {
                value.pop();
            }
        }
    }

    return value.join(' ');
};

module.exports = exports['default'];
},{"./parseTrbl":895}],894:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _parseWsc = require('./parseWsc');

var _parseWsc2 = _interopRequireDefault(_parseWsc);

var _minifyTrbl = require('./minifyTrbl');

var _minifyTrbl2 = _interopRequireDefault(_minifyTrbl);

var _validateWsc = require('./validateWsc');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const defaults = ['medium', 'none', 'currentcolor'];

exports.default = v => {
    const values = (0, _parseWsc2.default)(v);

    if (!(0, _validateWsc.isValidWsc)(values)) {
        return (0, _minifyTrbl2.default)(v);
    }

    const value = [...values, ''].reduceRight((prev, cur, i, arr) => {
        if (cur === undefined || cur.toLowerCase() === defaults[i] && (!i || (arr[i - 1] || '').toLowerCase() !== cur.toLowerCase())) {
            return prev;
        }

        return cur + ' ' + prev;
    }).trim();

    return (0, _minifyTrbl2.default)(value || 'none');
};

module.exports = exports['default'];
},{"./minifyTrbl":893,"./parseWsc":896,"./validateWsc":899}],895:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _postcss = require('postcss');

exports.default = v => {
    const s = typeof v === 'string' ? _postcss.list.space(v) : v;
    return [s[0], // top
    s[1] || s[0], // right
    s[2] || s[0], // bottom
    s[3] || s[1] || s[0]];
};

module.exports = exports['default'];
},{"postcss":1074}],896:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = parseWsc;

var _postcss = require('postcss');

var _validateWsc = require('./validateWsc');

const none = /^\s*(none|medium)(\s+none(\s+(none|currentcolor))?)?\s*$/i;

const varRE = /(^.*var)(.*\(.*--.*\))(.*)/i;
const varPreserveCase = p => `${p[1].toLowerCase()}${p[2]}${p[3].toLowerCase()}`;
const toLower = v => {
    const match = varRE.exec(v);
    return match ? varPreserveCase(match) : v.toLowerCase();
};

function parseWsc(value) {
    if (none.test(value)) {
        return ['medium', 'none', 'currentcolor'];
    }

    let width, style, color;

    const values = _postcss.list.space(value);

    if (values.length > 1 && (0, _validateWsc.isStyle)(values[1]) && values[0].toLowerCase() === 'none') {
        values.unshift();
        width = '0';
    }

    const unknown = [];

    values.forEach(v => {
        if ((0, _validateWsc.isStyle)(v)) {
            style = toLower(v);
        } else if ((0, _validateWsc.isWidth)(v)) {
            width = toLower(v);
        } else if ((0, _validateWsc.isColor)(v)) {
            color = toLower(v);
        } else {
            unknown.push(v);
        }
    });

    if (unknown.length) {
        if (!width && style && color) {
            width = unknown.pop();
        }

        if (width && !style && color) {
            style = unknown.pop();
        }

        if (width && style && !color) {
            color = unknown.pop();
        }
    }

    return [width, style, color];
}
module.exports = exports['default'];
},{"./validateWsc":899,"postcss":1074}],897:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = remove;
function remove(node) {
    return node.remove();
}
module.exports = exports["default"];
},{}],898:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = ['top', 'right', 'bottom', 'left'];
module.exports = exports['default'];
},{}],899:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isStyle = isStyle;
exports.isWidth = isWidth;
exports.isColor = isColor;
exports.isValidWsc = isValidWsc;

var _cssColorNames = require("css-color-names");

var _cssColorNames2 = _interopRequireDefault(_cssColorNames);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const widths = ["thin", "medium", "thick"];
const styles = ["none", "hidden", "dotted", "dashed", "solid", "double", "groove", "ridge", "inset", "outset"];
const colors = Object.keys(_cssColorNames2.default);

function isStyle(value) {
    return value && !!~styles.indexOf(value.toLowerCase());
}

function isWidth(value) {
    return value && !!~widths.indexOf(value.toLowerCase()) || /^(\d+(\.\d+)?|\.\d+)(\w+)?$/.test(value);
}

function isColor(value) {
    if (!value) {
        return false;
    }

    value = value.toLowerCase();

    if (/rgba?\(/.test(value)) {
        return true;
    }

    if (/hsla?\(/.test(value)) {
        return true;
    }

    if (/#([0-9a-z]{6}|[0-9a-z]{3})/.test(value)) {
        return true;
    }

    if (value === "transparent") {
        return true;
    }

    if (value === "currentcolor") {
        return true;
    }

    return !!~colors.indexOf(value);
}

function isValidWsc(wscs) {
    const validWidth = isWidth(wscs[0]);
    const validStyle = isStyle(wscs[1]);
    const validColor = isColor(wscs[2]);

    return validWidth && validStyle || validWidth && validColor || validStyle && validColor;
}
},{"css-color-names":550}],900:[function(require,module,exports){
(function (__dirname){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _browserslist = require('browserslist');

var _browserslist2 = _interopRequireDefault(_browserslist);

var _postcss = require('postcss');

var _postcss2 = _interopRequireDefault(_postcss);

var _vendors = require('vendors');

var _vendors2 = _interopRequireDefault(_vendors);

var _cssnanoUtilSameParent = require('cssnano-util-same-parent');

var _cssnanoUtilSameParent2 = _interopRequireDefault(_cssnanoUtilSameParent);

var _ensureCompatibility = require('./lib/ensureCompatibility');

var _ensureCompatibility2 = _interopRequireDefault(_ensureCompatibility);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const prefixes = _vendors2.default.map(v => `-${v}-`);

function intersect(a, b, not) {
    return a.filter(c => {
        const index = ~b.indexOf(c);
        return not ? !index : index;
    });
}

// Internet Explorer use :-ms-input-placeholder.
// Microsoft Edge use ::-ms-input-placeholder.
const findMsInputPlaceholder = selector => ~selector.search(/-ms-input-placeholder/i);
const different = (a, b) => intersect(a, b, true).concat(intersect(b, a, true));
const filterPrefixes = selector => intersect(prefixes, selector);

function sameVendor(selectorsA, selectorsB) {
    let same = selectors => selectors.map(filterPrefixes).join();
    let findMsVendor = selectors => selectors.find(findMsInputPlaceholder);
    return same(selectorsA) === same(selectorsB) && !(findMsVendor(selectorsA) && findMsVendor(selectorsB));
}

const noVendor = selector => !filterPrefixes(selector).length;

function canMerge(ruleA, ruleB, browsers, compatibilityCache) {
    const a = ruleA.selectors;
    const b = ruleB.selectors;

    const selectors = a.concat(b);

    if (!(0, _ensureCompatibility2.default)(selectors, browsers, compatibilityCache)) {
        return false;
    }

    const parent = (0, _cssnanoUtilSameParent2.default)(ruleA, ruleB);
    const { name } = ruleA.parent;
    if (parent && name && ~name.indexOf('keyframes')) {
        return false;
    }
    return parent && (selectors.every(noVendor) || sameVendor(a, b));
}

const getDecls = rule => rule.nodes && rule.nodes.map(String);
const joinSelectors = (...rules) => rules.map(s => s.selector).join();

function ruleLength(...rules) {
    return rules.map(r => r.nodes.length ? String(r) : '').join('').length;
}

function splitProp(prop) {
    const parts = prop.split('-');
    let base, rest;
    // Treat vendor prefixed properties as if they were unprefixed;
    // moving them when combined with non-prefixed properties can
    // cause issues. e.g. moving -webkit-background-clip when there
    // is a background shorthand definition.
    if (prop[0] === '-') {
        base = parts[2];
        rest = parts.slice(3);
    } else {
        base = parts[0];
        rest = parts.slice(1);
    }
    return [base, rest];
}

function isConflictingProp(propA, propB) {
    if (propA === propB) {
        return true;
    }
    const a = splitProp(propA);
    const b = splitProp(propB);
    return a[0] === b[0] && a[1].length !== b[1].length;
}

function hasConflicts(declProp, notMoved) {
    return notMoved.some(prop => isConflictingProp(prop, declProp));
}

function partialMerge(first, second) {
    let intersection = intersect(getDecls(first), getDecls(second));
    if (!intersection.length) {
        return second;
    }
    let nextRule = second.next();
    if (nextRule && nextRule.type === 'rule' && canMerge(second, nextRule)) {
        let nextIntersection = intersect(getDecls(second), getDecls(nextRule));
        if (nextIntersection.length > intersection.length) {
            first = second;second = nextRule;intersection = nextIntersection;
        }
    }
    const recievingBlock = second.clone();
    recievingBlock.selector = joinSelectors(first, second);
    recievingBlock.nodes = [];
    const difference = different(getDecls(first), getDecls(second));
    const filterConflicts = (decls, intersectn) => {
        let willNotMove = [];
        return decls.reduce((willMove, decl) => {
            let intersects = ~intersectn.indexOf(decl);
            let prop = decl.split(':')[0];
            let base = prop.split('-')[0];
            let canMove = difference.every(d => d.split(':')[0] !== base);
            if (intersects && canMove && !hasConflicts(prop, willNotMove)) {
                willMove.push(decl);
            } else {
                willNotMove.push(prop);
            }
            return willMove;
        }, []);
    };
    const containsAllDeclaration = intersectionList => {
        return intersectionList.some(declaration => {
            return declaration.split(':')[0].toLowerCase() === 'all';
        });
    };
    intersection = filterConflicts(getDecls(first).reverse(), intersection);
    intersection = filterConflicts(getDecls(second), intersection);

    // Rules with "all" declarations must be on top
    if (containsAllDeclaration(intersection)) {
        second.parent.insertBefore(first, recievingBlock);
    } else {
        second.parent.insertBefore(second, recievingBlock);
    }

    const firstClone = first.clone();
    const secondClone = second.clone();
    const moveDecl = callback => {
        return decl => {
            if (~intersection.indexOf(String(decl))) {
                callback.call(this, decl);
            }
        };
    };
    firstClone.walkDecls(moveDecl(decl => {
        decl.remove();
        recievingBlock.append(decl);
    }));
    secondClone.walkDecls(moveDecl(decl => decl.remove()));
    const merged = ruleLength(firstClone, recievingBlock, secondClone);
    const original = ruleLength(first, second);
    if (merged < original) {
        first.replaceWith(firstClone);
        second.replaceWith(secondClone);
        [firstClone, recievingBlock, secondClone].forEach(r => {
            if (!r.nodes.length) {
                r.remove();
            }
        });
        if (!secondClone.parent) {
            return recievingBlock;
        }
        return secondClone;
    } else {
        recievingBlock.remove();
        return second;
    }
}

function selectorMerger(browsers, compatibilityCache) {
    let cache = null;
    return function (rule) {
        // Prime the cache with the first rule, or alternately ensure that it is
        // safe to merge both declarations before continuing
        if (!cache || !canMerge(rule, cache, browsers, compatibilityCache)) {
            cache = rule;
            return;
        }
        // Ensure that we don't deduplicate the same rule; this is sometimes
        // caused by a partial merge
        if (cache === rule) {
            cache = rule;
            return;
        }
        // Merge when declarations are exactly equal
        // e.g. h1 { color: red } h2 { color: red }
        if (getDecls(rule).join(';') === getDecls(cache).join(';')) {
            rule.selector = joinSelectors(cache, rule);
            cache.remove();
            cache = rule;
            return;
        }
        // Merge when both selectors are exactly equal
        // e.g. a { color: blue } a { font-weight: bold }
        if (cache.selector === rule.selector) {
            const cached = getDecls(cache);
            rule.walk(decl => {
                if (~cached.indexOf(String(decl))) {
                    return decl.remove();
                }
                cache.append(decl);
            });
            rule.remove();
            return;
        }
        // Partial merge: check if the rule contains a subset of the last; if
        // so create a joined selector with the subset, if smaller.
        cache = partialMerge(cache, rule);
    };
}

exports.default = _postcss2.default.plugin('postcss-merge-rules', () => {
    return (css, result) => {
        const resultOpts = result.opts || {};
        const browsers = (0, _browserslist2.default)(null, {
            stats: resultOpts.stats,
            path: __dirname,
            env: resultOpts.env
        });
        const compatibilityCache = {};
        css.walkRules(selectorMerger(browsers, compatibilityCache));
    };
});
module.exports = exports['default'];
}).call(this,"/node_modules/postcss-merge-rules/dist")
},{"./lib/ensureCompatibility":901,"browserslist":12,"cssnano-util-same-parent":671,"postcss":1074,"vendors":1205}],901:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.pseudoElements = undefined;
exports.default = ensureCompatibility;

var _caniuseApi = require('caniuse-api');

var _postcssSelectorParser = require('postcss-selector-parser');

var _postcssSelectorParser2 = _interopRequireDefault(_postcssSelectorParser);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const simpleSelectorRe = /^#?[-._a-z0-9 ]+$/i;

const cssSel2 = 'css-sel2';
const cssSel3 = 'css-sel3';
const cssGencontent = 'css-gencontent';
const cssFirstLetter = 'css-first-letter';
const cssFirstLine = 'css-first-line';
const cssInOutOfRange = 'css-in-out-of-range';

const pseudoElements = exports.pseudoElements = {
    ':active': cssSel2,
    ':after': cssGencontent,
    ':before': cssGencontent,
    ':checked': cssSel3,
    ':default': 'css-default-pseudo',
    ':dir': 'css-dir-pseudo',
    ':disabled': cssSel3,
    ':empty': cssSel3,
    ':enabled': cssSel3,
    ':first-child': cssSel2,
    ':first-letter': cssFirstLetter,
    ':first-line': cssFirstLine,
    ':first-of-type': cssSel3,
    ':focus': cssSel2,
    ':focus-within': 'css-focus-within',
    ':has': 'css-has',
    ':hover': cssSel2,
    ':in-range': cssInOutOfRange,
    ':indeterminate': 'css-indeterminate-pseudo',
    ':lang': cssSel2,
    ':last-child': cssSel3,
    ':last-of-type': cssSel3,
    ':matches': 'css-matches-pseudo',
    ':not': cssSel3,
    ':nth-child': cssSel3,
    ':nth-last-child': cssSel3,
    ':nth-last-of-type': cssSel3,
    ':nth-of-type': cssSel3,
    ':only-child': cssSel3,
    ':only-of-type': cssSel3,
    ':optional': 'css-optional-pseudo',
    ':out-of-range': cssInOutOfRange,
    ':placeholder-shown': 'css-placeholder-shown',
    ':root': cssSel3,
    ':target': cssSel3,
    '::after': cssGencontent,
    '::backdrop': 'dialog',
    '::before': cssGencontent,
    '::first-letter': cssFirstLetter,
    '::first-line': cssFirstLine,
    '::marker': 'css-marker-pseudo',
    '::placeholder': 'css-placeholder',
    '::selection': 'css-selection'
};

function isCssMixin(selector) {
    return selector[selector.length - 1] === ':';
}

const isSupportedCache = {};

// Move to util in future
function isSupportedCached(feature, browsers) {
    const key = JSON.stringify({ feature, browsers });
    let result = isSupportedCache[key];

    if (!result) {
        result = (0, _caniuseApi.isSupported)(feature, browsers);
        isSupportedCache[key] = result;
    }

    return result;
}

function ensureCompatibility(selectors, browsers, compatibilityCache) {
    // Should not merge mixins
    if (selectors.some(isCssMixin)) {
        return false;
    }
    return selectors.every(selector => {
        if (simpleSelectorRe.test(selector)) {
            return true;
        }
        if (compatibilityCache && selector in compatibilityCache) {
            return compatibilityCache[selector];
        }
        let compatible = true;
        (0, _postcssSelectorParser2.default)(ast => {
            ast.walk(node => {
                const { type, value } = node;
                if (type === 'pseudo') {
                    const entry = pseudoElements[value];
                    if (entry && compatible) {
                        compatible = isSupportedCached(entry, browsers);
                    }
                }
                if (type === 'combinator') {
                    if (~value.indexOf('~')) {
                        compatible = isSupportedCached(cssSel3, browsers);
                    }
                    if (~value.indexOf('>') || ~value.indexOf('+')) {
                        compatible = isSupportedCached(cssSel2, browsers);
                    }
                }
                if (type === 'attribute' && node.attribute) {
                    // [foo]
                    if (!node.operator) {
                        compatible = isSupportedCached(cssSel2, browsers);
                    }

                    if (value) {
                        // [foo="bar"], [foo~="bar"], [foo|="bar"]
                        if (~['=', '~=', '|='].indexOf(node.operator)) {
                            compatible = isSupportedCached(cssSel2, browsers);
                        }
                        // [foo^="bar"], [foo$="bar"], [foo*="bar"]
                        if (~['^=', '$=', '*='].indexOf(node.operator)) {
                            compatible = isSupportedCached(cssSel3, browsers);
                        }
                    }

                    // [foo="bar" i]
                    if (node.insensitive) {
                        compatible = isSupportedCached('css-case-insensitive', browsers);
                    }
                }
                if (!compatible) {
                    // If this node was not compatible,
                    // break out early from walking the rest
                    return false;
                }
            });
        }).processSync(selector);
        if (compatibilityCache) {
            compatibilityCache[selector] = compatible;
        }
        return compatible;
    });
}
},{"caniuse-api":17,"postcss-selector-parser":902}],902:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _processor = require('./processor');

var _processor2 = _interopRequireDefault(_processor);

var _selectors = require('./selectors');

var selectors = _interopRequireWildcard(_selectors);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var parser = function parser(processor) {
  return new _processor2.default(processor);
};

Object.assign(parser, selectors);

delete parser.__esModule;

exports.default = parser;
module.exports = exports['default'];
},{"./processor":904,"./selectors":913}],903:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _dotProp = require('dot-prop');

var _dotProp2 = _interopRequireDefault(_dotProp);

var _indexesOf = require('indexes-of');

var _indexesOf2 = _interopRequireDefault(_indexesOf);

var _uniq = require('uniq');

var _uniq2 = _interopRequireDefault(_uniq);

var _root = require('./selectors/root');

var _root2 = _interopRequireDefault(_root);

var _selector = require('./selectors/selector');

var _selector2 = _interopRequireDefault(_selector);

var _className = require('./selectors/className');

var _className2 = _interopRequireDefault(_className);

var _comment = require('./selectors/comment');

var _comment2 = _interopRequireDefault(_comment);

var _id = require('./selectors/id');

var _id2 = _interopRequireDefault(_id);

var _tag = require('./selectors/tag');

var _tag2 = _interopRequireDefault(_tag);

var _string = require('./selectors/string');

var _string2 = _interopRequireDefault(_string);

var _pseudo = require('./selectors/pseudo');

var _pseudo2 = _interopRequireDefault(_pseudo);

var _attribute = require('./selectors/attribute');

var _attribute2 = _interopRequireDefault(_attribute);

var _universal = require('./selectors/universal');

var _universal2 = _interopRequireDefault(_universal);

var _combinator = require('./selectors/combinator');

var _combinator2 = _interopRequireDefault(_combinator);

var _nesting = require('./selectors/nesting');

var _nesting2 = _interopRequireDefault(_nesting);

var _sortAscending = require('./sortAscending');

var _sortAscending2 = _interopRequireDefault(_sortAscending);

var _tokenize = require('./tokenize');

var _tokenize2 = _interopRequireDefault(_tokenize);

var _tokenTypes = require('./tokenTypes');

var tokens = _interopRequireWildcard(_tokenTypes);

var _types = require('./selectors/types');

var types = _interopRequireWildcard(_types);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function getSource(startLine, startColumn, endLine, endColumn) {
    return {
        start: {
            line: startLine,
            column: startColumn
        },
        end: {
            line: endLine,
            column: endColumn
        }
    };
}

var Parser = function () {
    function Parser(rule) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        _classCallCheck(this, Parser);

        this.rule = rule;
        this.options = Object.assign({ lossy: false, safe: false }, options);
        this.position = 0;
        this.root = new _root2.default();
        this.root.errorGenerator = this._errorGenerator();

        var selector = new _selector2.default();
        this.root.append(selector);
        this.current = selector;

        this.css = typeof this.rule === 'string' ? this.rule : this.rule.selector;

        if (this.options.lossy) {
            this.css = this.css.trim();
        }
        this.tokens = (0, _tokenize2.default)({
            css: this.css,
            error: this._errorGenerator(),
            safe: this.options.safe
        });

        this.loop();
    }

    Parser.prototype._errorGenerator = function _errorGenerator() {
        var _this = this;

        return function (message, errorOptions) {
            if (typeof _this.rule === 'string') {
                return new Error(message);
            }
            return _this.rule.error(message, errorOptions);
        };
    };

    Parser.prototype.attribute = function attribute() {
        var attr = [];
        var startingToken = this.currToken;
        this.position++;
        while (this.position < this.tokens.length && this.currToken[0] !== tokens.closeSquare) {
            attr.push(this.currToken);
            this.position++;
        }
        if (this.currToken[0] !== tokens.closeSquare) {
            return this.expected('closing square bracket', this.currToken[5]);
        }

        var len = attr.length;
        var node = {
            source: getSource(startingToken[1], startingToken[2], this.currToken[3], this.currToken[4]),
            sourceIndex: startingToken[5]
        };

        if (len === 1 && !~[tokens.word].indexOf(attr[0][0])) {
            return this.expected('attribute', attr[0][5]);
        }

        var pos = 0;
        var spaceBefore = '';
        var commentBefore = '';
        var lastAdded = null;
        var spaceAfterMeaningfulToken = false;

        while (pos < len) {
            var token = attr[pos];
            var content = this.content(token);
            var next = attr[pos + 1];

            switch (token[0]) {
                case tokens.space:
                    if (len === 1 || pos === 0 && this.content(next) === '|') {
                        return this.expected('attribute', token[5], content);
                    }
                    spaceAfterMeaningfulToken = true;
                    if (this.options.lossy) {
                        break;
                    }
                    if (lastAdded) {
                        var spaceProp = 'spaces.' + lastAdded + '.after';
                        _dotProp2.default.set(node, spaceProp, _dotProp2.default.get(node, spaceProp, '') + content);
                        var commentProp = 'raws.spaces.' + lastAdded + '.after';
                        var existingComment = _dotProp2.default.get(node, commentProp);
                        if (existingComment) {
                            _dotProp2.default.set(node, commentProp, existingComment + content);
                        }
                    } else {
                        spaceBefore = spaceBefore + content;
                        commentBefore = commentBefore + content;
                    }
                    break;
                case tokens.asterisk:
                    if (next[0] === tokens.equals) {
                        node.operator = content;
                        lastAdded = 'operator';
                    } else if ((!node.namespace || lastAdded === "namespace" && !spaceAfterMeaningfulToken) && next) {
                        if (spaceBefore) {
                            _dotProp2.default.set(node, 'spaces.attribute.before', spaceBefore);
                            spaceBefore = '';
                        }
                        if (commentBefore) {
                            _dotProp2.default.set(node, 'raws.spaces.attribute.before', spaceBefore);
                            commentBefore = '';
                        }
                        node.namespace = (node.namespace || "") + content;
                        var rawValue = _dotProp2.default.get(node, "raws.namespace");
                        if (rawValue) {
                            node.raws.namespace += content;
                        }
                        lastAdded = 'namespace';
                    }
                    spaceAfterMeaningfulToken = false;
                    break;
                case tokens.dollar:
                case tokens.caret:
                    if (next[0] === tokens.equals) {
                        node.operator = content;
                        lastAdded = 'operator';
                    }
                    spaceAfterMeaningfulToken = false;
                    break;
                case tokens.combinator:
                    if (content === '~' && next[0] === tokens.equals) {
                        node.operator = content;
                        lastAdded = 'operator';
                    }
                    if (content !== '|') {
                        spaceAfterMeaningfulToken = false;
                        break;
                    }
                    if (next[0] === tokens.equals) {
                        node.operator = content;
                        lastAdded = 'operator';
                    } else if (!node.namespace && !node.attribute) {
                        node.namespace = true;
                    }
                    spaceAfterMeaningfulToken = false;
                    break;
                case tokens.word:
                    if (next && this.content(next) === '|' && attr[pos + 2] && attr[pos + 2][0] !== tokens.equals && // this look-ahead probably fails with comment nodes involved.
                    !node.operator && !node.namespace) {
                        node.namespace = content;
                        lastAdded = 'namespace';
                    } else if (!node.attribute || lastAdded === "attribute" && !spaceAfterMeaningfulToken) {
                        if (spaceBefore) {
                            _dotProp2.default.set(node, 'spaces.attribute.before', spaceBefore);
                            spaceBefore = '';
                        }
                        if (commentBefore) {
                            _dotProp2.default.set(node, 'raws.spaces.attribute.before', commentBefore);
                            commentBefore = '';
                        }
                        node.attribute = (node.attribute || "") + content;
                        var _rawValue = _dotProp2.default.get(node, "raws.attribute");
                        if (_rawValue) {
                            node.raws.attribute += content;
                        }
                        lastAdded = 'attribute';
                    } else if (!node.value || lastAdded === "value" && !spaceAfterMeaningfulToken) {
                        node.value = (node.value || "") + content;
                        var _rawValue2 = _dotProp2.default.get(node, "raws.value");
                        if (_rawValue2) {
                            node.raws.value += content;
                        }
                        lastAdded = 'value';
                        _dotProp2.default.set(node, 'raws.unquoted', _dotProp2.default.get(node, 'raws.unquoted', '') + content);
                    } else if (content === 'i') {
                        if (node.value && (node.quoted || spaceAfterMeaningfulToken)) {
                            node.insensitive = true;
                            lastAdded = 'insensitive';
                            if (spaceBefore) {
                                _dotProp2.default.set(node, 'spaces.insensitive.before', spaceBefore);
                                spaceBefore = '';
                            }
                            if (commentBefore) {
                                _dotProp2.default.set(node, 'raws.spaces.insensitive.before', commentBefore);
                                commentBefore = '';
                            }
                        } else if (node.value) {
                            lastAdded = 'value';
                            node.value += 'i';
                            if (node.raws.value) {
                                node.raws.value += 'i';
                            }
                        }
                    }
                    spaceAfterMeaningfulToken = false;
                    break;
                case tokens.str:
                    if (!node.attribute || !node.operator) {
                        return this.error('Expected an attribute followed by an operator preceding the string.', {
                            index: token[5]
                        });
                    }
                    node.value = content;
                    node.quoted = true;
                    lastAdded = 'value';
                    _dotProp2.default.set(node, 'raws.unquoted', content.slice(1, -1));
                    spaceAfterMeaningfulToken = false;
                    break;
                case tokens.equals:
                    if (!node.attribute) {
                        return this.expected('attribute', token[5], content);
                    }
                    if (node.value) {
                        return this.error('Unexpected "=" found; an operator was already defined.', { index: token[5] });
                    }
                    node.operator = node.operator ? node.operator + content : content;
                    lastAdded = 'operator';
                    spaceAfterMeaningfulToken = false;
                    break;
                case tokens.comment:
                    if (lastAdded) {
                        if (spaceAfterMeaningfulToken || next && next[0] === tokens.space) {
                            var lastComment = _dotProp2.default.get(node, 'raws.spaces.' + lastAdded + '.after', _dotProp2.default.get(node, 'spaces.' + lastAdded + '.after', ''));
                            _dotProp2.default.set(node, 'raws.spaces.' + lastAdded + '.after', lastComment + content);
                        } else {
                            var lastValue = _dotProp2.default.get(node, 'raws.' + lastAdded, _dotProp2.default.get(node, lastAdded, ''));
                            _dotProp2.default.set(node, 'raws.' + lastAdded, lastValue + content);
                        }
                    } else {
                        commentBefore = commentBefore + content;
                    }
                    break;
                default:
                    return this.error('Unexpected "' + content + '" found.', { index: token[5] });
            }
            pos++;
        }

        this.newNode(new _attribute2.default(node));
        this.position++;
    };

    Parser.prototype.combinator = function combinator() {
        var current = this.currToken;
        if (this.content() === '|') {
            return this.namespace();
        }
        var node = new _combinator2.default({
            value: '',
            source: getSource(current[1], current[2], current[3], current[4]),
            sourceIndex: current[5]
        });
        while (this.position < this.tokens.length && this.currToken && (this.currToken[0] === tokens.space || this.currToken[0] === tokens.combinator)) {
            var content = this.content();
            if (this.nextToken && this.nextToken[0] === tokens.combinator) {
                node.spaces.before = this.parseSpace(content);
                node.source = getSource(this.nextToken[1], this.nextToken[2], this.nextToken[3], this.nextToken[4]);
                node.sourceIndex = this.nextToken[5];
            } else if (this.prevToken && this.prevToken[0] === tokens.combinator) {
                node.spaces.after = this.parseSpace(content);
            } else if (this.currToken[0] === tokens.combinator) {
                node.value = content;
            } else if (this.currToken[0] === tokens.space) {
                node.value = this.parseSpace(content, ' ');
            }
            this.position++;
        }
        return this.newNode(node);
    };

    Parser.prototype.comma = function comma() {
        if (this.position === this.tokens.length - 1) {
            this.root.trailingComma = true;
            this.position++;
            return;
        }
        var selector = new _selector2.default();
        this.current.parent.append(selector);
        this.current = selector;
        this.position++;
    };

    Parser.prototype.comment = function comment() {
        var current = this.currToken;
        this.newNode(new _comment2.default({
            value: this.content(),
            source: getSource(current[1], current[2], current[3], current[4]),
            sourceIndex: current[5]
        }));
        this.position++;
    };

    Parser.prototype.error = function error(message, opts) {
        throw this.root.error(message, opts);
    };

    Parser.prototype.missingBackslash = function missingBackslash() {
        return this.error('Expected a backslash preceding the semicolon.', {
            index: this.currToken[5]
        });
    };

    Parser.prototype.missingParenthesis = function missingParenthesis() {
        return this.expected('opening parenthesis', this.currToken[5]);
    };

    Parser.prototype.missingSquareBracket = function missingSquareBracket() {
        return this.expected('opening square bracket', this.currToken[5]);
    };

    Parser.prototype.namespace = function namespace() {
        var before = this.prevToken && this.content(this.prevToken) || true;
        if (this.nextToken[0] === tokens.word) {
            this.position++;
            return this.word(before);
        } else if (this.nextToken[0] === tokens.asterisk) {
            this.position++;
            return this.universal(before);
        }
    };

    Parser.prototype.nesting = function nesting() {
        var current = this.currToken;
        this.newNode(new _nesting2.default({
            value: this.content(),
            source: getSource(current[1], current[2], current[3], current[4]),
            sourceIndex: current[5]
        }));
        this.position++;
    };

    Parser.prototype.parentheses = function parentheses() {
        var last = this.current.last;
        var balanced = 1;
        this.position++;
        if (last && last.type === types.PSEUDO) {
            var selector = new _selector2.default();
            var cache = this.current;
            last.append(selector);
            this.current = selector;
            while (this.position < this.tokens.length && balanced) {
                if (this.currToken[0] === tokens.openParenthesis) {
                    balanced++;
                }
                if (this.currToken[0] === tokens.closeParenthesis) {
                    balanced--;
                }
                if (balanced) {
                    this.parse();
                } else {
                    selector.parent.source.end.line = this.currToken[3];
                    selector.parent.source.end.column = this.currToken[4];
                    this.position++;
                }
            }
            this.current = cache;
        } else {
            last.value += '(';
            while (this.position < this.tokens.length && balanced) {
                if (this.currToken[0] === tokens.openParenthesis) {
                    balanced++;
                }
                if (this.currToken[0] === tokens.closeParenthesis) {
                    balanced--;
                }
                last.value += this.parseParenthesisToken(this.currToken);
                this.position++;
            }
        }
        if (balanced) {
            return this.expected('closing parenthesis', this.currToken[5]);
        }
    };

    Parser.prototype.pseudo = function pseudo() {
        var _this2 = this;

        var pseudoStr = '';
        var startingToken = this.currToken;
        while (this.currToken && this.currToken[0] === tokens.colon) {
            pseudoStr += this.content();
            this.position++;
        }
        if (!this.currToken) {
            return this.expected(['pseudo-class', 'pseudo-element'], this.position - 1);
        }
        if (this.currToken[0] === tokens.word) {
            this.splitWord(false, function (first, length) {
                pseudoStr += first;
                _this2.newNode(new _pseudo2.default({
                    value: pseudoStr,
                    source: getSource(startingToken[1], startingToken[2], _this2.currToken[3], _this2.currToken[4]),
                    sourceIndex: startingToken[5]
                }));
                if (length > 1 && _this2.nextToken && _this2.nextToken[0] === tokens.openParenthesis) {
                    _this2.error('Misplaced parenthesis.', {
                        index: _this2.nextToken[5]
                    });
                }
            });
        } else {
            return this.expected(['pseudo-class', 'pseudo-element'], this.currToken[5]);
        }
    };

    Parser.prototype.space = function space() {
        var content = this.content();
        // Handle space before and after the selector
        if (this.position === 0 || this.prevToken[0] === tokens.comma || this.prevToken[0] === tokens.openParenthesis) {
            this.spaces = this.parseSpace(content);
            this.position++;
        } else if (this.position === this.tokens.length - 1 || this.nextToken[0] === tokens.comma || this.nextToken[0] === tokens.closeParenthesis) {
            this.current.last.spaces.after = this.parseSpace(content);
            this.position++;
        } else {
            this.combinator();
        }
    };

    Parser.prototype.string = function string() {
        var current = this.currToken;
        this.newNode(new _string2.default({
            value: this.content(),
            source: getSource(current[1], current[2], current[3], current[4]),
            sourceIndex: current[5]
        }));
        this.position++;
    };

    Parser.prototype.universal = function universal(namespace) {
        var nextToken = this.nextToken;
        if (nextToken && this.content(nextToken) === '|') {
            this.position++;
            return this.namespace();
        }
        var current = this.currToken;
        this.newNode(new _universal2.default({
            value: this.content(),
            source: getSource(current[1], current[2], current[3], current[4]),
            sourceIndex: current[5]
        }), namespace);
        this.position++;
    };

    Parser.prototype.splitWord = function splitWord(namespace, firstCallback) {
        var _this3 = this;

        var nextToken = this.nextToken;
        var word = this.content();
        while (nextToken && ~[tokens.dollar, tokens.caret, tokens.equals, tokens.word].indexOf(nextToken[0])) {
            this.position++;
            var current = this.content();
            word += current;
            if (current.lastIndexOf('\\') === current.length - 1) {
                var next = this.nextToken;
                if (next && next[0] === tokens.space) {
                    word += this.parseSpace(this.content(next), ' ');
                    this.position++;
                }
            }
            nextToken = this.nextToken;
        }
        var hasClass = (0, _indexesOf2.default)(word, '.');
        var hasId = (0, _indexesOf2.default)(word, '#');
        // Eliminate Sass interpolations from the list of id indexes
        var interpolations = (0, _indexesOf2.default)(word, '#{');
        if (interpolations.length) {
            hasId = hasId.filter(function (hashIndex) {
                return !~interpolations.indexOf(hashIndex);
            });
        }
        var indices = (0, _sortAscending2.default)((0, _uniq2.default)([0].concat(hasClass, hasId)));
        indices.forEach(function (ind, i) {
            var index = indices[i + 1] || word.length;
            var value = word.slice(ind, index);
            if (i === 0 && firstCallback) {
                return firstCallback.call(_this3, value, indices.length);
            }
            var node = void 0;
            var current = _this3.currToken;
            var sourceIndex = current[5] + indices[i];
            var source = getSource(current[1], current[2] + ind, current[3], current[2] + (index - 1));
            if (~hasClass.indexOf(ind)) {
                node = new _className2.default({
                    value: value.slice(1),
                    source: source,
                    sourceIndex: sourceIndex
                });
            } else if (~hasId.indexOf(ind)) {
                node = new _id2.default({
                    value: value.slice(1),
                    source: source,
                    sourceIndex: sourceIndex
                });
            } else {
                node = new _tag2.default({
                    value: value,
                    source: source,
                    sourceIndex: sourceIndex
                });
            }
            _this3.newNode(node, namespace);
            // Ensure that the namespace is used only once
            namespace = null;
        });
        this.position++;
    };

    Parser.prototype.word = function word(namespace) {
        var nextToken = this.nextToken;
        if (nextToken && this.content(nextToken) === '|') {
            this.position++;
            return this.namespace();
        }
        return this.splitWord(namespace);
    };

    Parser.prototype.loop = function loop() {
        while (this.position < this.tokens.length) {
            this.parse(true);
        }
        return this.root;
    };

    Parser.prototype.parse = function parse(throwOnParenthesis) {
        switch (this.currToken[0]) {
            case tokens.space:
                this.space();
                break;
            case tokens.comment:
                this.comment();
                break;
            case tokens.openParenthesis:
                this.parentheses();
                break;
            case tokens.closeParenthesis:
                if (throwOnParenthesis) {
                    this.missingParenthesis();
                }
                break;
            case tokens.openSquare:
                this.attribute();
                break;
            case tokens.dollar:
            case tokens.caret:
            case tokens.equals:
            case tokens.word:
                this.word();
                break;
            case tokens.colon:
                this.pseudo();
                break;
            case tokens.comma:
                this.comma();
                break;
            case tokens.asterisk:
                this.universal();
                break;
            case tokens.ampersand:
                this.nesting();
                break;
            case tokens.combinator:
                this.combinator();
                break;
            case tokens.str:
                this.string();
                break;
            // These cases throw; no break needed.
            case tokens.closeSquare:
                this.missingSquareBracket();
            case tokens.semicolon:
                this.missingBackslash();
        }
    };

    /**
     * Helpers
     */

    Parser.prototype.expected = function expected(description, index, found) {
        if (Array.isArray(description)) {
            var last = description.pop();
            description = description.join(', ') + ' or ' + last;
        }
        var an = /^[aeiou]/.test(description[0]) ? 'an' : 'a';
        if (!found) {
            return this.error('Expected ' + an + ' ' + description + '.', { index: index });
        }
        return this.error('Expected ' + an + ' ' + description + ', found "' + found + '" instead.', { index: index });
    };

    Parser.prototype.parseNamespace = function parseNamespace(namespace) {
        if (this.options.lossy && typeof namespace === 'string') {
            var trimmed = namespace.trim();
            if (!trimmed.length) {
                return true;
            }

            return trimmed;
        }

        return namespace;
    };

    Parser.prototype.parseSpace = function parseSpace(space) {
        var replacement = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

        return this.options.lossy ? replacement : space;
    };

    Parser.prototype.parseValue = function parseValue(value) {
        if (!this.options.lossy || !value || typeof value !== 'string') {
            return value;
        }
        return value.trim();
    };

    Parser.prototype.parseParenthesisToken = function parseParenthesisToken(token) {
        var content = this.content(token);
        if (!this.options.lossy) {
            return content;
        }

        if (token[0] === tokens.space) {
            return this.parseSpace(content, ' ');
        }

        return this.parseValue(content);
    };

    Parser.prototype.newNode = function newNode(node, namespace) {
        if (namespace) {
            node.namespace = this.parseNamespace(namespace);
        }
        if (this.spaces) {
            node.spaces.before = this.spaces;
            this.spaces = '';
        }
        return this.current.append(node);
    };

    Parser.prototype.content = function content() {
        var token = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.currToken;

        return this.css.slice(token[5], token[6]);
    };

    _createClass(Parser, [{
        key: 'currToken',
        get: function get() {
            return this.tokens[this.position];
        }
    }, {
        key: 'nextToken',
        get: function get() {
            return this.tokens[this.position + 1];
        }
    }, {
        key: 'prevToken',
        get: function get() {
            return this.tokens[this.position - 1];
        }
    }]);

    return Parser;
}();

exports.default = Parser;
module.exports = exports['default'];
},{"./selectors/attribute":905,"./selectors/className":906,"./selectors/combinator":907,"./selectors/comment":908,"./selectors/id":912,"./selectors/nesting":915,"./selectors/pseudo":917,"./selectors/root":918,"./selectors/selector":919,"./selectors/string":920,"./selectors/tag":921,"./selectors/types":922,"./selectors/universal":923,"./sortAscending":924,"./tokenTypes":925,"./tokenize":926,"dot-prop":685,"indexes-of":727,"uniq":1198}],904:[function(require,module,exports){
"use strict";

exports.__esModule = true;

var _parser = require("./parser");

var _parser2 = _interopRequireDefault(_parser);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Processor = function () {
    function Processor(func, options) {
        _classCallCheck(this, Processor);

        this.func = func || function noop() {};
        this.funcRes = null;
        this.options = options;
    }

    Processor.prototype._shouldUpdateSelector = function _shouldUpdateSelector(rule) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        var merged = Object.assign({}, this.options, options);
        if (merged.updateSelector === false) {
            return false;
        } else {
            return typeof rule !== "string";
        }
    };

    Processor.prototype._isLossy = function _isLossy() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        var merged = Object.assign({}, this.options, options);
        if (merged.lossless === false) {
            return true;
        } else {
            return false;
        }
    };

    Processor.prototype._root = function _root(rule) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        var parser = new _parser2.default(rule, this._parseOptions(options));
        return parser.root;
    };

    Processor.prototype._parseOptions = function _parseOptions(options) {
        return {
            lossy: this._isLossy(options)
        };
    };

    Processor.prototype._run = function _run(rule) {
        var _this = this;

        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        return new Promise(function (resolve, reject) {
            try {
                var root = _this._root(rule, options);
                Promise.resolve(_this.func(root)).then(function (transform) {
                    var string = undefined;
                    if (_this._shouldUpdateSelector(rule, options)) {
                        string = root.toString();
                        rule.selector = string;
                    }
                    return { transform: transform, root: root, string: string };
                }).then(resolve, reject);
            } catch (e) {
                reject(e);
                return;
            }
        });
    };

    Processor.prototype._runSync = function _runSync(rule) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        var root = this._root(rule, options);
        var transform = this.func(root);
        if (transform && typeof transform.then === "function") {
            throw new Error("Selector processor returned a promise to a synchronous call.");
        }
        var string = undefined;
        if (options.updateSelector && typeof rule !== "string") {
            string = root.toString();
            rule.selector = string;
        }
        return { transform: transform, root: root, string: string };
    };

    /**
     * Process rule into a selector AST.
     * 
     * @param rule {postcss.Rule | string} The css selector to be processed
     * @param options The options for processing
     * @returns {Promise<parser.Root>} The AST of the selector after processing it.
     */


    Processor.prototype.ast = function ast(rule, options) {
        return this._run(rule, options).then(function (result) {
            return result.root;
        });
    };

    /**
     * Process rule into a selector AST synchronously.
     * 
     * @param rule {postcss.Rule | string} The css selector to be processed
     * @param options The options for processing
     * @returns {parser.Root} The AST of the selector after processing it.
     */


    Processor.prototype.astSync = function astSync(rule, options) {
        return this._runSync(rule, options).root;
    };

    /**
     * Process a selector into a transformed value asynchronously
     * 
     * @param rule {postcss.Rule | string} The css selector to be processed
     * @param options The options for processing
     * @returns {Promise<any>} The value returned by the processor.
     */


    Processor.prototype.transform = function transform(rule, options) {
        return this._run(rule, options).then(function (result) {
            return result.transform;
        });
    };

    /**
     * Process a selector into a transformed value synchronously.
     * 
     * @param rule {postcss.Rule | string} The css selector to be processed
     * @param options The options for processing
     * @returns {any} The value returned by the processor.
     */


    Processor.prototype.transformSync = function transformSync(rule, options) {
        return this._runSync(rule, options).transform;
    };

    /**
     * Process a selector into a new selector string asynchronously.
     * 
     * @param rule {postcss.Rule | string} The css selector to be processed
     * @param options The options for processing
     * @returns {string} the selector after processing.
     */


    Processor.prototype.process = function process(rule, options) {
        return this._run(rule, options).then(function (result) {
            return result.string || result.root.toString();
        });
    };

    /**
     * Process a selector into a new selector string synchronously.
     * 
     * @param rule {postcss.Rule | string} The css selector to be processed
     * @param options The options for processing
     * @returns {string} the selector after processing.
     */


    Processor.prototype.processSync = function processSync(rule, options) {
        var result = this._runSync(rule, options);
        return result.string || result.root.toString();
    };

    return Processor;
}();

exports.default = Processor;
module.exports = exports["default"];
},{"./parser":903}],905:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _namespace = require('./namespace');

var _namespace2 = _interopRequireDefault(_namespace);

var _types = require('./types');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Attribute = function (_Namespace) {
    _inherits(Attribute, _Namespace);

    function Attribute() {
        var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        _classCallCheck(this, Attribute);

        var _this = _possibleConstructorReturn(this, _Namespace.call(this, opts));

        _this.type = _types.ATTRIBUTE;
        _this.raws = _this.raws || {};
        _this._constructed = true;
        return _this;
    }

    Attribute.prototype._spacesFor = function _spacesFor(name) {
        var attrSpaces = { before: '', after: '' };
        var spaces = this.spaces[name] || {};
        var rawSpaces = this.raws.spaces && this.raws.spaces[name] || {};
        return Object.assign(attrSpaces, spaces, rawSpaces);
    };

    Attribute.prototype._valueFor = function _valueFor(name) {
        return this.raws[name] || this[name];
    };

    Attribute.prototype._stringFor = function _stringFor(name) {
        var spaceName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : name;
        var concat = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultAttrConcat;

        var attrSpaces = this._spacesFor(spaceName);
        return concat(this._valueFor(name), attrSpaces);
    };

    /**
     * returns the offset of the attribute part specified relative to the
     * start of the node of the output string.
     *
     * * "ns" - alias for "namespace"
     * * "namespace" - the namespace if it exists.
     * * "attribute" - the attribute name
     * * "attributeNS" - the start of the attribute or its namespace
     * * "operator" - the match operator of the attribute
     * * "value" - The value (string or identifier)
     * * "insensitive" - the case insensitivity flag;
     * @param part One of the possible values inside an attribute.
     * @returns -1 if the name is invalid or the value doesn't exist in this attribute.
     */


    Attribute.prototype.offsetOf = function offsetOf(name) {
        var count = 1;
        var attributeSpaces = this._spacesFor("attribute");
        count += attributeSpaces.before.length;
        if (name === "namespace" || name === "ns") {
            return this.namespace ? count : -1;
        }
        if (name === "attributeNS") {
            return count;
        }

        count += this.namespaceString.length;
        if (this.namespace) {
            count += 1;
        }
        if (name === "attribute") {
            return count;
        }

        count += this._valueFor("attribute").length;
        count += attributeSpaces.after.length;
        var operatorSpaces = this._spacesFor("operator");
        count += operatorSpaces.before.length;
        var operator = this._valueFor("operator");
        if (name === "operator") {
            return operator ? count : -1;
        }

        count += operator.length;
        count += operatorSpaces.after.length;
        var valueSpaces = this._spacesFor("value");
        count += valueSpaces.before.length;
        var value = this._valueFor("value");
        if (name === "value") {
            return value ? count : -1;
        }

        count += value.length;
        count += valueSpaces.after.length;
        var insensitiveSpaces = this._spacesFor("insensitive");
        count += insensitiveSpaces.before.length;
        if (name === "insensitive") {
            return this.insensitive ? count : -1;
        }
        return -1;
    };

    Attribute.prototype.toString = function toString() {
        var _this2 = this;

        var selector = [this.spaces.before, '['];

        selector.push(this._stringFor('qualifiedAttribute', 'attribute'));

        if (this.operator && this.value) {
            selector.push(this._stringFor('operator'));
            selector.push(this._stringFor('value'));
            selector.push(this._stringFor('insensitiveFlag', 'insensitive', function (attrValue, attrSpaces) {
                if (attrValue.length > 0 && !_this2.quoted && attrSpaces.before.length === 0 && !(_this2.spaces.value && _this2.spaces.value.after)) {
                    attrSpaces.before = " ";
                }
                return defaultAttrConcat(attrValue, attrSpaces);
            }));
        }

        selector.push(']');
        selector.push(this.spaces.after);
        return selector.join('');
    };

    _createClass(Attribute, [{
        key: 'qualifiedAttribute',
        get: function get() {
            return this.qualifiedName(this.raws.attribute || this.attribute);
        }
    }, {
        key: 'insensitiveFlag',
        get: function get() {
            return this.insensitive ? 'i' : '';
        }
    }, {
        key: 'value',
        get: function get() {
            return this._value;
        },
        set: function set(v) {
            this._value = v;
            if (this._constructed) {
                delete this.raws.value;
            }
        }
    }, {
        key: 'namespace',
        get: function get() {
            return this._namespace;
        },
        set: function set(v) {
            this._namespace = v;
            if (this._constructed) {
                delete this.raws.namespace;
            }
        }
    }, {
        key: 'attribute',
        get: function get() {
            return this._attribute;
        },
        set: function set(v) {
            this._attribute = v;
            if (this._constructed) {
                delete this.raws.attibute;
            }
        }
    }]);

    return Attribute;
}(_namespace2.default);

exports.default = Attribute;


function defaultAttrConcat(attrValue, attrSpaces) {
    return '' + attrSpaces.before + attrValue + attrSpaces.after;
}
module.exports = exports['default'];
},{"./namespace":914,"./types":922}],906:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _namespace = require('./namespace');

var _namespace2 = _interopRequireDefault(_namespace);

var _types = require('./types');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ClassName = function (_Namespace) {
    _inherits(ClassName, _Namespace);

    function ClassName(opts) {
        _classCallCheck(this, ClassName);

        var _this = _possibleConstructorReturn(this, _Namespace.call(this, opts));

        _this.type = _types.CLASS;
        return _this;
    }

    ClassName.prototype.toString = function toString() {
        return [this.spaces.before, this.ns, String('.' + this.value), this.spaces.after].join('');
    };

    return ClassName;
}(_namespace2.default);

exports.default = ClassName;
module.exports = exports['default'];
},{"./namespace":914,"./types":922}],907:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _node = require('./node');

var _node2 = _interopRequireDefault(_node);

var _types = require('./types');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Combinator = function (_Node) {
    _inherits(Combinator, _Node);

    function Combinator(opts) {
        _classCallCheck(this, Combinator);

        var _this = _possibleConstructorReturn(this, _Node.call(this, opts));

        _this.type = _types.COMBINATOR;
        return _this;
    }

    return Combinator;
}(_node2.default);

exports.default = Combinator;
module.exports = exports['default'];
},{"./node":916,"./types":922}],908:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _node = require('./node');

var _node2 = _interopRequireDefault(_node);

var _types = require('./types');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Comment = function (_Node) {
    _inherits(Comment, _Node);

    function Comment(opts) {
        _classCallCheck(this, Comment);

        var _this = _possibleConstructorReturn(this, _Node.call(this, opts));

        _this.type = _types.COMMENT;
        return _this;
    }

    return Comment;
}(_node2.default);

exports.default = Comment;
module.exports = exports['default'];
},{"./node":916,"./types":922}],909:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.universal = exports.tag = exports.string = exports.selector = exports.root = exports.pseudo = exports.nesting = exports.id = exports.comment = exports.combinator = exports.className = exports.attribute = undefined;

var _attribute = require('./attribute');

var _attribute2 = _interopRequireDefault(_attribute);

var _className = require('./className');

var _className2 = _interopRequireDefault(_className);

var _combinator = require('./combinator');

var _combinator2 = _interopRequireDefault(_combinator);

var _comment = require('./comment');

var _comment2 = _interopRequireDefault(_comment);

var _id = require('./id');

var _id2 = _interopRequireDefault(_id);

var _nesting = require('./nesting');

var _nesting2 = _interopRequireDefault(_nesting);

var _pseudo = require('./pseudo');

var _pseudo2 = _interopRequireDefault(_pseudo);

var _root = require('./root');

var _root2 = _interopRequireDefault(_root);

var _selector = require('./selector');

var _selector2 = _interopRequireDefault(_selector);

var _string = require('./string');

var _string2 = _interopRequireDefault(_string);

var _tag = require('./tag');

var _tag2 = _interopRequireDefault(_tag);

var _universal = require('./universal');

var _universal2 = _interopRequireDefault(_universal);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var attribute = exports.attribute = function attribute(opts) {
  return new _attribute2.default(opts);
};
var className = exports.className = function className(opts) {
  return new _className2.default(opts);
};
var combinator = exports.combinator = function combinator(opts) {
  return new _combinator2.default(opts);
};
var comment = exports.comment = function comment(opts) {
  return new _comment2.default(opts);
};
var id = exports.id = function id(opts) {
  return new _id2.default(opts);
};
var nesting = exports.nesting = function nesting(opts) {
  return new _nesting2.default(opts);
};
var pseudo = exports.pseudo = function pseudo(opts) {
  return new _pseudo2.default(opts);
};
var root = exports.root = function root(opts) {
  return new _root2.default(opts);
};
var selector = exports.selector = function selector(opts) {
  return new _selector2.default(opts);
};
var string = exports.string = function string(opts) {
  return new _string2.default(opts);
};
var tag = exports.tag = function tag(opts) {
  return new _tag2.default(opts);
};
var universal = exports.universal = function universal(opts) {
  return new _universal2.default(opts);
};
},{"./attribute":905,"./className":906,"./combinator":907,"./comment":908,"./id":912,"./nesting":915,"./pseudo":917,"./root":918,"./selector":919,"./string":920,"./tag":921,"./universal":923}],910:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _node = require('./node');

var _node2 = _interopRequireDefault(_node);

var _types = require('./types');

var types = _interopRequireWildcard(_types);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Container = function (_Node) {
    _inherits(Container, _Node);

    function Container(opts) {
        _classCallCheck(this, Container);

        var _this = _possibleConstructorReturn(this, _Node.call(this, opts));

        if (!_this.nodes) {
            _this.nodes = [];
        }
        return _this;
    }

    Container.prototype.append = function append(selector) {
        selector.parent = this;
        this.nodes.push(selector);
        return this;
    };

    Container.prototype.prepend = function prepend(selector) {
        selector.parent = this;
        this.nodes.unshift(selector);
        return this;
    };

    Container.prototype.at = function at(index) {
        return this.nodes[index];
    };

    Container.prototype.index = function index(child) {
        if (typeof child === 'number') {
            return child;
        }
        return this.nodes.indexOf(child);
    };

    Container.prototype.removeChild = function removeChild(child) {
        child = this.index(child);
        this.at(child).parent = undefined;
        this.nodes.splice(child, 1);

        var index = void 0;
        for (var id in this.indexes) {
            index = this.indexes[id];
            if (index >= child) {
                this.indexes[id] = index - 1;
            }
        }

        return this;
    };

    Container.prototype.removeAll = function removeAll() {
        for (var _iterator = this.nodes, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
            var _ref;

            if (_isArray) {
                if (_i >= _iterator.length) break;
                _ref = _iterator[_i++];
            } else {
                _i = _iterator.next();
                if (_i.done) break;
                _ref = _i.value;
            }

            var node = _ref;

            node.parent = undefined;
        }
        this.nodes = [];
        return this;
    };

    Container.prototype.empty = function empty() {
        return this.removeAll();
    };

    Container.prototype.insertAfter = function insertAfter(oldNode, newNode) {
        newNode.parent = this;
        var oldIndex = this.index(oldNode);
        this.nodes.splice(oldIndex + 1, 0, newNode);

        newNode.parent = this;

        var index = void 0;
        for (var id in this.indexes) {
            index = this.indexes[id];
            if (oldIndex <= index) {
                this.indexes[id] = index + 1;
            }
        }

        return this;
    };

    Container.prototype.insertBefore = function insertBefore(oldNode, newNode) {
        newNode.parent = this;
        var oldIndex = this.index(oldNode);
        this.nodes.splice(oldIndex, 0, newNode);

        newNode.parent = this;

        var index = void 0;
        for (var id in this.indexes) {
            index = this.indexes[id];
            if (index <= oldIndex) {
                this.indexes[id] = index + 1;
            }
        }

        return this;
    };

    Container.prototype.each = function each(callback) {
        if (!this.lastEach) {
            this.lastEach = 0;
        }
        if (!this.indexes) {
            this.indexes = {};
        }

        this.lastEach++;
        var id = this.lastEach;
        this.indexes[id] = 0;

        if (!this.length) {
            return undefined;
        }

        var index = void 0,
            result = void 0;
        while (this.indexes[id] < this.length) {
            index = this.indexes[id];
            result = callback(this.at(index), index);
            if (result === false) {
                break;
            }

            this.indexes[id] += 1;
        }

        delete this.indexes[id];

        if (result === false) {
            return false;
        }
    };

    Container.prototype.walk = function walk(callback) {
        return this.each(function (node, i) {
            var result = callback(node, i);

            if (result !== false && node.length) {
                result = node.walk(callback);
            }

            if (result === false) {
                return false;
            }
        });
    };

    Container.prototype.walkAttributes = function walkAttributes(callback) {
        var _this2 = this;

        return this.walk(function (selector) {
            if (selector.type === types.ATTRIBUTE) {
                return callback.call(_this2, selector);
            }
        });
    };

    Container.prototype.walkClasses = function walkClasses(callback) {
        var _this3 = this;

        return this.walk(function (selector) {
            if (selector.type === types.CLASS) {
                return callback.call(_this3, selector);
            }
        });
    };

    Container.prototype.walkCombinators = function walkCombinators(callback) {
        var _this4 = this;

        return this.walk(function (selector) {
            if (selector.type === types.COMBINATOR) {
                return callback.call(_this4, selector);
            }
        });
    };

    Container.prototype.walkComments = function walkComments(callback) {
        var _this5 = this;

        return this.walk(function (selector) {
            if (selector.type === types.COMMENT) {
                return callback.call(_this5, selector);
            }
        });
    };

    Container.prototype.walkIds = function walkIds(callback) {
        var _this6 = this;

        return this.walk(function (selector) {
            if (selector.type === types.ID) {
                return callback.call(_this6, selector);
            }
        });
    };

    Container.prototype.walkNesting = function walkNesting(callback) {
        var _this7 = this;

        return this.walk(function (selector) {
            if (selector.type === types.NESTING) {
                return callback.call(_this7, selector);
            }
        });
    };

    Container.prototype.walkPseudos = function walkPseudos(callback) {
        var _this8 = this;

        return this.walk(function (selector) {
            if (selector.type === types.PSEUDO) {
                return callback.call(_this8, selector);
            }
        });
    };

    Container.prototype.walkTags = function walkTags(callback) {
        var _this9 = this;

        return this.walk(function (selector) {
            if (selector.type === types.TAG) {
                return callback.call(_this9, selector);
            }
        });
    };

    Container.prototype.walkUniversals = function walkUniversals(callback) {
        var _this10 = this;

        return this.walk(function (selector) {
            if (selector.type === types.UNIVERSAL) {
                return callback.call(_this10, selector);
            }
        });
    };

    Container.prototype.split = function split(callback) {
        var _this11 = this;

        var current = [];
        return this.reduce(function (memo, node, index) {
            var split = callback.call(_this11, node);
            current.push(node);
            if (split) {
                memo.push(current);
                current = [];
            } else if (index === _this11.length - 1) {
                memo.push(current);
            }
            return memo;
        }, []);
    };

    Container.prototype.map = function map(callback) {
        return this.nodes.map(callback);
    };

    Container.prototype.reduce = function reduce(callback, memo) {
        return this.nodes.reduce(callback, memo);
    };

    Container.prototype.every = function every(callback) {
        return this.nodes.every(callback);
    };

    Container.prototype.some = function some(callback) {
        return this.nodes.some(callback);
    };

    Container.prototype.filter = function filter(callback) {
        return this.nodes.filter(callback);
    };

    Container.prototype.sort = function sort(callback) {
        return this.nodes.sort(callback);
    };

    Container.prototype.toString = function toString() {
        return this.map(String).join('');
    };

    _createClass(Container, [{
        key: 'first',
        get: function get() {
            return this.at(0);
        }
    }, {
        key: 'last',
        get: function get() {
            return this.at(this.length - 1);
        }
    }, {
        key: 'length',
        get: function get() {
            return this.nodes.length;
        }
    }]);

    return Container;
}(_node2.default);

exports.default = Container;
module.exports = exports['default'];
},{"./node":916,"./types":922}],911:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports.isUniversal = exports.isTag = exports.isString = exports.isSelector = exports.isRoot = exports.isPseudo = exports.isNesting = exports.isIdentifier = exports.isComment = exports.isCombinator = exports.isClassName = exports.isAttribute = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _IS_TYPE;

exports.isNode = isNode;
exports.isPseudoElement = isPseudoElement;
exports.isPseudoClass = isPseudoClass;
exports.isContainer = isContainer;
exports.isNamespace = isNamespace;

var _types = require("./types");

var IS_TYPE = (_IS_TYPE = {}, _IS_TYPE[_types.ATTRIBUTE] = true, _IS_TYPE[_types.CLASS] = true, _IS_TYPE[_types.COMBINATOR] = true, _IS_TYPE[_types.COMMENT] = true, _IS_TYPE[_types.ID] = true, _IS_TYPE[_types.NESTING] = true, _IS_TYPE[_types.PSEUDO] = true, _IS_TYPE[_types.ROOT] = true, _IS_TYPE[_types.SELECTOR] = true, _IS_TYPE[_types.STRING] = true, _IS_TYPE[_types.TAG] = true, _IS_TYPE[_types.UNIVERSAL] = true, _IS_TYPE);

function isNode(node) {
    return (typeof node === "undefined" ? "undefined" : _typeof(node)) === "object" && IS_TYPE[node.type];
}

function isNodeType(type, node) {
    return isNode(node) && node.type === type;
}

var isAttribute = exports.isAttribute = isNodeType.bind(null, _types.ATTRIBUTE);
var isClassName = exports.isClassName = isNodeType.bind(null, _types.CLASS);
var isCombinator = exports.isCombinator = isNodeType.bind(null, _types.COMBINATOR);
var isComment = exports.isComment = isNodeType.bind(null, _types.COMMENT);
var isIdentifier = exports.isIdentifier = isNodeType.bind(null, _types.ID);
var isNesting = exports.isNesting = isNodeType.bind(null, _types.NESTING);
var isPseudo = exports.isPseudo = isNodeType.bind(null, _types.PSEUDO);
var isRoot = exports.isRoot = isNodeType.bind(null, _types.ROOT);
var isSelector = exports.isSelector = isNodeType.bind(null, _types.SELECTOR);
var isString = exports.isString = isNodeType.bind(null, _types.STRING);
var isTag = exports.isTag = isNodeType.bind(null, _types.TAG);
var isUniversal = exports.isUniversal = isNodeType.bind(null, _types.UNIVERSAL);

function isPseudoElement(node) {
    return isPseudo(node) && node.value && (node.value.startsWith("::") || node.value === ":before" || node.value === ":after");
}
function isPseudoClass(node) {
    return isPseudo(node) && !isPseudoElement(node);
}

function isContainer(node) {
    return !!(isNode(node) && node.walk);
}

function isNamespace(node) {
    return isClassName(node) || isAttribute(node) || isTag(node);
}
},{"./types":922}],912:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _namespace = require('./namespace');

var _namespace2 = _interopRequireDefault(_namespace);

var _types = require('./types');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ID = function (_Namespace) {
    _inherits(ID, _Namespace);

    function ID(opts) {
        _classCallCheck(this, ID);

        var _this = _possibleConstructorReturn(this, _Namespace.call(this, opts));

        _this.type = _types.ID;
        return _this;
    }

    ID.prototype.toString = function toString() {
        return [this.spaces.before, this.ns, String('#' + this.value), this.spaces.after].join('');
    };

    return ID;
}(_namespace2.default);

exports.default = ID;
module.exports = exports['default'];
},{"./namespace":914,"./types":922}],913:[function(require,module,exports){
"use strict";

exports.__esModule = true;

var _types = require("./types");

Object.keys(_types).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _types[key];
    }
  });
});

var _constructors = require("./constructors");

Object.keys(_constructors).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _constructors[key];
    }
  });
});

var _guards = require("./guards");

Object.keys(_guards).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _guards[key];
    }
  });
});
},{"./constructors":909,"./guards":911,"./types":922}],914:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _node = require('./node');

var _node2 = _interopRequireDefault(_node);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Namespace = function (_Node) {
    _inherits(Namespace, _Node);

    function Namespace() {
        _classCallCheck(this, Namespace);

        return _possibleConstructorReturn(this, _Node.apply(this, arguments));
    }

    Namespace.prototype.qualifiedName = function qualifiedName(value) {
        if (this.namespace) {
            return this.namespaceString + '|' + value;
        } else {
            return value;
        }
    };

    Namespace.prototype.toString = function toString() {
        return [this.spaces.before, this.qualifiedName(this.value), this.spaces.after].join('');
    };

    _createClass(Namespace, [{
        key: 'namespace',
        get: function get() {
            return this._namespace;
        },
        set: function set(namespace) {
            this._namespace = namespace;
            if (this.raws) {
                delete this.raws.namespace;
            }
        }
    }, {
        key: 'ns',
        get: function get() {
            return this._namespace;
        },
        set: function set(namespace) {
            this._namespace = namespace;
            if (this.raws) {
                delete this.raws.namespace;
            }
        }
    }, {
        key: 'namespaceString',
        get: function get() {
            if (this.namespace) {
                var ns = this.raws && this.raws.namespace || this.namespace;
                if (ns === true) {
                    return '';
                } else {
                    return ns;
                }
            } else {
                return '';
            }
        }
    }]);

    return Namespace;
}(_node2.default);

exports.default = Namespace;
;
module.exports = exports['default'];
},{"./node":916}],915:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _node = require('./node');

var _node2 = _interopRequireDefault(_node);

var _types = require('./types');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Nesting = function (_Node) {
    _inherits(Nesting, _Node);

    function Nesting(opts) {
        _classCallCheck(this, Nesting);

        var _this = _possibleConstructorReturn(this, _Node.call(this, opts));

        _this.type = _types.NESTING;
        _this.value = '&';
        return _this;
    }

    return Nesting;
}(_node2.default);

exports.default = Nesting;
module.exports = exports['default'];
},{"./node":916,"./types":922}],916:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var cloneNode = function cloneNode(obj, parent) {
    if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) !== 'object') {
        return obj;
    }

    var cloned = new obj.constructor();

    for (var i in obj) {
        if (!obj.hasOwnProperty(i)) {
            continue;
        }
        var value = obj[i];
        var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);

        if (i === 'parent' && type === 'object') {
            if (parent) {
                cloned[i] = parent;
            }
        } else if (value instanceof Array) {
            cloned[i] = value.map(function (j) {
                return cloneNode(j, cloned);
            });
        } else {
            cloned[i] = cloneNode(value, cloned);
        }
    }

    return cloned;
};

var _class = function () {
    function _class() {
        var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        _classCallCheck(this, _class);

        Object.assign(this, opts);
        this.spaces = this.spaces || {};
        this.spaces.before = this.spaces.before || '';
        this.spaces.after = this.spaces.after || '';
    }

    _class.prototype.remove = function remove() {
        if (this.parent) {
            this.parent.removeChild(this);
        }
        this.parent = undefined;
        return this;
    };

    _class.prototype.replaceWith = function replaceWith() {
        if (this.parent) {
            for (var index in arguments) {
                this.parent.insertBefore(this, arguments[index]);
            }
            this.remove();
        }
        return this;
    };

    _class.prototype.next = function next() {
        return this.parent.at(this.parent.index(this) + 1);
    };

    _class.prototype.prev = function prev() {
        return this.parent.at(this.parent.index(this) - 1);
    };

    _class.prototype.clone = function clone() {
        var overrides = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        var cloned = cloneNode(this);
        for (var name in overrides) {
            cloned[name] = overrides[name];
        }
        return cloned;
    };

    _class.prototype.toString = function toString() {
        return [this.spaces.before, String(this.value), this.spaces.after].join('');
    };

    return _class;
}();

exports.default = _class;
module.exports = exports['default'];
},{}],917:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _container = require('./container');

var _container2 = _interopRequireDefault(_container);

var _types = require('./types');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Pseudo = function (_Container) {
    _inherits(Pseudo, _Container);

    function Pseudo(opts) {
        _classCallCheck(this, Pseudo);

        var _this = _possibleConstructorReturn(this, _Container.call(this, opts));

        _this.type = _types.PSEUDO;
        return _this;
    }

    Pseudo.prototype.toString = function toString() {
        var params = this.length ? '(' + this.map(String).join(',') + ')' : '';
        return [this.spaces.before, String(this.value), params, this.spaces.after].join('');
    };

    return Pseudo;
}(_container2.default);

exports.default = Pseudo;
module.exports = exports['default'];
},{"./container":910,"./types":922}],918:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _container = require('./container');

var _container2 = _interopRequireDefault(_container);

var _types = require('./types');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Root = function (_Container) {
    _inherits(Root, _Container);

    function Root(opts) {
        _classCallCheck(this, Root);

        var _this = _possibleConstructorReturn(this, _Container.call(this, opts));

        _this.type = _types.ROOT;
        return _this;
    }

    Root.prototype.toString = function toString() {
        var str = this.reduce(function (memo, selector) {
            var sel = String(selector);
            return sel ? memo + sel + ',' : '';
        }, '').slice(0, -1);
        return this.trailingComma ? str + ',' : str;
    };

    Root.prototype.error = function error(message, options) {
        if (this._error) {
            return this._error(message, options);
        } else {
            return new Error(message);
        }
    };

    _createClass(Root, [{
        key: 'errorGenerator',
        set: function set(handler) {
            this._error = handler;
        }
    }]);

    return Root;
}(_container2.default);

exports.default = Root;
module.exports = exports['default'];
},{"./container":910,"./types":922}],919:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _container = require('./container');

var _container2 = _interopRequireDefault(_container);

var _types = require('./types');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Selector = function (_Container) {
    _inherits(Selector, _Container);

    function Selector(opts) {
        _classCallCheck(this, Selector);

        var _this = _possibleConstructorReturn(this, _Container.call(this, opts));

        _this.type = _types.SELECTOR;
        return _this;
    }

    return Selector;
}(_container2.default);

exports.default = Selector;
module.exports = exports['default'];
},{"./container":910,"./types":922}],920:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _node = require('./node');

var _node2 = _interopRequireDefault(_node);

var _types = require('./types');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var String = function (_Node) {
    _inherits(String, _Node);

    function String(opts) {
        _classCallCheck(this, String);

        var _this = _possibleConstructorReturn(this, _Node.call(this, opts));

        _this.type = _types.STRING;
        return _this;
    }

    return String;
}(_node2.default);

exports.default = String;
module.exports = exports['default'];
},{"./node":916,"./types":922}],921:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _namespace = require('./namespace');

var _namespace2 = _interopRequireDefault(_namespace);

var _types = require('./types');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Tag = function (_Namespace) {
    _inherits(Tag, _Namespace);

    function Tag(opts) {
        _classCallCheck(this, Tag);

        var _this = _possibleConstructorReturn(this, _Namespace.call(this, opts));

        _this.type = _types.TAG;
        return _this;
    }

    return Tag;
}(_namespace2.default);

exports.default = Tag;
module.exports = exports['default'];
},{"./namespace":914,"./types":922}],922:[function(require,module,exports){
'use strict';

exports.__esModule = true;
var TAG = exports.TAG = 'tag';
var STRING = exports.STRING = 'string';
var SELECTOR = exports.SELECTOR = 'selector';
var ROOT = exports.ROOT = 'root';
var PSEUDO = exports.PSEUDO = 'pseudo';
var NESTING = exports.NESTING = 'nesting';
var ID = exports.ID = 'id';
var COMMENT = exports.COMMENT = 'comment';
var COMBINATOR = exports.COMBINATOR = 'combinator';
var CLASS = exports.CLASS = 'class';
var ATTRIBUTE = exports.ATTRIBUTE = 'attribute';
var UNIVERSAL = exports.UNIVERSAL = 'universal';
},{}],923:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _namespace = require('./namespace');

var _namespace2 = _interopRequireDefault(_namespace);

var _types = require('./types');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Universal = function (_Namespace) {
    _inherits(Universal, _Namespace);

    function Universal(opts) {
        _classCallCheck(this, Universal);

        var _this = _possibleConstructorReturn(this, _Namespace.call(this, opts));

        _this.type = _types.UNIVERSAL;
        _this.value = '*';
        return _this;
    }

    return Universal;
}(_namespace2.default);

exports.default = Universal;
module.exports = exports['default'];
},{"./namespace":914,"./types":922}],924:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports.default = sortAscending;
function sortAscending(list) {
    return list.sort(function (a, b) {
        return a - b;
    });
};
module.exports = exports["default"];
},{}],925:[function(require,module,exports){
'use strict';

exports.__esModule = true;
var ampersand = exports.ampersand = '&'.charCodeAt(0);
var asterisk = exports.asterisk = '*'.charCodeAt(0);
var at = exports.at = '@'.charCodeAt(0);
var comma = exports.comma = ','.charCodeAt(0);
var colon = exports.colon = ':'.charCodeAt(0);
var semicolon = exports.semicolon = ';'.charCodeAt(0);
var openParenthesis = exports.openParenthesis = '('.charCodeAt(0);
var closeParenthesis = exports.closeParenthesis = ')'.charCodeAt(0);
var openSquare = exports.openSquare = '['.charCodeAt(0);
var closeSquare = exports.closeSquare = ']'.charCodeAt(0);
var dollar = exports.dollar = '$'.charCodeAt(0);
var tilde = exports.tilde = '~'.charCodeAt(0);
var caret = exports.caret = '^'.charCodeAt(0);
var plus = exports.plus = '+'.charCodeAt(0);
var equals = exports.equals = '='.charCodeAt(0);
var pipe = exports.pipe = '|'.charCodeAt(0);
var greaterThan = exports.greaterThan = '>'.charCodeAt(0);
var space = exports.space = ' '.charCodeAt(0);
var singleQuote = exports.singleQuote = '\''.charCodeAt(0);
var doubleQuote = exports.doubleQuote = '"'.charCodeAt(0);
var slash = exports.slash = '/'.charCodeAt(0);

var backslash = exports.backslash = 92;
var cr = exports.cr = 13;
var feed = exports.feed = 12;
var newline = exports.newline = 10;
var tab = exports.tab = 9;

// Expose aliases primarily for readability.
var str = exports.str = singleQuote;

// No good single character representation!
var comment = exports.comment = -1;
var word = exports.word = -2;
var combinator = exports.combinator = -3;
},{}],926:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.default = tokenize;

var _tokenTypes = require('./tokenTypes');

var t = _interopRequireWildcard(_tokenTypes);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var wordEnd = /[ \n\t\r\(\)\*:;!&'"\+\|~>,=$^\[\]\\]|\/(?=\*)/g;

function tokenize(input) {
    var tokens = [];
    var css = input.css.valueOf();
    var _css = css,
        length = _css.length;

    var offset = -1;
    var line = 1;
    var start = 0;
    var end = 0;

    var code = void 0,
        content = void 0,
        endColumn = void 0,
        endLine = void 0,
        escaped = void 0,
        escapePos = void 0,
        last = void 0,
        lines = void 0,
        next = void 0,
        nextLine = void 0,
        nextOffset = void 0,
        quote = void 0,
        tokenType = void 0;

    function unclosed(what, fix) {
        if (input.safe) {
            // fyi: this is never set to true.
            css += fix;
            next = css.length - 1;
        } else {
            throw input.error('Unclosed ' + what, line, start - offset, start);
        }
    }

    while (start < length) {
        code = css.charCodeAt(start);

        if (code === t.newline) {
            offset = start;
            line += 1;
        }

        switch (code) {
            case t.newline:
            case t.space:
            case t.tab:
            case t.cr:
            case t.feed:
                next = start;
                do {
                    next += 1;
                    code = css.charCodeAt(next);
                    if (code === t.newline) {
                        offset = next;
                        line += 1;
                    }
                } while (code === t.space || code === t.newline || code === t.tab || code === t.cr || code === t.feed);

                tokenType = t.space;
                endLine = line;
                endColumn = start - offset;
                end = next;
                break;

            case t.plus:
            case t.greaterThan:
            case t.tilde:
            case t.pipe:
                next = start;
                do {
                    next += 1;
                    code = css.charCodeAt(next);
                } while (code === t.plus || code === t.greaterThan || code === t.tilde || code === t.pipe);

                tokenType = t.combinator;
                endLine = line;
                endColumn = start - offset;
                end = next;
                break;

            // Consume these characters as single tokens.
            case t.asterisk:
            case t.ampersand:
            case t.comma:
            case t.equals:
            case t.dollar:
            case t.caret:
            case t.openSquare:
            case t.closeSquare:
            case t.colon:
            case t.semicolon:
            case t.openParenthesis:
            case t.closeParenthesis:
                next = start;
                tokenType = code;
                endLine = line;
                endColumn = start - offset;
                end = next + 1;
                break;

            case t.singleQuote:
            case t.doubleQuote:
                quote = code === t.singleQuote ? "'" : '"';
                next = start;
                do {
                    escaped = false;
                    next = css.indexOf(quote, next + 1);
                    if (next === -1) {
                        unclosed('quote', quote);
                    }
                    escapePos = next;
                    while (css.charCodeAt(escapePos - 1) === t.backslash) {
                        escapePos -= 1;
                        escaped = !escaped;
                    }
                } while (escaped);

                tokenType = t.str;
                endLine = line;
                endColumn = start - offset;
                end = next + 1;
                break;

            case t.backslash:
                next = start;
                escaped = true;
                while (css.charCodeAt(next + 1) === t.backslash) {
                    next += 1;
                    escaped = !escaped;
                }
                code = css.charCodeAt(next + 1);
                if (escaped && code !== t.slash && code !== t.space && code !== t.newline && code !== t.tab && code !== t.cr && code !== t.feed) {
                    next += 1;
                }

                tokenType = t.word;
                endLine = line;
                endColumn = next - offset;
                end = next + 1;
                break;

            default:
                if (code === t.slash && css.charCodeAt(start + 1) === t.asterisk) {
                    next = css.indexOf('*/', start + 2) + 1;
                    if (next === 0) {
                        unclosed('comment', '*/');
                    }

                    content = css.slice(start, next + 1);
                    lines = content.split('\n');
                    last = lines.length - 1;

                    if (last > 0) {
                        nextLine = line + last;
                        nextOffset = next - lines[last].length;
                    } else {
                        nextLine = line;
                        nextOffset = offset;
                    }

                    tokenType = t.comment;
                    line = nextLine;
                    endLine = nextLine;
                    endColumn = next - nextOffset;
                } else {
                    wordEnd.lastIndex = start + 1;
                    wordEnd.test(css);
                    if (wordEnd.lastIndex === 0) {
                        next = css.length - 1;
                    } else {
                        next = wordEnd.lastIndex - 2;
                    }

                    tokenType = t.word;
                    endLine = line;
                    endColumn = next - offset;
                }

                end = next + 1;
                break;
        }

        // Ensure that the token structure remains consistent
        tokens.push([tokenType, // [0] Token type
        line, // [1] Starting line
        start - offset, // [2] Starting column
        endLine, // [3] Ending line
        endColumn, // [4] Ending column
        start, // [5] Start position / Source index
        end]);

        // Reset offset for the next token
        if (nextOffset) {
            offset = nextOffset;
            nextOffset = null;
        }

        start = end;
    }

    return tokens;
}
module.exports = exports['default'];
},{"./tokenTypes":925}],927:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _postcss = require('postcss');

var _postcss2 = _interopRequireDefault(_postcss);

var _postcssValueParser = require('postcss-value-parser');

var _postcssValueParser2 = _interopRequireDefault(_postcssValueParser);

var _minifyWeight = require('./lib/minify-weight');

var _minifyWeight2 = _interopRequireDefault(_minifyWeight);

var _minifyFamily = require('./lib/minify-family');

var _minifyFamily2 = _interopRequireDefault(_minifyFamily);

var _minifyFont = require('./lib/minify-font');

var _minifyFont2 = _interopRequireDefault(_minifyFont);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function transform(opts, decl) {
    let tree;
    let prop = decl.prop.toLowerCase();

    if (prop === 'font-weight') {
        decl.value = (0, _minifyWeight2.default)(decl.value);
    } else if (prop === 'font-family') {
        tree = (0, _postcssValueParser2.default)(decl.value);
        tree.nodes = (0, _minifyFamily2.default)(tree.nodes, opts);
        decl.value = tree.toString();
    } else if (prop === 'font') {
        tree = (0, _postcssValueParser2.default)(decl.value);
        tree.nodes = (0, _minifyFont2.default)(tree.nodes, opts);
        decl.value = tree.toString();
    }
}

exports.default = _postcss2.default.plugin('postcss-minify-font-values', opts => {
    opts = Object.assign({}, {
        removeAfterKeyword: false,
        removeDuplicates: true,
        removeQuotes: true
    }, opts);

    return css => css.walkDecls(/font/i, transform.bind(null, opts));
});
module.exports = exports['default'];
},{"./lib/minify-family":929,"./lib/minify-font":930,"./lib/minify-weight":931,"postcss":1074,"postcss-value-parser":1057}],928:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = {
    style: ['italic', 'oblique'],
    variant: ['small-caps'],
    weight: ['100', '200', '300', '400', '500', '600', '700', '800', '900', 'bold', 'lighter', 'bolder'],
    stretch: ['ultra-condensed', 'extra-condensed', 'condensed', 'semi-condensed', 'semi-expanded', 'expanded', 'extra-expanded', 'ultra-expanded'],
    size: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large', 'larger', 'smaller']
};
module.exports = exports['default'];
},{}],929:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

exports.default = function (nodes, opts) {
    let family = [];
    let last = null;
    let i, max;

    nodes.forEach((node, index, arr) => {
        if (node.type === 'string' || node.type === 'function') {
            family.push(node);
        } else if (node.type === 'word') {
            if (!last) {
                last = { type: 'word', value: '' };
                family.push(last);
            }

            last.value += node.value;
        } else if (node.type === 'space') {
            if (last && index !== arr.length - 1) {
                last.value += ' ';
            }
        } else {
            last = null;
        }
    });

    family = family.map(node => {
        if (node.type === 'string') {
            const isKeyword = regexKeyword.test(node.value);

            if (!opts.removeQuotes || isKeyword || /[0-9]/.test(node.value.slice(0, 1))) {
                return (0, _postcssValueParser.stringify)(node);
            }

            let escaped = escapeIdentifierSequence(node.value);

            if (escaped.length < node.value.length + 2) {
                return escaped;
            }
        }

        return (0, _postcssValueParser.stringify)(node);
    });

    if (opts.removeAfterKeyword) {
        for (i = 0, max = family.length; i < max; i += 1) {
            if (~genericFontFamilykeywords.indexOf(family[i].toLowerCase())) {
                family = family.slice(0, i + 1);
                break;
            }
        }
    }

    if (opts.removeDuplicates) {
        family = uniqs(family);
    }

    return [{
        type: 'word',
        value: family.join()
    }];
};

var _postcssValueParser = require('postcss-value-parser');

var _uniqs = require('./uniqs');

var _uniqs2 = _interopRequireDefault(_uniqs);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const uniqs = (0, _uniqs2.default)('monospace');
const globalKeywords = ['inherit', 'initial', 'unset'];
const genericFontFamilykeywords = ['sans-serif', 'serif', 'fantasy', 'cursive', 'monospace', 'system-ui'];

function makeArray(value, length) {
    let array = [];
    while (length--) {
        array[length] = value;
    }
    return array;
}

const regexSimpleEscapeCharacters = /[ !"#$%&'()*+,.\/;<=>?@\[\\\]^`{|}~]/;

function escape(string, escapeForString) {
    let counter = 0;
    let character = null;
    let charCode = null;
    let value = null;
    let output = '';

    while (counter < string.length) {
        character = string.charAt(counter++);
        charCode = character.charCodeAt();

        // \r is already tokenized away at this point
        // `:` can be escaped as `\:`, but that fails in IE < 8
        if (!escapeForString && /[\t\n\v\f:]/.test(character)) {
            value = '\\' + charCode.toString(16) + ' ';
        } else if (!escapeForString && regexSimpleEscapeCharacters.test(character)) {
            value = '\\' + character;
        } else {
            value = character;
        }

        output += value;
    }

    if (!escapeForString) {
        if (/^-[-\d]/.test(output)) {
            output = '\\-' + output.slice(1);
        }

        const firstChar = string.charAt(0);

        if (/\d/.test(firstChar)) {
            output = '\\3' + firstChar + ' ' + output.slice(1);
        }
    }

    return output;
}

const regexKeyword = new RegExp(genericFontFamilykeywords.concat(globalKeywords).join('|'), 'i');
const regexInvalidIdentifier = /^(-?\d|--)/;
const regexSpaceAtStart = /^\x20/;
const regexWhitespace = /[\t\n\f\r\x20]/g;
const regexIdentifierCharacter = /^[a-zA-Z\d\xa0-\uffff_-]+$/;
const regexConsecutiveSpaces = /(\\(?:[a-fA-F0-9]{1,6}\x20|\x20))?(\x20{2,})/g;
const regexTrailingEscape = /\\[a-fA-F0-9]{0,6}\x20$/;
const regexTrailingSpace = /\x20$/;

function escapeIdentifierSequence(string) {
    let identifiers = string.split(regexWhitespace);
    let index = 0;
    let result = [];
    let escapeResult;

    while (index < identifiers.length) {
        let subString = identifiers[index++];

        if (subString === '') {
            result.push(subString);
            continue;
        }

        escapeResult = escape(subString, false);

        if (regexIdentifierCharacter.test(subString)) {
            // the font family name part consists of allowed characters exclusively
            if (regexInvalidIdentifier.test(subString)) {
                // the font family name part starts with two hyphens, a digit, or a
                // hyphen followed by a digit
                if (index === 1) {
                    // if this is the first item
                    result.push(escapeResult);
                } else {
                    // if its not the first item, we can simply escape the space
                    // between the two identifiers to merge them into a single
                    // identifier rather than escaping the start characters of the
                    // second identifier
                    result[index - 2] += '\\';
                    result.push(escape(subString, true));
                }
            } else {
                // the font family name part doesnt start with two hyphens, a digit,
                // or a hyphen followed by a digit
                result.push(escapeResult);
            }
        } else {
            // the font family name part contains invalid identifier characters
            result.push(escapeResult);
        }
    }

    result = result.join(' ').replace(regexConsecutiveSpaces, ($0, $1, $2) => {
        const spaceCount = $2.length;
        const escapesNeeded = Math.floor(spaceCount / 2);
        const array = makeArray('\\ ', escapesNeeded);

        if (spaceCount % 2) {
            array[escapesNeeded - 1] += '\\ ';
        }

        return ($1 || '') + ' ' + array.join(' ');
    });

    // Escape trailing spaces unless theyre already part of an escape
    if (regexTrailingSpace.test(result) && !regexTrailingEscape.test(result)) {
        result = result.replace(regexTrailingSpace, '\\ ');
    }

    if (regexSpaceAtStart.test(result)) {
        result = '\\ ' + result.slice(1);
    }

    return result;
}

;
module.exports = exports['default'];
},{"./uniqs":932,"postcss-value-parser":1057}],930:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

exports.default = function (nodes, opts) {
    let i, max, node, familyStart, family;
    let hasSize = false;

    for (i = 0, max = nodes.length; i < max; i += 1) {
        node = nodes[i];
        if (node.type === 'word') {
            if (hasSize) {
                continue;
            }
            const value = node.value.toLowerCase();
            if (value === 'normal' || ~_keywords2.default.style.indexOf(value) || ~_keywords2.default.variant.indexOf(value) || ~_keywords2.default.stretch.indexOf(value)) {
                familyStart = i;
            } else if (~_keywords2.default.weight.indexOf(value)) {
                node.value = (0, _minifyWeight2.default)(value);
                familyStart = i;
            } else if (~_keywords2.default.size.indexOf(value) || (0, _postcssValueParser.unit)(value)) {
                familyStart = i;
                hasSize = true;
            }
        } else if (node.type === 'div' && node.value === '/') {
            familyStart = i + 1;
            break;
        }
    }

    familyStart += 2;
    family = (0, _minifyFamily2.default)(nodes.slice(familyStart), opts);
    return nodes.slice(0, familyStart).concat(family);
};

var _postcssValueParser = require('postcss-value-parser');

var _keywords = require('./keywords');

var _keywords2 = _interopRequireDefault(_keywords);

var _minifyFamily = require('./minify-family');

var _minifyFamily2 = _interopRequireDefault(_minifyFamily);

var _minifyWeight = require('./minify-weight');

var _minifyWeight2 = _interopRequireDefault(_minifyWeight);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

;
module.exports = exports['default'];
},{"./keywords":928,"./minify-family":929,"./minify-weight":931,"postcss-value-parser":1057}],931:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

exports.default = function (value) {
    const valueInLowerCase = value.toLowerCase();

    return valueInLowerCase === 'normal' ? '400' : valueInLowerCase === 'bold' ? '700' : value;
};

;
module.exports = exports['default'];
},{}],932:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = uniqueExcept;
function uniqueExcept(exclude) {
    return function unique() {
        const list = Array.prototype.concat.apply([], arguments);
        return list.filter((item, i) => {
            if (item.toLowerCase() === exclude) {
                return true;
            }
            return i === list.indexOf(item);
        });
    };
};
module.exports = exports["default"];
},{}],933:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _postcss = require('postcss');

var _postcss2 = _interopRequireDefault(_postcss);

var _postcssValueParser = require('postcss-value-parser');

var _postcssValueParser2 = _interopRequireDefault(_postcssValueParser);

var _cssnanoUtilGetArguments = require('cssnano-util-get-arguments');

var _cssnanoUtilGetArguments2 = _interopRequireDefault(_cssnanoUtilGetArguments);

var _isColorStop = require('is-color-stop');

var _isColorStop2 = _interopRequireDefault(_isColorStop);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const angles = {
    top: '0deg',
    right: '90deg',
    bottom: '180deg',
    left: '270deg'
};

function isLessThan(a, b) {
    return a.unit.toLowerCase() === b.unit.toLowerCase() && parseFloat(a.number) >= parseFloat(b.number);
}

function optimise(decl) {
    const value = decl.value;

    if (!~value.toLowerCase().indexOf('gradient')) {
        return;
    }

    decl.value = (0, _postcssValueParser2.default)(value).walk(node => {
        if (node.type !== 'function' || !node.nodes.length) {
            return false;
        }

        const lowerCasedValue = node.value.toLowerCase();

        if (lowerCasedValue === 'linear-gradient' || lowerCasedValue === 'repeating-linear-gradient' || lowerCasedValue === '-webkit-linear-gradient' || lowerCasedValue === '-webkit-repeating-linear-gradient') {
            let args = (0, _cssnanoUtilGetArguments2.default)(node);

            if (node.nodes[0].value.toLowerCase() === 'to' && args[0].length === 3) {
                node.nodes = node.nodes.slice(2);
                node.nodes[0].value = angles[node.nodes[0].value.toLowerCase()];
            }

            let lastStop = null;

            args.forEach((arg, index) => {
                if (!arg[2]) {
                    return;
                }

                let isFinalStop = index === args.length - 1;
                let thisStop = (0, _postcssValueParser.unit)(arg[2].value);

                if (lastStop === null) {
                    lastStop = thisStop;

                    if (!isFinalStop && lastStop && lastStop.number === '0' && lastStop.unit.toLowerCase() !== 'deg') {
                        arg[1].value = arg[2].value = '';
                    }

                    return;
                }

                if (lastStop && thisStop && isLessThan(lastStop, thisStop)) {
                    arg[2].value = 0;
                }

                lastStop = thisStop;

                if (isFinalStop && arg[2].value === '100%') {
                    arg[1].value = arg[2].value = '';
                }
            });

            return false;
        }

        if (lowerCasedValue === 'radial-gradient' || lowerCasedValue === 'repeating-radial-gradient') {
            let args = (0, _cssnanoUtilGetArguments2.default)(node);
            let lastStop;

            const hasAt = args[0].find(n => n.value.toLowerCase() === 'at');

            args.forEach((arg, index) => {
                if (!arg[2] || !index && hasAt) {
                    return;
                }

                let thisStop = (0, _postcssValueParser.unit)(arg[2].value);

                if (!lastStop) {
                    lastStop = thisStop;

                    return;
                }

                if (lastStop && thisStop && isLessThan(lastStop, thisStop)) {
                    arg[2].value = 0;
                }

                lastStop = thisStop;
            });

            return false;
        }

        if (lowerCasedValue === '-webkit-radial-gradient' || lowerCasedValue === '-webkit-repeating-radial-gradient') {
            let args = (0, _cssnanoUtilGetArguments2.default)(node);
            let lastStop;

            args.forEach(arg => {
                let color;
                let stop;

                if (arg[2] !== undefined) {
                    if (arg[0].type === 'function') {
                        color = `${arg[0].value}(${(0, _postcssValueParser.stringify)(arg[0].nodes)})`;
                    } else {
                        color = arg[0].value;
                    }

                    if (arg[2].type === 'function') {
                        stop = `${arg[2].value}(${(0, _postcssValueParser.stringify)(arg[2].nodes)})`;
                    } else {
                        stop = arg[2].value;
                    }
                } else {
                    if (arg[0].type === 'function') {
                        color = `${arg[0].value}(${(0, _postcssValueParser.stringify)(arg[0].nodes)})`;
                    }

                    color = arg[0].value;
                }

                color = color.toLowerCase();

                const colorStop = stop || stop === 0 ? (0, _isColorStop2.default)(color, stop.toLowerCase()) : (0, _isColorStop2.default)(color);

                if (!colorStop || !arg[2]) {
                    return;
                }

                let thisStop = (0, _postcssValueParser.unit)(arg[2].value);

                if (!lastStop) {
                    lastStop = thisStop;

                    return;
                }

                if (lastStop && thisStop && isLessThan(lastStop, thisStop)) {
                    arg[2].value = 0;
                }

                lastStop = thisStop;
            });

            return false;
        }
    }).toString();
}

exports.default = _postcss2.default.plugin('postcss-minify-gradients', () => {
    return css => css.walkDecls(optimise);
});
module.exports = exports['default'];
},{"cssnano-util-get-arguments":668,"is-color-stop":733,"postcss":1074,"postcss-value-parser":1057}],934:[function(require,module,exports){
(function (__dirname){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _browserslist = require('browserslist');

var _browserslist2 = _interopRequireDefault(_browserslist);

var _postcss = require('postcss');

var _postcss2 = _interopRequireDefault(_postcss);

var _postcssValueParser = require('postcss-value-parser');

var _postcssValueParser2 = _interopRequireDefault(_postcssValueParser);

var _alphanumSort = require('alphanum-sort');

var _alphanumSort2 = _interopRequireDefault(_alphanumSort);

var _uniqs = require('uniqs');

var _uniqs2 = _interopRequireDefault(_uniqs);

var _cssnanoUtilGetArguments = require('cssnano-util-get-arguments');

var _cssnanoUtilGetArguments2 = _interopRequireDefault(_cssnanoUtilGetArguments);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Return the greatest common divisor
 * of two numbers.
 */

function gcd(a, b) {
    return b ? gcd(b, a % b) : a;
}

function aspectRatio(a, b) {
    const divisor = gcd(a, b);

    return [a / divisor, b / divisor];
}

function split(args) {
    return args.map(arg => (0, _postcssValueParser.stringify)(arg)).join('');
}

function removeNode(node) {
    node.value = '';
    node.type = 'word';
}

function transform(legacy, rule) {
    const ruleName = rule.name.toLowerCase();

    // We should re-arrange parameters only for `@media` and `@supports` at-rules
    if (!rule.params || !["media", "supports"].includes(ruleName)) {
        return;
    }

    const params = (0, _postcssValueParser2.default)(rule.params);

    params.walk((node, index) => {
        if (node.type === 'div' || node.type === 'function') {
            node.before = node.after = '';

            if (node.type === 'function' && node.nodes[4] && node.nodes[0].value.toLowerCase().indexOf('-aspect-ratio') === 3) {
                const [a, b] = aspectRatio(node.nodes[2].value, node.nodes[4].value);

                node.nodes[2].value = a;
                node.nodes[4].value = b;
            }
        } else if (node.type === 'space') {
            node.value = ' ';
        } else {
            const prevWord = params.nodes[index - 2];

            if (node.value.toLowerCase() === 'all' && rule.name.toLowerCase() === 'media' && !prevWord) {
                const nextWord = params.nodes[index + 2];

                if (!legacy || nextWord) {
                    removeNode(node);
                }

                if (nextWord && nextWord.value.toLowerCase() === 'and') {
                    const nextSpace = params.nodes[index + 1];
                    const secondSpace = params.nodes[index + 3];

                    removeNode(nextWord);
                    removeNode(nextSpace);
                    removeNode(secondSpace);
                }
            }
        }
    }, true);

    rule.params = (0, _alphanumSort2.default)((0, _uniqs2.default)((0, _cssnanoUtilGetArguments2.default)(params).map(split)), {
        insensitive: true
    }).join();

    if (!rule.params.length) {
        rule.raws.afterName = '';
    }
}

function hasAllBug(browser) {
    return ~['ie 10', 'ie 11'].indexOf(browser);
}

exports.default = _postcss2.default.plugin('postcss-minify-params', () => {
    return (css, result) => {
        const resultOpts = result.opts || {};
        const browsers = (0, _browserslist2.default)(null, {
            stats: resultOpts.stats,
            path: __dirname,
            env: resultOpts.env
        });

        return css.walkAtRules(transform.bind(null, browsers.some(hasAllBug)));
    };
});
module.exports = exports['default'];
}).call(this,"/node_modules/postcss-minify-params/dist")
},{"alphanum-sort":4,"browserslist":12,"cssnano-util-get-arguments":668,"postcss":1074,"postcss-value-parser":1057,"uniqs":1199}],935:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _postcss = require("postcss");

var _alphanumSort = require("alphanum-sort");

var _alphanumSort2 = _interopRequireDefault(_alphanumSort);

var _has = require("has");

var _has2 = _interopRequireDefault(_has);

var _postcssSelectorParser = require("postcss-selector-parser");

var _postcssSelectorParser2 = _interopRequireDefault(_postcssSelectorParser);

var _unquote = require("./lib/unquote");

var _unquote2 = _interopRequireDefault(_unquote);

var _canUnquote = require("./lib/canUnquote");

var _canUnquote2 = _interopRequireDefault(_canUnquote);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const pseudoElements = ["::before", "::after", "::first-letter", "::first-line"];

function getParsed(selectors, callback) {
    return (0, _postcssSelectorParser2.default)(callback).processSync(selectors);
}

function attribute(selector) {
    if (selector.value) {
        // Join selectors that are split over new lines
        selector.value = selector.value.replace(/\\\n/g, "").trim();

        if ((0, _canUnquote2.default)(selector.value)) {
            selector.value = (0, _unquote2.default)(selector.value);
        }

        selector.operator = selector.operator.trim();
    }

    if (!selector.raws) {
        selector.raws = {};
    }

    if (!selector.raws.spaces) {
        selector.raws.spaces = {};
    }

    selector.raws.spaces.attribute = {
        before: "",
        after: ""
    };

    selector.raws.spaces.operator = {
        before: "",
        after: ""
    };

    selector.raws.spaces.value = {
        before: "",
        after: selector.insensitive ? " " : ""
    };

    if (selector.insensitive) {
        selector.raws.spaces.insensitive = {
            before: "",
            after: ""
        };
    }

    selector.attribute = selector.attribute.trim();
}

function combinator(selector) {
    const value = selector.value.trim();

    selector.value = value.length ? value : " ";
}

const pseudoReplacements = {
    ":nth-child": ":first-child",
    ":nth-of-type": ":first-of-type",
    ":nth-last-child": ":last-child",
    ":nth-last-of-type": ":last-of-type"
};

function pseudo(selector) {
    const value = selector.value.toLowerCase();

    if (selector.nodes.length === 1 && pseudoReplacements[value]) {
        const first = selector.at(0);
        const one = first.at(0);

        if (first.length === 1) {
            if (one.value === "1") {
                selector.replaceWith(_postcssSelectorParser2.default.pseudo({
                    value: pseudoReplacements[value]
                }));
            }

            if (one.value.toLowerCase() === "even") {
                one.value = "2n";
            }
        }

        if (first.length === 3) {
            const two = first.at(1);
            const three = first.at(2);

            if (one.value.toLowerCase() === "2n" && two.value === "+" && three.value === "1") {
                one.value = "odd";

                two.remove();
                three.remove();
            }
        }

        return;
    }

    const uniques = [];

    selector.walk(child => {
        if (child.type === "selector") {
            const childStr = String(child);

            if (!~uniques.indexOf(childStr)) {
                uniques.push(childStr);
            } else {
                child.remove();
            }
        }
    });

    if (~pseudoElements.indexOf(value)) {
        selector.value = selector.value.slice(1);
    }
}

const tagReplacements = {
    from: "0%",
    "100%": "to"
};

function tag(selector) {
    const value = selector.value.toLowerCase();

    if ((0, _has2.default)(tagReplacements, value)) {
        selector.value = tagReplacements[value];
    }
}

function universal(selector) {
    const next = selector.next();

    if (next && next.type !== "combinator") {
        selector.remove();
    }
}

const reducers = {
    attribute,
    combinator,
    pseudo,
    tag,
    universal
};

exports.default = (0, _postcss.plugin)("postcss-minify-selectors", () => {
    return css => {
        const cache = {};

        css.walkRules(rule => {
            const selector = rule.raws.selector && rule.raws.selector.value === rule.selector ? rule.raws.selector.raw : rule.selector;

            // If the selector ends with a ':' it is likely a part of a custom mixin,
            // so just pass through.
            if (selector[selector.length - 1] === ":") {
                return;
            }

            if (cache[selector]) {
                rule.selector = cache[selector];

                return;
            }

            const optimizedSelector = getParsed(selector, selectors => {
                selectors.nodes = (0, _alphanumSort2.default)(selectors.nodes, { insensitive: true });

                const uniqueSelectors = [];

                selectors.walk(sel => {
                    const { type } = sel;

                    // Trim whitespace around the value
                    sel.spaces.before = sel.spaces.after = "";

                    if ((0, _has2.default)(reducers, type)) {
                        reducers[type](sel);

                        return;
                    }

                    const toString = String(sel);

                    if (type === "selector" && sel.parent.type !== "pseudo") {
                        if (!~uniqueSelectors.indexOf(toString)) {
                            uniqueSelectors.push(toString);
                        } else {
                            sel.remove();
                        }
                    }
                });
            });

            rule.selector = optimizedSelector;
            cache[selector] = optimizedSelector;
        });
    };
});
module.exports = exports["default"];
},{"./lib/canUnquote":936,"./lib/unquote":937,"alphanum-sort":4,"has":720,"postcss":1074,"postcss-selector-parser":938}],936:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = canUnquote;

var _unquote = require('./unquote');

var _unquote2 = _interopRequireDefault(_unquote);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Can unquote attribute detection from mothereff.in
 * Copyright Mathias Bynens <https://mathiasbynens.be/>
 * https://github.com/mathiasbynens/mothereff.in
 */
const escapes = /\\([0-9A-Fa-f]{1,6})[ \t\n\f\r]?/g;
const range = /[\u0000-\u002c\u002e\u002f\u003A-\u0040\u005B-\u005E\u0060\u007B-\u009f]/;

function canUnquote(value) {
    value = (0, _unquote2.default)(value);
    if (value === '-' || value === '') {
        return false;
    }
    value = value.replace(escapes, 'a').replace(/\\./g, 'a');
    return !(range.test(value) || /^(?:-?\d|--)/.test(value));
}
module.exports = exports['default'];
},{"./unquote":937}],937:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = string => string.replace(/["']/g, '');

module.exports = exports['default'];
},{}],938:[function(require,module,exports){
arguments[4][902][0].apply(exports,arguments)
},{"./processor":940,"./selectors":949,"dup":902}],939:[function(require,module,exports){
arguments[4][903][0].apply(exports,arguments)
},{"./selectors/attribute":941,"./selectors/className":942,"./selectors/combinator":943,"./selectors/comment":944,"./selectors/id":948,"./selectors/nesting":951,"./selectors/pseudo":953,"./selectors/root":954,"./selectors/selector":955,"./selectors/string":956,"./selectors/tag":957,"./selectors/types":958,"./selectors/universal":959,"./sortAscending":960,"./tokenTypes":961,"./tokenize":962,"dot-prop":685,"dup":903,"indexes-of":727,"uniq":1198}],940:[function(require,module,exports){
arguments[4][904][0].apply(exports,arguments)
},{"./parser":939,"dup":904}],941:[function(require,module,exports){
arguments[4][905][0].apply(exports,arguments)
},{"./namespace":950,"./types":958,"dup":905}],942:[function(require,module,exports){
arguments[4][906][0].apply(exports,arguments)
},{"./namespace":950,"./types":958,"dup":906}],943:[function(require,module,exports){
arguments[4][907][0].apply(exports,arguments)
},{"./node":952,"./types":958,"dup":907}],944:[function(require,module,exports){
arguments[4][908][0].apply(exports,arguments)
},{"./node":952,"./types":958,"dup":908}],945:[function(require,module,exports){
arguments[4][909][0].apply(exports,arguments)
},{"./attribute":941,"./className":942,"./combinator":943,"./comment":944,"./id":948,"./nesting":951,"./pseudo":953,"./root":954,"./selector":955,"./string":956,"./tag":957,"./universal":959,"dup":909}],946:[function(require,module,exports){
arguments[4][910][0].apply(exports,arguments)
},{"./node":952,"./types":958,"dup":910}],947:[function(require,module,exports){
arguments[4][911][0].apply(exports,arguments)
},{"./types":958,"dup":911}],948:[function(require,module,exports){
arguments[4][912][0].apply(exports,arguments)
},{"./namespace":950,"./types":958,"dup":912}],949:[function(require,module,exports){
arguments[4][913][0].apply(exports,arguments)
},{"./constructors":945,"./guards":947,"./types":958,"dup":913}],950:[function(require,module,exports){
arguments[4][914][0].apply(exports,arguments)
},{"./node":952,"dup":914}],951:[function(require,module,exports){
arguments[4][915][0].apply(exports,arguments)
},{"./node":952,"./types":958,"dup":915}],952:[function(require,module,exports){
arguments[4][916][0].apply(exports,arguments)
},{"dup":916}],953:[function(require,module,exports){
arguments[4][917][0].apply(exports,arguments)
},{"./container":946,"./types":958,"dup":917}],954:[function(require,module,exports){
arguments[4][918][0].apply(exports,arguments)
},{"./container":946,"./types":958,"dup":918}],955:[function(require,module,exports){
arguments[4][919][0].apply(exports,arguments)
},{"./container":946,"./types":958,"dup":919}],956:[function(require,module,exports){
arguments[4][920][0].apply(exports,arguments)
},{"./node":952,"./types":958,"dup":920}],957:[function(require,module,exports){
arguments[4][921][0].apply(exports,arguments)
},{"./namespace":950,"./types":958,"dup":921}],958:[function(require,module,exports){
arguments[4][922][0].apply(exports,arguments)
},{"dup":922}],959:[function(require,module,exports){
arguments[4][923][0].apply(exports,arguments)
},{"./namespace":950,"./types":958,"dup":923}],960:[function(require,module,exports){
arguments[4][924][0].apply(exports,arguments)
},{"dup":924}],961:[function(require,module,exports){
arguments[4][925][0].apply(exports,arguments)
},{"dup":925}],962:[function(require,module,exports){
arguments[4][926][0].apply(exports,arguments)
},{"./tokenTypes":961,"dup":926}],963:[function(require,module,exports){
var postcss = require('postcss')
var parser = require('postcss-selector-parser')

function parse (str, rule) {
  var nodes
  var saver = parser(function (parsed) {
    nodes = parsed
  })
  try {
    saver.processSync(str)
  } catch (e) {
    if (str.indexOf(':') !== -1) {
      throw rule ? rule.error('Missed semicolon') : e
    } else {
      throw rule ? rule.error(e.message) : e
    }
  }
  return nodes.at(0)
}

function replace (nodes, parent) {
  var replaced = false
  nodes.each(function (i) {
    if (i.type === 'nesting') {
      var clonedParent = parent.clone()
      if (i.value !== '&') {
        i.replaceWith(parse(i.value.replace('&', clonedParent.toString())))
      } else {
        i.replaceWith(clonedParent)
      }
      replaced = true
    } else if (i.nodes) {
      if (replace(i, parent)) {
        replaced = true
      }
    }
  })
  return replaced
}

function selectors (parent, child) {
  var result = []
  parent.selectors.forEach(function (i) {
    var parentNode = parse(i, parent)

    child.selectors.forEach(function (j) {
      var node = parse(j, child)
      var replaced = replace(node, parentNode)
      if (!replaced) {
        node.prepend(parser.combinator({ value: ' ' }))
        node.prepend(parentNode.clone())
      }
      result.push(node.toString())
    })
  })
  return result
}

function pickComment (comment, after) {
  if (comment && comment.type === 'comment') {
    after.after(comment)
    return comment
  } else {
    return after
  }
}

function atruleChilds (rule, atrule, bubbling) {
  var children = []
  atrule.each(function (child) {
    if (child.type === 'comment') {
      children.push(child)
    } if (child.type === 'decl') {
      children.push(child)
    } else if (child.type === 'rule' && bubbling) {
      child.selectors = selectors(rule, child)
    } else if (child.type === 'atrule') {
      atruleChilds(rule, child, bubbling)
    }
  })
  if (bubbling) {
    if (children.length) {
      var clone = rule.clone({ nodes: [] })
      for (var i = 0; i < children.length; i++) {
        clone.append(children[i])
      }
      atrule.prepend(clone)
    }
  }
}

function processRule (rule, bubble, unwrap, preserveEmpty) {
  var unwrapped = false
  var after = rule
  rule.each(function (child) {
    if (child.type === 'rule') {
      unwrapped = true
      child.selectors = selectors(rule, child)
      after = pickComment(child.prev(), after)
      after.after(child)
      after = child
    } else if (child.type === 'atrule') {
      if (bubble[child.name]) {
        unwrapped = true
        atruleChilds(rule, child, true)
        after = pickComment(child.prev(), after)
        after.after(child)
        after = child
      } else if (unwrap[child.name]) {
        unwrapped = true
        atruleChilds(rule, child, false)
        after = pickComment(child.prev(), after)
        after.after(child)
        after = child
      }
    }
  })
  if (unwrapped && preserveEmpty !== true) {
    rule.raws.semicolon = true
    if (rule.nodes.length === 0) rule.remove()
  }
}

function atruleNames (defaults, custom) {
  var list = { }
  var i, name
  for (i = 0; i < defaults.length; i++) {
    list[defaults[i]] = true
  }
  if (custom) {
    for (i = 0; i < custom.length; i++) {
      name = custom[i].replace(/^@/, '')
      list[name] = true
    }
  }
  return list
}

module.exports = postcss.plugin('postcss-nested', function (opts) {
  if (!opts) opts = { }
  var bubble = atruleNames(['media', 'supports'], opts.bubble)
  var unwrap = atruleNames(['document', 'font-face', 'keyframes'], opts.unwrap)
  var preserveEmpty = opts ? opts.preserveEmpty : false

  var process = function (node) {
    node.each(function (child) {
      if (child.type === 'rule') {
        processRule(child, bubble, unwrap, preserveEmpty)
      } else if (child.type === 'atrule') {
        process(child)
      }
    })
  }
  return process
})

},{"postcss":1074,"postcss-selector-parser":1024}],964:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _postcss = require('postcss');

var _postcss2 = _interopRequireDefault(_postcss);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

let charset = 'charset';

exports.default = _postcss2.default.plugin('postcss-normalize-' + charset, (opts = {}) => {
    return css => {
        let charsetRule;
        let nonAsciiNode;
        let nonAscii = /[^\x00-\x7F]/;

        css.walk(node => {
            if (node.type === 'atrule' && node.name === charset) {
                if (!charsetRule) {
                    charsetRule = node;
                }
                node.remove();
            } else if (!nonAsciiNode && node.parent === css && nonAscii.test(node)) {
                nonAsciiNode = node;
            }
        });

        if (nonAsciiNode) {
            if (!charsetRule && opts.add !== false) {
                charsetRule = _postcss2.default.atRule({
                    name: charset,
                    params: '"utf-8"'
                });
            }
            if (charsetRule) {
                charsetRule.source = nonAsciiNode.source;
                css.prepend(charsetRule);
            }
        }
    };
});
module.exports = exports['default'];
},{"postcss":1074}],965:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _postcss = require("postcss");

var _postcss2 = _interopRequireDefault(_postcss);

var _postcssValueParser = require("postcss-value-parser");

var _postcssValueParser2 = _interopRequireDefault(_postcssValueParser);

var _cssnanoUtilGetMatch = require("cssnano-util-get-match");

var _cssnanoUtilGetMatch2 = _interopRequireDefault(_cssnanoUtilGetMatch);

var _map = require("./lib/map");

var _map2 = _interopRequireDefault(_map);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const getMatch = (0, _cssnanoUtilGetMatch2.default)(_map2.default);

function evenValues(list, index) {
    return index % 2 === 0;
}

exports.default = _postcss2.default.plugin("postcss-normalize-display-values", () => {
    return css => {
        const cache = {};

        css.walkDecls(/display/i, decl => {
            const value = decl.value;

            if (cache[value]) {
                decl.value = cache[value];

                return;
            }

            const { nodes } = (0, _postcssValueParser2.default)(value);

            if (nodes.length === 1) {
                cache[value] = value;

                return;
            }

            const match = getMatch(nodes.filter(evenValues).map(n => n.value.toLowerCase()));

            if (!match) {
                cache[value] = value;

                return;
            }

            const result = match;

            decl.value = result;
            cache[value] = result;
        });
    };
});
module.exports = exports["default"];
},{"./lib/map":966,"cssnano-util-get-match":669,"postcss":1074,"postcss-value-parser":1057}],966:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
const block = 'block';
const flex = 'flex';
const flow = 'flow';
const flowRoot = 'flow-root';
const grid = 'grid';
const inline = 'inline';
const inlineBlock = 'inline-block';
const inlineFlex = 'inline-flex';
const inlineGrid = 'inline-grid';
const inlineTable = 'inline-table';
const listItem = 'list-item';
const ruby = 'ruby';
const rubyBase = 'ruby-base';
const rubyText = 'ruby-text';
const runIn = 'run-in';
const table = 'table';
const tableCell = 'table-cell';
const tableCaption = 'table-caption';

/**
 * Specification: https://drafts.csswg.org/css-display/#the-display-properties
 */

exports.default = [[block, [block, flow]], [flowRoot, [block, flowRoot]], [inline, [inline, flow]], [inlineBlock, [inline, flowRoot]], [runIn, [runIn, flow]], [listItem, [listItem, block, flow]], [inline + ' ' + listItem, [inline, flow, listItem]], [flex, [block, flex]], [inlineFlex, [inline, flex]], [grid, [block, grid]], [inlineGrid, [inline, grid]], [ruby, [inline, ruby]],
// `block ruby` is same
[table, [block, table]], [inlineTable, [inline, table]], [tableCell, [tableCell, flow]], [tableCaption, [tableCaption, flow]], [rubyBase, [rubyBase, flow]], [rubyText, [rubyText, flow]]];
module.exports = exports['default'];
},{}],967:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _postcss = require('postcss');

var _postcssValueParser = require('postcss-value-parser');

var _postcssValueParser2 = _interopRequireDefault(_postcssValueParser);

var _cssnanoUtilGetArguments = require('cssnano-util-get-arguments');

var _cssnanoUtilGetArguments2 = _interopRequireDefault(_cssnanoUtilGetArguments);

var _has = require('has');

var _has2 = _interopRequireDefault(_has);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const directions = ['top', 'right', 'bottom', 'left', 'center'];

const center = '50%';

const horizontal = {
    right: '100%',
    left: '0'
};

const vertical = {
    bottom: '100%',
    top: '0'
};

function transform(value) {
    const parsed = (0, _postcssValueParser2.default)(value);
    const args = (0, _cssnanoUtilGetArguments2.default)(parsed);
    const relevant = [];

    args.forEach(arg => {
        relevant.push({
            start: null,
            end: null
        });

        arg.forEach((part, index) => {
            const isPosition = ~directions.indexOf(part.value.toLowerCase()) || (0, _postcssValueParser.unit)(part.value);
            const len = relevant.length - 1;

            if (relevant[len].start === null && isPosition) {
                relevant[len].start = index;
                relevant[len].end = index;

                return;
            }

            if (relevant[len].start !== null) {
                if (part.type === 'space') {
                    return;
                } else if (isPosition) {
                    relevant[len].end = index;

                    return;
                }

                return;
            }
        });
    });

    relevant.forEach((range, index) => {
        if (range.start === null) {
            return;
        }

        const position = args[index].slice(range.start, range.end + 1);

        if (position.length > 3) {
            return;
        }

        const firstValue = position[0].value.toLowerCase();
        const secondValue = position[2] && position[2].value ? position[2].value.toLowerCase() : null;

        if (position.length === 1 || secondValue === 'center') {
            if (secondValue) {
                position[2].value = position[1].value = '';
            }

            const map = Object.assign({}, horizontal, {
                center
            });

            if ((0, _has2.default)(map, firstValue)) {
                position[0].value = map[firstValue];
            }

            return;
        }

        if (firstValue === 'center' && ~directions.indexOf(secondValue)) {
            position[0].value = position[1].value = '';

            if ((0, _has2.default)(horizontal, secondValue)) {
                position[2].value = horizontal[secondValue];
            }

            return;
        }

        if ((0, _has2.default)(horizontal, firstValue) && (0, _has2.default)(vertical, secondValue)) {
            position[0].value = horizontal[firstValue];
            position[2].value = vertical[secondValue];

            return;
        } else if ((0, _has2.default)(vertical, firstValue) && (0, _has2.default)(horizontal, secondValue)) {
            position[0].value = horizontal[secondValue];
            position[2].value = vertical[firstValue];

            return;
        }
    });

    return parsed.toString();
}

exports.default = (0, _postcss.plugin)('postcss-normalize-positions', () => {
    return css => {
        const cache = {};

        css.walkDecls(/^(background(-position)?|(-webkit-)?perspective-origin)$/i, decl => {
            const value = decl.value;

            if (cache[value]) {
                decl.value = cache[value];

                return;
            }

            const result = transform(value);

            decl.value = result;
            cache[value] = result;
        });
    };
});
module.exports = exports['default'];
},{"cssnano-util-get-arguments":668,"has":720,"postcss":1074,"postcss-value-parser":1057}],968:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _postcss = require('postcss');

var _postcss2 = _interopRequireDefault(_postcss);

var _postcssValueParser = require('postcss-value-parser');

var _postcssValueParser2 = _interopRequireDefault(_postcssValueParser);

var _cssnanoUtilGetArguments = require('cssnano-util-get-arguments');

var _cssnanoUtilGetArguments2 = _interopRequireDefault(_cssnanoUtilGetArguments);

var _cssnanoUtilGetMatch = require('cssnano-util-get-match');

var _cssnanoUtilGetMatch2 = _interopRequireDefault(_cssnanoUtilGetMatch);

var _map = require('./lib/map');

var _map2 = _interopRequireDefault(_map);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function evenValues(list, index) {
    return index % 2 === 0;
}

const repeatKeywords = _map2.default.map(mapping => mapping[0]);

const getMatch = (0, _cssnanoUtilGetMatch2.default)(_map2.default);

exports.default = _postcss2.default.plugin('postcss-normalize-repeat-style', () => {
    return css => {
        const cache = {};

        css.walkDecls(/background(-repeat)?|(-webkit-)?mask-repeat/i, decl => {
            const value = decl.value;

            if (cache[value]) {
                decl.value = cache[value];

                return;
            }

            const parsed = (0, _postcssValueParser2.default)(value);

            if (parsed.nodes.length === 1) {
                cache[value] = value;

                return;
            }

            const args = (0, _cssnanoUtilGetArguments2.default)(parsed);
            const relevant = [];

            args.forEach(arg => {
                relevant.push({
                    start: null,
                    end: null
                });

                arg.forEach((part, index) => {
                    const isRepeat = ~repeatKeywords.indexOf(part.value.toLowerCase());
                    const len = relevant.length - 1;

                    if (relevant[len].start === null && isRepeat) {
                        relevant[len].start = index;
                        relevant[len].end = index;

                        return;
                    }

                    if (relevant[len].start !== null) {
                        if (part.type === 'space') {
                            return;
                        } else if (isRepeat) {
                            relevant[len].end = index;

                            return;
                        }

                        return;
                    }
                });
            });

            relevant.forEach((range, index) => {
                if (range.start === null) {
                    return;
                }

                const val = args[index].slice(range.start, range.end + 1);

                if (val.length !== 3) {
                    return;
                }

                const match = getMatch(val.filter(evenValues).map(n => n.value.toLowerCase()));

                if (match) {
                    args[index][range.start].value = match;
                    args[index][range.start + 1].value = '';
                    args[index][range.end].value = '';
                }
            });

            const result = parsed.toString();

            decl.value = result;
            cache[value] = result;
        });
    };
});
module.exports = exports['default'];
},{"./lib/map":969,"cssnano-util-get-arguments":668,"cssnano-util-get-match":669,"postcss":1074,"postcss-value-parser":1057}],969:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = [['repeat-x', ['repeat', 'no-repeat']], ['repeat-y', ['no-repeat', 'repeat']], ['repeat', ['repeat', 'repeat']], ['space', ['space', 'space']], ['round', ['round', 'round']], ['no-repeat', ['no-repeat', 'no-repeat']]];
module.exports = exports['default'];
},{}],970:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _postcss = require('postcss');

var _postcss2 = _interopRequireDefault(_postcss);

var _postcssValueParser = require('postcss-value-parser');

var _postcssValueParser2 = _interopRequireDefault(_postcssValueParser);

var _has = require('has');

var _has2 = _interopRequireDefault(_has);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
 * Constants (parser usage)
 */

const SINGLE_QUOTE = '\''.charCodeAt(0);
const DOUBLE_QUOTE = '"'.charCodeAt(0);
const BACKSLASH = '\\'.charCodeAt(0);
const NEWLINE = '\n'.charCodeAt(0);
const SPACE = ' '.charCodeAt(0);
const FEED = '\f'.charCodeAt(0);
const TAB = '\t'.charCodeAt(0);
const CR = '\r'.charCodeAt(0);

const WORD_END = /[ \n\t\r\f'"\\]/g;

/*
 * Constants (node type strings)
 */

const C_STRING = 'string';
const C_ESCAPED_SINGLE_QUOTE = 'escapedSingleQuote';
const C_ESCAPED_DOUBLE_QUOTE = 'escapedDoubleQuote';
const C_SINGLE_QUOTE = 'singleQuote';
const C_DOUBLE_QUOTE = 'doubleQuote';
const C_NEWLINE = 'newline';
const C_SINGLE = 'single';

/*
 * Literals
 */

const L_SINGLE_QUOTE = `'`;
const L_DOUBLE_QUOTE = `"`;
const L_NEWLINE = `\\\n`;

/*
 * Parser nodes
 */

const T_ESCAPED_SINGLE_QUOTE = { type: C_ESCAPED_SINGLE_QUOTE, value: `\\'` };
const T_ESCAPED_DOUBLE_QUOTE = { type: C_ESCAPED_DOUBLE_QUOTE, value: `\\"` };
const T_SINGLE_QUOTE = { type: C_SINGLE_QUOTE, value: L_SINGLE_QUOTE };
const T_DOUBLE_QUOTE = { type: C_DOUBLE_QUOTE, value: L_DOUBLE_QUOTE };
const T_NEWLINE = { type: C_NEWLINE, value: L_NEWLINE };

function stringify(ast) {
    return ast.nodes.reduce((str, { value }) => {
        // Collapse multiple line strings automatically
        if (value === L_NEWLINE) {
            return str;
        }

        return str + value;
    }, '');
}

function parse(str) {
    let code, next, value;
    let pos = 0;
    let len = str.length;

    const ast = {
        nodes: [],
        types: {
            escapedSingleQuote: 0,
            escapedDoubleQuote: 0,
            singleQuote: 0,
            doubleQuote: 0
        },
        quotes: false
    };

    while (pos < len) {
        code = str.charCodeAt(pos);

        switch (code) {
            case SPACE:
            case TAB:
            case CR:
            case FEED:
                next = pos;

                do {
                    next += 1;
                    code = str.charCodeAt(next);
                } while (code === SPACE || code === NEWLINE || code === TAB || code === CR || code === FEED);

                ast.nodes.push({
                    type: 'space',
                    value: str.slice(pos, next)
                });
                pos = next - 1;
                break;
            case SINGLE_QUOTE:
                ast.nodes.push(T_SINGLE_QUOTE);
                ast.types[C_SINGLE_QUOTE]++;
                ast.quotes = true;
                break;
            case DOUBLE_QUOTE:
                ast.nodes.push(T_DOUBLE_QUOTE);
                ast.types[C_DOUBLE_QUOTE]++;
                ast.quotes = true;
                break;
            case BACKSLASH:
                next = pos + 1;

                if (str.charCodeAt(next) === SINGLE_QUOTE) {
                    ast.nodes.push(T_ESCAPED_SINGLE_QUOTE);
                    ast.types[C_ESCAPED_SINGLE_QUOTE]++;
                    ast.quotes = true;
                    pos = next;
                    break;
                } else if (str.charCodeAt(next) === DOUBLE_QUOTE) {
                    ast.nodes.push(T_ESCAPED_DOUBLE_QUOTE);
                    ast.types[C_ESCAPED_DOUBLE_QUOTE]++;
                    ast.quotes = true;
                    pos = next;
                    break;
                } else if (str.charCodeAt(next) === NEWLINE) {
                    ast.nodes.push(T_NEWLINE);
                    pos = next;
                    break;
                }
            /*
             * We need to fall through here to handle the token as
             * a whole word. The missing 'break' is intentional.
             */
            default:
                WORD_END.lastIndex = pos + 1;
                WORD_END.test(str);

                if (WORD_END.lastIndex === 0) {
                    next = len - 1;
                } else {
                    next = WORD_END.lastIndex - 2;
                }

                value = str.slice(pos, next + 1);

                ast.nodes.push({
                    type: C_STRING,
                    value
                });

                pos = next;
        }
        pos++;
    }

    return ast;
}

function changeWrappingQuotes(node, ast) {
    const { types } = ast;

    if (types[C_SINGLE_QUOTE] || types[C_DOUBLE_QUOTE]) {
        return;
    }

    if (node.quote === L_SINGLE_QUOTE && types[C_ESCAPED_SINGLE_QUOTE] > 0 && !types[C_ESCAPED_DOUBLE_QUOTE]) {
        node.quote = L_DOUBLE_QUOTE;
    }

    if (node.quote === L_DOUBLE_QUOTE && types[C_ESCAPED_DOUBLE_QUOTE] > 0 && !types[C_ESCAPED_SINGLE_QUOTE]) {
        node.quote = L_SINGLE_QUOTE;
    }

    ast.nodes = ast.nodes.reduce((newAst, child) => {
        if (child.type === C_ESCAPED_DOUBLE_QUOTE && node.quote === L_SINGLE_QUOTE) {
            return [...newAst, T_DOUBLE_QUOTE];
        }

        if (child.type === C_ESCAPED_SINGLE_QUOTE && node.quote === L_DOUBLE_QUOTE) {
            return [...newAst, T_SINGLE_QUOTE];
        }

        return [...newAst, child];
    }, []);
}

function normalize(value, preferredQuote) {
    if (!value || !value.length) {
        return value;
    }

    return (0, _postcssValueParser2.default)(value).walk(child => {
        if (child.type !== C_STRING) {
            return;
        }

        const ast = parse(child.value);

        if (ast.quotes) {
            changeWrappingQuotes(child, ast);
        } else if (preferredQuote === C_SINGLE) {
            child.quote = L_SINGLE_QUOTE;
        } else {
            child.quote = L_DOUBLE_QUOTE;
        }

        child.value = stringify(ast);
    }).toString();
}

const params = {
    rule: 'selector',
    decl: 'value',
    atrule: 'params'
};

exports.default = _postcss2.default.plugin('postcss-normalize-string', opts => {
    const { preferredQuote } = Object.assign({}, {
        preferredQuote: 'double'
    }, opts);

    return css => {
        const cache = {};

        css.walk(node => {
            const { type } = node;

            if ((0, _has2.default)(params, type)) {
                const param = params[type];
                const key = node[param] + '|' + preferredQuote;

                if (cache[key]) {
                    node[param] = cache[key];

                    return;
                }

                const result = normalize(node[param], preferredQuote);

                node[param] = result;
                cache[key] = result;
            }
        });
    };
});
module.exports = exports['default'];
},{"has":720,"postcss":1074,"postcss-value-parser":1057}],971:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _postcss = require('postcss');

var _postcssValueParser = require('postcss-value-parser');

var _postcssValueParser2 = _interopRequireDefault(_postcssValueParser);

var _cssnanoUtilGetMatch = require('cssnano-util-get-match');

var _cssnanoUtilGetMatch2 = _interopRequireDefault(_cssnanoUtilGetMatch);

var _map = require('./lib/map');

var _map2 = _interopRequireDefault(_map);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const getMatch = (0, _cssnanoUtilGetMatch2.default)(_map2.default);
const getValue = node => parseFloat(node.value);

function evenValues(list, index) {
    return index % 2 === 0;
}

function reduce(node) {
    if (node.type !== 'function') {
        return false;
    }

    const lowerCasedValue = node.value.toLowerCase();

    if (lowerCasedValue === 'steps') {
        // Don't bother checking the step-end case as it has the same length
        // as steps(1)
        if (getValue(node.nodes[0]) === 1 && node.nodes[2] && node.nodes[2].value.toLowerCase() === 'start') {
            node.type = 'word';
            node.value = 'step-start';

            delete node.nodes;

            return;
        }

        // The end case is actually the browser default, so it isn't required.
        if (node.nodes[2] && node.nodes[2].value.toLowerCase() === 'end') {
            node.nodes = [node.nodes[0]];

            return;
        }

        return false;
    }

    if (lowerCasedValue === 'cubic-bezier') {
        const match = getMatch(node.nodes.filter(evenValues).map(getValue));

        if (match) {
            node.type = 'word';
            node.value = match;

            delete node.nodes;

            return;
        }
    }
}

exports.default = (0, _postcss.plugin)('postcss-normalize-timing-functions', () => {
    return css => {
        const cache = {};

        css.walkDecls(/(animation|transition)(-timing-function|$)/i, decl => {
            const value = decl.value;

            if (cache[value]) {
                decl.value = cache[value];

                return;
            }

            const result = (0, _postcssValueParser2.default)(value).walk(reduce).toString();

            decl.value = result;
            cache[value] = result;
        });
    };
});
module.exports = exports['default'];
},{"./lib/map":972,"cssnano-util-get-match":669,"postcss":1074,"postcss-value-parser":1057}],972:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = [['ease', [0.25, 0.1, 0.25, 1]], ['linear', [0, 0, 1, 1]], ['ease-in', [0.42, 0, 1, 1]], ['ease-out', [0, 0, 0.58, 1]], ['ease-in-out', [0.42, 0, 0.58, 1]]];
module.exports = exports['default'];
},{}],973:[function(require,module,exports){
(function (__dirname){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _browserslist = require('browserslist');

var _browserslist2 = _interopRequireDefault(_browserslist);

var _postcss = require('postcss');

var _postcss2 = _interopRequireDefault(_postcss);

var _postcssValueParser = require('postcss-value-parser');

var _postcssValueParser2 = _interopRequireDefault(_postcssValueParser);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const regexLowerCaseUPrefix = /^u(?=\+)/;

function unicode(range) {
    const values = range.slice(2).split('-');
    if (values.length < 2) {
        return range;
    }
    const left = values[0].split('');
    const right = values[1].split('');

    if (left.length !== right.length) {
        return range;
    }

    let questionCounter = 0;

    const merged = left.reduce((group, value, index) => {
        if (group === false) {
            return false;
        }
        if (value === right[index] && !questionCounter) {
            return group + value;
        }
        if (value === '0' && right[index] === 'f') {
            questionCounter++;
            return group + '?';
        }
        return false;
    }, 'u+');

    /*
     * The maximum number of wildcard characters (?) for ranges is 5.
     */

    if (merged && questionCounter < 6) {
        return merged;
    }

    return range;
}

/*
 * IE and Edge before 16 version ignore the unicode-range if the 'U' is lowercase
 *
 * https://caniuse.com/#search=unicode-range
 */

function hasLowerCaseUPrefixBug(browser) {
    return ~(0, _browserslist2.default)('ie <=11, edge <= 15').indexOf(browser);
}

function transform(legacy = false, node) {
    node.value = (0, _postcssValueParser2.default)(node.value).walk(child => {
        if (child.type === 'word') {
            const transformed = unicode(child.value.toLowerCase());
            child.value = legacy ? transformed.replace(regexLowerCaseUPrefix, 'U') : transformed;
        }
        return false;
    }).toString();
}

exports.default = _postcss2.default.plugin('postcss-normalize-unicode', () => {
    return (css, result) => {
        const resultOpts = result.opts || {};
        const browsers = (0, _browserslist2.default)(null, {
            stats: resultOpts.stats,
            path: __dirname,
            env: resultOpts.env
        });
        css.walkDecls(/^unicode-range$/i, transform.bind(null, browsers.some(hasLowerCaseUPrefixBug)));
    };
});
module.exports = exports['default'];
}).call(this,"/node_modules/postcss-normalize-unicode/dist")
},{"browserslist":12,"postcss":1074,"postcss-value-parser":1057}],974:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _postcss = require('postcss');

var _postcss2 = _interopRequireDefault(_postcss);

var _postcssValueParser = require('postcss-value-parser');

var _postcssValueParser2 = _interopRequireDefault(_postcssValueParser);

var _normalizeUrl = require('normalize-url');

var _normalizeUrl2 = _interopRequireDefault(_normalizeUrl);

var _isAbsoluteUrl = require('is-absolute-url');

var _isAbsoluteUrl2 = _interopRequireDefault(_isAbsoluteUrl);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const multiline = /\\[\r\n]/;
const escapeChars = /([\s\(\)"'])/g;

function convert(url, options) {
    if ((0, _isAbsoluteUrl2.default)(url) || url.startsWith('//')) {
        let normalizedURL = null;

        try {
            normalizedURL = (0, _normalizeUrl2.default)(url, options);
        } catch (e) {
            normalizedURL = url;
        }

        return normalizedURL;
    }

    // `path.normalize` always returns backslashes on Windows, need replace in `/`
    return _path2.default.normalize(url).replace(new RegExp('\\' + _path2.default.sep, 'g'), '/');
}

function transformNamespace(rule) {
    rule.params = (0, _postcssValueParser2.default)(rule.params).walk(node => {
        if (node.type === 'function' && node.value.toLowerCase() === 'url' && node.nodes.length) {
            node.type = 'string';
            node.quote = node.nodes[0].quote || '"';
            node.value = node.nodes[0].value;
        }
        if (node.type === 'string') {
            node.value = node.value.trim();
        }
        return false;
    }).toString();
}

function transformDecl(decl, opts) {
    decl.value = (0, _postcssValueParser2.default)(decl.value).walk(node => {
        if (node.type !== 'function' || node.value.toLowerCase() !== 'url' || !node.nodes.length) {
            return false;
        }

        let url = node.nodes[0];
        let escaped;

        node.before = node.after = '';
        url.value = url.value.trim().replace(multiline, '');

        // Skip empty URLs
        // Empty URL function equals request to current stylesheet where it is declared
        if (url.value.length === 0) {
            url.quote = '';

            return false;
        }

        if (/^data:(.*)?,/i.test(url.value)) {
            return false;
        }

        if (!/^.+-extension:\//i.test(url.value)) {
            url.value = convert(url.value, opts);
        }

        if (escapeChars.test(url.value) && url.type === 'string') {
            escaped = url.value.replace(escapeChars, '\\$1');
            if (escaped.length < url.value.length + 2) {
                url.value = escaped;
                url.type = 'word';
            }
        } else {
            url.type = 'word';
        }

        return false;
    }).toString();
}

exports.default = _postcss2.default.plugin('postcss-normalize-url', opts => {
    opts = Object.assign({}, {
        normalizeProtocol: false,
        stripFragment: false,
        stripWWW: false
    }, opts);

    return css => {
        css.walk(node => {
            if (node.type === 'decl') {
                return transformDecl(node, opts);
            } else if (node.type === 'atrule' && node.name.toLowerCase() === 'namespace') {
                return transformNamespace(node);
            }
        });
    };
});
module.exports = exports['default'];
},{"is-absolute-url":729,"normalize-url":789,"path":802,"postcss":1074,"postcss-value-parser":1057}],975:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _postcss = require("postcss");

var _postcssValueParser = require("postcss-value-parser");

var _postcssValueParser2 = _interopRequireDefault(_postcssValueParser);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const atrule = "atrule";
const decl = "decl";
const rule = "rule";

function reduceCalcWhitespaces(node) {
    if (node.type === "space") {
        node.value = " ";
    } else if (node.type === "function") {
        node.before = node.after = "";
    }
}

function reduceWhitespaces(node) {
    if (node.type === "space") {
        node.value = " ";
    } else if (node.type === "div") {
        node.before = node.after = "";
    } else if (node.type === "function") {
        node.before = node.after = "";

        if (node.value.toLowerCase() === "calc") {
            _postcssValueParser2.default.walk(node.nodes, reduceCalcWhitespaces);
            return false;
        }
    }
}

exports.default = (0, _postcss.plugin)("postcss-normalize-whitespace", () => {
    return css => {
        const cache = {};

        css.walk(node => {
            const { type } = node;

            if (~[decl, rule, atrule].indexOf(type) && node.raws.before) {
                node.raws.before = node.raws.before.replace(/\s/g, "");
            }

            if (type === decl) {
                // Ensure that !important values do not have any excess whitespace
                if (node.important) {
                    node.raws.important = "!important";
                }

                // Remove whitespaces around ie 9 hack
                node.value = node.value.replace(/\s*(\\9)\s*/, "$1");

                const value = node.value;

                if (cache[value]) {
                    node.value = cache[value];
                } else {
                    const parsed = (0, _postcssValueParser2.default)(node.value);
                    const result = parsed.walk(reduceWhitespaces).toString();

                    // Trim whitespace inside functions & dividers
                    node.value = result;
                    cache[value] = result;
                }

                // Remove extra semicolons and whitespace before the declaration
                if (node.raws.before) {
                    const prev = node.prev();

                    if (prev && prev.type !== rule) {
                        node.raws.before = node.raws.before.replace(/;/g, "");
                    }
                }

                node.raws.between = ":";
                node.raws.semicolon = false;
            } else if (type === rule || type === atrule) {
                node.raws.between = node.raws.after = "";
                node.raws.semicolon = false;
            }
        });

        // Remove final newline
        css.raws.after = "";
    };
});
module.exports = exports["default"];
},{"postcss":1074,"postcss-value-parser":1057}],976:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _postcss = require('postcss');

var _postcss2 = _interopRequireDefault(_postcss);

var _postcssValueParser = require('postcss-value-parser');

var _postcssValueParser2 = _interopRequireDefault(_postcssValueParser);

var _animation = require('./rules/animation');

var _animation2 = _interopRequireDefault(_animation);

var _border = require('./rules/border');

var _border2 = _interopRequireDefault(_border);

var _boxShadow = require('./rules/boxShadow');

var _boxShadow2 = _interopRequireDefault(_boxShadow);

var _flexFlow = require('./rules/flexFlow');

var _flexFlow2 = _interopRequireDefault(_flexFlow);

var _transition = require('./rules/transition');

var _transition2 = _interopRequireDefault(_transition);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint-disable quote-props */

const rules = {
    'animation': _animation2.default,
    '-webkit-animation': _animation2.default,
    'border': _border2.default,
    'border-top': _border2.default,
    'border-right': _border2.default,
    'border-bottom': _border2.default,
    'border-left': _border2.default,
    'outline': _border2.default,
    'box-shadow': _boxShadow2.default,
    'flex-flow': _flexFlow2.default,
    'transition': _transition2.default,
    '-webkit-transition': _transition2.default
};

/* eslint-enable */

// rules
function shouldAbort(parsed) {
    let abort = false;

    parsed.walk(({ type, value }) => {
        if (type === 'comment' || type === 'function' && value.toLowerCase() === 'var' || type === 'word' && ~value.indexOf(`___CSS_LOADER_IMPORT___`)) {
            abort = true;

            return false;
        }
    });

    return abort;
}

function getValue(decl) {
    let { value, raws } = decl;

    if (raws && raws.value && raws.value.raw) {
        value = raws.value.raw;
    }

    return value;
}

exports.default = _postcss2.default.plugin('postcss-ordered-values', () => {
    return css => {
        const cache = {};

        css.walkDecls(decl => {
            const lowerCasedProp = decl.prop.toLowerCase();
            const processor = rules[lowerCasedProp];

            if (!processor) {
                return;
            }

            const value = getValue(decl);

            if (cache[value]) {
                decl.value = cache[value];

                return;
            }

            const parsed = (0, _postcssValueParser2.default)(value);

            if (parsed.nodes.length < 2 || shouldAbort(parsed)) {
                cache[value] = value;

                return;
            }

            const result = processor(parsed);

            decl.value = result;
            cache[value] = result;
        });
    };
});
module.exports = exports['default'];
},{"./rules/animation":979,"./rules/border":980,"./rules/boxShadow":981,"./rules/flexFlow":982,"./rules/transition":983,"postcss":1074,"postcss-value-parser":1057}],977:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = addSpace;
function addSpace() {
    return { type: 'space', value: ' ' };
}
module.exports = exports['default'];
},{}],978:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = getValue;

var _postcssValueParser = require('postcss-value-parser');

function getValue(values) {
    return (0, _postcssValueParser.stringify)({
        nodes: values.reduce((nodes, arg, index) => {
            arg.forEach((val, idx) => {
                if (idx === arg.length - 1 && index === values.length - 1 && val.type === 'space') {
                    return;
                }
                nodes.push(val);
            });

            if (index !== values.length - 1) {
                nodes[nodes.length - 1].type = 'div';
                nodes[nodes.length - 1].value = ',';
            }

            return nodes;
        }, [])
    });
}
module.exports = exports['default'];
},{"postcss-value-parser":1057}],979:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = normalizeAnimation;

var _postcssValueParser = require('postcss-value-parser');

var _cssnanoUtilGetArguments = require('cssnano-util-get-arguments');

var _cssnanoUtilGetArguments2 = _interopRequireDefault(_cssnanoUtilGetArguments);

var _addSpace = require('../lib/addSpace');

var _addSpace2 = _interopRequireDefault(_addSpace);

var _getValue = require('../lib/getValue');

var _getValue2 = _interopRequireDefault(_getValue);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// animation: [ none | <keyframes-name> ] || <time> || <single-timing-function> || <time> || <single-animation-iteration-count> || <single-animation-direction> || <single-animation-fill-mode> || <single-animation-play-state>

const isTimingFunction = (value, type) => {
    const functions = ['steps', 'cubic-bezier', 'frames'];
    const keywords = ['ease', 'ease-in', 'ease-in-out', 'ease-out', 'linear', 'step-end', 'step-start'];

    return type === 'function' && functions.includes(value) || keywords.includes(value);
};

const isDirection = value => {
    return ['normal', 'reverse', 'alternate', 'alternate-reverse'].includes(value);
};

const isFillMode = value => {
    return ['none', 'forwards', 'backwards', 'both'].includes(value);
};

const isPlayState = value => {
    return ['running', 'paused'].includes(value);
};

const isTime = value => {
    const quantity = (0, _postcssValueParser.unit)(value);

    return quantity && ['ms', 's'].includes(quantity.unit);
};

const isIterationCount = value => {
    const quantity = (0, _postcssValueParser.unit)(value);

    return value === 'infinite' || quantity && !quantity.unit;
};

function normalizeAnimation(parsed) {
    const args = (0, _cssnanoUtilGetArguments2.default)(parsed);

    const values = args.reduce((list, arg) => {
        const state = {
            name: [],
            duration: [],
            timingFunction: [],
            delay: [],
            iterationCount: [],
            direction: [],
            fillMode: [],
            playState: []
        };
        const stateConditions = [{ property: 'duration', delegate: isTime }, { property: 'timingFunction', delegate: isTimingFunction }, { property: 'delay', delegate: isTime }, { property: 'iterationCount', delegate: isIterationCount }, { property: 'direction', delegate: isDirection }, { property: 'fillMode', delegate: isFillMode }, { property: 'playState', delegate: isPlayState }];

        arg.forEach(node => {
            let { type, value } = node;

            if (type === 'space') {
                return;
            }

            value = value.toLowerCase();

            const hasMatch = stateConditions.some(({ property, delegate }) => {
                if (delegate(value, type) && !state[property].length) {
                    state[property] = [node, (0, _addSpace2.default)()];
                    return true;
                }
            });

            if (!hasMatch) {
                state.name = [...state.name, node, (0, _addSpace2.default)()];
            }
        });
        return [...list, [...state.name, ...state.duration, ...state.timingFunction, ...state.delay, ...state.iterationCount, ...state.direction, ...state.fillMode, ...state.playState]];
    }, []);

    return (0, _getValue2.default)(values);
};
module.exports = exports['default'];
},{"../lib/addSpace":977,"../lib/getValue":978,"cssnano-util-get-arguments":668,"postcss-value-parser":1057}],980:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = normalizeBorder;

var _postcssValueParser = require('postcss-value-parser');

// border: <line-width> || <line-style> || <color>
// outline: <outline-color> || <outline-style> || <outline-width>

const borderWidths = ['thin', 'medium', 'thick'];

const borderStyles = ['none', 'auto', // only in outline-style
'hidden', 'dotted', 'dashed', 'solid', 'double', 'groove', 'ridge', 'inset', 'outset'];

function normalizeBorder(border) {
    const order = { width: '', style: '', color: '' };

    border.walk(node => {
        const { type, value } = node;
        if (type === 'word') {
            if (~borderStyles.indexOf(value.toLowerCase())) {
                order.style = value;
                return false;
            }
            if (~borderWidths.indexOf(value.toLowerCase()) || (0, _postcssValueParser.unit)(value.toLowerCase())) {
                if (order.width !== '') {
                    order.width = `${order.width} ${value}`;
                    return false;
                }
                order.width = value;
                return false;
            }
            order.color = value;
            return false;
        }
        if (type === 'function') {
            if (value.toLowerCase() === 'calc') {
                order.width = (0, _postcssValueParser.stringify)(node);
            } else {
                order.color = (0, _postcssValueParser.stringify)(node);
            }
            return false;
        }
    });

    return `${order.width} ${order.style} ${order.color}`.trim();
};
module.exports = exports['default'];
},{"postcss-value-parser":1057}],981:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = normalizeBoxShadow;

var _postcssValueParser = require('postcss-value-parser');

var _cssnanoUtilGetArguments = require('cssnano-util-get-arguments');

var _cssnanoUtilGetArguments2 = _interopRequireDefault(_cssnanoUtilGetArguments);

var _addSpace = require('../lib/addSpace');

var _addSpace2 = _interopRequireDefault(_addSpace);

var _getValue = require('../lib/getValue');

var _getValue2 = _interopRequireDefault(_getValue);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// box-shadow: inset? && <length>{2,4} && <color>?

function normalizeBoxShadow(parsed) {
    let args = (0, _cssnanoUtilGetArguments2.default)(parsed);
    let abort = false;

    let values = args.reduce((list, arg) => {
        let val = [];
        let state = {
            inset: [],
            color: []
        };

        arg.forEach(node => {
            const { type, value } = node;

            if (type === 'function' && ~value.toLowerCase().indexOf('calc')) {
                abort = true;
                return;
            }

            if (type === 'space') {
                return;
            }

            if ((0, _postcssValueParser.unit)(value)) {
                val = [...val, node, (0, _addSpace2.default)()];
            } else if (value.toLowerCase() === 'inset') {
                state.inset = [...state.inset, node, (0, _addSpace2.default)()];
            } else {
                state.color = [...state.color, node, (0, _addSpace2.default)()];
            }
        });

        return [...list, [...state.inset, ...val, ...state.color]];
    }, []);

    if (abort) {
        return parsed.toString();
    }

    return (0, _getValue2.default)(values);
}
module.exports = exports['default'];
},{"../lib/addSpace":977,"../lib/getValue":978,"cssnano-util-get-arguments":668,"postcss-value-parser":1057}],982:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = normalizeFlexFlow;
// flex-flow: <flex-direction> || <flex-wrap>

const flexDirection = ['row', 'row-reverse', 'column', 'column-reverse'];

const flexWrap = ['nowrap', 'wrap', 'wrap-reverse'];

function normalizeFlexFlow(flexFlow) {
    let order = {
        direction: '',
        wrap: ''
    };

    flexFlow.walk(({ value }) => {
        if (~flexDirection.indexOf(value.toLowerCase())) {
            order.direction = value;
            return;
        }

        if (~flexWrap.indexOf(value.toLowerCase())) {
            order.wrap = value;

            return;
        }
    });

    return `${order.direction} ${order.wrap}`.trim();
};
module.exports = exports['default'];
},{}],983:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = normalizeTransition;

var _postcssValueParser = require('postcss-value-parser');

var _cssnanoUtilGetArguments = require('cssnano-util-get-arguments');

var _cssnanoUtilGetArguments2 = _interopRequireDefault(_cssnanoUtilGetArguments);

var _addSpace = require('../lib/addSpace');

var _addSpace2 = _interopRequireDefault(_addSpace);

var _getValue = require('../lib/getValue');

var _getValue2 = _interopRequireDefault(_getValue);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// transition: [ none | <single-transition-property> ] || <time> || <single-transition-timing-function> || <time>

const timingFunctions = ['ease', 'linear', 'ease-in', 'ease-out', 'ease-in-out', 'step-start', 'step-end'];

function normalizeTransition(parsed) {
    let args = (0, _cssnanoUtilGetArguments2.default)(parsed);

    let values = args.reduce((list, arg) => {
        let state = {
            timingFunction: [],
            property: [],
            time1: [],
            time2: []
        };

        arg.forEach(node => {
            const { type, value } = node;

            if (type === 'space') {
                return;
            }

            if (type === 'function' && ~['steps', 'cubic-bezier'].indexOf(value.toLowerCase())) {
                state.timingFunction = [...state.timingFunction, node, (0, _addSpace2.default)()];
            } else if ((0, _postcssValueParser.unit)(value)) {
                if (!state.time1.length) {
                    state.time1 = [...state.time1, node, (0, _addSpace2.default)()];
                } else {
                    state.time2 = [...state.time2, node, (0, _addSpace2.default)()];
                }
            } else if (~timingFunctions.indexOf(value.toLowerCase())) {
                state.timingFunction = [...state.timingFunction, node, (0, _addSpace2.default)()];
            } else {
                state.property = [...state.property, node, (0, _addSpace2.default)()];
            }
        });

        return [...list, [...state.property, ...state.time1, ...state.timingFunction, ...state.time2]];
    }, []);

    return (0, _getValue2.default)(values);
}
module.exports = exports['default'];
},{"../lib/addSpace":977,"../lib/getValue":978,"cssnano-util-get-arguments":668,"postcss-value-parser":1057}],984:[function(require,module,exports){
module.exports={
  "align-content": "normal",
  "align-items": "normal",
  "align-self": "auto",
  "animation-delay": "0s",
  "animation-direction": "normal",
  "animation-duration": "0s",
  "animation-fill-mode": "none",
  "animation-iteration-count": "1",
  "animation-name": "none",
  "animation-timing-function": "ease",
  "appearance": "auto",
  "azimuth": "center",
  "backdrop-filter": "none",
  "background-attachment": "scroll",
  "background-blend-mode": "normal",
  "background-image": "none",
  "background-position": "0% 0%",
  "background-position-x": "left",
  "background-position-y": "top",
  "background-repeat": "repeat",
  "block-overflow": "clip",
  "block-size": "auto",
  "border-block-style": "none",
  "border-block-width": "medium",
  "border-block-end-style": "none",
  "border-block-end-width": "medium",
  "border-block-start-style": "none",
  "border-block-start-width": "medium",
  "border-bottom-left-radius": "0",
  "border-bottom-right-radius": "0",
  "border-bottom-style": "none",
  "border-bottom-width": "medium",
  "border-end-end-radius": "0",
  "border-end-start-radius": "0",
  "border-image-outset": "0",
  "border-image-slice": "100%",
  "border-image-source": "none",
  "border-image-width": "1",
  "border-inline-style": "none",
  "border-inline-width": "medium",
  "border-inline-end-style": "none",
  "border-inline-end-width": "medium",
  "border-inline-start-style": "none",
  "border-inline-start-width": "medium",
  "border-left-style": "none",
  "border-left-width": "medium",
  "border-right-style": "none",
  "border-right-width": "medium",
  "border-spacing": "0",
  "border-start-end-radius": "0",
  "border-start-start-radius": "0",
  "border-top-left-radius": "0",
  "border-top-right-radius": "0",
  "border-top-style": "none",
  "border-top-width": "medium",
  "bottom": "auto",
  "box-decoration-break": "slice",
  "box-shadow": "none",
  "break-after": "auto",
  "break-before": "auto",
  "break-inside": "auto",
  "caption-side": "top",
  "caret-color": "auto",
  "clear": "none",
  "clip": "auto",
  "clip-path": "none",
  "column-count": "auto",
  "column-gap": "normal",
  "column-rule-style": "none",
  "column-rule-width": "medium",
  "column-span": "none",
  "column-width": "auto",
  "contain": "none",
  "content": "normal",
  "counter-increment": "none",
  "counter-reset": "none",
  "cursor": "auto",
  "direction": "ltr",
  "empty-cells": "show",
  "filter": "none",
  "flex-basis": "auto",
  "flex-direction": "row",
  "flex-grow": "0",
  "flex-shrink": "1",
  "flex-wrap": "nowrap",
  "float": "none",
  "font-feature-settings": "normal",
  "font-kerning": "auto",
  "font-language-override": "normal",
  "font-optical-sizing": "auto",
  "font-variation-settings": "normal",
  "font-size": "medium",
  "font-size-adjust": "none",
  "font-stretch": "normal",
  "font-style": "normal",
  "font-variant": "normal",
  "font-variant-alternates": "normal",
  "font-variant-caps": "normal",
  "font-variant-east-asian": "normal",
  "font-variant-ligatures": "normal",
  "font-variant-numeric": "normal",
  "font-variant-position": "normal",
  "font-weight": "normal",
  "grid-auto-columns": "auto",
  "grid-auto-flow": "row",
  "grid-auto-rows": "auto",
  "grid-column-end": "auto",
  "grid-column-gap": "0",
  "grid-column-start": "auto",
  "grid-row-end": "auto",
  "grid-row-gap": "0",
  "grid-row-start": "auto",
  "grid-template-areas": "none",
  "grid-template-columns": "none",
  "grid-template-rows": "none",
  "hanging-punctuation": "none",
  "height": "auto",
  "hyphens": "manual",
  "image-orientation": "0deg",
  "image-rendering": "auto",
  "image-resolution": "1dppx",
  "ime-mode": "auto",
  "initial-letter": "normal",
  "initial-letter-align": "auto",
  "inline-size": "auto",
  "inset": "auto",
  "inset-block": "auto",
  "inset-block-end": "auto",
  "inset-block-start": "auto",
  "inset-inline": "auto",
  "inset-inline-end": "auto",
  "inset-inline-start": "auto",
  "isolation": "auto",
  "justify-content": "normal",
  "justify-items": "legacy",
  "justify-self": "auto",
  "left": "auto",
  "letter-spacing": "normal",
  "line-break": "auto",
  "line-clamp": "none",
  "line-height": "normal",
  "list-style-image": "none",
  "list-style-type": "disc",
  "margin-block": "0",
  "margin-block-end": "0",
  "margin-block-start": "0",
  "margin-bottom": "0",
  "margin-inline": "0",
  "margin-inline-end": "0",
  "margin-inline-start": "0",
  "margin-left": "0",
  "margin-right": "0",
  "margin-top": "0",
  "mask-border-mode": "alpha",
  "mask-border-outset": "0",
  "mask-border-slice": "0",
  "mask-border-source": "none",
  "mask-border-width": "auto",
  "mask-composite": "add",
  "mask-image": "none",
  "mask-position": "center",
  "mask-size": "auto",
  "max-block-size": "0",
  "max-height": "none",
  "max-inline-size": "0",
  "max-lines": "none",
  "max-width": "none",
  "min-block-size": "0",
  "min-height": "0",
  "min-inline-size": "0",
  "min-width": "0",
  "mix-blend-mode": "normal",
  "object-fit": "fill",
  "offset-anchor": "auto",
  "offset-distance": "0",
  "offset-path": "none",
  "offset-position": "auto",
  "offset-rotate": "auto",
  "opacity": "1.0",
  "order": "0",
  "orphans": "2",
  "outline-offset": "0",
  "outline-style": "none",
  "outline-width": "medium",
  "overflow-anchor": "auto",
  "overflow-block": "auto",
  "overflow-inline": "auto",
  "overflow-wrap": "normal",
  "padding-block": "0",
  "padding-block-end": "0",
  "padding-block-start": "0",
  "padding-bottom": "0",
  "padding-inline": "0",
  "padding-inline-end": "0",
  "padding-inline-start": "0",
  "padding-left": "0",
  "padding-right": "0",
  "padding-top": "0",
  "page-break-after": "auto",
  "page-break-before": "auto",
  "page-break-inside": "auto",
  "paint-order": "normal",
  "perspective": "none",
  "place-content": "normal",
  "pointer-events": "auto",
  "position": "static",
  "resize": "none",
  "right": "auto",
  "rotate": "none",
  "row-gap": "normal",
  "ruby-position": "over",
  "scale": "none",
  "scrollbar-color": "auto",
  "scrollbar-width": "auto",
  "scroll-behavior": "auto",
  "scroll-margin": "0",
  "scroll-margin-block": "0",
  "scroll-margin-block-start": "0",
  "scroll-margin-block-end": "0",
  "scroll-margin-bottom": "0",
  "scroll-margin-inline": "0",
  "scroll-margin-inline-start": "0",
  "scroll-margin-inline-end": "0",
  "scroll-margin-left": "0",
  "scroll-margin-right": "0",
  "scroll-margin-top": "0",
  "scroll-padding": "auto",
  "scroll-padding-block": "auto",
  "scroll-padding-block-start": "auto",
  "scroll-padding-block-end": "auto",
  "scroll-padding-bottom": "auto",
  "scroll-padding-inline": "auto",
  "scroll-padding-inline-start": "auto",
  "scroll-padding-inline-end": "auto",
  "scroll-padding-left": "auto",
  "scroll-padding-right": "auto",
  "scroll-padding-top": "auto",
  "scroll-snap-align": "none",
  "scroll-snap-coordinate": "none",
  "scroll-snap-points-x": "none",
  "scroll-snap-points-y": "none",
  "scroll-snap-stop": "normal",
  "scroll-snap-type": "none",
  "shape-image-threshold": "0.0",
  "shape-margin": "0",
  "shape-outside": "none",
  "tab-size": "8",
  "table-layout": "auto",
  "text-align-last": "auto",
  "text-combine-upright": "none",
  "text-decoration-line": "none",
  "text-decoration-skip-ink": "auto",
  "text-decoration-style": "solid",
  "text-emphasis-style": "none",
  "text-indent": "0",
  "text-justify": "auto",
  "text-orientation": "mixed",
  "text-overflow": "clip",
  "text-rendering": "auto",
  "text-shadow": "none",
  "text-transform": "none",
  "text-underline-position": "auto",
  "top": "auto",
  "touch-action": "auto",
  "transform": "none",
  "transform-style": "flat",
  "transition-delay": "0s",
  "transition-duration": "0s",
  "transition-property": "all",
  "transition-timing-function": "ease",
  "translate": "none",
  "unicode-bidi": "normal",
  "white-space": "normal",
  "widows": "2",
  "width": "auto",
  "will-change": "auto",
  "word-break": "normal",
  "word-spacing": "normal",
  "word-wrap": "normal",
  "z-index": "auto"
}

},{}],985:[function(require,module,exports){
module.exports={
  "background-clip": "border-box",
  "background-color": "transparent",
  "background-origin": "padding-box",
  "background-size": "auto auto",
  "border-block-color": "currentcolor",
  "border-block-end-color": "currentcolor",
  "border-block-start-color": "currentcolor",
  "border-bottom-color": "currentcolor",
  "border-collapse": "separate",
  "border-inline-color": "currentcolor",
  "border-inline-end-color": "currentcolor",
  "border-inline-start-color": "currentcolor",
  "border-left-color": "currentcolor",
  "border-right-color": "currentcolor",
  "border-top-color": "currentcolor",
  "box-sizing": "content-box",
  "column-rule-color": "currentcolor",
  "font-synthesis": "weight style",
  "mask-clip": "border-box",
  "mask-mode": "match-source",
  "mask-origin": "border-box",
  "mask-repeat": "repeat",
  "mask-type": "luminance",
  "ruby-align": "space-around",
  "ruby-merge": "separate",
  "text-decoration-color": "currentcolor",
  "text-emphasis-color": "currentcolor",
  "text-emphasis-position": "over right",
  "transform-box": "border-box",
  "transform-origin": "50% 50% 0",
  "vertical-align": "baseline",
  "writing-mode": "horizontal-tb"
}

},{}],986:[function(require,module,exports){
(function (__dirname){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _postcss = require('postcss');

var _has = require('has');

var _has2 = _interopRequireDefault(_has);

var _browserslist = require('browserslist');

var _browserslist2 = _interopRequireDefault(_browserslist);

var _caniuseApi = require('caniuse-api');

var _fromInitial = require('../data/fromInitial.json');

var _fromInitial2 = _interopRequireDefault(_fromInitial);

var _toInitial = require('../data/toInitial.json');

var _toInitial2 = _interopRequireDefault(_toInitial);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const initial = 'initial';

exports.default = (0, _postcss.plugin)('postcss-reduce-initial', () => {
    return (css, result) => {
        const resultOpts = result.opts || {};
        const browsers = (0, _browserslist2.default)(null, {
            stats: resultOpts.stats,
            path: __dirname,
            env: resultOpts.env
        });

        const initialSupport = (0, _caniuseApi.isSupported)('css-initial-value', browsers);

        css.walkDecls(decl => {
            const lowerCasedProp = decl.prop.toLowerCase();

            if (initialSupport && (0, _has2.default)(_toInitial2.default, lowerCasedProp) && decl.value.toLowerCase() === _toInitial2.default[lowerCasedProp]) {
                decl.value = initial;
                return;
            }

            if (decl.value.toLowerCase() !== initial || !_fromInitial2.default[lowerCasedProp]) {
                return;
            }

            decl.value = _fromInitial2.default[lowerCasedProp];
        });
    };
});
module.exports = exports['default'];
}).call(this,"/node_modules/postcss-reduce-initial/dist")
},{"../data/fromInitial.json":984,"../data/toInitial.json":985,"browserslist":12,"caniuse-api":17,"has":720,"postcss":1074}],987:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _has = require('has');

var _has2 = _interopRequireDefault(_has);

var _postcss = require('postcss');

var _postcss2 = _interopRequireDefault(_postcss);

var _postcssValueParser = require('postcss-value-parser');

var _postcssValueParser2 = _interopRequireDefault(_postcssValueParser);

var _cssnanoUtilGetMatch = require('cssnano-util-get-match');

var _cssnanoUtilGetMatch2 = _interopRequireDefault(_cssnanoUtilGetMatch);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getValues(list, { value }, index) {
    if (index % 2 === 0) {
        return [...list, parseFloat(value)];
    }

    return list;
}

function matrix3d(node, values) {
    // matrix3d(a, b, 0, 0, c, d, 0, 0, 0, 0, 1, 0, tx, ty, 0, 1) => matrix(a, b, c, d, tx, ty)
    if (values[15] && values[2] === 0 && values[3] === 0 && values[6] === 0 && values[7] === 0 && values[8] === 0 && values[9] === 0 && values[10] === 1 && values[11] === 0 && values[14] === 0 && values[15] === 1) {
        const { nodes } = node;

        node.value = 'matrix';
        node.nodes = [nodes[0], // a
        nodes[1], // ,
        nodes[2], // b
        nodes[3], // ,
        nodes[8], // c
        nodes[9], // ,
        nodes[10], // d
        nodes[11], // ,
        nodes[24], // tx
        nodes[25], // ,
        nodes[26]];
    }
}

const rotate3dMappings = [['rotateX', [1, 0, 0]], // rotate3d(1, 0, 0, a) => rotateX(a)
['rotateY', [0, 1, 0]], // rotate3d(0, 1, 0, a) => rotateY(a)
['rotate', [0, 0, 1]]];

const rotate3dMatch = (0, _cssnanoUtilGetMatch2.default)(rotate3dMappings);

function rotate3d(node, values) {
    const { nodes } = node;
    const match = rotate3dMatch(values.slice(0, 3));

    if (match.length) {
        node.value = match;
        node.nodes = [nodes[6]];
    }
}

function rotateZ(node) {
    // rotateZ(rz) => rotate(rz)
    node.value = 'rotate';
}

function scale(node, values) {
    const { nodes } = node;

    if (!nodes[2]) {
        return;
    }

    const [first, second] = values;

    // scale(sx, sy) => scale(sx)
    if (first === second) {
        node.nodes = [nodes[0]];

        return;
    }

    // scale(sx, 1) => scaleX(sx)
    if (second === 1) {
        node.value = 'scaleX';
        node.nodes = [nodes[0]];

        return;
    }

    // scale(1, sy) => scaleY(sy)
    if (first === 1) {
        node.value = 'scaleY';
        node.nodes = [nodes[2]];

        return;
    }
}

function scale3d(node, values) {
    const { nodes } = node;
    const [first, second, third] = values;

    // scale3d(sx, 1, 1) => scaleX(sx)
    if (second === 1 && third === 1) {
        node.value = 'scaleX';
        node.nodes = [nodes[0]];

        return;
    }

    // scale3d(1, sy, 1) => scaleY(sy)
    if (first === 1 && third === 1) {
        node.value = 'scaleY';
        node.nodes = [nodes[2]];

        return;
    }

    // scale3d(1, 1, sz) => scaleZ(sz)
    if (first === 1 && second === 1) {
        node.value = 'scaleZ';
        node.nodes = [nodes[4]];

        return;
    }
}

function translate(node, values) {
    const { nodes } = node;

    if (!nodes[2]) {
        return;
    }

    // translate(tx, 0) => translate(tx)
    if (values[1] === 0) {
        node.nodes = [nodes[0]];

        return;
    }

    // translate(0, ty) => translateY(ty)
    if (values[0] === 0) {
        node.value = 'translateY';
        node.nodes = [nodes[2]];

        return;
    }
}

function translate3d(node, values) {
    const { nodes } = node;

    // translate3d(0, 0, tz) => translateZ(tz)
    if (values[0] === 0 && values[1] === 0) {
        node.value = 'translateZ';
        node.nodes = [nodes[4]];
    }
}

const reducers = {
    matrix3d,
    rotate3d,
    rotateZ,
    scale,
    scale3d,
    translate,
    translate3d
};

function normalizeReducerName(name) {
    const lowerCasedName = name.toLowerCase();

    if (lowerCasedName === 'rotatez') {
        return 'rotateZ';
    }

    return lowerCasedName;
}

function reduce(node) {
    const { nodes, type, value } = node;
    const normalizedReducerName = normalizeReducerName(value);

    if (type === 'function' && (0, _has2.default)(reducers, normalizedReducerName)) {
        reducers[normalizedReducerName](node, nodes.reduce(getValues, []));
    }

    return false;
}

exports.default = _postcss2.default.plugin('postcss-reduce-transforms', () => {
    return css => {
        const cache = {};

        css.walkDecls(/transform$/i, decl => {
            const value = decl.value;

            if (cache[value]) {
                decl.value = cache[value];

                return;
            }

            const result = (0, _postcssValueParser2.default)(value).walk(reduce).toString();

            decl.value = result;
            cache[value] = result;
        });
    };
});
module.exports = exports['default'];
},{"cssnano-util-get-match":669,"has":720,"postcss":1074,"postcss-value-parser":1057}],988:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _container = require('postcss/lib/container');

var _container2 = _interopRequireDefault(_container);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var NestedDeclaration = function (_Container) {
    _inherits(NestedDeclaration, _Container);

    function NestedDeclaration(defaults) {
        _classCallCheck(this, NestedDeclaration);

        var _this = _possibleConstructorReturn(this, _Container.call(this, defaults));

        _this.type = 'decl';
        _this.isNested = true;
        if (!_this.nodes) _this.nodes = [];
        return _this;
    }

    return NestedDeclaration;
}(_container2.default);

exports.default = NestedDeclaration;
module.exports = exports['default'];


},{"postcss/lib/container":1001}],989:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.default = scssParse;

var _input = require('postcss/lib/input');

var _input2 = _interopRequireDefault(_input);

var _scssParser = require('./scss-parser');

var _scssParser2 = _interopRequireDefault(_scssParser);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function scssParse(scss, opts) {
    var input = new _input2.default(scss, opts);

    var parser = new _scssParser2.default(input);
    parser.tokenize();
    parser.loop();

    return parser.root;
}
module.exports = exports['default'];


},{"./scss-parser":990,"postcss/lib/input":1004}],990:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _comment = require('postcss/lib/comment');

var _comment2 = _interopRequireDefault(_comment);

var _parser = require('postcss/lib/parser');

var _parser2 = _interopRequireDefault(_parser);

var _nestedDeclaration = require('./nested-declaration');

var _nestedDeclaration2 = _interopRequireDefault(_nestedDeclaration);

var _scssTokenize = require('./scss-tokenize');

var _scssTokenize2 = _interopRequireDefault(_scssTokenize);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ScssParser = function (_Parser) {
    _inherits(ScssParser, _Parser);

    function ScssParser() {
        _classCallCheck(this, ScssParser);

        return _possibleConstructorReturn(this, _Parser.apply(this, arguments));
    }

    ScssParser.prototype.tokenize = function tokenize() {
        this.tokens = (0, _scssTokenize2.default)(this.input);
    };

    ScssParser.prototype.rule = function rule(tokens) {
        var withColon = false;
        var brackets = 0;
        var value = '';
        for (var _iterator = tokens, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
            var _ref;

            if (_isArray) {
                if (_i >= _iterator.length) break;
                _ref = _iterator[_i++];
            } else {
                _i = _iterator.next();
                if (_i.done) break;
                _ref = _i.value;
            }

            var _i2 = _ref;

            if (withColon) {
                if (_i2[0] !== 'comment' && _i2[0] !== '{') {
                    value += _i2[1];
                }
            } else if (_i2[0] === 'space' && _i2[1].indexOf('\n') !== -1) {
                break;
            } else if (_i2[0] === '(') {
                brackets += 1;
            } else if (_i2[0] === ')') {
                brackets -= 1;
            } else if (brackets === 0 && _i2[0] === ':') {
                withColon = true;
            }
        }

        if (!withColon || value.trim() === '' || /^[a-zA-Z-:#]/.test(value)) {
            _Parser.prototype.rule.call(this, tokens);
        } else {

            tokens.pop();
            var node = new _nestedDeclaration2.default();
            this.init(node);

            var last = tokens[tokens.length - 1];
            if (last[4]) {
                node.source.end = { line: last[4], column: last[5] };
            } else {
                node.source.end = { line: last[2], column: last[3] };
            }

            while (tokens[0][0] !== 'word') {
                node.raws.before += tokens.shift()[1];
            }
            node.source.start = { line: tokens[0][2], column: tokens[0][3] };

            node.prop = '';
            while (tokens.length) {
                var type = tokens[0][0];
                if (type === ':' || type === 'space' || type === 'comment') {
                    break;
                }
                node.prop += tokens.shift()[1];
            }

            node.raws.between = '';

            var token = void 0;
            while (tokens.length) {
                token = tokens.shift();

                if (token[0] === ':') {
                    node.raws.between += token[1];
                    break;
                } else {
                    node.raws.between += token[1];
                }
            }

            if (node.prop[0] === '_' || node.prop[0] === '*') {
                node.raws.before += node.prop[0];
                node.prop = node.prop.slice(1);
            }
            node.raws.between += this.spacesFromStart(tokens);
            this.precheckMissedSemicolon(tokens);

            for (var i = tokens.length - 1; i > 0; i--) {
                token = tokens[i];
                if (token[1] === '!important') {
                    node.important = true;
                    var string = this.stringFrom(tokens, i);
                    string = this.spacesFromEnd(tokens) + string;
                    if (string !== ' !important') {
                        node.raws.important = string;
                    }
                    break;
                } else if (token[1] === 'important') {
                    var cache = tokens.slice(0);
                    var str = '';
                    for (var j = i; j > 0; j--) {
                        var _type = cache[j][0];
                        if (str.trim().indexOf('!') === 0 && _type !== 'space') {
                            break;
                        }
                        str = cache.pop()[1] + str;
                    }
                    if (str.trim().indexOf('!') === 0) {
                        node.important = true;
                        node.raws.important = str;
                        tokens = cache;
                    }
                }

                if (token[0] !== 'space' && token[0] !== 'comment') {
                    break;
                }
            }

            this.raw(node, 'value', tokens);

            if (node.value.indexOf(':') !== -1) {
                this.checkMissedSemicolon(tokens);
            }

            this.current = node;
        }
    };

    ScssParser.prototype.comment = function comment(token) {
        if (token[6] === 'inline') {
            var node = new _comment2.default();
            this.init(node, token[2], token[3]);
            node.raws.inline = true;
            node.source.end = { line: token[4], column: token[5] };

            var text = token[1].slice(2);
            if (/^\s*$/.test(text)) {
                node.text = '';
                node.raws.left = text;
                node.raws.right = '';
            } else {
                var match = text.match(/^(\s*)([^]*[^\s])(\s*)$/);
                node.text = match[2];
                node.raws.left = match[1];
                node.raws.right = match[3];
            }
        } else {
            _Parser.prototype.comment.call(this, token);
        }
    };

    return ScssParser;
}(_parser2.default);

exports.default = ScssParser;
module.exports = exports['default'];


},{"./nested-declaration":988,"./scss-tokenize":994,"postcss/lib/comment":1000,"postcss/lib/parser":1010}],991:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _stringifier = require('postcss/lib/stringifier');

var _stringifier2 = _interopRequireDefault(_stringifier);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ScssStringifier = function (_Stringifier) {
    _inherits(ScssStringifier, _Stringifier);

    function ScssStringifier() {
        _classCallCheck(this, ScssStringifier);

        return _possibleConstructorReturn(this, _Stringifier.apply(this, arguments));
    }

    ScssStringifier.prototype.comment = function comment(node) {
        var left = this.raw(node, 'left', 'commentLeft');
        var right = this.raw(node, 'right', 'commentRight');

        if (node.raws.inline) {
            this.builder('//' + left + node.text + right, node);
        } else {
            this.builder('/*' + left + node.text + right + '*/', node);
        }
    };

    ScssStringifier.prototype.decl = function decl(node, semicolon) {
        if (!node.isNested) {
            _Stringifier.prototype.decl.call(this, node, semicolon);
        } else {

            var between = this.raw(node, 'between', 'colon');
            var string = node.prop + between + this.rawValue(node, 'value');
            if (node.important) {
                string += node.raws.important || ' !important';
            }

            this.builder(string + '{', node, 'start');

            var after = void 0;
            if (node.nodes && node.nodes.length) {
                this.body(node);
                after = this.raw(node, 'after');
            } else {
                after = this.raw(node, 'after', 'emptyBody');
            }
            if (after) this.builder(after);
            this.builder('}', node, 'end');
        }
    };

    return ScssStringifier;
}(_stringifier2.default);

exports.default = ScssStringifier;
module.exports = exports['default'];


},{"postcss/lib/stringifier":1016}],992:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.default = scssStringify;

var _scssStringifier = require('./scss-stringifier');

var _scssStringifier2 = _interopRequireDefault(_scssStringifier);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function scssStringify(node, builder) {
    var str = new _scssStringifier2.default(builder);
    str.stringify(node);
}
module.exports = exports['default'];


},{"./scss-stringifier":991}],993:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _scssStringify = require('./scss-stringify');

var _scssStringify2 = _interopRequireDefault(_scssStringify);

var _scssParse = require('./scss-parse');

var _scssParse2 = _interopRequireDefault(_scssParse);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = { parse: _scssParse2.default, stringify: _scssStringify2.default };
module.exports = exports['default'];


},{"./scss-parse":989,"./scss-stringify":992}],994:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.default = scssTokenize;
var SINGLE_QUOTE = 39;
var DOUBLE_QUOTE = 34;
var BACKSLASH = 92;
var SLASH = 47;
var NEWLINE = 10;
var SPACE = 32;
var FEED = 12;
var TAB = 9;
var CR = 13;
var OPEN_SQUARE = 91;
var CLOSE_SQUARE = 93;
var OPEN_PARENTHESES = 40;
var CLOSE_PARENTHESES = 41;
var OPEN_CURLY = 123;
var CLOSE_CURLY = 125;
var SEMICOLON = 59;
var ASTERICK = 42;
var COLON = 58;
var AT = 64;

// SCSS PATCH {
var COMMA = 44;
var HASH = 35;
// } SCSS PATCH

var RE_AT_END = /[ \n\t\r\f\{\(\)'"\\;/\[\]#]/g;
var RE_WORD_END = /[ \n\t\r\f\(\)\{\}:;@!'"\\\]\[#]|\/(?=\*)/g;
var RE_BAD_BRACKET = /.[\\\/\("'\n]/;

var RE_NEW_LINE = /[\r\f\n]/g; // SCSS PATCH

// SCSS PATCH function name was changed
function scssTokenize(input) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    var tokens = [];
    var css = input.css.valueOf();

    var ignore = options.ignoreErrors;

    var code = void 0,
        next = void 0,
        quote = void 0,
        lines = void 0,
        last = void 0,
        content = void 0,
        escape = void 0,
        nextLine = void 0,
        nextOffset = void 0,
        escaped = void 0,
        escapePos = void 0,
        prev = void 0,
        n = void 0;

    var brackets = void 0; // SCSS PATCH

    var length = css.length;
    var offset = -1;
    var line = 1;
    var pos = 0;

    function unclosed(what) {
        throw input.error('Unclosed ' + what, line, pos - offset);
    }

    while (pos < length) {
        code = css.charCodeAt(pos);

        if (code === NEWLINE || code === FEED || code === CR && css.charCodeAt(pos + 1) !== NEWLINE) {
            offset = pos;
            line += 1;
        }

        switch (code) {
            case NEWLINE:
            case SPACE:
            case TAB:
            case CR:
            case FEED:
                next = pos;
                do {
                    next += 1;
                    code = css.charCodeAt(next);
                    if (code === NEWLINE) {
                        offset = next;
                        line += 1;
                    }
                } while (code === SPACE || code === NEWLINE || code === TAB || code === CR || code === FEED);

                tokens.push(['space', css.slice(pos, next)]);
                pos = next - 1;
                break;

            case OPEN_SQUARE:
                tokens.push(['[', '[', line, pos - offset]);
                break;

            case CLOSE_SQUARE:
                tokens.push([']', ']', line, pos - offset]);
                break;

            case OPEN_CURLY:
                tokens.push(['{', '{', line, pos - offset]);
                break;

            case CLOSE_CURLY:
                tokens.push(['}', '}', line, pos - offset]);
                break;

            // SCSS PATCH {
            case COMMA:
                tokens.push(['word', ',', line, pos - offset, line, pos - offset + 1]);
                break;
            // } SCSS PATCH

            case COLON:
                tokens.push([':', ':', line, pos - offset]);
                break;

            case SEMICOLON:
                tokens.push([';', ';', line, pos - offset]);
                break;

            case OPEN_PARENTHESES:
                prev = tokens.length ? tokens[tokens.length - 1][1] : '';
                n = css.charCodeAt(pos + 1);
                if (prev === 'url' && n !== SINGLE_QUOTE && n !== DOUBLE_QUOTE && n !== SPACE && n !== NEWLINE && n !== TAB && n !== FEED && n !== CR) {
                    // SCSS PATCH {
                    brackets = 1;
                    escaped = false;
                    next = pos + 1;
                    while (next <= css.length - 1) {
                        n = css.charCodeAt(next);
                        if (n === BACKSLASH) {
                            escaped = !escaped;
                        } else if (n === OPEN_PARENTHESES) {
                            brackets += 1;
                        } else if (n === CLOSE_PARENTHESES) {
                            brackets -= 1;
                            if (brackets === 0) break;
                        }
                        next += 1;
                    }
                    // } SCSS PATCH

                    tokens.push(['brackets', css.slice(pos, next + 1), line, pos - offset, line, next - offset]);
                    pos = next;
                } else {
                    next = css.indexOf(')', pos + 1);
                    content = css.slice(pos, next + 1);

                    if (next === -1 || RE_BAD_BRACKET.test(content)) {
                        tokens.push(['(', '(', line, pos - offset]);
                    } else {
                        tokens.push(['brackets', content, line, pos - offset, line, next - offset]);
                        pos = next;
                    }
                }

                break;

            case CLOSE_PARENTHESES:
                tokens.push([')', ')', line, pos - offset]);
                break;

            case SINGLE_QUOTE:
            case DOUBLE_QUOTE:
                quote = code === SINGLE_QUOTE ? '\'' : '"';
                next = pos;
                do {
                    escaped = false;
                    next = css.indexOf(quote, next + 1);
                    if (next === -1) {
                        if (ignore) {
                            next = pos + 1;
                            break;
                        } else {
                            unclosed('quote');
                        }
                    }
                    escapePos = next;
                    while (css.charCodeAt(escapePos - 1) === BACKSLASH) {
                        escapePos -= 1;
                        escaped = !escaped;
                    }
                } while (escaped);

                content = css.slice(pos, next + 1);
                lines = content.split('\n');
                last = lines.length - 1;

                if (last > 0) {
                    nextLine = line + last;
                    nextOffset = next - lines[last].length;
                } else {
                    nextLine = line;
                    nextOffset = offset;
                }

                tokens.push(['string', css.slice(pos, next + 1), line, pos - offset, nextLine, next - nextOffset]);

                offset = nextOffset;
                line = nextLine;
                pos = next;
                break;

            case AT:
                RE_AT_END.lastIndex = pos + 1;
                RE_AT_END.test(css);
                if (RE_AT_END.lastIndex === 0) {
                    next = css.length - 1;
                } else {
                    next = RE_AT_END.lastIndex - 2;
                }
                tokens.push(['at-word', css.slice(pos, next + 1), line, pos - offset, line, next - offset]);
                pos = next;
                break;

            case BACKSLASH:
                next = pos;
                escape = true;
                while (css.charCodeAt(next + 1) === BACKSLASH) {
                    next += 1;
                    escape = !escape;
                }
                code = css.charCodeAt(next + 1);
                if (escape && code !== SLASH && code !== SPACE && code !== NEWLINE && code !== TAB && code !== CR && code !== FEED) {
                    next += 1;
                }
                tokens.push(['word', css.slice(pos, next + 1), line, pos - offset, line, next - offset]);
                pos = next;
                break;

            default:
                // SCSS PATCH {
                n = css.charCodeAt(pos + 1);

                if (code === HASH && n === OPEN_CURLY) {
                    var deep = 1;
                    next = pos;
                    while (deep > 0) {
                        next += 1;
                        if (css.length <= next) unclosed('interpolation');

                        code = css.charCodeAt(next);
                        n = css.charCodeAt(next + 1);

                        if (code === CLOSE_CURLY) {
                            deep -= 1;
                        } else if (code === HASH && n === OPEN_CURLY) {
                            deep += 1;
                        }
                    }

                    content = css.slice(pos, next + 1);
                    lines = content.split('\n');
                    last = lines.length - 1;

                    if (last > 0) {
                        nextLine = line + last;
                        nextOffset = next - lines[last].length;
                    } else {
                        nextLine = line;
                        nextOffset = offset;
                    }

                    tokens.push(['word', content, line, pos - offset, nextLine, next - nextOffset]);

                    offset = nextOffset;
                    line = nextLine;
                    pos = next;
                } else if (code === SLASH && n === ASTERICK) {
                    // } SCSS PATCH

                    next = css.indexOf('*/', pos + 2) + 1;
                    if (next === 0) {
                        if (ignore) {
                            next = css.length;
                        } else {
                            unclosed('comment');
                        }
                    }

                    content = css.slice(pos, next + 1);
                    lines = content.split('\n');
                    last = lines.length - 1;

                    if (last > 0) {
                        nextLine = line + last;
                        nextOffset = next - lines[last].length;
                    } else {
                        nextLine = line;
                        nextOffset = offset;
                    }

                    tokens.push(['comment', content, line, pos - offset, nextLine, next - nextOffset]);

                    offset = nextOffset;
                    line = nextLine;
                    pos = next;

                    // SCSS PATCH {
                } else if (code === SLASH && n === SLASH) {
                    RE_NEW_LINE.lastIndex = pos + 1;
                    RE_NEW_LINE.test(css);
                    if (RE_NEW_LINE.lastIndex === 0) {
                        next = css.length - 1;
                    } else {
                        next = RE_NEW_LINE.lastIndex - 2;
                    }

                    content = css.slice(pos, next + 1);

                    tokens.push(['comment', content, line, pos - offset, line, next - offset, 'inline']);

                    pos = next;
                    // } SCSS PATCH
                } else {
                    RE_WORD_END.lastIndex = pos + 1;
                    RE_WORD_END.test(css);
                    if (RE_WORD_END.lastIndex === 0) {
                        next = css.length - 1;
                    } else {
                        next = RE_WORD_END.lastIndex - 2;
                    }

                    tokens.push(['word', css.slice(pos, next + 1), line, pos - offset, line, next - offset]);
                    pos = next;
                }

                break;
        }

        pos++;
    }

    return tokens;
}
module.exports = exports['default'];


},{}],995:[function(require,module,exports){
arguments[4][717][0].apply(exports,arguments)
},{"dup":717}],996:[function(require,module,exports){
arguments[4][819][0].apply(exports,arguments)
},{"dup":819}],997:[function(require,module,exports){
arguments[4][820][0].apply(exports,arguments)
},{"_process":1098,"ansi-styles":996,"dup":820,"escape-string-regexp":712,"has-ansi":716,"strip-ansi":1022,"supports-color":998}],998:[function(require,module,exports){
arguments[4][821][0].apply(exports,arguments)
},{"_process":1098,"dup":821}],999:[function(require,module,exports){
arguments[4][822][0].apply(exports,arguments)
},{"./container":1001,"./warn-once":1020,"dup":822}],1000:[function(require,module,exports){
arguments[4][823][0].apply(exports,arguments)
},{"./node":1008,"./warn-once":1020,"dup":823}],1001:[function(require,module,exports){
arguments[4][824][0].apply(exports,arguments)
},{"./at-rule":999,"./comment":1000,"./declaration":1003,"./node":1008,"./parse":1009,"./root":1014,"./rule":1015,"./warn-once":1020,"dup":824}],1002:[function(require,module,exports){
arguments[4][825][0].apply(exports,arguments)
},{"./terminal-highlight":1018,"./warn-once":1020,"chalk":997,"dup":825,"supports-color":1023}],1003:[function(require,module,exports){
arguments[4][826][0].apply(exports,arguments)
},{"./node":1008,"./warn-once":1020,"dup":826}],1004:[function(require,module,exports){
arguments[4][827][0].apply(exports,arguments)
},{"./css-syntax-error":1002,"./previous-map":1011,"dup":827,"path":802}],1005:[function(require,module,exports){
arguments[4][828][0].apply(exports,arguments)
},{"./map-generator":1007,"./parse":1009,"./result":1013,"./stringify":1017,"./warn-once":1020,"dup":828}],1006:[function(require,module,exports){
arguments[4][829][0].apply(exports,arguments)
},{"dup":829}],1007:[function(require,module,exports){
arguments[4][830][0].apply(exports,arguments)
},{"dup":830,"js-base64":752,"path":802,"source-map":1132}],1008:[function(require,module,exports){
arguments[4][831][0].apply(exports,arguments)
},{"./css-syntax-error":1002,"./stringifier":1016,"./stringify":1017,"./warn-once":1020,"dup":831}],1009:[function(require,module,exports){
arguments[4][832][0].apply(exports,arguments)
},{"./input":1004,"./parser":1010,"dup":832}],1010:[function(require,module,exports){
arguments[4][833][0].apply(exports,arguments)
},{"./at-rule":999,"./comment":1000,"./declaration":1003,"./root":1014,"./rule":1015,"./tokenize":1019,"dup":833}],1011:[function(require,module,exports){
arguments[4][835][0].apply(exports,arguments)
},{"dup":835,"fs":7,"js-base64":752,"path":802,"source-map":1132}],1012:[function(require,module,exports){
arguments[4][836][0].apply(exports,arguments)
},{"./lazy-result":1005,"dup":836}],1013:[function(require,module,exports){
arguments[4][837][0].apply(exports,arguments)
},{"./warning":1021,"dup":837}],1014:[function(require,module,exports){
arguments[4][838][0].apply(exports,arguments)
},{"./container":1001,"./lazy-result":1005,"./processor":1012,"./warn-once":1020,"dup":838}],1015:[function(require,module,exports){
arguments[4][839][0].apply(exports,arguments)
},{"./container":1001,"./list":1006,"./warn-once":1020,"dup":839}],1016:[function(require,module,exports){
arguments[4][840][0].apply(exports,arguments)
},{"dup":840}],1017:[function(require,module,exports){
arguments[4][841][0].apply(exports,arguments)
},{"./stringifier":1016,"dup":841}],1018:[function(require,module,exports){
arguments[4][842][0].apply(exports,arguments)
},{"./input":1004,"./tokenize":1019,"chalk":997,"dup":842}],1019:[function(require,module,exports){
arguments[4][843][0].apply(exports,arguments)
},{"dup":843}],1020:[function(require,module,exports){
arguments[4][845][0].apply(exports,arguments)
},{"dup":845}],1021:[function(require,module,exports){
arguments[4][846][0].apply(exports,arguments)
},{"dup":846}],1022:[function(require,module,exports){
arguments[4][847][0].apply(exports,arguments)
},{"ansi-regex":995,"dup":847}],1023:[function(require,module,exports){
arguments[4][848][0].apply(exports,arguments)
},{"dup":848}],1024:[function(require,module,exports){
arguments[4][902][0].apply(exports,arguments)
},{"./processor":1026,"./selectors":1035,"dup":902}],1025:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _WHITESPACE_TOKENS, _extends2;

var _indexesOf = require('indexes-of');

var _indexesOf2 = _interopRequireDefault(_indexesOf);

var _uniq = require('uniq');

var _uniq2 = _interopRequireDefault(_uniq);

var _root = require('./selectors/root');

var _root2 = _interopRequireDefault(_root);

var _selector = require('./selectors/selector');

var _selector2 = _interopRequireDefault(_selector);

var _className = require('./selectors/className');

var _className2 = _interopRequireDefault(_className);

var _comment = require('./selectors/comment');

var _comment2 = _interopRequireDefault(_comment);

var _id = require('./selectors/id');

var _id2 = _interopRequireDefault(_id);

var _tag = require('./selectors/tag');

var _tag2 = _interopRequireDefault(_tag);

var _string = require('./selectors/string');

var _string2 = _interopRequireDefault(_string);

var _pseudo = require('./selectors/pseudo');

var _pseudo2 = _interopRequireDefault(_pseudo);

var _attribute = require('./selectors/attribute');

var _attribute2 = _interopRequireDefault(_attribute);

var _universal = require('./selectors/universal');

var _universal2 = _interopRequireDefault(_universal);

var _combinator = require('./selectors/combinator');

var _combinator2 = _interopRequireDefault(_combinator);

var _nesting = require('./selectors/nesting');

var _nesting2 = _interopRequireDefault(_nesting);

var _sortAscending = require('./sortAscending');

var _sortAscending2 = _interopRequireDefault(_sortAscending);

var _tokenize = require('./tokenize');

var _tokenize2 = _interopRequireDefault(_tokenize);

var _tokenTypes = require('./tokenTypes');

var tokens = _interopRequireWildcard(_tokenTypes);

var _types = require('./selectors/types');

var types = _interopRequireWildcard(_types);

var _util = require('./util');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var WHITESPACE_TOKENS = (_WHITESPACE_TOKENS = {}, _WHITESPACE_TOKENS[tokens.space] = true, _WHITESPACE_TOKENS[tokens.cr] = true, _WHITESPACE_TOKENS[tokens.feed] = true, _WHITESPACE_TOKENS[tokens.newline] = true, _WHITESPACE_TOKENS[tokens.tab] = true, _WHITESPACE_TOKENS);

var WHITESPACE_EQUIV_TOKENS = _extends({}, WHITESPACE_TOKENS, (_extends2 = {}, _extends2[tokens.comment] = true, _extends2));

function tokenStart(token) {
    return {
        line: token[_tokenize.FIELDS.START_LINE],
        column: token[_tokenize.FIELDS.START_COL]
    };
}

function tokenEnd(token) {
    return {
        line: token[_tokenize.FIELDS.END_LINE],
        column: token[_tokenize.FIELDS.END_COL]
    };
}

function getSource(startLine, startColumn, endLine, endColumn) {
    return {
        start: {
            line: startLine,
            column: startColumn
        },
        end: {
            line: endLine,
            column: endColumn
        }
    };
}

function getTokenSource(token) {
    return getSource(token[_tokenize.FIELDS.START_LINE], token[_tokenize.FIELDS.START_COL], token[_tokenize.FIELDS.END_LINE], token[_tokenize.FIELDS.END_COL]);
}

function getTokenSourceSpan(startToken, endToken) {
    if (!startToken) {
        return undefined;
    }
    return getSource(startToken[_tokenize.FIELDS.START_LINE], startToken[_tokenize.FIELDS.START_COL], endToken[_tokenize.FIELDS.END_LINE], endToken[_tokenize.FIELDS.END_COL]);
}

function unescapeProp(node, prop) {
    var value = node[prop];
    if (typeof value !== "string") {
        return;
    }
    if (value.indexOf("\\") !== -1) {
        (0, _util.ensureObject)(node, 'raws');
        node[prop] = (0, _util.unesc)(value);
        if (node.raws[prop] === undefined) {
            node.raws[prop] = value;
        }
    }
    return node;
}

var Parser = function () {
    function Parser(rule) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        _classCallCheck(this, Parser);

        this.rule = rule;
        this.options = Object.assign({ lossy: false, safe: false }, options);
        this.position = 0;

        this.css = typeof this.rule === 'string' ? this.rule : this.rule.selector;

        this.tokens = (0, _tokenize2.default)({
            css: this.css,
            error: this._errorGenerator(),
            safe: this.options.safe
        });

        var rootSource = getTokenSourceSpan(this.tokens[0], this.tokens[this.tokens.length - 1]);
        this.root = new _root2.default({ source: rootSource });
        this.root.errorGenerator = this._errorGenerator();

        var selector = new _selector2.default({ source: { start: { line: 1, column: 1 } } });
        this.root.append(selector);
        this.current = selector;

        this.loop();
    }

    Parser.prototype._errorGenerator = function _errorGenerator() {
        var _this = this;

        return function (message, errorOptions) {
            if (typeof _this.rule === 'string') {
                return new Error(message);
            }
            return _this.rule.error(message, errorOptions);
        };
    };

    Parser.prototype.attribute = function attribute() {
        var attr = [];
        var startingToken = this.currToken;
        this.position++;
        while (this.position < this.tokens.length && this.currToken[_tokenize.FIELDS.TYPE] !== tokens.closeSquare) {
            attr.push(this.currToken);
            this.position++;
        }
        if (this.currToken[_tokenize.FIELDS.TYPE] !== tokens.closeSquare) {
            return this.expected('closing square bracket', this.currToken[_tokenize.FIELDS.START_POS]);
        }

        var len = attr.length;
        var node = {
            source: getSource(startingToken[1], startingToken[2], this.currToken[3], this.currToken[4]),
            sourceIndex: startingToken[_tokenize.FIELDS.START_POS]
        };

        if (len === 1 && !~[tokens.word].indexOf(attr[0][_tokenize.FIELDS.TYPE])) {
            return this.expected('attribute', attr[0][_tokenize.FIELDS.START_POS]);
        }

        var pos = 0;
        var spaceBefore = '';
        var commentBefore = '';
        var lastAdded = null;
        var spaceAfterMeaningfulToken = false;

        while (pos < len) {
            var token = attr[pos];
            var content = this.content(token);
            var next = attr[pos + 1];

            switch (token[_tokenize.FIELDS.TYPE]) {
                case tokens.space:
                    // if (
                    //     len === 1 ||
                    //     pos === 0 && this.content(next) === '|'
                    // ) {
                    //     return this.expected('attribute', token[TOKEN.START_POS], content);
                    // }
                    spaceAfterMeaningfulToken = true;
                    if (this.options.lossy) {
                        break;
                    }
                    if (lastAdded) {
                        (0, _util.ensureObject)(node, 'spaces', lastAdded);
                        var prevContent = node.spaces[lastAdded].after || '';
                        node.spaces[lastAdded].after = prevContent + content;

                        var existingComment = (0, _util.getProp)(node, 'raws', 'spaces', lastAdded, 'after') || null;

                        if (existingComment) {
                            node.raws.spaces[lastAdded].after = existingComment + content;
                        }
                    } else {
                        spaceBefore = spaceBefore + content;
                        commentBefore = commentBefore + content;
                    }
                    break;
                case tokens.asterisk:
                    if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {
                        node.operator = content;
                        lastAdded = 'operator';
                    } else if ((!node.namespace || lastAdded === "namespace" && !spaceAfterMeaningfulToken) && next) {
                        if (spaceBefore) {
                            (0, _util.ensureObject)(node, 'spaces', 'attribute');
                            node.spaces.attribute.before = spaceBefore;
                            spaceBefore = '';
                        }
                        if (commentBefore) {
                            (0, _util.ensureObject)(node, 'raws', 'spaces', 'attribute');
                            node.raws.spaces.attribute.before = spaceBefore;
                            commentBefore = '';
                        }
                        node.namespace = (node.namespace || "") + content;
                        var rawValue = (0, _util.getProp)(node, 'raws', 'namespace') || null;
                        if (rawValue) {
                            node.raws.namespace += content;
                        }
                        lastAdded = 'namespace';
                    }
                    spaceAfterMeaningfulToken = false;
                    break;
                case tokens.dollar:
                    if (lastAdded === "value") {
                        var oldRawValue = (0, _util.getProp)(node, 'raws', 'value');
                        node.value += "$";
                        if (oldRawValue) {
                            node.raws.value = oldRawValue + "$";
                        }
                        break;
                    }
                // Falls through
                case tokens.caret:
                    if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {
                        node.operator = content;
                        lastAdded = 'operator';
                    }
                    spaceAfterMeaningfulToken = false;
                    break;
                case tokens.combinator:
                    if (content === '~' && next[_tokenize.FIELDS.TYPE] === tokens.equals) {
                        node.operator = content;
                        lastAdded = 'operator';
                    }
                    if (content !== '|') {
                        spaceAfterMeaningfulToken = false;
                        break;
                    }
                    if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {
                        node.operator = content;
                        lastAdded = 'operator';
                    } else if (!node.namespace && !node.attribute) {
                        node.namespace = true;
                    }
                    spaceAfterMeaningfulToken = false;
                    break;
                case tokens.word:
                    if (next && this.content(next) === '|' && attr[pos + 2] && attr[pos + 2][_tokenize.FIELDS.TYPE] !== tokens.equals && // this look-ahead probably fails with comment nodes involved.
                    !node.operator && !node.namespace) {
                        node.namespace = content;
                        lastAdded = 'namespace';
                    } else if (!node.attribute || lastAdded === "attribute" && !spaceAfterMeaningfulToken) {
                        if (spaceBefore) {
                            (0, _util.ensureObject)(node, 'spaces', 'attribute');
                            node.spaces.attribute.before = spaceBefore;

                            spaceBefore = '';
                        }
                        if (commentBefore) {
                            (0, _util.ensureObject)(node, 'raws', 'spaces', 'attribute');
                            node.raws.spaces.attribute.before = commentBefore;
                            commentBefore = '';
                        }
                        node.attribute = (node.attribute || "") + content;
                        var _rawValue = (0, _util.getProp)(node, 'raws', 'attribute') || null;
                        if (_rawValue) {
                            node.raws.attribute += content;
                        }
                        lastAdded = 'attribute';
                    } else if (!node.value || lastAdded === "value" && !spaceAfterMeaningfulToken) {
                        var _unescaped = (0, _util.unesc)(content);
                        var _oldRawValue = (0, _util.getProp)(node, 'raws', 'value') || '';
                        var oldValue = node.value || '';
                        node.value = oldValue + _unescaped;
                        node.quoteMark = null;
                        if (_unescaped !== content || _oldRawValue) {
                            (0, _util.ensureObject)(node, 'raws');
                            node.raws.value = (_oldRawValue || oldValue) + content;
                        }
                        lastAdded = 'value';
                    } else {
                        var insensitive = content === 'i' || content === "I";
                        if (node.value && (node.quoteMark || spaceAfterMeaningfulToken)) {
                            node.insensitive = insensitive;
                            if (!insensitive || content === "I") {
                                (0, _util.ensureObject)(node, 'raws');
                                node.raws.insensitiveFlag = content;
                            }
                            lastAdded = 'insensitive';
                            if (spaceBefore) {
                                (0, _util.ensureObject)(node, 'spaces', 'insensitive');
                                node.spaces.insensitive.before = spaceBefore;

                                spaceBefore = '';
                            }
                            if (commentBefore) {
                                (0, _util.ensureObject)(node, 'raws', 'spaces', 'insensitive');
                                node.raws.spaces.insensitive.before = commentBefore;
                                commentBefore = '';
                            }
                        } else if (node.value) {
                            lastAdded = 'value';
                            node.value += content;
                            if (node.raws.value) {
                                node.raws.value += content;
                            }
                        }
                    }
                    spaceAfterMeaningfulToken = false;
                    break;
                case tokens.str:
                    if (!node.attribute || !node.operator) {
                        return this.error('Expected an attribute followed by an operator preceding the string.', {
                            index: token[_tokenize.FIELDS.START_POS]
                        });
                    }

                    var _unescapeValue = (0, _attribute.unescapeValue)(content),
                        unescaped = _unescapeValue.unescaped,
                        quoteMark = _unescapeValue.quoteMark;

                    node.value = unescaped;
                    node.quoteMark = quoteMark;
                    lastAdded = 'value';

                    (0, _util.ensureObject)(node, 'raws');
                    node.raws.value = content;

                    spaceAfterMeaningfulToken = false;
                    break;
                case tokens.equals:
                    if (!node.attribute) {
                        return this.expected('attribute', token[_tokenize.FIELDS.START_POS], content);
                    }
                    if (node.value) {
                        return this.error('Unexpected "=" found; an operator was already defined.', { index: token[_tokenize.FIELDS.START_POS] });
                    }
                    node.operator = node.operator ? node.operator + content : content;
                    lastAdded = 'operator';
                    spaceAfterMeaningfulToken = false;
                    break;
                case tokens.comment:
                    if (lastAdded) {
                        if (spaceAfterMeaningfulToken || next && next[_tokenize.FIELDS.TYPE] === tokens.space || lastAdded === 'insensitive') {
                            var lastComment = (0, _util.getProp)(node, 'spaces', lastAdded, 'after') || '';
                            var rawLastComment = (0, _util.getProp)(node, 'raws', 'spaces', lastAdded, 'after') || lastComment;

                            (0, _util.ensureObject)(node, 'raws', 'spaces', lastAdded);
                            node.raws.spaces[lastAdded].after = rawLastComment + content;
                        } else {
                            var lastValue = node[lastAdded] || '';
                            var rawLastValue = (0, _util.getProp)(node, 'raws', lastAdded) || lastValue;
                            (0, _util.ensureObject)(node, 'raws');
                            node.raws[lastAdded] = rawLastValue + content;
                        }
                    } else {
                        commentBefore = commentBefore + content;
                    }
                    break;
                default:
                    return this.error('Unexpected "' + content + '" found.', { index: token[_tokenize.FIELDS.START_POS] });
            }
            pos++;
        }
        unescapeProp(node, "attribute");
        unescapeProp(node, "namespace");
        this.newNode(new _attribute2.default(node));
        this.position++;
    };

    /**
     * return a node containing meaningless garbage up to (but not including) the specified token position.
     * if the token position is negative, all remaining tokens are consumed.
     *
     * This returns an array containing a single string node if all whitespace,
     * otherwise an array of comment nodes with space before and after.
     *
     * These tokens are not added to the current selector, the caller can add them or use them to amend
     * a previous node's space metadata.
     *
     * In lossy mode, this returns only comments.
     */


    Parser.prototype.parseWhitespaceEquivalentTokens = function parseWhitespaceEquivalentTokens(stopPosition) {
        if (stopPosition < 0) {
            stopPosition = this.tokens.length;
        }
        var startPosition = this.position;
        var nodes = [];
        var space = "";
        var lastComment = undefined;
        do {
            if (WHITESPACE_TOKENS[this.currToken[_tokenize.FIELDS.TYPE]]) {
                if (!this.options.lossy) {
                    space += this.content();
                }
            } else if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.comment) {
                var spaces = {};
                if (space) {
                    spaces.before = space;
                    space = "";
                }
                lastComment = new _comment2.default({
                    value: this.content(),
                    source: getTokenSource(this.currToken),
                    sourceIndex: this.currToken[_tokenize.FIELDS.START_POS],
                    spaces: spaces
                });
                nodes.push(lastComment);
            }
        } while (++this.position < stopPosition);

        if (space) {
            if (lastComment) {
                lastComment.spaces.after = space;
            } else if (!this.options.lossy) {
                var firstToken = this.tokens[startPosition];
                var lastToken = this.tokens[this.position - 1];
                nodes.push(new _string2.default({
                    value: '',
                    source: getSource(firstToken[_tokenize.FIELDS.START_LINE], firstToken[_tokenize.FIELDS.START_COL], lastToken[_tokenize.FIELDS.END_LINE], lastToken[_tokenize.FIELDS.END_COL]),
                    sourceIndex: firstToken[_tokenize.FIELDS.START_POS],
                    spaces: { before: space, after: '' }
                }));
            }
        }
        return nodes;
    };

    /**
     * 
     * @param {*} nodes 
     */


    Parser.prototype.convertWhitespaceNodesToSpace = function convertWhitespaceNodesToSpace(nodes) {
        var _this2 = this;

        var requiredSpace = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

        var space = "";
        var rawSpace = "";
        nodes.forEach(function (n) {
            var spaceBefore = _this2.lossySpace(n.spaces.before, requiredSpace);
            var rawSpaceBefore = _this2.lossySpace(n.rawSpaceBefore, requiredSpace);
            space += spaceBefore + _this2.lossySpace(n.spaces.after, requiredSpace && spaceBefore.length === 0);
            rawSpace += spaceBefore + n.value + _this2.lossySpace(n.rawSpaceAfter, requiredSpace && rawSpaceBefore.length === 0);
        });
        if (rawSpace === space) {
            rawSpace = undefined;
        }
        var result = { space: space, rawSpace: rawSpace };
        return result;
    };

    Parser.prototype.isNamedCombinator = function isNamedCombinator() {
        var position = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.position;

        return this.tokens[position + 0] && this.tokens[position + 0][_tokenize.FIELDS.TYPE] === tokens.slash && this.tokens[position + 1] && this.tokens[position + 1][_tokenize.FIELDS.TYPE] === tokens.word && this.tokens[position + 2] && this.tokens[position + 2][_tokenize.FIELDS.TYPE] === tokens.slash;
    };

    Parser.prototype.namedCombinator = function namedCombinator() {
        if (this.isNamedCombinator()) {
            var nameRaw = this.content(this.tokens[this.position + 1]);
            var name = (0, _util.unesc)(nameRaw).toLowerCase();
            var raws = {};
            if (name !== nameRaw) {
                raws.value = '/' + nameRaw + '/';
            }
            var node = new _combinator2.default({
                value: '/' + name + '/',
                source: getSource(this.currToken[_tokenize.FIELDS.START_LINE], this.currToken[_tokenize.FIELDS.START_COL], this.tokens[this.position + 2][_tokenize.FIELDS.END_LINE], this.tokens[this.position + 2][_tokenize.FIELDS.END_COL]),
                sourceIndex: this.currToken[_tokenize.FIELDS.START_POS],
                raws: raws
            });
            this.position = this.position + 3;
            return node;
        } else {
            this.unexpected();
        }
    };

    Parser.prototype.combinator = function combinator() {
        var _this3 = this;

        if (this.content() === '|') {
            return this.namespace();
        }
        // We need to decide between a space that's a descendant combinator and meaningless whitespace at the end of a selector.
        var nextSigTokenPos = this.locateNextMeaningfulToken(this.position);

        if (nextSigTokenPos < 0 || this.tokens[nextSigTokenPos][_tokenize.FIELDS.TYPE] === tokens.comma) {
            var nodes = this.parseWhitespaceEquivalentTokens(nextSigTokenPos);
            if (nodes.length > 0) {
                var last = this.current.last;
                if (last) {
                    var _convertWhitespaceNod = this.convertWhitespaceNodesToSpace(nodes),
                        space = _convertWhitespaceNod.space,
                        rawSpace = _convertWhitespaceNod.rawSpace;

                    if (rawSpace !== undefined) {
                        last.rawSpaceAfter += rawSpace;
                    }
                    last.spaces.after += space;
                } else {
                    nodes.forEach(function (n) {
                        return _this3.newNode(n);
                    });
                }
            }
            return;
        }

        var firstToken = this.currToken;
        var spaceOrDescendantSelectorNodes = undefined;
        if (nextSigTokenPos > this.position) {
            spaceOrDescendantSelectorNodes = this.parseWhitespaceEquivalentTokens(nextSigTokenPos);
        }

        var node = void 0;
        if (this.isNamedCombinator()) {
            node = this.namedCombinator();
        } else if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.combinator) {
            node = new _combinator2.default({
                value: this.content(),
                source: getTokenSource(this.currToken),
                sourceIndex: this.currToken[_tokenize.FIELDS.START_POS]
            });
            this.position++;
        } else if (WHITESPACE_TOKENS[this.currToken[_tokenize.FIELDS.TYPE]]) {
            // pass
        } else if (!spaceOrDescendantSelectorNodes) {
            this.unexpected();
        }

        if (node) {
            if (spaceOrDescendantSelectorNodes) {
                var _convertWhitespaceNod2 = this.convertWhitespaceNodesToSpace(spaceOrDescendantSelectorNodes),
                    _space = _convertWhitespaceNod2.space,
                    _rawSpace = _convertWhitespaceNod2.rawSpace;

                node.spaces.before = _space;
                node.rawSpaceBefore = _rawSpace;
            }
        } else {
            // descendant combinator
            var _convertWhitespaceNod3 = this.convertWhitespaceNodesToSpace(spaceOrDescendantSelectorNodes, true),
                _space2 = _convertWhitespaceNod3.space,
                _rawSpace2 = _convertWhitespaceNod3.rawSpace;

            if (!_rawSpace2) {
                _rawSpace2 = _space2;
            }
            var spaces = {};
            var raws = { spaces: {} };
            if (_space2.endsWith(' ') && _rawSpace2.endsWith(' ')) {
                spaces.before = _space2.slice(0, _space2.length - 1);
                raws.spaces.before = _rawSpace2.slice(0, _rawSpace2.length - 1);
            } else if (_space2.startsWith(' ') && _rawSpace2.startsWith(' ')) {
                spaces.after = _space2.slice(1);
                raws.spaces.after = _rawSpace2.slice(1);
            } else {
                raws.value = _rawSpace2;
            }
            node = new _combinator2.default({
                value: ' ',
                source: getTokenSourceSpan(firstToken, this.tokens[this.position - 1]),
                sourceIndex: firstToken[_tokenize.FIELDS.START_POS],
                spaces: spaces,
                raws: raws
            });
        }

        if (this.currToken && this.currToken[_tokenize.FIELDS.TYPE] === tokens.space) {
            node.spaces.after = this.optionalSpace(this.content());
            this.position++;
        }

        return this.newNode(node);
    };

    Parser.prototype.comma = function comma() {
        if (this.position === this.tokens.length - 1) {
            this.root.trailingComma = true;
            this.position++;
            return;
        }
        this.current._inferEndPosition();
        var selector = new _selector2.default({ source: { start: tokenStart(this.tokens[this.position + 1]) } });
        this.current.parent.append(selector);
        this.current = selector;
        this.position++;
    };

    Parser.prototype.comment = function comment() {
        var current = this.currToken;
        this.newNode(new _comment2.default({
            value: this.content(),
            source: getTokenSource(current),
            sourceIndex: current[_tokenize.FIELDS.START_POS]
        }));
        this.position++;
    };

    Parser.prototype.error = function error(message, opts) {
        throw this.root.error(message, opts);
    };

    Parser.prototype.missingBackslash = function missingBackslash() {
        return this.error('Expected a backslash preceding the semicolon.', {
            index: this.currToken[_tokenize.FIELDS.START_POS]
        });
    };

    Parser.prototype.missingParenthesis = function missingParenthesis() {
        return this.expected('opening parenthesis', this.currToken[_tokenize.FIELDS.START_POS]);
    };

    Parser.prototype.missingSquareBracket = function missingSquareBracket() {
        return this.expected('opening square bracket', this.currToken[_tokenize.FIELDS.START_POS]);
    };

    Parser.prototype.unexpected = function unexpected() {
        return this.error('Unexpected \'' + this.content() + '\'. Escaping special characters with \\ may help.', this.currToken[_tokenize.FIELDS.START_POS]);
    };

    Parser.prototype.namespace = function namespace() {
        var before = this.prevToken && this.content(this.prevToken) || true;
        if (this.nextToken[_tokenize.FIELDS.TYPE] === tokens.word) {
            this.position++;
            return this.word(before);
        } else if (this.nextToken[_tokenize.FIELDS.TYPE] === tokens.asterisk) {
            this.position++;
            return this.universal(before);
        }
    };

    Parser.prototype.nesting = function nesting() {
        if (this.nextToken) {
            var nextContent = this.content(this.nextToken);
            if (nextContent === "|") {
                this.position++;
                return;
            }
        }
        var current = this.currToken;
        this.newNode(new _nesting2.default({
            value: this.content(),
            source: getTokenSource(current),
            sourceIndex: current[_tokenize.FIELDS.START_POS]
        }));
        this.position++;
    };

    Parser.prototype.parentheses = function parentheses() {
        var last = this.current.last;
        var unbalanced = 1;
        this.position++;
        if (last && last.type === types.PSEUDO) {
            var selector = new _selector2.default({ source: { start: tokenStart(this.tokens[this.position - 1]) } });
            var cache = this.current;
            last.append(selector);
            this.current = selector;
            while (this.position < this.tokens.length && unbalanced) {
                if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {
                    unbalanced++;
                }
                if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {
                    unbalanced--;
                }
                if (unbalanced) {
                    this.parse();
                } else {
                    this.current.source.end = tokenEnd(this.currToken);
                    this.current.parent.source.end = tokenEnd(this.currToken);
                    this.position++;
                }
            }
            this.current = cache;
        } else {
            // I think this case should be an error. It's used to implement a basic parse of media queries
            // but I don't think it's a good idea.
            var parenStart = this.currToken;
            var parenValue = "(";
            var parenEnd = void 0;
            while (this.position < this.tokens.length && unbalanced) {
                if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {
                    unbalanced++;
                }
                if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {
                    unbalanced--;
                }
                parenEnd = this.currToken;
                parenValue += this.parseParenthesisToken(this.currToken);
                this.position++;
            }
            if (last) {
                last.appendToPropertyAndEscape("value", parenValue, parenValue);
            } else {
                this.newNode(new _string2.default({
                    value: parenValue,
                    source: getSource(parenStart[_tokenize.FIELDS.START_LINE], parenStart[_tokenize.FIELDS.START_COL], parenEnd[_tokenize.FIELDS.END_LINE], parenEnd[_tokenize.FIELDS.END_COL]),
                    sourceIndex: parenStart[_tokenize.FIELDS.START_POS]
                }));
            }
        }
        if (unbalanced) {
            return this.expected('closing parenthesis', this.currToken[_tokenize.FIELDS.START_POS]);
        }
    };

    Parser.prototype.pseudo = function pseudo() {
        var _this4 = this;

        var pseudoStr = '';
        var startingToken = this.currToken;
        while (this.currToken && this.currToken[_tokenize.FIELDS.TYPE] === tokens.colon) {
            pseudoStr += this.content();
            this.position++;
        }
        if (!this.currToken) {
            return this.expected(['pseudo-class', 'pseudo-element'], this.position - 1);
        }
        if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.word) {
            this.splitWord(false, function (first, length) {
                pseudoStr += first;
                _this4.newNode(new _pseudo2.default({
                    value: pseudoStr,
                    source: getTokenSourceSpan(startingToken, _this4.currToken),
                    sourceIndex: startingToken[_tokenize.FIELDS.START_POS]
                }));
                if (length > 1 && _this4.nextToken && _this4.nextToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {
                    _this4.error('Misplaced parenthesis.', {
                        index: _this4.nextToken[_tokenize.FIELDS.START_POS]
                    });
                }
            });
        } else {
            return this.expected(['pseudo-class', 'pseudo-element'], this.currToken[_tokenize.FIELDS.START_POS]);
        }
    };

    Parser.prototype.space = function space() {
        var content = this.content();
        // Handle space before and after the selector
        if (this.position === 0 || this.prevToken[_tokenize.FIELDS.TYPE] === tokens.comma || this.prevToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {
            this.spaces = this.optionalSpace(content);
            this.position++;
        } else if (this.position === this.tokens.length - 1 || this.nextToken[_tokenize.FIELDS.TYPE] === tokens.comma || this.nextToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {
            this.current.last.spaces.after = this.optionalSpace(content);
            this.position++;
        } else {
            this.combinator();
        }
    };

    Parser.prototype.string = function string() {
        var current = this.currToken;
        this.newNode(new _string2.default({
            value: this.content(),
            source: getTokenSource(current),
            sourceIndex: current[_tokenize.FIELDS.START_POS]
        }));
        this.position++;
    };

    Parser.prototype.universal = function universal(namespace) {
        var nextToken = this.nextToken;
        if (nextToken && this.content(nextToken) === '|') {
            this.position++;
            return this.namespace();
        }
        var current = this.currToken;
        this.newNode(new _universal2.default({
            value: this.content(),
            source: getTokenSource(current),
            sourceIndex: current[_tokenize.FIELDS.START_POS]
        }), namespace);
        this.position++;
    };

    Parser.prototype.splitWord = function splitWord(namespace, firstCallback) {
        var _this5 = this;

        var nextToken = this.nextToken;
        var word = this.content();
        while (nextToken && ~[tokens.dollar, tokens.caret, tokens.equals, tokens.word].indexOf(nextToken[_tokenize.FIELDS.TYPE])) {
            this.position++;
            var current = this.content();
            word += current;
            if (current.lastIndexOf('\\') === current.length - 1) {
                var next = this.nextToken;
                if (next && next[_tokenize.FIELDS.TYPE] === tokens.space) {
                    word += this.requiredSpace(this.content(next));
                    this.position++;
                }
            }
            nextToken = this.nextToken;
        }
        var hasClass = (0, _indexesOf2.default)(word, '.').filter(function (i) {
            return word[i - 1] !== '\\';
        });
        var hasId = (0, _indexesOf2.default)(word, '#');
        // Eliminate Sass interpolations from the list of id indexes
        var interpolations = (0, _indexesOf2.default)(word, '#{');
        if (interpolations.length) {
            hasId = hasId.filter(function (hashIndex) {
                return !~interpolations.indexOf(hashIndex);
            });
        }
        var indices = (0, _sortAscending2.default)((0, _uniq2.default)([0].concat(hasClass, hasId)));
        indices.forEach(function (ind, i) {
            var index = indices[i + 1] || word.length;
            var value = word.slice(ind, index);
            if (i === 0 && firstCallback) {
                return firstCallback.call(_this5, value, indices.length);
            }
            var node = void 0;
            var current = _this5.currToken;
            var sourceIndex = current[_tokenize.FIELDS.START_POS] + indices[i];
            var source = getSource(current[1], current[2] + ind, current[3], current[2] + (index - 1));
            if (~hasClass.indexOf(ind)) {
                var classNameOpts = {
                    value: value.slice(1),
                    source: source,
                    sourceIndex: sourceIndex
                };
                node = new _className2.default(unescapeProp(classNameOpts, "value"));
            } else if (~hasId.indexOf(ind)) {
                var idOpts = {
                    value: value.slice(1),
                    source: source,
                    sourceIndex: sourceIndex
                };
                node = new _id2.default(unescapeProp(idOpts, "value"));
            } else {
                var tagOpts = {
                    value: value,
                    source: source,
                    sourceIndex: sourceIndex
                };
                unescapeProp(tagOpts, "value");
                node = new _tag2.default(tagOpts);
            }
            _this5.newNode(node, namespace);
            // Ensure that the namespace is used only once
            namespace = null;
        });
        this.position++;
    };

    Parser.prototype.word = function word(namespace) {
        var nextToken = this.nextToken;
        if (nextToken && this.content(nextToken) === '|') {
            this.position++;
            return this.namespace();
        }
        return this.splitWord(namespace);
    };

    Parser.prototype.loop = function loop() {
        while (this.position < this.tokens.length) {
            this.parse(true);
        }
        this.current._inferEndPosition();
        return this.root;
    };

    Parser.prototype.parse = function parse(throwOnParenthesis) {
        switch (this.currToken[_tokenize.FIELDS.TYPE]) {
            case tokens.space:
                this.space();
                break;
            case tokens.comment:
                this.comment();
                break;
            case tokens.openParenthesis:
                this.parentheses();
                break;
            case tokens.closeParenthesis:
                if (throwOnParenthesis) {
                    this.missingParenthesis();
                }
                break;
            case tokens.openSquare:
                this.attribute();
                break;
            case tokens.dollar:
            case tokens.caret:
            case tokens.equals:
            case tokens.word:
                this.word();
                break;
            case tokens.colon:
                this.pseudo();
                break;
            case tokens.comma:
                this.comma();
                break;
            case tokens.asterisk:
                this.universal();
                break;
            case tokens.ampersand:
                this.nesting();
                break;
            case tokens.slash:
            case tokens.combinator:
                this.combinator();
                break;
            case tokens.str:
                this.string();
                break;
            // These cases throw; no break needed.
            case tokens.closeSquare:
                this.missingSquareBracket();
            case tokens.semicolon:
                this.missingBackslash();
            default:
                this.unexpected();
        }
    };

    /**
     * Helpers
     */

    Parser.prototype.expected = function expected(description, index, found) {
        if (Array.isArray(description)) {
            var last = description.pop();
            description = description.join(', ') + ' or ' + last;
        }
        var an = /^[aeiou]/.test(description[0]) ? 'an' : 'a';
        if (!found) {
            return this.error('Expected ' + an + ' ' + description + '.', { index: index });
        }
        return this.error('Expected ' + an + ' ' + description + ', found "' + found + '" instead.', { index: index });
    };

    Parser.prototype.requiredSpace = function requiredSpace(space) {
        return this.options.lossy ? ' ' : space;
    };

    Parser.prototype.optionalSpace = function optionalSpace(space) {
        return this.options.lossy ? '' : space;
    };

    Parser.prototype.lossySpace = function lossySpace(space, required) {
        if (this.options.lossy) {
            return required ? ' ' : '';
        } else {
            return space;
        }
    };

    Parser.prototype.parseParenthesisToken = function parseParenthesisToken(token) {
        var content = this.content(token);
        if (token[_tokenize.FIELDS.TYPE] === tokens.space) {
            return this.requiredSpace(content);
        } else {
            return content;
        }
    };

    Parser.prototype.newNode = function newNode(node, namespace) {
        if (namespace) {
            if (/^ +$/.test(namespace)) {
                if (!this.options.lossy) {
                    this.spaces = (this.spaces || '') + namespace;
                }
                namespace = true;
            }
            node.namespace = namespace;
            unescapeProp(node, "namespace");
        }
        if (this.spaces) {
            node.spaces.before = this.spaces;
            this.spaces = '';
        }
        return this.current.append(node);
    };

    Parser.prototype.content = function content() {
        var token = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.currToken;

        return this.css.slice(token[_tokenize.FIELDS.START_POS], token[_tokenize.FIELDS.END_POS]);
    };

    /**
     * returns the index of the next non-whitespace, non-comment token.
     * returns -1 if no meaningful token is found.
     */
    Parser.prototype.locateNextMeaningfulToken = function locateNextMeaningfulToken() {
        var startPosition = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.position + 1;

        var searchPosition = startPosition;
        while (searchPosition < this.tokens.length) {
            if (WHITESPACE_EQUIV_TOKENS[this.tokens[searchPosition][_tokenize.FIELDS.TYPE]]) {
                searchPosition++;
                continue;
            } else {
                return searchPosition;
            }
        }
        return -1;
    };

    _createClass(Parser, [{
        key: 'currToken',
        get: function get() {
            return this.tokens[this.position];
        }
    }, {
        key: 'nextToken',
        get: function get() {
            return this.tokens[this.position + 1];
        }
    }, {
        key: 'prevToken',
        get: function get() {
            return this.tokens[this.position - 1];
        }
    }]);

    return Parser;
}();

exports.default = Parser;
module.exports = exports['default'];
},{"./selectors/attribute":1027,"./selectors/className":1028,"./selectors/combinator":1029,"./selectors/comment":1030,"./selectors/id":1034,"./selectors/nesting":1037,"./selectors/pseudo":1039,"./selectors/root":1040,"./selectors/selector":1041,"./selectors/string":1042,"./selectors/tag":1043,"./selectors/types":1044,"./selectors/universal":1045,"./sortAscending":1046,"./tokenTypes":1047,"./tokenize":1048,"./util":1051,"indexes-of":727,"uniq":1198}],1026:[function(require,module,exports){
"use strict";

exports.__esModule = true;

var _parser = require("./parser");

var _parser2 = _interopRequireDefault(_parser);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Processor = function () {
    function Processor(func, options) {
        _classCallCheck(this, Processor);

        this.func = func || function noop() {};
        this.funcRes = null;
        this.options = options;
    }

    Processor.prototype._shouldUpdateSelector = function _shouldUpdateSelector(rule) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        var merged = Object.assign({}, this.options, options);
        if (merged.updateSelector === false) {
            return false;
        } else {
            return typeof rule !== "string";
        }
    };

    Processor.prototype._isLossy = function _isLossy() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        var merged = Object.assign({}, this.options, options);
        if (merged.lossless === false) {
            return true;
        } else {
            return false;
        }
    };

    Processor.prototype._root = function _root(rule) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        var parser = new _parser2.default(rule, this._parseOptions(options));
        return parser.root;
    };

    Processor.prototype._parseOptions = function _parseOptions(options) {
        return {
            lossy: this._isLossy(options)
        };
    };

    Processor.prototype._run = function _run(rule) {
        var _this = this;

        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        return new Promise(function (resolve, reject) {
            try {
                var root = _this._root(rule, options);
                Promise.resolve(_this.func(root)).then(function (transform) {
                    var string = undefined;
                    if (_this._shouldUpdateSelector(rule, options)) {
                        string = root.toString();
                        rule.selector = string;
                    }
                    return { transform: transform, root: root, string: string };
                }).then(resolve, reject);
            } catch (e) {
                reject(e);
                return;
            }
        });
    };

    Processor.prototype._runSync = function _runSync(rule) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        var root = this._root(rule, options);
        var transform = this.func(root);
        if (transform && typeof transform.then === "function") {
            throw new Error("Selector processor returned a promise to a synchronous call.");
        }
        var string = undefined;
        if (options.updateSelector && typeof rule !== "string") {
            string = root.toString();
            rule.selector = string;
        }
        return { transform: transform, root: root, string: string };
    };

    /**
     * Process rule into a selector AST.
     *
     * @param rule {postcss.Rule | string} The css selector to be processed
     * @param options The options for processing
     * @returns {Promise<parser.Root>} The AST of the selector after processing it.
     */


    Processor.prototype.ast = function ast(rule, options) {
        return this._run(rule, options).then(function (result) {
            return result.root;
        });
    };

    /**
     * Process rule into a selector AST synchronously.
     *
     * @param rule {postcss.Rule | string} The css selector to be processed
     * @param options The options for processing
     * @returns {parser.Root} The AST of the selector after processing it.
     */


    Processor.prototype.astSync = function astSync(rule, options) {
        return this._runSync(rule, options).root;
    };

    /**
     * Process a selector into a transformed value asynchronously
     *
     * @param rule {postcss.Rule | string} The css selector to be processed
     * @param options The options for processing
     * @returns {Promise<any>} The value returned by the processor.
     */


    Processor.prototype.transform = function transform(rule, options) {
        return this._run(rule, options).then(function (result) {
            return result.transform;
        });
    };

    /**
     * Process a selector into a transformed value synchronously.
     *
     * @param rule {postcss.Rule | string} The css selector to be processed
     * @param options The options for processing
     * @returns {any} The value returned by the processor.
     */


    Processor.prototype.transformSync = function transformSync(rule, options) {
        return this._runSync(rule, options).transform;
    };

    /**
     * Process a selector into a new selector string asynchronously.
     *
     * @param rule {postcss.Rule | string} The css selector to be processed
     * @param options The options for processing
     * @returns {string} the selector after processing.
     */


    Processor.prototype.process = function process(rule, options) {
        return this._run(rule, options).then(function (result) {
            return result.string || result.root.toString();
        });
    };

    /**
     * Process a selector into a new selector string synchronously.
     *
     * @param rule {postcss.Rule | string} The css selector to be processed
     * @param options The options for processing
     * @returns {string} the selector after processing.
     */


    Processor.prototype.processSync = function processSync(rule, options) {
        var result = this._runSync(rule, options);
        return result.string || result.root.toString();
    };

    return Processor;
}();

exports.default = Processor;
module.exports = exports["default"];
},{"./parser":1025}],1027:[function(require,module,exports){
"use strict";

exports.__esModule = true;

var _CSSESC_QUOTE_OPTIONS;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.unescapeValue = unescapeValue;

var _cssesc = require("cssesc");

var _cssesc2 = _interopRequireDefault(_cssesc);

var _unesc = require("../util/unesc");

var _unesc2 = _interopRequireDefault(_unesc);

var _namespace = require("./namespace");

var _namespace2 = _interopRequireDefault(_namespace);

var _types = require("./types");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _require = require("util"),
    deprecate = _require.deprecate;

var WRAPPED_IN_QUOTES = /^('|")(.*)\1$/;

var warnOfDeprecatedValueAssignment = deprecate(function () {}, "Assigning an attribute a value containing characters that might need to be escaped is deprecated. " + "Call attribute.setValue() instead.");

var warnOfDeprecatedQuotedAssignment = deprecate(function () {}, "Assigning attr.quoted is deprecated and has no effect. Assign to attr.quoteMark instead.");

var warnOfDeprecatedConstructor = deprecate(function () {}, "Constructing an Attribute selector with a value without specifying quoteMark is deprecated. Note: The value should be unescaped now.");

function unescapeValue(value) {
    var deprecatedUsage = false;
    var quoteMark = null;
    var unescaped = value;
    var m = unescaped.match(WRAPPED_IN_QUOTES);
    if (m) {
        quoteMark = m[1];
        unescaped = m[2];
    }
    unescaped = (0, _unesc2.default)(unescaped);
    if (unescaped !== value) {
        deprecatedUsage = true;
    }
    return {
        deprecatedUsage: deprecatedUsage,
        unescaped: unescaped,
        quoteMark: quoteMark
    };
}

function handleDeprecatedContructorOpts(opts) {
    if (opts.quoteMark !== undefined) {
        return opts;
    }
    if (opts.value === undefined) {
        return opts;
    }
    warnOfDeprecatedConstructor();

    var _unescapeValue = unescapeValue(opts.value),
        quoteMark = _unescapeValue.quoteMark,
        unescaped = _unescapeValue.unescaped;

    if (!opts.raws) {
        opts.raws = {};
    }
    if (opts.raws.value === undefined) {
        opts.raws.value = opts.value;
    }
    opts.value = unescaped;
    opts.quoteMark = quoteMark;
    return opts;
}

var Attribute = function (_Namespace) {
    _inherits(Attribute, _Namespace);

    function Attribute() {
        var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        _classCallCheck(this, Attribute);

        var _this = _possibleConstructorReturn(this, _Namespace.call(this, handleDeprecatedContructorOpts(opts)));

        _this.type = _types.ATTRIBUTE;
        _this.raws = _this.raws || {};
        Object.defineProperty(_this.raws, 'unquoted', {
            get: deprecate(function () {
                return _this.value;
            }, "attr.raws.unquoted is deprecated. Call attr.value instead."),
            set: deprecate(function () {
                return _this.value;
            }, "Setting attr.raws.unquoted is deprecated and has no effect. attr.value is unescaped by default now.")
        });
        _this._constructed = true;
        return _this;
    }

    /**
     * Returns the Attribute's value quoted such that it would be legal to use
     * in the value of a css file. The original value's quotation setting
     * used for stringification is left unchanged. See `setValue(value, options)`
     * if you want to control the quote settings of a new value for the attribute.
     *
     * You can also change the quotation used for the current value by setting quoteMark.
     *
     * Options:
     *   * quoteMark {'"' | "'" | null} - Use this value to quote the value. If this
     *     option is not set, the original value for quoteMark will be used. If
     *     indeterminate, a double quote is used. The legal values are:
     *     * `null` - the value will be unquoted and characters will be escaped as necessary.
     *     * `'` - the value will be quoted with a single quote and single quotes are escaped.
     *     * `"` - the value will be quoted with a double quote and double quotes are escaped.
     *   * preferCurrentQuoteMark {boolean} - if true, prefer the source quote mark
     *     over the quoteMark option value.
     *   * smart {boolean} - if true, will select a quote mark based on the value
     *     and the other options specified here. See the `smartQuoteMark()`
     *     method.
     **/


    Attribute.prototype.getQuotedValue = function getQuotedValue() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        var quoteMark = this._determineQuoteMark(options);
        var cssescopts = CSSESC_QUOTE_OPTIONS[quoteMark];
        var escaped = (0, _cssesc2.default)(this._value, cssescopts);
        return escaped;
    };

    Attribute.prototype._determineQuoteMark = function _determineQuoteMark(options) {
        return options.smart ? this.smartQuoteMark(options) : this.preferredQuoteMark(options);
    };

    /**
     * Set the unescaped value with the specified quotation options. The value
     * provided must not include any wrapping quote marks -- those quotes will
     * be interpreted as part of the value and escaped accordingly.
     */


    Attribute.prototype.setValue = function setValue(value) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        this._value = value;
        this._quoteMark = this._determineQuoteMark(options);
        this._syncRawValue();
    };

    /**
     * Intelligently select a quoteMark value based on the value's contents. If
     * the value is a legal CSS ident, it will not be quoted. Otherwise a quote
     * mark will be picked that minimizes the number of escapes.
     *
     * If there's no clear winner, the quote mark from these options is used,
     * then the source quote mark (this is inverted if `preferCurrentQuoteMark` is
     * true). If the quoteMark is unspecified, a double quote is used.
     *
     * @param options This takes the quoteMark and preferCurrentQuoteMark options
     * from the quoteValue method.
     */


    Attribute.prototype.smartQuoteMark = function smartQuoteMark(options) {
        var v = this.value;
        var numSingleQuotes = v.replace(/[^']/g, '').length;
        var numDoubleQuotes = v.replace(/[^"]/g, '').length;
        if (numSingleQuotes + numDoubleQuotes === 0) {
            var escaped = (0, _cssesc2.default)(v, { isIdentifier: true });
            if (escaped === v) {
                return Attribute.NO_QUOTE;
            } else {
                var pref = this.preferredQuoteMark(options);
                if (pref === Attribute.NO_QUOTE) {
                    // pick a quote mark that isn't none and see if it's smaller
                    var quote = this.quoteMark || options.quoteMark || Attribute.DOUBLE_QUOTE;
                    var opts = CSSESC_QUOTE_OPTIONS[quote];
                    var quoteValue = (0, _cssesc2.default)(v, opts);
                    if (quoteValue.length < escaped.length) {
                        return quote;
                    }
                }
                return pref;
            }
        } else if (numDoubleQuotes === numSingleQuotes) {
            return this.preferredQuoteMark(options);
        } else if (numDoubleQuotes < numSingleQuotes) {
            return Attribute.DOUBLE_QUOTE;
        } else {
            return Attribute.SINGLE_QUOTE;
        }
    };

    /**
     * Selects the preferred quote mark based on the options and the current quote mark value.
     * If you want the quote mark to depend on the attribute value, call `smartQuoteMark(opts)`
     * instead.
     */


    Attribute.prototype.preferredQuoteMark = function preferredQuoteMark(options) {
        var quoteMark = options.preferCurrentQuoteMark ? this.quoteMark : options.quoteMark;

        if (quoteMark === undefined) {
            quoteMark = options.preferCurrentQuoteMark ? options.quoteMark : this.quoteMark;
        }

        if (quoteMark === undefined) {
            quoteMark = Attribute.DOUBLE_QUOTE;
        }

        return quoteMark;
    };

    Attribute.prototype._syncRawValue = function _syncRawValue() {
        var rawValue = (0, _cssesc2.default)(this._value, CSSESC_QUOTE_OPTIONS[this.quoteMark]);
        if (rawValue === this._value) {
            if (this.raws) {
                delete this.raws.value;
            }
        } else {
            this.raws.value = rawValue;
        }
    };

    Attribute.prototype._handleEscapes = function _handleEscapes(prop, value) {
        if (this._constructed) {
            var escaped = (0, _cssesc2.default)(value, { isIdentifier: true });
            if (escaped !== value) {
                this.raws[prop] = escaped;
            } else {
                delete this.raws[prop];
            }
        }
    };

    Attribute.prototype._spacesFor = function _spacesFor(name) {
        var attrSpaces = { before: '', after: '' };
        var spaces = this.spaces[name] || {};
        var rawSpaces = this.raws.spaces && this.raws.spaces[name] || {};
        return Object.assign(attrSpaces, spaces, rawSpaces);
    };

    Attribute.prototype._stringFor = function _stringFor(name) {
        var spaceName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : name;
        var concat = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultAttrConcat;

        var attrSpaces = this._spacesFor(spaceName);
        return concat(this.stringifyProperty(name), attrSpaces);
    };

    /**
     * returns the offset of the attribute part specified relative to the
     * start of the node of the output string.
     *
     * * "ns" - alias for "namespace"
     * * "namespace" - the namespace if it exists.
     * * "attribute" - the attribute name
     * * "attributeNS" - the start of the attribute or its namespace
     * * "operator" - the match operator of the attribute
     * * "value" - The value (string or identifier)
     * * "insensitive" - the case insensitivity flag;
     * @param part One of the possible values inside an attribute.
     * @returns -1 if the name is invalid or the value doesn't exist in this attribute.
     */


    Attribute.prototype.offsetOf = function offsetOf(name) {
        var count = 1;
        var attributeSpaces = this._spacesFor("attribute");
        count += attributeSpaces.before.length;
        if (name === "namespace" || name === "ns") {
            return this.namespace ? count : -1;
        }
        if (name === "attributeNS") {
            return count;
        }

        count += this.namespaceString.length;
        if (this.namespace) {
            count += 1;
        }
        if (name === "attribute") {
            return count;
        }

        count += this.stringifyProperty("attribute").length;
        count += attributeSpaces.after.length;
        var operatorSpaces = this._spacesFor("operator");
        count += operatorSpaces.before.length;
        var operator = this.stringifyProperty("operator");
        if (name === "operator") {
            return operator ? count : -1;
        }

        count += operator.length;
        count += operatorSpaces.after.length;
        var valueSpaces = this._spacesFor("value");
        count += valueSpaces.before.length;
        var value = this.stringifyProperty("value");
        if (name === "value") {
            return value ? count : -1;
        }

        count += value.length;
        count += valueSpaces.after.length;
        var insensitiveSpaces = this._spacesFor("insensitive");
        count += insensitiveSpaces.before.length;
        if (name === "insensitive") {
            return this.insensitive ? count : -1;
        }
        return -1;
    };

    Attribute.prototype.toString = function toString() {
        var _this2 = this;

        var selector = [this.rawSpaceBefore, '['];

        selector.push(this._stringFor('qualifiedAttribute', 'attribute'));

        if (this.operator && this.value) {
            selector.push(this._stringFor('operator'));
            selector.push(this._stringFor('value'));
            selector.push(this._stringFor('insensitiveFlag', 'insensitive', function (attrValue, attrSpaces) {
                if (attrValue.length > 0 && !_this2.quoted && attrSpaces.before.length === 0 && !(_this2.spaces.value && _this2.spaces.value.after)) {
                    attrSpaces.before = " ";
                }
                return defaultAttrConcat(attrValue, attrSpaces);
            }));
        }

        selector.push(']');
        selector.push(this.rawSpaceAfter);
        return selector.join('');
    };

    _createClass(Attribute, [{
        key: "quoted",
        get: function get() {
            var qm = this.quoteMark;
            return qm === "'" || qm === '"';
        },
        set: function set(value) {
            warnOfDeprecatedQuotedAssignment();
        }

        /**
         * returns a single (`'`) or double (`"`) quote character if the value is quoted.
         * returns `null` if the value is not quoted.
         * returns `undefined` if the quotation state is unknown (this can happen when
         * the attribute is constructed without specifying a quote mark.)
         */

    }, {
        key: "quoteMark",
        get: function get() {
            return this._quoteMark;
        }

        /**
         * Set the quote mark to be used by this attribute's value.
         * If the quote mark changes, the raw (escaped) value at `attr.raws.value` of the attribute
         * value is updated accordingly.
         *
         * @param {"'" | '"' | null} quoteMark The quote mark or `null` if the value should be unquoted.
         */
        ,
        set: function set(quoteMark) {
            if (!this._constructed) {
                this._quoteMark = quoteMark;
                return;
            }
            if (this._quoteMark !== quoteMark) {
                this._quoteMark = quoteMark;
                this._syncRawValue();
            }
        }
    }, {
        key: "qualifiedAttribute",
        get: function get() {
            return this.qualifiedName(this.raws.attribute || this.attribute);
        }
    }, {
        key: "insensitiveFlag",
        get: function get() {
            return this.insensitive ? 'i' : '';
        }
    }, {
        key: "value",
        get: function get() {
            return this._value;
        }

        /**
         * Before 3.0, the value had to be set to an escaped value including any wrapped
         * quote marks. In 3.0, the semantics of `Attribute.value` changed so that the value
         * is unescaped during parsing and any quote marks are removed.
         *
         * Because the ambiguity of this semantic change, if you set `attr.value = newValue`,
         * a deprecation warning is raised when the new value contains any characters that would
         * require escaping (including if it contains wrapped quotes).
         *
         * Instead, you should call `attr.setValue(newValue, opts)` and pass options that describe
         * how the new value is quoted.
         */
        ,
        set: function set(v) {
            if (this._constructed) {
                var _unescapeValue2 = unescapeValue(v),
                    deprecatedUsage = _unescapeValue2.deprecatedUsage,
                    unescaped = _unescapeValue2.unescaped,
                    quoteMark = _unescapeValue2.quoteMark;

                if (deprecatedUsage) {
                    warnOfDeprecatedValueAssignment();
                }
                if (unescaped === this._value && quoteMark === this._quoteMark) {
                    return;
                }
                this._value = unescaped;
                this._quoteMark = quoteMark;
                this._syncRawValue();
            } else {
                this._value = v;
            }
        }
    }, {
        key: "attribute",
        get: function get() {
            return this._attribute;
        },
        set: function set(name) {
            this._handleEscapes("attribute", name);
            this._attribute = name;
        }
    }]);

    return Attribute;
}(_namespace2.default);

Attribute.NO_QUOTE = null;
Attribute.SINGLE_QUOTE = "'";
Attribute.DOUBLE_QUOTE = '"';
exports.default = Attribute;


var CSSESC_QUOTE_OPTIONS = (_CSSESC_QUOTE_OPTIONS = {
    "'": { quotes: 'single', wrap: true },
    '"': { quotes: 'double', wrap: true }
}, _CSSESC_QUOTE_OPTIONS[null] = { isIdentifier: true }, _CSSESC_QUOTE_OPTIONS);

function defaultAttrConcat(attrValue, attrSpaces) {
    return "" + attrSpaces.before + attrValue + attrSpaces.after;
}
},{"../util/unesc":1053,"./namespace":1036,"./types":1044,"cssesc":666,"util":1204}],1028:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cssesc = require('cssesc');

var _cssesc2 = _interopRequireDefault(_cssesc);

var _util = require('../util');

var _node = require('./node');

var _node2 = _interopRequireDefault(_node);

var _types = require('./types');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ClassName = function (_Node) {
    _inherits(ClassName, _Node);

    function ClassName(opts) {
        _classCallCheck(this, ClassName);

        var _this = _possibleConstructorReturn(this, _Node.call(this, opts));

        _this.type = _types.CLASS;
        _this._constructed = true;
        return _this;
    }

    ClassName.prototype.toString = function toString() {
        return [this.rawSpaceBefore, String('.' + this.stringifyProperty("value")), this.rawSpaceAfter].join('');
    };

    _createClass(ClassName, [{
        key: 'value',
        set: function set(v) {
            if (this._constructed) {
                var escaped = (0, _cssesc2.default)(v, { isIdentifier: true });
                if (escaped !== v) {
                    (0, _util.ensureObject)(this, "raws");
                    this.raws.value = escaped;
                } else if (this.raws) {
                    delete this.raws.value;
                }
            }
            this._value = v;
        },
        get: function get() {
            return this._value;
        }
    }]);

    return ClassName;
}(_node2.default);

exports.default = ClassName;
module.exports = exports['default'];
},{"../util":1051,"./node":1038,"./types":1044,"cssesc":666}],1029:[function(require,module,exports){
arguments[4][907][0].apply(exports,arguments)
},{"./node":1038,"./types":1044,"dup":907}],1030:[function(require,module,exports){
arguments[4][908][0].apply(exports,arguments)
},{"./node":1038,"./types":1044,"dup":908}],1031:[function(require,module,exports){
arguments[4][909][0].apply(exports,arguments)
},{"./attribute":1027,"./className":1028,"./combinator":1029,"./comment":1030,"./id":1034,"./nesting":1037,"./pseudo":1039,"./root":1040,"./selector":1041,"./string":1042,"./tag":1043,"./universal":1045,"dup":909}],1032:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _node = require('./node');

var _node2 = _interopRequireDefault(_node);

var _types = require('./types');

var types = _interopRequireWildcard(_types);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Container = function (_Node) {
    _inherits(Container, _Node);

    function Container(opts) {
        _classCallCheck(this, Container);

        var _this = _possibleConstructorReturn(this, _Node.call(this, opts));

        if (!_this.nodes) {
            _this.nodes = [];
        }
        return _this;
    }

    Container.prototype.append = function append(selector) {
        selector.parent = this;
        this.nodes.push(selector);
        return this;
    };

    Container.prototype.prepend = function prepend(selector) {
        selector.parent = this;
        this.nodes.unshift(selector);
        return this;
    };

    Container.prototype.at = function at(index) {
        return this.nodes[index];
    };

    Container.prototype.index = function index(child) {
        if (typeof child === 'number') {
            return child;
        }
        return this.nodes.indexOf(child);
    };

    Container.prototype.removeChild = function removeChild(child) {
        child = this.index(child);
        this.at(child).parent = undefined;
        this.nodes.splice(child, 1);

        var index = void 0;
        for (var id in this.indexes) {
            index = this.indexes[id];
            if (index >= child) {
                this.indexes[id] = index - 1;
            }
        }

        return this;
    };

    Container.prototype.removeAll = function removeAll() {
        for (var _iterator = this.nodes, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
            var _ref;

            if (_isArray) {
                if (_i >= _iterator.length) break;
                _ref = _iterator[_i++];
            } else {
                _i = _iterator.next();
                if (_i.done) break;
                _ref = _i.value;
            }

            var node = _ref;

            node.parent = undefined;
        }
        this.nodes = [];
        return this;
    };

    Container.prototype.empty = function empty() {
        return this.removeAll();
    };

    Container.prototype.insertAfter = function insertAfter(oldNode, newNode) {
        newNode.parent = this;
        var oldIndex = this.index(oldNode);
        this.nodes.splice(oldIndex + 1, 0, newNode);

        newNode.parent = this;

        var index = void 0;
        for (var id in this.indexes) {
            index = this.indexes[id];
            if (oldIndex <= index) {
                this.indexes[id] = index + 1;
            }
        }

        return this;
    };

    Container.prototype.insertBefore = function insertBefore(oldNode, newNode) {
        newNode.parent = this;
        var oldIndex = this.index(oldNode);
        this.nodes.splice(oldIndex, 0, newNode);

        newNode.parent = this;

        var index = void 0;
        for (var id in this.indexes) {
            index = this.indexes[id];
            if (index <= oldIndex) {
                this.indexes[id] = index + 1;
            }
        }

        return this;
    };

    Container.prototype._findChildAtPosition = function _findChildAtPosition(line, col) {
        var found = undefined;
        this.each(function (node) {
            if (node.atPosition) {
                var foundChild = node.atPosition(line, col);
                if (foundChild) {
                    found = foundChild;
                    return false;
                }
            } else if (node.isAtPosition(line, col)) {
                found = node;
                return false;
            }
        });
        return found;
    };

    /**
     * Return the most specific node at the line and column number given.
     * The source location is based on the original parsed location, locations aren't
     * updated as selector nodes are mutated.
     * 
     * Note that this location is relative to the location of the first character
     * of the selector, and not the location of the selector in the overall document
     * when used in conjunction with postcss.
     *
     * If not found, returns undefined.
     * @param {number} line The line number of the node to find. (1-based index)
     * @param {number} col  The column number of the node to find. (1-based index)
     */


    Container.prototype.atPosition = function atPosition(line, col) {
        if (this.isAtPosition(line, col)) {
            return this._findChildAtPosition(line, col) || this;
        } else {
            return undefined;
        }
    };

    Container.prototype._inferEndPosition = function _inferEndPosition() {
        if (this.last && this.last.source && this.last.source.end) {
            this.source = this.source || {};
            this.source.end = this.source.end || {};
            Object.assign(this.source.end, this.last.source.end);
        }
    };

    Container.prototype.each = function each(callback) {
        if (!this.lastEach) {
            this.lastEach = 0;
        }
        if (!this.indexes) {
            this.indexes = {};
        }

        this.lastEach++;
        var id = this.lastEach;
        this.indexes[id] = 0;

        if (!this.length) {
            return undefined;
        }

        var index = void 0,
            result = void 0;
        while (this.indexes[id] < this.length) {
            index = this.indexes[id];
            result = callback(this.at(index), index);
            if (result === false) {
                break;
            }

            this.indexes[id] += 1;
        }

        delete this.indexes[id];

        if (result === false) {
            return false;
        }
    };

    Container.prototype.walk = function walk(callback) {
        return this.each(function (node, i) {
            var result = callback(node, i);

            if (result !== false && node.length) {
                result = node.walk(callback);
            }

            if (result === false) {
                return false;
            }
        });
    };

    Container.prototype.walkAttributes = function walkAttributes(callback) {
        var _this2 = this;

        return this.walk(function (selector) {
            if (selector.type === types.ATTRIBUTE) {
                return callback.call(_this2, selector);
            }
        });
    };

    Container.prototype.walkClasses = function walkClasses(callback) {
        var _this3 = this;

        return this.walk(function (selector) {
            if (selector.type === types.CLASS) {
                return callback.call(_this3, selector);
            }
        });
    };

    Container.prototype.walkCombinators = function walkCombinators(callback) {
        var _this4 = this;

        return this.walk(function (selector) {
            if (selector.type === types.COMBINATOR) {
                return callback.call(_this4, selector);
            }
        });
    };

    Container.prototype.walkComments = function walkComments(callback) {
        var _this5 = this;

        return this.walk(function (selector) {
            if (selector.type === types.COMMENT) {
                return callback.call(_this5, selector);
            }
        });
    };

    Container.prototype.walkIds = function walkIds(callback) {
        var _this6 = this;

        return this.walk(function (selector) {
            if (selector.type === types.ID) {
                return callback.call(_this6, selector);
            }
        });
    };

    Container.prototype.walkNesting = function walkNesting(callback) {
        var _this7 = this;

        return this.walk(function (selector) {
            if (selector.type === types.NESTING) {
                return callback.call(_this7, selector);
            }
        });
    };

    Container.prototype.walkPseudos = function walkPseudos(callback) {
        var _this8 = this;

        return this.walk(function (selector) {
            if (selector.type === types.PSEUDO) {
                return callback.call(_this8, selector);
            }
        });
    };

    Container.prototype.walkTags = function walkTags(callback) {
        var _this9 = this;

        return this.walk(function (selector) {
            if (selector.type === types.TAG) {
                return callback.call(_this9, selector);
            }
        });
    };

    Container.prototype.walkUniversals = function walkUniversals(callback) {
        var _this10 = this;

        return this.walk(function (selector) {
            if (selector.type === types.UNIVERSAL) {
                return callback.call(_this10, selector);
            }
        });
    };

    Container.prototype.split = function split(callback) {
        var _this11 = this;

        var current = [];
        return this.reduce(function (memo, node, index) {
            var split = callback.call(_this11, node);
            current.push(node);
            if (split) {
                memo.push(current);
                current = [];
            } else if (index === _this11.length - 1) {
                memo.push(current);
            }
            return memo;
        }, []);
    };

    Container.prototype.map = function map(callback) {
        return this.nodes.map(callback);
    };

    Container.prototype.reduce = function reduce(callback, memo) {
        return this.nodes.reduce(callback, memo);
    };

    Container.prototype.every = function every(callback) {
        return this.nodes.every(callback);
    };

    Container.prototype.some = function some(callback) {
        return this.nodes.some(callback);
    };

    Container.prototype.filter = function filter(callback) {
        return this.nodes.filter(callback);
    };

    Container.prototype.sort = function sort(callback) {
        return this.nodes.sort(callback);
    };

    Container.prototype.toString = function toString() {
        return this.map(String).join('');
    };

    _createClass(Container, [{
        key: 'first',
        get: function get() {
            return this.at(0);
        }
    }, {
        key: 'last',
        get: function get() {
            return this.at(this.length - 1);
        }
    }, {
        key: 'length',
        get: function get() {
            return this.nodes.length;
        }
    }]);

    return Container;
}(_node2.default);

exports.default = Container;
module.exports = exports['default'];
},{"./node":1038,"./types":1044}],1033:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports.isUniversal = exports.isTag = exports.isString = exports.isSelector = exports.isRoot = exports.isPseudo = exports.isNesting = exports.isIdentifier = exports.isComment = exports.isCombinator = exports.isClassName = exports.isAttribute = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _IS_TYPE;

exports.isNode = isNode;
exports.isPseudoElement = isPseudoElement;
exports.isPseudoClass = isPseudoClass;
exports.isContainer = isContainer;
exports.isNamespace = isNamespace;

var _types = require("./types");

var IS_TYPE = (_IS_TYPE = {}, _IS_TYPE[_types.ATTRIBUTE] = true, _IS_TYPE[_types.CLASS] = true, _IS_TYPE[_types.COMBINATOR] = true, _IS_TYPE[_types.COMMENT] = true, _IS_TYPE[_types.ID] = true, _IS_TYPE[_types.NESTING] = true, _IS_TYPE[_types.PSEUDO] = true, _IS_TYPE[_types.ROOT] = true, _IS_TYPE[_types.SELECTOR] = true, _IS_TYPE[_types.STRING] = true, _IS_TYPE[_types.TAG] = true, _IS_TYPE[_types.UNIVERSAL] = true, _IS_TYPE);

function isNode(node) {
    return (typeof node === "undefined" ? "undefined" : _typeof(node)) === "object" && IS_TYPE[node.type];
}

function isNodeType(type, node) {
    return isNode(node) && node.type === type;
}

var isAttribute = exports.isAttribute = isNodeType.bind(null, _types.ATTRIBUTE);
var isClassName = exports.isClassName = isNodeType.bind(null, _types.CLASS);
var isCombinator = exports.isCombinator = isNodeType.bind(null, _types.COMBINATOR);
var isComment = exports.isComment = isNodeType.bind(null, _types.COMMENT);
var isIdentifier = exports.isIdentifier = isNodeType.bind(null, _types.ID);
var isNesting = exports.isNesting = isNodeType.bind(null, _types.NESTING);
var isPseudo = exports.isPseudo = isNodeType.bind(null, _types.PSEUDO);
var isRoot = exports.isRoot = isNodeType.bind(null, _types.ROOT);
var isSelector = exports.isSelector = isNodeType.bind(null, _types.SELECTOR);
var isString = exports.isString = isNodeType.bind(null, _types.STRING);
var isTag = exports.isTag = isNodeType.bind(null, _types.TAG);
var isUniversal = exports.isUniversal = isNodeType.bind(null, _types.UNIVERSAL);

function isPseudoElement(node) {
    return isPseudo(node) && node.value && (node.value.startsWith("::") || node.value === ":before" || node.value === ":after");
}
function isPseudoClass(node) {
    return isPseudo(node) && !isPseudoElement(node);
}

function isContainer(node) {
    return !!(isNode(node) && node.walk);
}

function isNamespace(node) {
    return isAttribute(node) || isTag(node);
}
},{"./types":1044}],1034:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _node = require('./node');

var _node2 = _interopRequireDefault(_node);

var _types = require('./types');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ID = function (_Node) {
    _inherits(ID, _Node);

    function ID(opts) {
        _classCallCheck(this, ID);

        var _this = _possibleConstructorReturn(this, _Node.call(this, opts));

        _this.type = _types.ID;
        return _this;
    }

    ID.prototype.toString = function toString() {
        return [this.rawSpaceBefore, String('#' + this.stringifyProperty("value")), this.rawSpaceAfter].join('');
    };

    return ID;
}(_node2.default);

exports.default = ID;
module.exports = exports['default'];
},{"./node":1038,"./types":1044}],1035:[function(require,module,exports){
arguments[4][913][0].apply(exports,arguments)
},{"./constructors":1031,"./guards":1033,"./types":1044,"dup":913}],1036:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cssesc = require('cssesc');

var _cssesc2 = _interopRequireDefault(_cssesc);

var _util = require('../util');

var _node = require('./node');

var _node2 = _interopRequireDefault(_node);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Namespace = function (_Node) {
    _inherits(Namespace, _Node);

    function Namespace() {
        _classCallCheck(this, Namespace);

        return _possibleConstructorReturn(this, _Node.apply(this, arguments));
    }

    Namespace.prototype.qualifiedName = function qualifiedName(value) {
        if (this.namespace) {
            return this.namespaceString + '|' + value;
        } else {
            return value;
        }
    };

    Namespace.prototype.toString = function toString() {
        return [this.rawSpaceBefore, this.qualifiedName(this.stringifyProperty("value")), this.rawSpaceAfter].join('');
    };

    _createClass(Namespace, [{
        key: 'namespace',
        get: function get() {
            return this._namespace;
        },
        set: function set(namespace) {
            if (namespace === true || namespace === "*" || namespace === "&") {
                this._namespace = namespace;
                if (this.raws) {
                    delete this.raws.namespace;
                }
                return;
            }

            var escaped = (0, _cssesc2.default)(namespace, { isIdentifier: true });
            this._namespace = namespace;
            if (escaped !== namespace) {
                (0, _util.ensureObject)(this, "raws");
                this.raws.namespace = escaped;
            } else if (this.raws) {
                delete this.raws.namespace;
            }
        }
    }, {
        key: 'ns',
        get: function get() {
            return this._namespace;
        },
        set: function set(namespace) {
            this.namespace = namespace;
        }
    }, {
        key: 'namespaceString',
        get: function get() {
            if (this.namespace) {
                var ns = this.stringifyProperty("namespace");
                if (ns === true) {
                    return '';
                } else {
                    return ns;
                }
            } else {
                return '';
            }
        }
    }]);

    return Namespace;
}(_node2.default);

exports.default = Namespace;
;
module.exports = exports['default'];
},{"../util":1051,"./node":1038,"cssesc":666}],1037:[function(require,module,exports){
arguments[4][915][0].apply(exports,arguments)
},{"./node":1038,"./types":1044,"dup":915}],1038:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _util = require('../util');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var cloneNode = function cloneNode(obj, parent) {
    if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) !== 'object' || obj === null) {
        return obj;
    }

    var cloned = new obj.constructor();

    for (var i in obj) {
        if (!obj.hasOwnProperty(i)) {
            continue;
        }
        var value = obj[i];
        var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);

        if (i === 'parent' && type === 'object') {
            if (parent) {
                cloned[i] = parent;
            }
        } else if (value instanceof Array) {
            cloned[i] = value.map(function (j) {
                return cloneNode(j, cloned);
            });
        } else {
            cloned[i] = cloneNode(value, cloned);
        }
    }

    return cloned;
};

var Node = function () {
    function Node() {
        var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        _classCallCheck(this, Node);

        Object.assign(this, opts);
        this.spaces = this.spaces || {};
        this.spaces.before = this.spaces.before || '';
        this.spaces.after = this.spaces.after || '';
    }

    Node.prototype.remove = function remove() {
        if (this.parent) {
            this.parent.removeChild(this);
        }
        this.parent = undefined;
        return this;
    };

    Node.prototype.replaceWith = function replaceWith() {
        if (this.parent) {
            for (var index in arguments) {
                this.parent.insertBefore(this, arguments[index]);
            }
            this.remove();
        }
        return this;
    };

    Node.prototype.next = function next() {
        return this.parent.at(this.parent.index(this) + 1);
    };

    Node.prototype.prev = function prev() {
        return this.parent.at(this.parent.index(this) - 1);
    };

    Node.prototype.clone = function clone() {
        var overrides = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        var cloned = cloneNode(this);
        for (var name in overrides) {
            cloned[name] = overrides[name];
        }
        return cloned;
    };

    /**
     * Some non-standard syntax doesn't follow normal escaping rules for css.
     * This allows non standard syntax to be appended to an existing property
     * by specifying the escaped value. By specifying the escaped value,
     * illegal characters are allowed to be directly inserted into css output.
     * @param {string} name the property to set
     * @param {any} value the unescaped value of the property
     * @param {string} valueEscaped optional. the escaped value of the property.
     */


    Node.prototype.appendToPropertyAndEscape = function appendToPropertyAndEscape(name, value, valueEscaped) {
        if (!this.raws) {
            this.raws = {};
        }
        var originalValue = this[name];
        var originalEscaped = this.raws[name];
        this[name] = originalValue + value; // this may trigger a setter that updates raws, so it has to be set first.
        if (originalEscaped || valueEscaped !== value) {
            this.raws[name] = (originalEscaped || originalValue) + valueEscaped;
        } else {
            delete this.raws[name]; // delete any escaped value that was created by the setter.
        }
    };

    /**
     * Some non-standard syntax doesn't follow normal escaping rules for css.
     * This allows the escaped value to be specified directly, allowing illegal
     * characters to be directly inserted into css output.
     * @param {string} name the property to set
     * @param {any} value the unescaped value of the property
     * @param {string} valueEscaped the escaped value of the property.
     */


    Node.prototype.setPropertyAndEscape = function setPropertyAndEscape(name, value, valueEscaped) {
        if (!this.raws) {
            this.raws = {};
        }
        this[name] = value; // this may trigger a setter that updates raws, so it has to be set first.
        this.raws[name] = valueEscaped;
    };

    /**
     * When you want a value to passed through to CSS directly. This method
     * deletes the corresponding raw value causing the stringifier to fallback
     * to the unescaped value.
     * @param {string} name the property to set.
     * @param {any} value The value that is both escaped and unescaped.
     */


    Node.prototype.setPropertyWithoutEscape = function setPropertyWithoutEscape(name, value) {
        this[name] = value; // this may trigger a setter that updates raws, so it has to be set first.
        if (this.raws) {
            delete this.raws[name];
        }
    };

    /**
     * 
     * @param {number} line The number (starting with 1)
     * @param {number} column The column number (starting with 1)
     */


    Node.prototype.isAtPosition = function isAtPosition(line, column) {
        if (this.source && this.source.start && this.source.end) {
            if (this.source.start.line > line) {
                return false;
            }
            if (this.source.end.line < line) {
                return false;
            }
            if (this.source.start.line === line && this.source.start.column > column) {
                return false;
            }
            if (this.source.end.line === line && this.source.end.column < column) {
                return false;
            }
            return true;
        }
        return undefined;
    };

    Node.prototype.stringifyProperty = function stringifyProperty(name) {
        return this.raws && this.raws[name] || this[name];
    };

    Node.prototype.toString = function toString() {
        return [this.rawSpaceBefore, String(this.stringifyProperty("value")), this.rawSpaceAfter].join('');
    };

    _createClass(Node, [{
        key: 'rawSpaceBefore',
        get: function get() {
            var rawSpace = this.raws && this.raws.spaces && this.raws.spaces.before;
            if (rawSpace === undefined) {
                rawSpace = this.spaces && this.spaces.before;
            }
            return rawSpace || "";
        },
        set: function set(raw) {
            (0, _util.ensureObject)(this, "raws", "spaces");
            this.raws.spaces.before = raw;
        }
    }, {
        key: 'rawSpaceAfter',
        get: function get() {
            var rawSpace = this.raws && this.raws.spaces && this.raws.spaces.after;
            if (rawSpace === undefined) {
                rawSpace = this.spaces.after;
            }
            return rawSpace || "";
        },
        set: function set(raw) {
            (0, _util.ensureObject)(this, "raws", "spaces");
            this.raws.spaces.after = raw;
        }
    }]);

    return Node;
}();

exports.default = Node;
module.exports = exports['default'];
},{"../util":1051}],1039:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _container = require('./container');

var _container2 = _interopRequireDefault(_container);

var _types = require('./types');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Pseudo = function (_Container) {
    _inherits(Pseudo, _Container);

    function Pseudo(opts) {
        _classCallCheck(this, Pseudo);

        var _this = _possibleConstructorReturn(this, _Container.call(this, opts));

        _this.type = _types.PSEUDO;
        return _this;
    }

    Pseudo.prototype.toString = function toString() {
        var params = this.length ? '(' + this.map(String).join(',') + ')' : '';
        return [this.rawSpaceBefore, this.stringifyProperty("value"), params, this.rawSpaceAfter].join('');
    };

    return Pseudo;
}(_container2.default);

exports.default = Pseudo;
module.exports = exports['default'];
},{"./container":1032,"./types":1044}],1040:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _container = require('./container');

var _container2 = _interopRequireDefault(_container);

var _types = require('./types');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Root = function (_Container) {
    _inherits(Root, _Container);

    function Root(opts) {
        _classCallCheck(this, Root);

        var _this = _possibleConstructorReturn(this, _Container.call(this, opts));

        _this.type = _types.ROOT;
        return _this;
    }

    Root.prototype.toString = function toString() {
        var str = this.reduce(function (memo, selector) {
            memo.push(String(selector));
            return memo;
        }, []).join(',');
        return this.trailingComma ? str + ',' : str;
    };

    Root.prototype.error = function error(message, options) {
        if (this._error) {
            return this._error(message, options);
        } else {
            return new Error(message);
        }
    };

    _createClass(Root, [{
        key: 'errorGenerator',
        set: function set(handler) {
            this._error = handler;
        }
    }]);

    return Root;
}(_container2.default);

exports.default = Root;
module.exports = exports['default'];
},{"./container":1032,"./types":1044}],1041:[function(require,module,exports){
arguments[4][919][0].apply(exports,arguments)
},{"./container":1032,"./types":1044,"dup":919}],1042:[function(require,module,exports){
arguments[4][920][0].apply(exports,arguments)
},{"./node":1038,"./types":1044,"dup":920}],1043:[function(require,module,exports){
arguments[4][921][0].apply(exports,arguments)
},{"./namespace":1036,"./types":1044,"dup":921}],1044:[function(require,module,exports){
arguments[4][922][0].apply(exports,arguments)
},{"dup":922}],1045:[function(require,module,exports){
arguments[4][923][0].apply(exports,arguments)
},{"./namespace":1036,"./types":1044,"dup":923}],1046:[function(require,module,exports){
arguments[4][924][0].apply(exports,arguments)
},{"dup":924}],1047:[function(require,module,exports){
'use strict';

exports.__esModule = true;
var ampersand = exports.ampersand = 38;
var asterisk = exports.asterisk = 42;
var at = exports.at = 64;
var comma = exports.comma = 44;
var colon = exports.colon = 58;
var semicolon = exports.semicolon = 59;
var openParenthesis = exports.openParenthesis = 40;
var closeParenthesis = exports.closeParenthesis = 41;
var openSquare = exports.openSquare = 91;
var closeSquare = exports.closeSquare = 93;
var dollar = exports.dollar = 36;
var tilde = exports.tilde = 126;
var caret = exports.caret = 94;
var plus = exports.plus = 43;
var equals = exports.equals = 61;
var pipe = exports.pipe = 124;
var greaterThan = exports.greaterThan = 62;
var space = exports.space = 32;
var singleQuote = exports.singleQuote = 39;
var doubleQuote = exports.doubleQuote = 34;
var slash = exports.slash = 47;
var bang = exports.bang = 33;

var backslash = exports.backslash = 92;
var cr = exports.cr = 13;
var feed = exports.feed = 12;
var newline = exports.newline = 10;
var tab = exports.tab = 9;

// Expose aliases primarily for readability.
var str = exports.str = singleQuote;

// No good single character representation!
var comment = exports.comment = -1;
var word = exports.word = -2;
var combinator = exports.combinator = -3;
},{}],1048:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.FIELDS = undefined;

var _unescapable, _wordDelimiters;

exports.default = tokenize;

var _tokenTypes = require('./tokenTypes');

var t = _interopRequireWildcard(_tokenTypes);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var unescapable = (_unescapable = {}, _unescapable[t.tab] = true, _unescapable[t.newline] = true, _unescapable[t.cr] = true, _unescapable[t.feed] = true, _unescapable);
var wordDelimiters = (_wordDelimiters = {}, _wordDelimiters[t.space] = true, _wordDelimiters[t.tab] = true, _wordDelimiters[t.newline] = true, _wordDelimiters[t.cr] = true, _wordDelimiters[t.feed] = true, _wordDelimiters[t.ampersand] = true, _wordDelimiters[t.asterisk] = true, _wordDelimiters[t.bang] = true, _wordDelimiters[t.comma] = true, _wordDelimiters[t.colon] = true, _wordDelimiters[t.semicolon] = true, _wordDelimiters[t.openParenthesis] = true, _wordDelimiters[t.closeParenthesis] = true, _wordDelimiters[t.openSquare] = true, _wordDelimiters[t.closeSquare] = true, _wordDelimiters[t.singleQuote] = true, _wordDelimiters[t.doubleQuote] = true, _wordDelimiters[t.plus] = true, _wordDelimiters[t.pipe] = true, _wordDelimiters[t.tilde] = true, _wordDelimiters[t.greaterThan] = true, _wordDelimiters[t.equals] = true, _wordDelimiters[t.dollar] = true, _wordDelimiters[t.caret] = true, _wordDelimiters[t.slash] = true, _wordDelimiters);

var hex = {};
var hexChars = "0123456789abcdefABCDEF";
for (var i = 0; i < hexChars.length; i++) {
    hex[hexChars.charCodeAt(i)] = true;
}

/**
 *  Returns the last index of the bar css word
 * @param {string} css The string in which the word begins
 * @param {number} start The index into the string where word's first letter occurs
 */
function consumeWord(css, start) {
    var next = start;
    var code = void 0;
    do {
        code = css.charCodeAt(next);
        if (wordDelimiters[code]) {
            return next - 1;
        } else if (code === t.backslash) {
            next = consumeEscape(css, next) + 1;
        } else {
            // All other characters are part of the word
            next++;
        }
    } while (next < css.length);
    return next - 1;
}

/**
 *  Returns the last index of the escape sequence
 * @param {string} css The string in which the sequence begins
 * @param {number} start The index into the string where escape character (`\`) occurs.
 */
function consumeEscape(css, start) {
    var next = start;
    var code = css.charCodeAt(next + 1);
    if (unescapable[code]) {
        // just consume the escape char
    } else if (hex[code]) {
        var hexDigits = 0;
        // consume up to 6 hex chars
        do {
            next++;
            hexDigits++;
            code = css.charCodeAt(next + 1);
        } while (hex[code] && hexDigits < 6);
        // if fewer than 6 hex chars, a trailing space ends the escape
        if (hexDigits < 6 && code === t.space) {
            next++;
        }
    } else {
        // the next char is part of the current word
        next++;
    }
    return next;
}

var FIELDS = exports.FIELDS = {
    TYPE: 0,
    START_LINE: 1,
    START_COL: 2,
    END_LINE: 3,
    END_COL: 4,
    START_POS: 5,
    END_POS: 6
};

function tokenize(input) {
    var tokens = [];
    var css = input.css.valueOf();
    var _css = css,
        length = _css.length;

    var offset = -1;
    var line = 1;
    var start = 0;
    var end = 0;

    var code = void 0,
        content = void 0,
        endColumn = void 0,
        endLine = void 0,
        escaped = void 0,
        escapePos = void 0,
        last = void 0,
        lines = void 0,
        next = void 0,
        nextLine = void 0,
        nextOffset = void 0,
        quote = void 0,
        tokenType = void 0;

    function unclosed(what, fix) {
        if (input.safe) {
            // fyi: this is never set to true.
            css += fix;
            next = css.length - 1;
        } else {
            throw input.error('Unclosed ' + what, line, start - offset, start);
        }
    }

    while (start < length) {
        code = css.charCodeAt(start);

        if (code === t.newline) {
            offset = start;
            line += 1;
        }

        switch (code) {
            case t.space:
            case t.tab:
            case t.newline:
            case t.cr:
            case t.feed:
                next = start;
                do {
                    next += 1;
                    code = css.charCodeAt(next);
                    if (code === t.newline) {
                        offset = next;
                        line += 1;
                    }
                } while (code === t.space || code === t.newline || code === t.tab || code === t.cr || code === t.feed);

                tokenType = t.space;
                endLine = line;
                endColumn = next - offset - 1;
                end = next;
                break;

            case t.plus:
            case t.greaterThan:
            case t.tilde:
            case t.pipe:
                next = start;
                do {
                    next += 1;
                    code = css.charCodeAt(next);
                } while (code === t.plus || code === t.greaterThan || code === t.tilde || code === t.pipe);

                tokenType = t.combinator;
                endLine = line;
                endColumn = start - offset;
                end = next;
                break;

            // Consume these characters as single tokens.
            case t.asterisk:
            case t.ampersand:
            case t.bang:
            case t.comma:
            case t.equals:
            case t.dollar:
            case t.caret:
            case t.openSquare:
            case t.closeSquare:
            case t.colon:
            case t.semicolon:
            case t.openParenthesis:
            case t.closeParenthesis:
                next = start;
                tokenType = code;
                endLine = line;
                endColumn = start - offset;
                end = next + 1;
                break;

            case t.singleQuote:
            case t.doubleQuote:
                quote = code === t.singleQuote ? "'" : '"';
                next = start;
                do {
                    escaped = false;
                    next = css.indexOf(quote, next + 1);
                    if (next === -1) {
                        unclosed('quote', quote);
                    }
                    escapePos = next;
                    while (css.charCodeAt(escapePos - 1) === t.backslash) {
                        escapePos -= 1;
                        escaped = !escaped;
                    }
                } while (escaped);

                tokenType = t.str;
                endLine = line;
                endColumn = start - offset;
                end = next + 1;
                break;

            default:
                if (code === t.slash && css.charCodeAt(start + 1) === t.asterisk) {
                    next = css.indexOf('*/', start + 2) + 1;
                    if (next === 0) {
                        unclosed('comment', '*/');
                    }

                    content = css.slice(start, next + 1);
                    lines = content.split('\n');
                    last = lines.length - 1;

                    if (last > 0) {
                        nextLine = line + last;
                        nextOffset = next - lines[last].length;
                    } else {
                        nextLine = line;
                        nextOffset = offset;
                    }

                    tokenType = t.comment;
                    line = nextLine;
                    endLine = nextLine;
                    endColumn = next - nextOffset;
                } else if (code === t.slash) {
                    next = start;
                    tokenType = code;
                    endLine = line;
                    endColumn = start - offset;
                    end = next + 1;
                } else {
                    next = consumeWord(css, start);
                    tokenType = t.word;
                    endLine = line;
                    endColumn = next - offset;
                }

                end = next + 1;
                break;
        }

        // Ensure that the token structure remains consistent
        tokens.push([tokenType, // [0] Token type
        line, // [1] Starting line
        start - offset, // [2] Starting column
        endLine, // [3] Ending line
        endColumn, // [4] Ending column
        start, // [5] Start position / Source index
        end] // [6] End position
        );

        // Reset offset for the next token
        if (nextOffset) {
            offset = nextOffset;
            nextOffset = null;
        }

        start = end;
    }

    return tokens;
}
},{"./tokenTypes":1047}],1049:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports.default = ensureObject;
function ensureObject(obj) {
    for (var _len = arguments.length, props = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        props[_key - 1] = arguments[_key];
    }

    while (props.length > 0) {
        var prop = props.shift();

        if (!obj[prop]) {
            obj[prop] = {};
        }

        obj = obj[prop];
    }
}
module.exports = exports["default"];
},{}],1050:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports.default = getProp;
function getProp(obj) {
    for (var _len = arguments.length, props = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        props[_key - 1] = arguments[_key];
    }

    while (props.length > 0) {
        var prop = props.shift();

        if (!obj[prop]) {
            return undefined;
        }

        obj = obj[prop];
    }

    return obj;
}
module.exports = exports["default"];
},{}],1051:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _unesc = require('./unesc');

Object.defineProperty(exports, 'unesc', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_unesc).default;
  }
});

var _getProp = require('./getProp');

Object.defineProperty(exports, 'getProp', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_getProp).default;
  }
});

var _ensureObject = require('./ensureObject');

Object.defineProperty(exports, 'ensureObject', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_ensureObject).default;
  }
});

var _stripComments = require('./stripComments');

Object.defineProperty(exports, 'stripComments', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_stripComments).default;
  }
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./ensureObject":1049,"./getProp":1050,"./stripComments":1052,"./unesc":1053}],1052:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports.default = stripComments;
function stripComments(str) {
    var s = "";
    var commentStart = str.indexOf("/*");
    var lastEnd = 0;
    while (commentStart >= 0) {
        s = s + str.slice(lastEnd, commentStart);
        var commentEnd = str.indexOf("*/", commentStart + 2);
        if (commentEnd < 0) {
            return s;
        }
        lastEnd = commentEnd + 2;
        commentStart = str.indexOf("/*", lastEnd);
    }
    s = s + str.slice(lastEnd);
    return s;
}
module.exports = exports["default"];
},{}],1053:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports.default = unesc;
var HEX_ESC = /\\(?:([0-9a-fA-F]{6})|([0-9a-fA-F]{1,5})(?: |(?![0-9a-fA-F])))/g;
var OTHER_ESC = /\\(.)/g;
function unesc(str) {
    str = str.replace(HEX_ESC, function (_, hex1, hex2) {
        var hex = hex1 || hex2;
        var code = parseInt(hex, 16);
        return String.fromCharCode(code);
    });
    str = str.replace(OTHER_ESC, function (_, char) {
        return char;
    });
    return str;
}
module.exports = exports["default"];
},{}],1054:[function(require,module,exports){
(function (Buffer){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _postcss = require('postcss');

var _postcss2 = _interopRequireDefault(_postcss);

var _postcssValueParser = require('postcss-value-parser');

var _postcssValueParser2 = _interopRequireDefault(_postcssValueParser);

var _svgo = require('svgo');

var _svgo2 = _interopRequireDefault(_svgo);

var _isSvg = require('is-svg');

var _isSvg2 = _interopRequireDefault(_isSvg);

var _url = require('./lib/url');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const PLUGIN = 'postcss-svgo';
const dataURI = /data:image\/svg\+xml(;((charset=)?utf-8|base64))?,/i;
const dataURIBase64 = /data:image\/svg\+xml;base64,/i;

function minifyPromise(decl, getSvgo, opts) {
    const promises = [];
    const parsed = (0, _postcssValueParser2.default)(decl.value);

    decl.value = parsed.walk(node => {
        if (node.type !== 'function' || node.value.toLowerCase() !== 'url' || !node.nodes.length) {
            return;
        }

        let { value, quote } = node.nodes[0];
        let isBase64, isUriEncoded;
        let svg = value.replace(dataURI, '');

        if (dataURIBase64.test(value)) {
            svg = Buffer.from(svg, 'base64').toString('utf8');
            isBase64 = true;
        } else {
            let decodedUri;

            try {
                decodedUri = (0, _url.decode)(svg);
                isUriEncoded = decodedUri !== svg;
            } catch (e) {
                // Swallow exception if we cannot decode the value
                isUriEncoded = false;
            }

            if (isUriEncoded) {
                svg = decodedUri;
            }

            if (opts.encode !== undefined) {
                isUriEncoded = opts.encode;
            }
        }

        if (!(0, _isSvg2.default)(svg)) {
            return;
        }

        promises.push(getSvgo().optimize(svg).then(result => {
            let data, optimizedValue;

            if (isBase64) {
                data = Buffer.from(result.data).toString('base64');
                optimizedValue = 'data:image/svg+xml;base64,' + data;
            } else {
                data = isUriEncoded ? (0, _url.encode)(result.data) : result.data;
                // Should always encode # otherwise we yield a broken SVG
                // in Firefox (works in Chrome however). See this issue:
                // https://github.com/cssnano/cssnano/issues/245
                data = data.replace(/#/g, '%23');
                optimizedValue = 'data:image/svg+xml;charset=utf-8,' + data;
                quote = isUriEncoded ? '"' : '\'';
            }

            node.nodes[0] = Object.assign({}, node.nodes[0], {
                value: optimizedValue,
                quote: quote,
                type: 'string',
                before: '',
                after: ''
            });
        }).catch(error => {
            throw new Error(`${PLUGIN}: ${error}`);
        }));

        return false;
    });

    return Promise.all(promises).then(() => decl.value = decl.value.toString());
}

exports.default = _postcss2.default.plugin(PLUGIN, (opts = {}) => {
    let svgo = null;

    const getSvgo = () => {
        if (!svgo) {
            svgo = new _svgo2.default(opts);
        }

        return svgo;
    };

    return css => {
        return new Promise((resolve, reject) => {
            const svgoQueue = [];

            css.walkDecls(decl => {
                if (!dataURI.test(decl.value)) {
                    return;
                }

                svgoQueue.push(minifyPromise(decl, getSvgo, opts));
            });

            return Promise.all(svgoQueue).then(resolve, reject);
        });
    };
});
module.exports = exports['default'];
}).call(this,require("buffer").Buffer)
},{"./lib/url":1055,"buffer":13,"is-svg":749,"postcss":1074,"postcss-value-parser":1057,"svgo":1184}],1055:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.encode = encode;
function encode(data) {
    return data.replace(/"/g, '\'').replace(/%/g, '%25').replace(/</g, '%3C').replace(/>/g, '%3E').replace(/&/g, '%26').replace(/#/g, '%23').replace(/\s+/g, ' ');
};

const decode = exports.decode = decodeURIComponent;
},{}],1056:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _postcss = require('postcss');

var _alphanumSort = require('alphanum-sort');

var _alphanumSort2 = _interopRequireDefault(_alphanumSort);

var _uniqs = require('uniqs');

var _uniqs2 = _interopRequireDefault(_uniqs);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function unique(rule) {
    rule.selector = (0, _alphanumSort2.default)((0, _uniqs2.default)(rule.selectors), { insensitive: true }).join();
}

exports.default = (0, _postcss.plugin)('postcss-unique-selectors', () => {
    return css => css.walkRules(unique);
});
module.exports = exports['default'];
},{"alphanum-sort":4,"postcss":1074,"uniqs":1199}],1057:[function(require,module,exports){
var parse = require("./parse");
var walk = require("./walk");
var stringify = require("./stringify");

function ValueParser(value) {
  if (this instanceof ValueParser) {
    this.nodes = parse(value);
    return this;
  }
  return new ValueParser(value);
}

ValueParser.prototype.toString = function() {
  return Array.isArray(this.nodes) ? stringify(this.nodes) : "";
};

ValueParser.prototype.walk = function(cb, bubble) {
  walk(this.nodes, cb, bubble);
  return this;
};

ValueParser.unit = require("./unit");

ValueParser.walk = walk;

ValueParser.stringify = stringify;

module.exports = ValueParser;

},{"./parse":1058,"./stringify":1059,"./unit":1060,"./walk":1061}],1058:[function(require,module,exports){
var openParentheses = "(".charCodeAt(0);
var closeParentheses = ")".charCodeAt(0);
var singleQuote = "'".charCodeAt(0);
var doubleQuote = '"'.charCodeAt(0);
var backslash = "\\".charCodeAt(0);
var slash = "/".charCodeAt(0);
var comma = ",".charCodeAt(0);
var colon = ":".charCodeAt(0);
var star = "*".charCodeAt(0);

module.exports = function(input) {
  var tokens = [];
  var value = input;

  var next, quote, prev, token, escape, escapePos, whitespacePos;
  var pos = 0;
  var code = value.charCodeAt(pos);
  var max = value.length;
  var stack = [{ nodes: tokens }];
  var balanced = 0;
  var parent;

  var name = "";
  var before = "";
  var after = "";

  while (pos < max) {
    // Whitespaces
    if (code <= 32) {
      next = pos;
      do {
        next += 1;
        code = value.charCodeAt(next);
      } while (code <= 32);
      token = value.slice(pos, next);

      prev = tokens[tokens.length - 1];
      if (code === closeParentheses && balanced) {
        after = token;
      } else if (prev && prev.type === "div") {
        prev.after = token;
      } else if (
        code === comma ||
        code === colon ||
        (code === slash && value.charCodeAt(next + 1) !== star)
      ) {
        before = token;
      } else {
        tokens.push({
          type: "space",
          sourceIndex: pos,
          value: token
        });
      }

      pos = next;

      // Quotes
    } else if (code === singleQuote || code === doubleQuote) {
      next = pos;
      quote = code === singleQuote ? "'" : '"';
      token = {
        type: "string",
        sourceIndex: pos,
        quote: quote
      };
      do {
        escape = false;
        next = value.indexOf(quote, next + 1);
        if (~next) {
          escapePos = next;
          while (value.charCodeAt(escapePos - 1) === backslash) {
            escapePos -= 1;
            escape = !escape;
          }
        } else {
          value += quote;
          next = value.length - 1;
          token.unclosed = true;
        }
      } while (escape);
      token.value = value.slice(pos + 1, next);

      tokens.push(token);
      pos = next + 1;
      code = value.charCodeAt(pos);

      // Comments
    } else if (code === slash && value.charCodeAt(pos + 1) === star) {
      token = {
        type: "comment",
        sourceIndex: pos
      };

      next = value.indexOf("*/", pos);
      if (next === -1) {
        token.unclosed = true;
        next = value.length;
      }

      token.value = value.slice(pos + 2, next);
      tokens.push(token);

      pos = next + 2;
      code = value.charCodeAt(pos);

      // Dividers
    } else if (code === slash || code === comma || code === colon) {
      token = value[pos];

      tokens.push({
        type: "div",
        sourceIndex: pos - before.length,
        value: token,
        before: before,
        after: ""
      });
      before = "";

      pos += 1;
      code = value.charCodeAt(pos);

      // Open parentheses
    } else if (openParentheses === code) {
      // Whitespaces after open parentheses
      next = pos;
      do {
        next += 1;
        code = value.charCodeAt(next);
      } while (code <= 32);
      token = {
        type: "function",
        sourceIndex: pos - name.length,
        value: name,
        before: value.slice(pos + 1, next)
      };
      pos = next;

      if (name === "url" && code !== singleQuote && code !== doubleQuote) {
        next -= 1;
        do {
          escape = false;
          next = value.indexOf(")", next + 1);
          if (~next) {
            escapePos = next;
            while (value.charCodeAt(escapePos - 1) === backslash) {
              escapePos -= 1;
              escape = !escape;
            }
          } else {
            value += ")";
            next = value.length - 1;
            token.unclosed = true;
          }
        } while (escape);
        // Whitespaces before closed
        whitespacePos = next;
        do {
          whitespacePos -= 1;
          code = value.charCodeAt(whitespacePos);
        } while (code <= 32);
        if (pos !== whitespacePos + 1) {
          token.nodes = [
            {
              type: "word",
              sourceIndex: pos,
              value: value.slice(pos, whitespacePos + 1)
            }
          ];
        } else {
          token.nodes = [];
        }
        if (token.unclosed && whitespacePos + 1 !== next) {
          token.after = "";
          token.nodes.push({
            type: "space",
            sourceIndex: whitespacePos + 1,
            value: value.slice(whitespacePos + 1, next)
          });
        } else {
          token.after = value.slice(whitespacePos + 1, next);
        }
        pos = next + 1;
        code = value.charCodeAt(pos);
        tokens.push(token);
      } else {
        balanced += 1;
        token.after = "";
        tokens.push(token);
        stack.push(token);
        tokens = token.nodes = [];
        parent = token;
      }
      name = "";

      // Close parentheses
    } else if (closeParentheses === code && balanced) {
      pos += 1;
      code = value.charCodeAt(pos);

      parent.after = after;
      after = "";
      balanced -= 1;
      stack.pop();
      parent = stack[balanced];
      tokens = parent.nodes;

      // Words
    } else {
      next = pos;
      do {
        if (code === backslash) {
          next += 1;
        }
        next += 1;
        code = value.charCodeAt(next);
      } while (
        next < max &&
        !(
          code <= 32 ||
          code === singleQuote ||
          code === doubleQuote ||
          code === comma ||
          code === colon ||
          code === slash ||
          code === openParentheses ||
          (code === closeParentheses && balanced)
        )
      );
      token = value.slice(pos, next);

      if (openParentheses === code) {
        name = token;
      } else {
        tokens.push({
          type: "word",
          sourceIndex: pos,
          value: token
        });
      }

      pos = next;
    }
  }

  for (pos = stack.length - 1; pos; pos -= 1) {
    stack[pos].unclosed = true;
  }

  return stack[0].nodes;
};

},{}],1059:[function(require,module,exports){
function stringifyNode(node, custom) {
  var type = node.type;
  var value = node.value;
  var buf;
  var customResult;

  if (custom && (customResult = custom(node)) !== undefined) {
    return customResult;
  } else if (type === "word" || type === "space") {
    return value;
  } else if (type === "string") {
    buf = node.quote || "";
    return buf + value + (node.unclosed ? "" : buf);
  } else if (type === "comment") {
    return "/*" + value + (node.unclosed ? "" : "*/");
  } else if (type === "div") {
    return (node.before || "") + value + (node.after || "");
  } else if (Array.isArray(node.nodes)) {
    buf = stringify(node.nodes);
    if (type !== "function") {
      return buf;
    }
    return (
      value +
      "(" +
      (node.before || "") +
      buf +
      (node.after || "") +
      (node.unclosed ? "" : ")")
    );
  }
  return value;
}

function stringify(nodes, custom) {
  var result, i;

  if (Array.isArray(nodes)) {
    result = "";
    for (i = nodes.length - 1; ~i; i -= 1) {
      result = stringifyNode(nodes[i], custom) + result;
    }
    return result;
  }
  return stringifyNode(nodes, custom);
}

module.exports = stringify;

},{}],1060:[function(require,module,exports){
var minus = "-".charCodeAt(0);
var plus = "+".charCodeAt(0);
var dot = ".".charCodeAt(0);
var exp = "e".charCodeAt(0);
var EXP = "E".charCodeAt(0);

module.exports = function(value) {
  var pos = 0;
  var length = value.length;
  var dotted = false;
  var sciPos = -1;
  var containsNumber = false;
  var code;

  while (pos < length) {
    code = value.charCodeAt(pos);

    if (code >= 48 && code <= 57) {
      containsNumber = true;
    } else if (code === exp || code === EXP) {
      if (sciPos > -1) {
        break;
      }
      sciPos = pos;
    } else if (code === dot) {
      if (dotted) {
        break;
      }
      dotted = true;
    } else if (code === plus || code === minus) {
      if (pos !== 0) {
        break;
      }
    } else {
      break;
    }

    pos += 1;
  }

  if (sciPos + 1 === pos) pos--;

  return containsNumber
    ? {
        number: value.slice(0, pos),
        unit: value.slice(pos)
      }
    : false;
};

},{}],1061:[function(require,module,exports){
module.exports = function walk(nodes, cb, bubble) {
  var i, max, node, result;

  for (i = 0, max = nodes.length; i < max; i += 1) {
    node = nodes[i];
    if (!bubble) {
      result = cb(node, i, nodes);
    }

    if (
      result !== false &&
      node.type === "function" &&
      Array.isArray(node.nodes)
    ) {
      walk(node.nodes, cb, bubble);
    }

    if (bubble) {
      cb(node, i, nodes);
    }
  }
};

},{}],1062:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports.default = void 0;

var _container = _interopRequireDefault(require("./container"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

/**
 * Represents an at-rule.
 *
 * If its followed in the CSS by a {} block, this node will have
 * a nodes property representing its children.
 *
 * @extends Container
 *
 * @example
 * const root = postcss.parse('@charset "UTF-8"; @media print {}')
 *
 * const charset = root.first
 * charset.type  //=> 'atrule'
 * charset.nodes //=> undefined
 *
 * const media = root.last
 * media.nodes   //=> []
 */
var AtRule =
/*#__PURE__*/
function (_Container) {
  _inheritsLoose(AtRule, _Container);

  function AtRule(defaults) {
    var _this;

    _this = _Container.call(this, defaults) || this;
    _this.type = 'atrule';
    return _this;
  }

  var _proto = AtRule.prototype;

  _proto.append = function append() {
    var _Container$prototype$;

    if (!this.nodes) this.nodes = [];

    for (var _len = arguments.length, children = new Array(_len), _key = 0; _key < _len; _key++) {
      children[_key] = arguments[_key];
    }

    return (_Container$prototype$ = _Container.prototype.append).call.apply(_Container$prototype$, [this].concat(children));
  };

  _proto.prepend = function prepend() {
    var _Container$prototype$2;

    if (!this.nodes) this.nodes = [];

    for (var _len2 = arguments.length, children = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      children[_key2] = arguments[_key2];
    }

    return (_Container$prototype$2 = _Container.prototype.prepend).call.apply(_Container$prototype$2, [this].concat(children));
  }
  /**
   * @memberof AtRule#
   * @member {string} name The at-rules name immediately follows the `@`.
   *
   * @example
   * const root  = postcss.parse('@media print {}')
   * media.name //=> 'media'
   * const media = root.first
   */

  /**
   * @memberof AtRule#
   * @member {string} params The at-rules parameters, the values
   *                         that follow the at-rules name but precede
   *                         any {} block.
   *
   * @example
   * const root  = postcss.parse('@media print, screen {}')
   * const media = root.first
   * media.params //=> 'print, screen'
   */

  /**
   * @memberof AtRule#
   * @member {object} raws Information to generate byte-to-byte equal
   *                        node string as it was in the origin input.
   *
   * Every parser saves its own properties,
   * but the default CSS parser uses:
   *
   * * `before`: the space symbols before the node. It also stores `*`
   *   and `_` symbols before the declaration (IE hack).
   * * `after`: the space symbols after the last child of the node
   *   to the end of the node.
   * * `between`: the symbols between the property and value
   *   for declarations, selector and `{` for rules, or last parameter
   *   and `{` for at-rules.
   * * `semicolon`: contains true if the last child has
   *   an (optional) semicolon.
   * * `afterName`: the space between the at-rule name and its parameters.
   *
   * PostCSS cleans at-rule parameters from comments and extra spaces,
   * but it stores origin content in raws properties.
   * As such, if you dont change a declarations value,
   * PostCSS will use the raw value with comments.
   *
   * @example
   * const root = postcss.parse('  @media\nprint {\n}')
   * root.first.first.raws //=> { before: '  ',
   *                       //     between: ' ',
   *                       //     afterName: '\n',
   *                       //     after: '\n' }
   */
  ;

  return AtRule;
}(_container.default);

var _default = AtRule;
exports.default = _default;
module.exports = exports.default;


},{"./container":1064}],1063:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports.default = void 0;

var _node = _interopRequireDefault(require("./node"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

/**
 * Represents a comment between declarations or statements (rule and at-rules).
 *
 * Comments inside selectors, at-rule parameters, or declaration values
 * will be stored in the `raws` properties explained above.
 *
 * @extends Node
 */
var Comment =
/*#__PURE__*/
function (_Node) {
  _inheritsLoose(Comment, _Node);

  function Comment(defaults) {
    var _this;

    _this = _Node.call(this, defaults) || this;
    _this.type = 'comment';
    return _this;
  }
  /**
   * @memberof Comment#
   * @member {string} text The comments text.
   */

  /**
   * @memberof Comment#
   * @member {object} raws Information to generate byte-to-byte equal
   *                       node string as it was in the origin input.
   *
   * Every parser saves its own properties,
   * but the default CSS parser uses:
   *
   * * `before`: the space symbols before the node.
   * * `left`: the space symbols between `/*` and the comments text.
   * * `right`: the space symbols between the comments text.
   */


  return Comment;
}(_node.default);

var _default = Comment;
exports.default = _default;
module.exports = exports.default;


},{"./node":1071}],1064:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports.default = void 0;

var _declaration = _interopRequireDefault(require("./declaration"));

var _comment = _interopRequireDefault(require("./comment"));

var _node = _interopRequireDefault(require("./node"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

function cleanSource(nodes) {
  return nodes.map(function (i) {
    if (i.nodes) i.nodes = cleanSource(i.nodes);
    delete i.source;
    return i;
  });
}
/**
 * The {@link Root}, {@link AtRule}, and {@link Rule} container nodes
 * inherit some common methods to help work with their children.
 *
 * Note that all containers can store any content. If you write a rule inside
 * a rule, PostCSS will parse it.
 *
 * @extends Node
 * @abstract
 */


var Container =
/*#__PURE__*/
function (_Node) {
  _inheritsLoose(Container, _Node);

  function Container() {
    return _Node.apply(this, arguments) || this;
  }

  var _proto = Container.prototype;

  _proto.push = function push(child) {
    child.parent = this;
    this.nodes.push(child);
    return this;
  }
  /**
   * Iterates through the containers immediate children,
   * calling `callback` for each child.
   *
   * Returning `false` in the callback will break iteration.
   *
   * This method only iterates through the containers immediate children.
   * If you need to recursively iterate through all the containers descendant
   * nodes, use {@link Container#walk}.
   *
   * Unlike the for `{}`-cycle or `Array#forEach` this iterator is safe
   * if you are mutating the array of child nodes during iteration.
   * PostCSS will adjust the current index to match the mutations.
   *
   * @param {childIterator} callback Iterator receives each node and index.
   *
   * @return {false|undefined} Returns `false` if iteration was broke.
   *
   * @example
   * const root = postcss.parse('a { color: black; z-index: 1 }')
   * const rule = root.first
   *
   * for (const decl of rule.nodes) {
   *   decl.cloneBefore({ prop: '-webkit-' + decl.prop })
   *   // Cycle will be infinite, because cloneBefore moves the current node
   *   // to the next index
   * }
   *
   * rule.each(decl => {
   *   decl.cloneBefore({ prop: '-webkit-' + decl.prop })
   *   // Will be executed only for color and z-index
   * })
   */
  ;

  _proto.each = function each(callback) {
    if (!this.lastEach) this.lastEach = 0;
    if (!this.indexes) this.indexes = {};
    this.lastEach += 1;
    var id = this.lastEach;
    this.indexes[id] = 0;
    if (!this.nodes) return undefined;
    var index, result;

    while (this.indexes[id] < this.nodes.length) {
      index = this.indexes[id];
      result = callback(this.nodes[index], index);
      if (result === false) break;
      this.indexes[id] += 1;
    }

    delete this.indexes[id];
    return result;
  }
  /**
   * Traverses the containers descendant nodes, calling callback
   * for each node.
   *
   * Like container.each(), this method is safe to use
   * if you are mutating arrays during iteration.
   *
   * If you only need to iterate through the containers immediate children,
   * use {@link Container#each}.
   *
   * @param {childIterator} callback Iterator receives each node and index.
   *
   * @return {false|undefined} Returns `false` if iteration was broke.
   *
   * @example
   * root.walk(node => {
   *   // Traverses all descendant nodes.
   * })
   */
  ;

  _proto.walk = function walk(callback) {
    return this.each(function (child, i) {
      var result;

      try {
        result = callback(child, i);
      } catch (e) {
        e.postcssNode = child;

        if (e.stack && child.source && /\n\s{4}at /.test(e.stack)) {
          var s = child.source;
          e.stack = e.stack.replace(/\n\s{4}at /, "$&" + s.input.from + ":" + s.start.line + ":" + s.start.column + "$&");
        }

        throw e;
      }

      if (result !== false && child.walk) {
        result = child.walk(callback);
      }

      return result;
    });
  }
  /**
   * Traverses the containers descendant nodes, calling callback
   * for each declaration node.
   *
   * If you pass a filter, iteration will only happen over declarations
   * with matching properties.
   *
   * Like {@link Container#each}, this method is safe
   * to use if you are mutating arrays during iteration.
   *
   * @param {string|RegExp} [prop]   String or regular expression
   *                                 to filter declarations by property name.
   * @param {childIterator} callback Iterator receives each node and index.
   *
   * @return {false|undefined} Returns `false` if iteration was broke.
   *
   * @example
   * root.walkDecls(decl => {
   *   checkPropertySupport(decl.prop)
   * })
   *
   * root.walkDecls('border-radius', decl => {
   *   decl.remove()
   * })
   *
   * root.walkDecls(/^background/, decl => {
   *   decl.value = takeFirstColorFromGradient(decl.value)
   * })
   */
  ;

  _proto.walkDecls = function walkDecls(prop, callback) {
    if (!callback) {
      callback = prop;
      return this.walk(function (child, i) {
        if (child.type === 'decl') {
          return callback(child, i);
        }
      });
    }

    if (prop instanceof RegExp) {
      return this.walk(function (child, i) {
        if (child.type === 'decl' && prop.test(child.prop)) {
          return callback(child, i);
        }
      });
    }

    return this.walk(function (child, i) {
      if (child.type === 'decl' && child.prop === prop) {
        return callback(child, i);
      }
    });
  }
  /**
   * Traverses the containers descendant nodes, calling callback
   * for each rule node.
   *
   * If you pass a filter, iteration will only happen over rules
   * with matching selectors.
   *
   * Like {@link Container#each}, this method is safe
   * to use if you are mutating arrays during iteration.
   *
   * @param {string|RegExp} [selector] String or regular expression
   *                                   to filter rules by selector.
   * @param {childIterator} callback   Iterator receives each node and index.
   *
   * @return {false|undefined} returns `false` if iteration was broke.
   *
   * @example
   * const selectors = []
   * root.walkRules(rule => {
   *   selectors.push(rule.selector)
   * })
   * console.log(`Your CSS uses ${ selectors.length } selectors`)
   */
  ;

  _proto.walkRules = function walkRules(selector, callback) {
    if (!callback) {
      callback = selector;
      return this.walk(function (child, i) {
        if (child.type === 'rule') {
          return callback(child, i);
        }
      });
    }

    if (selector instanceof RegExp) {
      return this.walk(function (child, i) {
        if (child.type === 'rule' && selector.test(child.selector)) {
          return callback(child, i);
        }
      });
    }

    return this.walk(function (child, i) {
      if (child.type === 'rule' && child.selector === selector) {
        return callback(child, i);
      }
    });
  }
  /**
   * Traverses the containers descendant nodes, calling callback
   * for each at-rule node.
   *
   * If you pass a filter, iteration will only happen over at-rules
   * that have matching names.
   *
   * Like {@link Container#each}, this method is safe
   * to use if you are mutating arrays during iteration.
   *
   * @param {string|RegExp} [name]   String or regular expression
   *                                 to filter at-rules by name.
   * @param {childIterator} callback Iterator receives each node and index.
   *
   * @return {false|undefined} Returns `false` if iteration was broke.
   *
   * @example
   * root.walkAtRules(rule => {
   *   if (isOld(rule.name)) rule.remove()
   * })
   *
   * let first = false
   * root.walkAtRules('charset', rule => {
   *   if (!first) {
   *     first = true
   *   } else {
   *     rule.remove()
   *   }
   * })
   */
  ;

  _proto.walkAtRules = function walkAtRules(name, callback) {
    if (!callback) {
      callback = name;
      return this.walk(function (child, i) {
        if (child.type === 'atrule') {
          return callback(child, i);
        }
      });
    }

    if (name instanceof RegExp) {
      return this.walk(function (child, i) {
        if (child.type === 'atrule' && name.test(child.name)) {
          return callback(child, i);
        }
      });
    }

    return this.walk(function (child, i) {
      if (child.type === 'atrule' && child.name === name) {
        return callback(child, i);
      }
    });
  }
  /**
   * Traverses the containers descendant nodes, calling callback
   * for each comment node.
   *
   * Like {@link Container#each}, this method is safe
   * to use if you are mutating arrays during iteration.
   *
   * @param {childIterator} callback Iterator receives each node and index.
   *
   * @return {false|undefined} Returns `false` if iteration was broke.
   *
   * @example
   * root.walkComments(comment => {
   *   comment.remove()
   * })
   */
  ;

  _proto.walkComments = function walkComments(callback) {
    return this.walk(function (child, i) {
      if (child.type === 'comment') {
        return callback(child, i);
      }
    });
  }
  /**
   * Inserts new nodes to the end of the container.
   *
   * @param {...(Node|object|string|Node[])} children New nodes.
   *
   * @return {Node} This node for methods chain.
   *
   * @example
   * const decl1 = postcss.decl({ prop: 'color', value: 'black' })
   * const decl2 = postcss.decl({ prop: 'background-color', value: 'white' })
   * rule.append(decl1, decl2)
   *
   * root.append({ name: 'charset', params: '"UTF-8"' })  // at-rule
   * root.append({ selector: 'a' })                       // rule
   * rule.append({ prop: 'color', value: 'black' })       // declaration
   * rule.append({ text: 'Comment' })                     // comment
   *
   * root.append('a {}')
   * root.first.append('color: black; z-index: 1')
   */
  ;

  _proto.append = function append() {
    for (var _len = arguments.length, children = new Array(_len), _key = 0; _key < _len; _key++) {
      children[_key] = arguments[_key];
    }

    for (var _i = 0; _i < children.length; _i++) {
      var child = children[_i];
      var nodes = this.normalize(child, this.last);

      for (var _iterator = nodes, _isArray = Array.isArray(_iterator), _i2 = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
        var _ref;

        if (_isArray) {
          if (_i2 >= _iterator.length) break;
          _ref = _iterator[_i2++];
        } else {
          _i2 = _iterator.next();
          if (_i2.done) break;
          _ref = _i2.value;
        }

        var node = _ref;
        this.nodes.push(node);
      }
    }

    return this;
  }
  /**
   * Inserts new nodes to the start of the container.
   *
   * @param {...(Node|object|string|Node[])} children New nodes.
   *
   * @return {Node} This node for methods chain.
   *
   * @example
   * const decl1 = postcss.decl({ prop: 'color', value: 'black' })
   * const decl2 = postcss.decl({ prop: 'background-color', value: 'white' })
   * rule.prepend(decl1, decl2)
   *
   * root.append({ name: 'charset', params: '"UTF-8"' })  // at-rule
   * root.append({ selector: 'a' })                       // rule
   * rule.append({ prop: 'color', value: 'black' })       // declaration
   * rule.append({ text: 'Comment' })                     // comment
   *
   * root.append('a {}')
   * root.first.append('color: black; z-index: 1')
   */
  ;

  _proto.prepend = function prepend() {
    for (var _len2 = arguments.length, children = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      children[_key2] = arguments[_key2];
    }

    children = children.reverse();

    for (var _iterator2 = children, _isArray2 = Array.isArray(_iterator2), _i3 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
      var _ref2;

      if (_isArray2) {
        if (_i3 >= _iterator2.length) break;
        _ref2 = _iterator2[_i3++];
      } else {
        _i3 = _iterator2.next();
        if (_i3.done) break;
        _ref2 = _i3.value;
      }

      var child = _ref2;
      var nodes = this.normalize(child, this.first, 'prepend').reverse();

      for (var _iterator3 = nodes, _isArray3 = Array.isArray(_iterator3), _i4 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {
        var _ref3;

        if (_isArray3) {
          if (_i4 >= _iterator3.length) break;
          _ref3 = _iterator3[_i4++];
        } else {
          _i4 = _iterator3.next();
          if (_i4.done) break;
          _ref3 = _i4.value;
        }

        var node = _ref3;
        this.nodes.unshift(node);
      }

      for (var id in this.indexes) {
        this.indexes[id] = this.indexes[id] + nodes.length;
      }
    }

    return this;
  };

  _proto.cleanRaws = function cleanRaws(keepBetween) {
    _Node.prototype.cleanRaws.call(this, keepBetween);

    if (this.nodes) {
      for (var _iterator4 = this.nodes, _isArray4 = Array.isArray(_iterator4), _i5 = 0, _iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator]();;) {
        var _ref4;

        if (_isArray4) {
          if (_i5 >= _iterator4.length) break;
          _ref4 = _iterator4[_i5++];
        } else {
          _i5 = _iterator4.next();
          if (_i5.done) break;
          _ref4 = _i5.value;
        }

        var node = _ref4;
        node.cleanRaws(keepBetween);
      }
    }
  }
  /**
   * Insert new node before old node within the container.
   *
   * @param {Node|number} exist             Child or childs index.
   * @param {Node|object|string|Node[]} add New node.
   *
   * @return {Node} This node for methods chain.
   *
   * @example
   * rule.insertBefore(decl, decl.clone({ prop: '-webkit-' + decl.prop }))
   */
  ;

  _proto.insertBefore = function insertBefore(exist, add) {
    exist = this.index(exist);
    var type = exist === 0 ? 'prepend' : false;
    var nodes = this.normalize(add, this.nodes[exist], type).reverse();

    for (var _iterator5 = nodes, _isArray5 = Array.isArray(_iterator5), _i6 = 0, _iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator]();;) {
      var _ref5;

      if (_isArray5) {
        if (_i6 >= _iterator5.length) break;
        _ref5 = _iterator5[_i6++];
      } else {
        _i6 = _iterator5.next();
        if (_i6.done) break;
        _ref5 = _i6.value;
      }

      var node = _ref5;
      this.nodes.splice(exist, 0, node);
    }

    var index;

    for (var id in this.indexes) {
      index = this.indexes[id];

      if (exist <= index) {
        this.indexes[id] = index + nodes.length;
      }
    }

    return this;
  }
  /**
   * Insert new node after old node within the container.
   *
   * @param {Node|number} exist             Child or childs index.
   * @param {Node|object|string|Node[]} add New node.
   *
   * @return {Node} This node for methods chain.
   */
  ;

  _proto.insertAfter = function insertAfter(exist, add) {
    exist = this.index(exist);
    var nodes = this.normalize(add, this.nodes[exist]).reverse();

    for (var _iterator6 = nodes, _isArray6 = Array.isArray(_iterator6), _i7 = 0, _iterator6 = _isArray6 ? _iterator6 : _iterator6[Symbol.iterator]();;) {
      var _ref6;

      if (_isArray6) {
        if (_i7 >= _iterator6.length) break;
        _ref6 = _iterator6[_i7++];
      } else {
        _i7 = _iterator6.next();
        if (_i7.done) break;
        _ref6 = _i7.value;
      }

      var node = _ref6;
      this.nodes.splice(exist + 1, 0, node);
    }

    var index;

    for (var id in this.indexes) {
      index = this.indexes[id];

      if (exist < index) {
        this.indexes[id] = index + nodes.length;
      }
    }

    return this;
  }
  /**
   * Removes node from the container and cleans the parent properties
   * from the node and its children.
   *
   * @param {Node|number} child Child or childs index.
   *
   * @return {Node} This node for methods chain
   *
   * @example
   * rule.nodes.length  //=> 5
   * rule.removeChild(decl)
   * rule.nodes.length  //=> 4
   * decl.parent        //=> undefined
   */
  ;

  _proto.removeChild = function removeChild(child) {
    child = this.index(child);
    this.nodes[child].parent = undefined;
    this.nodes.splice(child, 1);
    var index;

    for (var id in this.indexes) {
      index = this.indexes[id];

      if (index >= child) {
        this.indexes[id] = index - 1;
      }
    }

    return this;
  }
  /**
   * Removes all children from the container
   * and cleans their parent properties.
   *
   * @return {Node} This node for methods chain.
   *
   * @example
   * rule.removeAll()
   * rule.nodes.length //=> 0
   */
  ;

  _proto.removeAll = function removeAll() {
    for (var _iterator7 = this.nodes, _isArray7 = Array.isArray(_iterator7), _i8 = 0, _iterator7 = _isArray7 ? _iterator7 : _iterator7[Symbol.iterator]();;) {
      var _ref7;

      if (_isArray7) {
        if (_i8 >= _iterator7.length) break;
        _ref7 = _iterator7[_i8++];
      } else {
        _i8 = _iterator7.next();
        if (_i8.done) break;
        _ref7 = _i8.value;
      }

      var node = _ref7;
      node.parent = undefined;
    }

    this.nodes = [];
    return this;
  }
  /**
   * Passes all declaration values within the container that match pattern
   * through callback, replacing those values with the returned result
   * of callback.
   *
   * This method is useful if you are using a custom unit or function
   * and need to iterate through all values.
   *
   * @param {string|RegExp} pattern      Replace pattern.
   * @param {object} opts                Options to speed up the search.
   * @param {string|string[]} opts.props An array of property names.
   * @param {string} opts.fast           String thats used to narrow down
   *                                     values and speed up the regexp search.
   * @param {function|string} callback   String to replace pattern or callback
   *                                     that returns a new value. The callback
   *                                     will receive the same arguments
   *                                     as those passed to a function parameter
   *                                     of `String#replace`.
   *
   * @return {Node} This node for methods chain.
   *
   * @example
   * root.replaceValues(/\d+rem/, { fast: 'rem' }, string => {
   *   return 15 * parseInt(string) + 'px'
   * })
   */
  ;

  _proto.replaceValues = function replaceValues(pattern, opts, callback) {
    if (!callback) {
      callback = opts;
      opts = {};
    }

    this.walkDecls(function (decl) {
      if (opts.props && opts.props.indexOf(decl.prop) === -1) return;
      if (opts.fast && decl.value.indexOf(opts.fast) === -1) return;
      decl.value = decl.value.replace(pattern, callback);
    });
    return this;
  }
  /**
   * Returns `true` if callback returns `true`
   * for all of the containers children.
   *
   * @param {childCondition} condition Iterator returns true or false.
   *
   * @return {boolean} Is every child pass condition.
   *
   * @example
   * const noPrefixes = rule.every(i => i.prop[0] !== '-')
   */
  ;

  _proto.every = function every(condition) {
    return this.nodes.every(condition);
  }
  /**
   * Returns `true` if callback returns `true` for (at least) one
   * of the containers children.
   *
   * @param {childCondition} condition Iterator returns true or false.
   *
   * @return {boolean} Is some child pass condition.
   *
   * @example
   * const hasPrefix = rule.some(i => i.prop[0] === '-')
   */
  ;

  _proto.some = function some(condition) {
    return this.nodes.some(condition);
  }
  /**
   * Returns a `child`s index within the {@link Container#nodes} array.
   *
   * @param {Node} child Child of the current container.
   *
   * @return {number} Child index.
   *
   * @example
   * rule.index( rule.nodes[2] ) //=> 2
   */
  ;

  _proto.index = function index(child) {
    if (typeof child === 'number') {
      return child;
    }

    return this.nodes.indexOf(child);
  }
  /**
   * The containers first child.
   *
   * @type {Node}
   *
   * @example
   * rule.first === rules.nodes[0]
   */
  ;

  _proto.normalize = function normalize(nodes, sample) {
    var _this = this;

    if (typeof nodes === 'string') {
      var parse = require('./parse');

      nodes = cleanSource(parse(nodes).nodes);
    } else if (Array.isArray(nodes)) {
      nodes = nodes.slice(0);

      for (var _iterator8 = nodes, _isArray8 = Array.isArray(_iterator8), _i9 = 0, _iterator8 = _isArray8 ? _iterator8 : _iterator8[Symbol.iterator]();;) {
        var _ref8;

        if (_isArray8) {
          if (_i9 >= _iterator8.length) break;
          _ref8 = _iterator8[_i9++];
        } else {
          _i9 = _iterator8.next();
          if (_i9.done) break;
          _ref8 = _i9.value;
        }

        var i = _ref8;
        if (i.parent) i.parent.removeChild(i, 'ignore');
      }
    } else if (nodes.type === 'root') {
      nodes = nodes.nodes.slice(0);

      for (var _iterator9 = nodes, _isArray9 = Array.isArray(_iterator9), _i10 = 0, _iterator9 = _isArray9 ? _iterator9 : _iterator9[Symbol.iterator]();;) {
        var _ref9;

        if (_isArray9) {
          if (_i10 >= _iterator9.length) break;
          _ref9 = _iterator9[_i10++];
        } else {
          _i10 = _iterator9.next();
          if (_i10.done) break;
          _ref9 = _i10.value;
        }

        var _i11 = _ref9;
        if (_i11.parent) _i11.parent.removeChild(_i11, 'ignore');
      }
    } else if (nodes.type) {
      nodes = [nodes];
    } else if (nodes.prop) {
      if (typeof nodes.value === 'undefined') {
        throw new Error('Value field is missed in node creation');
      } else if (typeof nodes.value !== 'string') {
        nodes.value = String(nodes.value);
      }

      nodes = [new _declaration.default(nodes)];
    } else if (nodes.selector) {
      var Rule = require('./rule');

      nodes = [new Rule(nodes)];
    } else if (nodes.name) {
      var AtRule = require('./at-rule');

      nodes = [new AtRule(nodes)];
    } else if (nodes.text) {
      nodes = [new _comment.default(nodes)];
    } else {
      throw new Error('Unknown node type in node creation');
    }

    var processed = nodes.map(function (i) {
      if (i.parent) i.parent.removeChild(i);

      if (typeof i.raws.before === 'undefined') {
        if (sample && typeof sample.raws.before !== 'undefined') {
          i.raws.before = sample.raws.before.replace(/[^\s]/g, '');
        }
      }

      i.parent = _this;
      return i;
    });
    return processed;
  }
  /**
   * @memberof Container#
   * @member {Node[]} nodes An array containing the containers children.
   *
   * @example
   * const root = postcss.parse('a { color: black }')
   * root.nodes.length           //=> 1
   * root.nodes[0].selector      //=> 'a'
   * root.nodes[0].nodes[0].prop //=> 'color'
   */
  ;

  _createClass(Container, [{
    key: "first",
    get: function get() {
      if (!this.nodes) return undefined;
      return this.nodes[0];
    }
    /**
     * The containers last child.
     *
     * @type {Node}
     *
     * @example
     * rule.last === rule.nodes[rule.nodes.length - 1]
     */

  }, {
    key: "last",
    get: function get() {
      if (!this.nodes) return undefined;
      return this.nodes[this.nodes.length - 1];
    }
  }]);

  return Container;
}(_node.default);

var _default = Container;
/**
 * @callback childCondition
 * @param {Node} node    Container child.
 * @param {number} index Child index.
 * @param {Node[]} nodes All container children.
 * @return {boolean}
 */

/**
 * @callback childIterator
 * @param {Node} node    Container child.
 * @param {number} index Child index.
 * @return {false|undefined} Returning `false` will break iteration.
 */

exports.default = _default;
module.exports = exports.default;


},{"./at-rule":1062,"./comment":1063,"./declaration":1066,"./node":1071,"./parse":1072,"./rule":1079}],1065:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports.default = void 0;

var _supportsColor = _interopRequireDefault(require("supports-color"));

var _chalk = _interopRequireDefault(require("chalk"));

var _terminalHighlight = _interopRequireDefault(require("./terminal-highlight"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * The CSS parser throws this error for broken CSS.
 *
 * Custom parsers can throw this error for broken custom syntax using
 * the {@link Node#error} method.
 *
 * PostCSS will use the input source map to detect the original error location.
 * If you wrote a Sass file, compiled it to CSS and then parsed it with PostCSS,
 * PostCSS will show the original position in the Sass file.
 *
 * If you need the position in the PostCSS input
 * (e.g., to debug the previous compiler), use `error.input.file`.
 *
 * @example
 * // Catching and checking syntax error
 * try {
 *   postcss.parse('a{')
 * } catch (error) {
 *   if (error.name === 'CssSyntaxError') {
 *     error //=> CssSyntaxError
 *   }
 * }
 *
 * @example
 * // Raising error from plugin
 * throw node.error('Unknown variable', { plugin: 'postcss-vars' })
 */
var CssSyntaxError =
/*#__PURE__*/
function (_Error) {
  _inheritsLoose(CssSyntaxError, _Error);

  /**
   * @param {string} message  Error message.
   * @param {number} [line]   Source line of the error.
   * @param {number} [column] Source column of the error.
   * @param {string} [source] Source code of the broken file.
   * @param {string} [file]   Absolute path to the broken file.
   * @param {string} [plugin] PostCSS plugin name, if error came from plugin.
   */
  function CssSyntaxError(message, line, column, source, file, plugin) {
    var _this;

    _this = _Error.call(this, message) || this;
    /**
     * Always equal to `'CssSyntaxError'`. You should always check error type
     * by `error.name === 'CssSyntaxError'`
     * instead of `error instanceof CssSyntaxError`,
     * because npm could have several PostCSS versions.
     *
     * @type {string}
     *
     * @example
     * if (error.name === 'CssSyntaxError') {
     *   error //=> CssSyntaxError
     * }
     */

    _this.name = 'CssSyntaxError';
    /**
     * Error message.
     *
     * @type {string}
     *
     * @example
     * error.message //=> 'Unclosed block'
     */

    _this.reason = message;

    if (file) {
      /**
       * Absolute path to the broken file.
       *
       * @type {string}
       *
       * @example
       * error.file       //=> 'a.sass'
       * error.input.file //=> 'a.css'
       */
      _this.file = file;
    }

    if (source) {
      /**
       * Source code of the broken file.
       *
       * @type {string}
       *
       * @example
       * error.source       //=> 'a { b {} }'
       * error.input.column //=> 'a b { }'
       */
      _this.source = source;
    }

    if (plugin) {
      /**
       * Plugin name, if error came from plugin.
       *
       * @type {string}
       *
       * @example
       * error.plugin //=> 'postcss-vars'
       */
      _this.plugin = plugin;
    }

    if (typeof line !== 'undefined' && typeof column !== 'undefined') {
      /**
       * Source line of the error.
       *
       * @type {number}
       *
       * @example
       * error.line       //=> 2
       * error.input.line //=> 4
       */
      _this.line = line;
      /**
       * Source column of the error.
       *
       * @type {number}
       *
       * @example
       * error.column       //=> 1
       * error.input.column //=> 4
       */

      _this.column = column;
    }

    _this.setMessage();

    if (Error.captureStackTrace) {
      Error.captureStackTrace(_assertThisInitialized(_assertThisInitialized(_this)), CssSyntaxError);
    }

    return _this;
  }

  var _proto = CssSyntaxError.prototype;

  _proto.setMessage = function setMessage() {
    /**
     * Full error text in the GNU error format
     * with plugin, file, line and column.
     *
     * @type {string}
     *
     * @example
     * error.message //=> 'a.css:1:1: Unclosed block'
     */
    this.message = this.plugin ? this.plugin + ': ' : '';
    this.message += this.file ? this.file : '<css input>';

    if (typeof this.line !== 'undefined') {
      this.message += ':' + this.line + ':' + this.column;
    }

    this.message += ': ' + this.reason;
  }
  /**
   * Returns a few lines of CSS source that caused the error.
   *
   * If the CSS has an input source map without `sourceContent`,
   * this method will return an empty string.
   *
   * @param {boolean} [color] Whether arrow will be colored red by terminal
   *                          color codes. By default, PostCSS will detect
   *                          color support by `process.stdout.isTTY`
   *                          and `process.env.NODE_DISABLE_COLORS`.
   *
   * @example
   * error.showSourceCode() //=> "  4 | }
   *                        //      5 | a {
   *                        //    > 6 |   bad
   *                        //        |   ^
   *                        //      7 | }
   *                        //      8 | b {"
   *
   * @return {string} Few lines of CSS source that caused the error.
   */
  ;

  _proto.showSourceCode = function showSourceCode(color) {
    var _this2 = this;

    if (!this.source) return '';
    var css = this.source;

    if (_terminalHighlight.default) {
      if (typeof color === 'undefined') color = _supportsColor.default.stdout;
      if (color) css = (0, _terminalHighlight.default)(css);
    }

    var lines = css.split(/\r?\n/);
    var start = Math.max(this.line - 3, 0);
    var end = Math.min(this.line + 2, lines.length);
    var maxWidth = String(end).length;

    function mark(text) {
      if (color && _chalk.default.red) {
        return _chalk.default.red.bold(text);
      }

      return text;
    }

    function aside(text) {
      if (color && _chalk.default.gray) {
        return _chalk.default.gray(text);
      }

      return text;
    }

    return lines.slice(start, end).map(function (line, index) {
      var number = start + 1 + index;
      var gutter = ' ' + (' ' + number).slice(-maxWidth) + ' | ';

      if (number === _this2.line) {
        var spacing = aside(gutter.replace(/\d/g, ' ')) + line.slice(0, _this2.column - 1).replace(/[^\t]/g, ' ');
        return mark('>') + aside(gutter) + line + '\n ' + spacing + mark('^');
      }

      return ' ' + aside(gutter) + line;
    }).join('\n');
  }
  /**
   * Returns error position, message and source code of the broken part.
   *
   * @example
   * error.toString() //=> "CssSyntaxError: app.css:1:1: Unclosed block
   *                  //    > 1 | a {
   *                  //        | ^"
   *
   * @return {string} Error position, message and source code.
   */
  ;

  _proto.toString = function toString() {
    var code = this.showSourceCode();

    if (code) {
      code = '\n\n' + code + '\n';
    }

    return this.name + ': ' + this.message + code;
  }
  /**
   * @memberof CssSyntaxError#
   * @member {Input} input Input object with PostCSS internal information
   *                       about input file. If input has source map
   *                       from previous tool, PostCSS will use origin
   *                       (for example, Sass) source. You can use this
   *                       object to get PostCSS input source.
   *
   * @example
   * error.input.file //=> 'a.css'
   * error.file       //=> 'a.sass'
   */
  ;

  return CssSyntaxError;
}(_wrapNativeSuper(Error));

var _default = CssSyntaxError;
exports.default = _default;
module.exports = exports.default;


},{"./terminal-highlight":7,"chalk":7,"supports-color":7}],1066:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports.default = void 0;

var _node = _interopRequireDefault(require("./node"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

/**
 * Represents a CSS declaration.
 *
 * @extends Node
 *
 * @example
 * const root = postcss.parse('a { color: black }')
 * const decl = root.first.first
 * decl.type       //=> 'decl'
 * decl.toString() //=> ' color: black'
 */
var Declaration =
/*#__PURE__*/
function (_Node) {
  _inheritsLoose(Declaration, _Node);

  function Declaration(defaults) {
    var _this;

    _this = _Node.call(this, defaults) || this;
    _this.type = 'decl';
    return _this;
  }
  /**
   * @memberof Declaration#
   * @member {string} prop The declarations property name.
   *
   * @example
   * const root = postcss.parse('a { color: black }')
   * const decl = root.first.first
   * decl.prop //=> 'color'
   */

  /**
   * @memberof Declaration#
   * @member {string} value The declarations value.
   *
   * @example
   * const root = postcss.parse('a { color: black }')
   * const decl = root.first.first
   * decl.value //=> 'black'
   */

  /**
   * @memberof Declaration#
   * @member {boolean} important `true` if the declaration
   *                             has an !important annotation.
   *
   * @example
   * const root = postcss.parse('a { color: black !important; color: red }')
   * root.first.first.important //=> true
   * root.first.last.important  //=> undefined
   */

  /**
   * @memberof Declaration#
   * @member {object} raws Information to generate byte-to-byte equal
   *                       node string as it was in the origin input.
   *
   * Every parser saves its own properties,
   * but the default CSS parser uses:
   *
   * * `before`: the space symbols before the node. It also stores `*`
   *   and `_` symbols before the declaration (IE hack).
   * * `between`: the symbols between the property and value
   *   for declarations.
   * * `important`: the content of the important statement,
   *   if it is not just `!important`.
   *
   * PostCSS cleans declaration from comments and extra spaces,
   * but it stores origin content in raws properties.
   * As such, if you dont change a declarations value,
   * PostCSS will use the raw value with comments.
   *
   * @example
   * const root = postcss.parse('a {\n  color:black\n}')
   * root.first.first.raws //=> { before: '\n  ', between: ':' }
   */


  return Declaration;
}(_node.default);

var _default = Declaration;
exports.default = _default;
module.exports = exports.default;


},{"./node":1071}],1067:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports.default = void 0;

var _cssSyntaxError = _interopRequireDefault(require("./css-syntax-error"));

var _previousMap = _interopRequireDefault(require("./previous-map"));

var _path = _interopRequireDefault(require("path"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var sequence = 0;
/**
 * Represents the source CSS.
 *
 * @example
 * const root  = postcss.parse(css, { from: file })
 * const input = root.source.input
 */

var Input =
/*#__PURE__*/
function () {
  /**
   * @param {string} css    Input CSS source.
   * @param {object} [opts] {@link Processor#process} options.
   */
  function Input(css, opts) {
    if (opts === void 0) {
      opts = {};
    }

    if (css === null || typeof css === 'object' && !css.toString) {
      throw new Error("PostCSS received " + css + " instead of CSS string");
    }
    /**
     * Input CSS source
     *
     * @type {string}
     *
     * @example
     * const input = postcss.parse('a{}', { from: file }).input
     * input.css //=> "a{}"
     */


    this.css = css.toString();

    if (this.css[0] === "\uFEFF" || this.css[0] === "\uFFFE") {
      this.hasBOM = true;
      this.css = this.css.slice(1);
    } else {
      this.hasBOM = false;
    }

    if (opts.from) {
      if (/^\w+:\/\//.test(opts.from)) {
        /**
         * The absolute path to the CSS source file defined
         * with the `from` option.
         *
         * @type {string}
         *
         * @example
         * const root = postcss.parse(css, { from: 'a.css' })
         * root.source.input.file //=> '/home/ai/a.css'
         */
        this.file = opts.from;
      } else {
        this.file = _path.default.resolve(opts.from);
      }
    }

    var map = new _previousMap.default(this.css, opts);

    if (map.text) {
      /**
       * The input source map passed from a compilation step before PostCSS
       * (for example, from Sass compiler).
       *
       * @type {PreviousMap}
       *
       * @example
       * root.source.input.map.consumer().sources //=> ['a.sass']
       */
      this.map = map;
      var file = map.consumer().file;
      if (!this.file && file) this.file = this.mapResolve(file);
    }

    if (!this.file) {
      sequence += 1;
      /**
       * The unique ID of the CSS source. It will be created if `from` option
       * is not provided (because PostCSS does not know the file path).
       *
       * @type {string}
       *
       * @example
       * const root = postcss.parse(css)
       * root.source.input.file //=> undefined
       * root.source.input.id   //=> "<input css 1>"
       */

      this.id = '<input css ' + sequence + '>';
    }

    if (this.map) this.map.file = this.from;
  }

  var _proto = Input.prototype;

  _proto.error = function error(message, line, column, opts) {
    if (opts === void 0) {
      opts = {};
    }

    var result;
    var origin = this.origin(line, column);

    if (origin) {
      result = new _cssSyntaxError.default(message, origin.line, origin.column, origin.source, origin.file, opts.plugin);
    } else {
      result = new _cssSyntaxError.default(message, line, column, this.css, this.file, opts.plugin);
    }

    result.input = {
      line: line,
      column: column,
      source: this.css
    };
    if (this.file) result.input.file = this.file;
    return result;
  }
  /**
   * Reads the input source map and returns a symbol position
   * in the input source (e.g., in a Sass file that was compiled
   * to CSS before being passed to PostCSS).
   *
   * @param {number} line   Line in input CSS.
   * @param {number} column Column in input CSS.
   *
   * @return {filePosition} Position in input source.
   *
   * @example
   * root.source.input.origin(1, 1) //=> { file: 'a.css', line: 3, column: 1 }
   */
  ;

  _proto.origin = function origin(line, column) {
    if (!this.map) return false;
    var consumer = this.map.consumer();
    var from = consumer.originalPositionFor({
      line: line,
      column: column
    });
    if (!from.source) return false;
    var result = {
      file: this.mapResolve(from.source),
      line: from.line,
      column: from.column
    };
    var source = consumer.sourceContentFor(from.source);
    if (source) result.source = source;
    return result;
  };

  _proto.mapResolve = function mapResolve(file) {
    if (/^\w+:\/\//.test(file)) {
      return file;
    }

    return _path.default.resolve(this.map.consumer().sourceRoot || '.', file);
  }
  /**
   * The CSS source identifier. Contains {@link Input#file} if the user
   * set the `from` option, or {@link Input#id} if they did not.
   *
   * @type {string}
   *
   * @example
   * const root = postcss.parse(css, { from: 'a.css' })
   * root.source.input.from //=> "/home/ai/a.css"
   *
   * const root = postcss.parse(css)
   * root.source.input.from //=> "<input css 1>"
   */
  ;

  _createClass(Input, [{
    key: "from",
    get: function get() {
      return this.file || this.id;
    }
  }]);

  return Input;
}();

var _default = Input;
/**
 * @typedef  {object} filePosition
 * @property {string} file   Path to file.
 * @property {number} line   Source line in file.
 * @property {number} column Source column in file.
 */

exports.default = _default;
module.exports = exports.default;


},{"./css-syntax-error":1065,"./previous-map":1075,"path":802}],1068:[function(require,module,exports){
(function (process){
"use strict";

exports.__esModule = true;
exports.default = void 0;

var _mapGenerator = _interopRequireDefault(require("./map-generator"));

var _stringify2 = _interopRequireDefault(require("./stringify"));

var _warnOnce = _interopRequireDefault(require("./warn-once"));

var _result = _interopRequireDefault(require("./result"));

var _parse = _interopRequireDefault(require("./parse"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function isPromise(obj) {
  return typeof obj === 'object' && typeof obj.then === 'function';
}
/**
 * A Promise proxy for the result of PostCSS transformations.
 *
 * A `LazyResult` instance is returned by {@link Processor#process}.
 *
 * @example
 * const lazy = postcss([autoprefixer]).process(css)
 */


var LazyResult =
/*#__PURE__*/
function () {
  function LazyResult(processor, css, opts) {
    this.stringified = false;
    this.processed = false;
    var root;

    if (typeof css === 'object' && css !== null && css.type === 'root') {
      root = css;
    } else if (css instanceof LazyResult || css instanceof _result.default) {
      root = css.root;

      if (css.map) {
        if (typeof opts.map === 'undefined') opts.map = {};
        if (!opts.map.inline) opts.map.inline = false;
        opts.map.prev = css.map;
      }
    } else {
      var parser = _parse.default;
      if (opts.syntax) parser = opts.syntax.parse;
      if (opts.parser) parser = opts.parser;
      if (parser.parse) parser = parser.parse;

      try {
        root = parser(css, opts);
      } catch (error) {
        this.error = error;
      }
    }

    this.result = new _result.default(processor, root, opts);
  }
  /**
   * Returns a {@link Processor} instance, which will be used
   * for CSS transformations.
   *
   * @type {Processor}
   */


  var _proto = LazyResult.prototype;

  /**
   * Processes input CSS through synchronous plugins
   * and calls {@link Result#warnings()}.
   *
   * @return {Warning[]} Warnings from plugins.
   */
  _proto.warnings = function warnings() {
    return this.sync().warnings();
  }
  /**
   * Alias for the {@link LazyResult#css} property.
   *
   * @example
   * lazy + '' === lazy.css
   *
   * @return {string} Output CSS.
   */
  ;

  _proto.toString = function toString() {
    return this.css;
  }
  /**
   * Processes input CSS through synchronous and asynchronous plugins
   * and calls `onFulfilled` with a Result instance. If a plugin throws
   * an error, the `onRejected` callback will be executed.
   *
   * It implements standard Promise API.
   *
   * @param {onFulfilled} onFulfilled Callback will be executed
   *                                  when all plugins will finish work.
   * @param {onRejected}  onRejected  Callback will be executed on any error.
   *
   * @return {Promise} Promise API to make queue.
   *
   * @example
   * postcss([autoprefixer]).process(css, { from: cssPath }).then(result => {
   *   console.log(result.css)
   * })
   */
  ;

  _proto.then = function then(onFulfilled, onRejected) {
    if (process.env.NODE_ENV !== 'production') {
      if (!('from' in this.opts)) {
        (0, _warnOnce.default)('Without `from` option PostCSS could generate wrong source map ' + 'and will not find Browserslist config. Set it to CSS file path ' + 'or to `undefined` to prevent this warning.');
      }
    }

    return this.async().then(onFulfilled, onRejected);
  }
  /**
   * Processes input CSS through synchronous and asynchronous plugins
   * and calls onRejected for each error thrown in any plugin.
   *
   * It implements standard Promise API.
   *
   * @param {onRejected} onRejected Callback will be executed on any error.
   *
   * @return {Promise} Promise API to make queue.
   *
   * @example
   * postcss([autoprefixer]).process(css).then(result => {
   *   console.log(result.css)
   * }).catch(error => {
   *   console.error(error)
   * })
   */
  ;

  _proto.catch = function _catch(onRejected) {
    return this.async().catch(onRejected);
  }
  /**
   * Processes input CSS through synchronous and asynchronous plugins
   * and calls onFinally on any error or when all plugins will finish work.
   *
   * It implements standard Promise API.
   *
   * @param {onFinally} onFinally Callback will be executed on any error or
   *                              when all plugins will finish work.
   *
   * @return {Promise} Promise API to make queue.
   *
   * @example
   * postcss([autoprefixer]).process(css).finally(() => {
   *   console.log('processing ended')
   * })
   */
  ;

  _proto.finally = function _finally(onFinally) {
    return this.async().then(onFinally, onFinally);
  };

  _proto.handleError = function handleError(error, plugin) {
    try {
      this.error = error;

      if (error.name === 'CssSyntaxError' && !error.plugin) {
        error.plugin = plugin.postcssPlugin;
        error.setMessage();
      } else if (plugin.postcssVersion) {
        if (process.env.NODE_ENV !== 'production') {
          var pluginName = plugin.postcssPlugin;
          var pluginVer = plugin.postcssVersion;
          var runtimeVer = this.result.processor.version;
          var a = pluginVer.split('.');
          var b = runtimeVer.split('.');

          if (a[0] !== b[0] || parseInt(a[1]) > parseInt(b[1])) {
            console.error('Unknown error from PostCSS plugin. Your current PostCSS ' + 'version is ' + runtimeVer + ', but ' + pluginName + ' uses ' + pluginVer + '. Perhaps this is the source of the error below.');
          }
        }
      }
    } catch (err) {
      if (console && console.error) console.error(err);
    }
  };

  _proto.asyncTick = function asyncTick(resolve, reject) {
    var _this = this;

    if (this.plugin >= this.processor.plugins.length) {
      this.processed = true;
      return resolve();
    }

    try {
      var plugin = this.processor.plugins[this.plugin];
      var promise = this.run(plugin);
      this.plugin += 1;

      if (isPromise(promise)) {
        promise.then(function () {
          _this.asyncTick(resolve, reject);
        }).catch(function (error) {
          _this.handleError(error, plugin);

          _this.processed = true;
          reject(error);
        });
      } else {
        this.asyncTick(resolve, reject);
      }
    } catch (error) {
      this.processed = true;
      reject(error);
    }
  };

  _proto.async = function async() {
    var _this2 = this;

    if (this.processed) {
      return new Promise(function (resolve, reject) {
        if (_this2.error) {
          reject(_this2.error);
        } else {
          resolve(_this2.stringify());
        }
      });
    }

    if (this.processing) {
      return this.processing;
    }

    this.processing = new Promise(function (resolve, reject) {
      if (_this2.error) return reject(_this2.error);
      _this2.plugin = 0;

      _this2.asyncTick(resolve, reject);
    }).then(function () {
      _this2.processed = true;
      return _this2.stringify();
    });
    return this.processing;
  };

  _proto.sync = function sync() {
    if (this.processed) return this.result;
    this.processed = true;

    if (this.processing) {
      throw new Error('Use process(css).then(cb) to work with async plugins');
    }

    if (this.error) throw this.error;

    for (var _iterator = this.result.processor.plugins, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var plugin = _ref;
      var promise = this.run(plugin);

      if (isPromise(promise)) {
        throw new Error('Use process(css).then(cb) to work with async plugins');
      }
    }

    return this.result;
  };

  _proto.run = function run(plugin) {
    this.result.lastPlugin = plugin;

    try {
      return plugin(this.result.root, this.result);
    } catch (error) {
      this.handleError(error, plugin);
      throw error;
    }
  };

  _proto.stringify = function stringify() {
    if (this.stringified) return this.result;
    this.stringified = true;
    this.sync();
    var opts = this.result.opts;
    var str = _stringify2.default;
    if (opts.syntax) str = opts.syntax.stringify;
    if (opts.stringifier) str = opts.stringifier;
    if (str.stringify) str = str.stringify;
    var map = new _mapGenerator.default(str, this.result.root, this.result.opts);
    var data = map.generate();
    this.result.css = data[0];
    this.result.map = data[1];
    return this.result;
  };

  _createClass(LazyResult, [{
    key: "processor",
    get: function get() {
      return this.result.processor;
    }
    /**
     * Options from the {@link Processor#process} call.
     *
     * @type {processOptions}
     */

  }, {
    key: "opts",
    get: function get() {
      return this.result.opts;
    }
    /**
     * Processes input CSS through synchronous plugins, converts `Root`
     * to a CSS string and returns {@link Result#css}.
     *
     * This property will only work with synchronous plugins.
     * If the processor contains any asynchronous plugins
     * it will throw an error. This is why this method is only
     * for debug purpose, you should always use {@link LazyResult#then}.
     *
     * @type {string}
     * @see Result#css
     */

  }, {
    key: "css",
    get: function get() {
      return this.stringify().css;
    }
    /**
     * An alias for the `css` property. Use it with syntaxes
     * that generate non-CSS output.
     *
     * This property will only work with synchronous plugins.
     * If the processor contains any asynchronous plugins
     * it will throw an error. This is why this method is only
     * for debug purpose, you should always use {@link LazyResult#then}.
     *
     * @type {string}
     * @see Result#content
     */

  }, {
    key: "content",
    get: function get() {
      return this.stringify().content;
    }
    /**
     * Processes input CSS through synchronous plugins
     * and returns {@link Result#map}.
     *
     * This property will only work with synchronous plugins.
     * If the processor contains any asynchronous plugins
     * it will throw an error. This is why this method is only
     * for debug purpose, you should always use {@link LazyResult#then}.
     *
     * @type {SourceMapGenerator}
     * @see Result#map
     */

  }, {
    key: "map",
    get: function get() {
      return this.stringify().map;
    }
    /**
     * Processes input CSS through synchronous plugins
     * and returns {@link Result#root}.
     *
     * This property will only work with synchronous plugins. If the processor
     * contains any asynchronous plugins it will throw an error.
     *
     * This is why this method is only for debug purpose,
     * you should always use {@link LazyResult#then}.
     *
     * @type {Root}
     * @see Result#root
     */

  }, {
    key: "root",
    get: function get() {
      return this.sync().root;
    }
    /**
     * Processes input CSS through synchronous plugins
     * and returns {@link Result#messages}.
     *
     * This property will only work with synchronous plugins. If the processor
     * contains any asynchronous plugins it will throw an error.
     *
     * This is why this method is only for debug purpose,
     * you should always use {@link LazyResult#then}.
     *
     * @type {Message[]}
     * @see Result#messages
     */

  }, {
    key: "messages",
    get: function get() {
      return this.sync().messages;
    }
  }]);

  return LazyResult;
}();

var _default = LazyResult;
/**
 * @callback onFulfilled
 * @param {Result} result
 */

/**
 * @callback onRejected
 * @param {Error} error
 */

exports.default = _default;
module.exports = exports.default;


}).call(this,require('_process'))
},{"./map-generator":1070,"./parse":1072,"./result":1077,"./stringify":1081,"./warn-once":1084,"_process":1098}],1069:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports.default = void 0;

/**
 * Contains helpers for safely splitting lists of CSS values,
 * preserving parentheses and quotes.
 *
 * @example
 * const list = postcss.list
 *
 * @namespace list
 */
var list = {
  split: function split(string, separators, last) {
    var array = [];
    var current = '';
    var split = false;
    var func = 0;
    var quote = false;
    var escape = false;

    for (var i = 0; i < string.length; i++) {
      var letter = string[i];

      if (quote) {
        if (escape) {
          escape = false;
        } else if (letter === '\\') {
          escape = true;
        } else if (letter === quote) {
          quote = false;
        }
      } else if (letter === '"' || letter === '\'') {
        quote = letter;
      } else if (letter === '(') {
        func += 1;
      } else if (letter === ')') {
        if (func > 0) func -= 1;
      } else if (func === 0) {
        if (separators.indexOf(letter) !== -1) split = true;
      }

      if (split) {
        if (current !== '') array.push(current.trim());
        current = '';
        split = false;
      } else {
        current += letter;
      }
    }

    if (last || current !== '') array.push(current.trim());
    return array;
  },

  /**
   * Safely splits space-separated values (such as those for `background`,
   * `border-radius`, and other shorthand properties).
   *
   * @param {string} string Space-separated values.
   *
   * @return {string[]} Split values.
   *
   * @example
   * postcss.list.space('1px calc(10% + 1px)') //=> ['1px', 'calc(10% + 1px)']
   */
  space: function space(string) {
    var spaces = [' ', '\n', '\t'];
    return list.split(string, spaces);
  },

  /**
   * Safely splits comma-separated values (such as those for `transition-*`
   * and `background` properties).
   *
   * @param {string} string Comma-separated values.
   *
   * @return {string[]} Split values.
   *
   * @example
   * postcss.list.comma('black, linear-gradient(white, black)')
   * //=> ['black', 'linear-gradient(white, black)']
   */
  comma: function comma(string) {
    return list.split(string, [','], true);
  }
};
var _default = list;
exports.default = _default;
module.exports = exports.default;


},{}],1070:[function(require,module,exports){
(function (Buffer){
"use strict";

exports.__esModule = true;
exports.default = void 0;

var _sourceMap = _interopRequireDefault(require("source-map"));

var _path = _interopRequireDefault(require("path"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var MapGenerator =
/*#__PURE__*/
function () {
  function MapGenerator(stringify, root, opts) {
    this.stringify = stringify;
    this.mapOpts = opts.map || {};
    this.root = root;
    this.opts = opts;
  }

  var _proto = MapGenerator.prototype;

  _proto.isMap = function isMap() {
    if (typeof this.opts.map !== 'undefined') {
      return !!this.opts.map;
    }

    return this.previous().length > 0;
  };

  _proto.previous = function previous() {
    var _this = this;

    if (!this.previousMaps) {
      this.previousMaps = [];
      this.root.walk(function (node) {
        if (node.source && node.source.input.map) {
          var map = node.source.input.map;

          if (_this.previousMaps.indexOf(map) === -1) {
            _this.previousMaps.push(map);
          }
        }
      });
    }

    return this.previousMaps;
  };

  _proto.isInline = function isInline() {
    if (typeof this.mapOpts.inline !== 'undefined') {
      return this.mapOpts.inline;
    }

    var annotation = this.mapOpts.annotation;

    if (typeof annotation !== 'undefined' && annotation !== true) {
      return false;
    }

    if (this.previous().length) {
      return this.previous().some(function (i) {
        return i.inline;
      });
    }

    return true;
  };

  _proto.isSourcesContent = function isSourcesContent() {
    if (typeof this.mapOpts.sourcesContent !== 'undefined') {
      return this.mapOpts.sourcesContent;
    }

    if (this.previous().length) {
      return this.previous().some(function (i) {
        return i.withContent();
      });
    }

    return true;
  };

  _proto.clearAnnotation = function clearAnnotation() {
    if (this.mapOpts.annotation === false) return;
    var node;

    for (var i = this.root.nodes.length - 1; i >= 0; i--) {
      node = this.root.nodes[i];
      if (node.type !== 'comment') continue;

      if (node.text.indexOf('# sourceMappingURL=') === 0) {
        this.root.removeChild(i);
      }
    }
  };

  _proto.setSourcesContent = function setSourcesContent() {
    var _this2 = this;

    var already = {};
    this.root.walk(function (node) {
      if (node.source) {
        var from = node.source.input.from;

        if (from && !already[from]) {
          already[from] = true;

          var relative = _this2.relative(from);

          _this2.map.setSourceContent(relative, node.source.input.css);
        }
      }
    });
  };

  _proto.applyPrevMaps = function applyPrevMaps() {
    for (var _iterator = this.previous(), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var prev = _ref;
      var from = this.relative(prev.file);

      var root = prev.root || _path.default.dirname(prev.file);

      var map = void 0;

      if (this.mapOpts.sourcesContent === false) {
        map = new _sourceMap.default.SourceMapConsumer(prev.text);

        if (map.sourcesContent) {
          map.sourcesContent = map.sourcesContent.map(function () {
            return null;
          });
        }
      } else {
        map = prev.consumer();
      }

      this.map.applySourceMap(map, from, this.relative(root));
    }
  };

  _proto.isAnnotation = function isAnnotation() {
    if (this.isInline()) {
      return true;
    }

    if (typeof this.mapOpts.annotation !== 'undefined') {
      return this.mapOpts.annotation;
    }

    if (this.previous().length) {
      return this.previous().some(function (i) {
        return i.annotation;
      });
    }

    return true;
  };

  _proto.toBase64 = function toBase64(str) {
    if (Buffer) {
      return Buffer.from(str).toString('base64');
    }

    return window.btoa(unescape(encodeURIComponent(str)));
  };

  _proto.addAnnotation = function addAnnotation() {
    var content;

    if (this.isInline()) {
      content = 'data:application/json;base64,' + this.toBase64(this.map.toString());
    } else if (typeof this.mapOpts.annotation === 'string') {
      content = this.mapOpts.annotation;
    } else {
      content = this.outputFile() + '.map';
    }

    var eol = '\n';
    if (this.css.indexOf('\r\n') !== -1) eol = '\r\n';
    this.css += eol + '/*# sourceMappingURL=' + content + ' */';
  };

  _proto.outputFile = function outputFile() {
    if (this.opts.to) {
      return this.relative(this.opts.to);
    }

    if (this.opts.from) {
      return this.relative(this.opts.from);
    }

    return 'to.css';
  };

  _proto.generateMap = function generateMap() {
    this.generateString();
    if (this.isSourcesContent()) this.setSourcesContent();
    if (this.previous().length > 0) this.applyPrevMaps();
    if (this.isAnnotation()) this.addAnnotation();

    if (this.isInline()) {
      return [this.css];
    }

    return [this.css, this.map];
  };

  _proto.relative = function relative(file) {
    if (file.indexOf('<') === 0) return file;
    if (/^\w+:\/\//.test(file)) return file;
    var from = this.opts.to ? _path.default.dirname(this.opts.to) : '.';

    if (typeof this.mapOpts.annotation === 'string') {
      from = _path.default.dirname(_path.default.resolve(from, this.mapOpts.annotation));
    }

    file = _path.default.relative(from, file);

    if (_path.default.sep === '\\') {
      return file.replace(/\\/g, '/');
    }

    return file;
  };

  _proto.sourcePath = function sourcePath(node) {
    if (this.mapOpts.from) {
      return this.mapOpts.from;
    }

    return this.relative(node.source.input.from);
  };

  _proto.generateString = function generateString() {
    var _this3 = this;

    this.css = '';
    this.map = new _sourceMap.default.SourceMapGenerator({
      file: this.outputFile()
    });
    var line = 1;
    var column = 1;
    var lines, last;
    this.stringify(this.root, function (str, node, type) {
      _this3.css += str;

      if (node && type !== 'end') {
        if (node.source && node.source.start) {
          _this3.map.addMapping({
            source: _this3.sourcePath(node),
            generated: {
              line: line,
              column: column - 1
            },
            original: {
              line: node.source.start.line,
              column: node.source.start.column - 1
            }
          });
        } else {
          _this3.map.addMapping({
            source: '<no source>',
            original: {
              line: 1,
              column: 0
            },
            generated: {
              line: line,
              column: column - 1
            }
          });
        }
      }

      lines = str.match(/\n/g);

      if (lines) {
        line += lines.length;
        last = str.lastIndexOf('\n');
        column = str.length - last;
      } else {
        column += str.length;
      }

      if (node && type !== 'start') {
        var p = node.parent || {
          raws: {}
        };

        if (node.type !== 'decl' || node !== p.last || p.raws.semicolon) {
          if (node.source && node.source.end) {
            _this3.map.addMapping({
              source: _this3.sourcePath(node),
              generated: {
                line: line,
                column: column - 2
              },
              original: {
                line: node.source.end.line,
                column: node.source.end.column - 1
              }
            });
          } else {
            _this3.map.addMapping({
              source: '<no source>',
              original: {
                line: 1,
                column: 0
              },
              generated: {
                line: line,
                column: column - 1
              }
            });
          }
        }
      }
    });
  };

  _proto.generate = function generate() {
    this.clearAnnotation();

    if (this.isMap()) {
      return this.generateMap();
    }

    var result = '';
    this.stringify(this.root, function (i) {
      result += i;
    });
    return [result];
  };

  return MapGenerator;
}();

var _default = MapGenerator;
exports.default = _default;
module.exports = exports.default;


}).call(this,require("buffer").Buffer)
},{"buffer":13,"path":802,"source-map":1096}],1071:[function(require,module,exports){
(function (process){
"use strict";

exports.__esModule = true;
exports.default = void 0;

var _cssSyntaxError = _interopRequireDefault(require("./css-syntax-error"));

var _stringifier = _interopRequireDefault(require("./stringifier"));

var _stringify = _interopRequireDefault(require("./stringify"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function cloneNode(obj, parent) {
  var cloned = new obj.constructor();

  for (var i in obj) {
    if (!obj.hasOwnProperty(i)) continue;
    var value = obj[i];
    var type = typeof value;

    if (i === 'parent' && type === 'object') {
      if (parent) cloned[i] = parent;
    } else if (i === 'source') {
      cloned[i] = value;
    } else if (value instanceof Array) {
      cloned[i] = value.map(function (j) {
        return cloneNode(j, cloned);
      });
    } else {
      if (type === 'object' && value !== null) value = cloneNode(value);
      cloned[i] = value;
    }
  }

  return cloned;
}
/**
 * All node classes inherit the following common methods.
 *
 * @abstract
 */


var Node =
/*#__PURE__*/
function () {
  /**
   * @param {object} [defaults] Value for node properties.
   */
  function Node(defaults) {
    if (defaults === void 0) {
      defaults = {};
    }

    this.raws = {};

    if (process.env.NODE_ENV !== 'production') {
      if (typeof defaults !== 'object' && typeof defaults !== 'undefined') {
        throw new Error('PostCSS nodes constructor accepts object, not ' + JSON.stringify(defaults));
      }
    }

    for (var name in defaults) {
      this[name] = defaults[name];
    }
  }
  /**
   * Returns a `CssSyntaxError` instance containing the original position
   * of the node in the source, showing line and column numbers and also
   * a small excerpt to facilitate debugging.
   *
   * If present, an input source map will be used to get the original position
   * of the source, even from a previous compilation step
   * (e.g., from Sass compilation).
   *
   * This method produces very useful error messages.
   *
   * @param {string} message     Error description.
   * @param {object} [opts]      Options.
   * @param {string} opts.plugin Plugin name that created this error.
   *                             PostCSS will set it automatically.
   * @param {string} opts.word   A word inside a nodes string that should
   *                             be highlighted as the source of the error.
   * @param {number} opts.index  An index inside a nodes string that should
   *                             be highlighted as the source of the error.
   *
   * @return {CssSyntaxError} Error object to throw it.
   *
   * @example
   * if (!variables[name]) {
   *   throw decl.error('Unknown variable ' + name, { word: name })
   *   // CssSyntaxError: postcss-vars:a.sass:4:3: Unknown variable $black
   *   //   color: $black
   *   // a
   *   //          ^
   *   //   background: white
   * }
   */


  var _proto = Node.prototype;

  _proto.error = function error(message, opts) {
    if (opts === void 0) {
      opts = {};
    }

    if (this.source) {
      var pos = this.positionBy(opts);
      return this.source.input.error(message, pos.line, pos.column, opts);
    }

    return new _cssSyntaxError.default(message);
  }
  /**
   * This method is provided as a convenience wrapper for {@link Result#warn}.
   *
   * @param {Result} result      The {@link Result} instance
   *                             that will receive the warning.
   * @param {string} text        Warning message.
   * @param {object} [opts]      Options
   * @param {string} opts.plugin Plugin name that created this warning.
   *                             PostCSS will set it automatically.
   * @param {string} opts.word   A word inside a nodes string that should
   *                             be highlighted as the source of the warning.
   * @param {number} opts.index  An index inside a nodes string that should
   *                             be highlighted as the source of the warning.
   *
   * @return {Warning} Created warning object.
   *
   * @example
   * const plugin = postcss.plugin('postcss-deprecated', () => {
   *   return (root, result) => {
   *     root.walkDecls('bad', decl => {
   *       decl.warn(result, 'Deprecated property bad')
   *     })
   *   }
   * })
   */
  ;

  _proto.warn = function warn(result, text, opts) {
    var data = {
      node: this
    };

    for (var i in opts) {
      data[i] = opts[i];
    }

    return result.warn(text, data);
  }
  /**
   * Removes the node from its parent and cleans the parent properties
   * from the node and its children.
   *
   * @example
   * if (decl.prop.match(/^-webkit-/)) {
   *   decl.remove()
   * }
   *
   * @return {Node} Node to make calls chain.
   */
  ;

  _proto.remove = function remove() {
    if (this.parent) {
      this.parent.removeChild(this);
    }

    this.parent = undefined;
    return this;
  }
  /**
   * Returns a CSS string representing the node.
   *
   * @param {stringifier|syntax} [stringifier] A syntax to use
   *                                           in string generation.
   *
   * @return {string} CSS string of this node.
   *
   * @example
   * postcss.rule({ selector: 'a' }).toString() //=> "a {}"
   */
  ;

  _proto.toString = function toString(stringifier) {
    if (stringifier === void 0) {
      stringifier = _stringify.default;
    }

    if (stringifier.stringify) stringifier = stringifier.stringify;
    var result = '';
    stringifier(this, function (i) {
      result += i;
    });
    return result;
  }
  /**
   * Returns an exact clone of the node.
   *
   * The resulting cloned node and its (cloned) children will retain
   * code style properties.
   *
   * @param {object} [overrides] New properties to override in the clone.
   *
   * @example
   * decl.raws.before    //=> "\n  "
   * const cloned = decl.clone({ prop: '-moz-' + decl.prop })
   * cloned.raws.before  //=> "\n  "
   * cloned.toString()   //=> -moz-transform: scale(0)
   *
   * @return {Node} Clone of the node.
   */
  ;

  _proto.clone = function clone(overrides) {
    if (overrides === void 0) {
      overrides = {};
    }

    var cloned = cloneNode(this);

    for (var name in overrides) {
      cloned[name] = overrides[name];
    }

    return cloned;
  }
  /**
   * Shortcut to clone the node and insert the resulting cloned node
   * before the current node.
   *
   * @param {object} [overrides] Mew properties to override in the clone.
   *
   * @example
   * decl.cloneBefore({ prop: '-moz-' + decl.prop })
   *
   * @return {Node} New node
   */
  ;

  _proto.cloneBefore = function cloneBefore(overrides) {
    if (overrides === void 0) {
      overrides = {};
    }

    var cloned = this.clone(overrides);
    this.parent.insertBefore(this, cloned);
    return cloned;
  }
  /**
   * Shortcut to clone the node and insert the resulting cloned node
   * after the current node.
   *
   * @param {object} [overrides] New properties to override in the clone.
   *
   * @return {Node} New node.
   */
  ;

  _proto.cloneAfter = function cloneAfter(overrides) {
    if (overrides === void 0) {
      overrides = {};
    }

    var cloned = this.clone(overrides);
    this.parent.insertAfter(this, cloned);
    return cloned;
  }
  /**
   * Inserts node(s) before the current node and removes the current node.
   *
   * @param {...Node} nodes Mode(s) to replace current one.
   *
   * @example
   * if (atrule.name === 'mixin') {
   *   atrule.replaceWith(mixinRules[atrule.params])
   * }
   *
   * @return {Node} Current node to methods chain.
   */
  ;

  _proto.replaceWith = function replaceWith() {
    if (this.parent) {
      for (var _len = arguments.length, nodes = new Array(_len), _key = 0; _key < _len; _key++) {
        nodes[_key] = arguments[_key];
      }

      for (var _i = 0; _i < nodes.length; _i++) {
        var node = nodes[_i];
        this.parent.insertBefore(this, node);
      }

      this.remove();
    }

    return this;
  }
  /**
   * Returns the next child of the nodes parent.
   * Returns `undefined` if the current node is the last child.
   *
   * @return {Node|undefined} Next node.
   *
   * @example
   * if (comment.text === 'delete next') {
   *   const next = comment.next()
   *   if (next) {
   *     next.remove()
   *   }
   * }
   */
  ;

  _proto.next = function next() {
    if (!this.parent) return undefined;
    var index = this.parent.index(this);
    return this.parent.nodes[index + 1];
  }
  /**
   * Returns the previous child of the nodes parent.
   * Returns `undefined` if the current node is the first child.
   *
   * @return {Node|undefined} Previous node.
   *
   * @example
   * const annotation = decl.prev()
   * if (annotation.type === 'comment') {
   *   readAnnotation(annotation.text)
   * }
   */
  ;

  _proto.prev = function prev() {
    if (!this.parent) return undefined;
    var index = this.parent.index(this);
    return this.parent.nodes[index - 1];
  }
  /**
   * Insert new node before current node to current nodes parent.
   *
   * Just alias for `node.parent.insertBefore(node, add)`.
   *
   * @param {Node|object|string|Node[]} add New node.
   *
   * @return {Node} This node for methods chain.
   *
   * @example
   * decl.before('content: ""')
   */
  ;

  _proto.before = function before(add) {
    this.parent.insertBefore(this, add);
    return this;
  }
  /**
   * Insert new node after current node to current nodes parent.
   *
   * Just alias for `node.parent.insertAfter(node, add)`.
   *
   * @param {Node|object|string|Node[]} add New node.
   *
   * @return {Node} This node for methods chain.
   *
   * @example
   * decl.after('color: black')
   */
  ;

  _proto.after = function after(add) {
    this.parent.insertAfter(this, add);
    return this;
  };

  _proto.toJSON = function toJSON() {
    var fixed = {};

    for (var name in this) {
      if (!this.hasOwnProperty(name)) continue;
      if (name === 'parent') continue;
      var value = this[name];

      if (value instanceof Array) {
        fixed[name] = value.map(function (i) {
          if (typeof i === 'object' && i.toJSON) {
            return i.toJSON();
          } else {
            return i;
          }
        });
      } else if (typeof value === 'object' && value.toJSON) {
        fixed[name] = value.toJSON();
      } else {
        fixed[name] = value;
      }
    }

    return fixed;
  }
  /**
   * Returns a {@link Node#raws} value. If the node is missing
   * the code style property (because the node was manually built or cloned),
   * PostCSS will try to autodetect the code style property by looking
   * at other nodes in the tree.
   *
   * @param {string} prop          Name of code style property.
   * @param {string} [defaultType] Name of default value, it can be missed
   *                               if the value is the same as prop.
   *
   * @example
   * const root = postcss.parse('a { background: white }')
   * root.nodes[0].append({ prop: 'color', value: 'black' })
   * root.nodes[0].nodes[1].raws.before   //=> undefined
   * root.nodes[0].nodes[1].raw('before') //=> ' '
   *
   * @return {string} Code style value.
   */
  ;

  _proto.raw = function raw(prop, defaultType) {
    var str = new _stringifier.default();
    return str.raw(this, prop, defaultType);
  }
  /**
   * Finds the Root instance of the nodes tree.
   *
   * @example
   * root.nodes[0].nodes[0].root() === root
   *
   * @return {Root} Root parent.
   */
  ;

  _proto.root = function root() {
    var result = this;

    while (result.parent) {
      result = result.parent;
    }

    return result;
  }
  /**
   * Clear the code style properties for the node and its children.
   *
   * @param {boolean} [keepBetween] Keep the raws.between symbols.
   *
   * @return {undefined}
   *
   * @example
   * node.raws.before  //=> ' '
   * node.cleanRaws()
   * node.raws.before  //=> undefined
   */
  ;

  _proto.cleanRaws = function cleanRaws(keepBetween) {
    delete this.raws.before;
    delete this.raws.after;
    if (!keepBetween) delete this.raws.between;
  };

  _proto.positionInside = function positionInside(index) {
    var string = this.toString();
    var column = this.source.start.column;
    var line = this.source.start.line;

    for (var i = 0; i < index; i++) {
      if (string[i] === '\n') {
        column = 1;
        line += 1;
      } else {
        column += 1;
      }
    }

    return {
      line: line,
      column: column
    };
  };

  _proto.positionBy = function positionBy(opts) {
    var pos = this.source.start;

    if (opts.index) {
      pos = this.positionInside(opts.index);
    } else if (opts.word) {
      var index = this.toString().indexOf(opts.word);
      if (index !== -1) pos = this.positionInside(index);
    }

    return pos;
  }
  /**
   * @memberof Node#
   * @member {string} type String representing the nodes type.
   *                       Possible values are `root`, `atrule`, `rule`,
   *                       `decl`, or `comment`.
   *
   * @example
   * postcss.decl({ prop: 'color', value: 'black' }).type //=> 'decl'
   */

  /**
   * @memberof Node#
   * @member {Container} parent The nodes parent node.
   *
   * @example
   * root.nodes[0].parent === root
   */

  /**
   * @memberof Node#
   * @member {source} source The input source of the node.
   *
   * The property is used in source map generation.
   *
   * If you create a node manually (e.g., with `postcss.decl()`),
   * that node will not have a `source` property and will be absent
   * from the source map. For this reason, the plugin developer should
   * consider cloning nodes to create new ones (in which case the new nodes
   * source will reference the original, cloned node) or setting
   * the `source` property manually.
   *
   * ```js
   * // Bad
   * const prefixed = postcss.decl({
   *   prop: '-moz-' + decl.prop,
   *   value: decl.value
   * })
   *
   * // Good
   * const prefixed = decl.clone({ prop: '-moz-' + decl.prop })
   * ```
   *
   * ```js
   * if (atrule.name === 'add-link') {
   *   const rule = postcss.rule({ selector: 'a', source: atrule.source })
   *   atrule.parent.insertBefore(atrule, rule)
   * }
   * ```
   *
   * @example
   * decl.source.input.from //=> '/home/ai/a.sass'
   * decl.source.start      //=> { line: 10, column: 2 }
   * decl.source.end        //=> { line: 10, column: 12 }
   */

  /**
   * @memberof Node#
   * @member {object} raws Information to generate byte-to-byte equal
   *                       node string as it was in the origin input.
   *
   * Every parser saves its own properties,
   * but the default CSS parser uses:
   *
   * * `before`: the space symbols before the node. It also stores `*`
   *   and `_` symbols before the declaration (IE hack).
   * * `after`: the space symbols after the last child of the node
   *   to the end of the node.
   * * `between`: the symbols between the property and value
   *   for declarations, selector and `{` for rules, or last parameter
   *   and `{` for at-rules.
   * * `semicolon`: contains true if the last child has
   *   an (optional) semicolon.
   * * `afterName`: the space between the at-rule name and its parameters.
   * * `left`: the space symbols between `/*` and the comments text.
   * * `right`: the space symbols between the comments text
   *   and <code>*&#47;</code>.
   * * `important`: the content of the important statement,
   *   if it is not just `!important`.
   *
   * PostCSS cleans selectors, declaration values and at-rule parameters
   * from comments and extra spaces, but it stores origin content in raws
   * properties. As such, if you dont change a declarations value,
   * PostCSS will use the raw value with comments.
   *
   * @example
   * const root = postcss.parse('a {\n  color:black\n}')
   * root.first.first.raws //=> { before: '\n  ', between: ':' }
   */
  ;

  return Node;
}();

var _default = Node;
/**
 * @typedef {object} position
 * @property {number} line   Source line in file.
 * @property {number} column Source column in file.
 */

/**
 * @typedef {object} source
 * @property {Input} input    {@link Input} with input file
 * @property {position} start The starting position of the nodes source.
 * @property {position} end   The ending position of the nodes source.
 */

exports.default = _default;
module.exports = exports.default;


}).call(this,require('_process'))
},{"./css-syntax-error":1065,"./stringifier":1080,"./stringify":1081,"_process":1098}],1072:[function(require,module,exports){
(function (process){
"use strict";

exports.__esModule = true;
exports.default = void 0;

var _parser = _interopRequireDefault(require("./parser"));

var _input = _interopRequireDefault(require("./input"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function parse(css, opts) {
  var input = new _input.default(css, opts);
  var parser = new _parser.default(input);

  try {
    parser.parse();
  } catch (e) {
    if (process.env.NODE_ENV !== 'production') {
      if (e.name === 'CssSyntaxError' && opts && opts.from) {
        if (/\.scss$/i.test(opts.from)) {
          e.message += '\nYou tried to parse SCSS with ' + 'the standard CSS parser; ' + 'try again with the postcss-scss parser';
        } else if (/\.sass/i.test(opts.from)) {
          e.message += '\nYou tried to parse Sass with ' + 'the standard CSS parser; ' + 'try again with the postcss-sass parser';
        } else if (/\.less$/i.test(opts.from)) {
          e.message += '\nYou tried to parse Less with ' + 'the standard CSS parser; ' + 'try again with the postcss-less parser';
        }
      }
    }

    throw e;
  }

  return parser.root;
}

var _default = parse;
exports.default = _default;
module.exports = exports.default;


}).call(this,require('_process'))
},{"./input":1067,"./parser":1073,"_process":1098}],1073:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports.default = void 0;

var _declaration = _interopRequireDefault(require("./declaration"));

var _tokenize = _interopRequireDefault(require("./tokenize"));

var _comment = _interopRequireDefault(require("./comment"));

var _atRule = _interopRequireDefault(require("./at-rule"));

var _root = _interopRequireDefault(require("./root"));

var _rule = _interopRequireDefault(require("./rule"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Parser =
/*#__PURE__*/
function () {
  function Parser(input) {
    this.input = input;
    this.root = new _root.default();
    this.current = this.root;
    this.spaces = '';
    this.semicolon = false;
    this.createTokenizer();
    this.root.source = {
      input: input,
      start: {
        line: 1,
        column: 1
      }
    };
  }

  var _proto = Parser.prototype;

  _proto.createTokenizer = function createTokenizer() {
    this.tokenizer = (0, _tokenize.default)(this.input);
  };

  _proto.parse = function parse() {
    var token;

    while (!this.tokenizer.endOfFile()) {
      token = this.tokenizer.nextToken();

      switch (token[0]) {
        case 'space':
          this.spaces += token[1];
          break;

        case ';':
          this.freeSemicolon(token);
          break;

        case '}':
          this.end(token);
          break;

        case 'comment':
          this.comment(token);
          break;

        case 'at-word':
          this.atrule(token);
          break;

        case '{':
          this.emptyRule(token);
          break;

        default:
          this.other(token);
          break;
      }
    }

    this.endFile();
  };

  _proto.comment = function comment(token) {
    var node = new _comment.default();
    this.init(node, token[2], token[3]);
    node.source.end = {
      line: token[4],
      column: token[5]
    };
    var text = token[1].slice(2, -2);

    if (/^\s*$/.test(text)) {
      node.text = '';
      node.raws.left = text;
      node.raws.right = '';
    } else {
      var match = text.match(/^(\s*)([^]*[^\s])(\s*)$/);
      node.text = match[2];
      node.raws.left = match[1];
      node.raws.right = match[3];
    }
  };

  _proto.emptyRule = function emptyRule(token) {
    var node = new _rule.default();
    this.init(node, token[2], token[3]);
    node.selector = '';
    node.raws.between = '';
    this.current = node;
  };

  _proto.other = function other(start) {
    var end = false;
    var type = null;
    var colon = false;
    var bracket = null;
    var brackets = [];
    var tokens = [];
    var token = start;

    while (token) {
      type = token[0];
      tokens.push(token);

      if (type === '(' || type === '[') {
        if (!bracket) bracket = token;
        brackets.push(type === '(' ? ')' : ']');
      } else if (brackets.length === 0) {
        if (type === ';') {
          if (colon) {
            this.decl(tokens);
            return;
          } else {
            break;
          }
        } else if (type === '{') {
          this.rule(tokens);
          return;
        } else if (type === '}') {
          this.tokenizer.back(tokens.pop());
          end = true;
          break;
        } else if (type === ':') {
          colon = true;
        }
      } else if (type === brackets[brackets.length - 1]) {
        brackets.pop();
        if (brackets.length === 0) bracket = null;
      }

      token = this.tokenizer.nextToken();
    }

    if (this.tokenizer.endOfFile()) end = true;
    if (brackets.length > 0) this.unclosedBracket(bracket);

    if (end && colon) {
      while (tokens.length) {
        token = tokens[tokens.length - 1][0];
        if (token !== 'space' && token !== 'comment') break;
        this.tokenizer.back(tokens.pop());
      }

      this.decl(tokens);
    } else {
      this.unknownWord(tokens);
    }
  };

  _proto.rule = function rule(tokens) {
    tokens.pop();
    var node = new _rule.default();
    this.init(node, tokens[0][2], tokens[0][3]);
    node.raws.between = this.spacesAndCommentsFromEnd(tokens);
    this.raw(node, 'selector', tokens);
    this.current = node;
  };

  _proto.decl = function decl(tokens) {
    var node = new _declaration.default();
    this.init(node);
    var last = tokens[tokens.length - 1];

    if (last[0] === ';') {
      this.semicolon = true;
      tokens.pop();
    }

    if (last[4]) {
      node.source.end = {
        line: last[4],
        column: last[5]
      };
    } else {
      node.source.end = {
        line: last[2],
        column: last[3]
      };
    }

    while (tokens[0][0] !== 'word') {
      if (tokens.length === 1) this.unknownWord(tokens);
      node.raws.before += tokens.shift()[1];
    }

    node.source.start = {
      line: tokens[0][2],
      column: tokens[0][3]
    };
    node.prop = '';

    while (tokens.length) {
      var type = tokens[0][0];

      if (type === ':' || type === 'space' || type === 'comment') {
        break;
      }

      node.prop += tokens.shift()[1];
    }

    node.raws.between = '';
    var token;

    while (tokens.length) {
      token = tokens.shift();

      if (token[0] === ':') {
        node.raws.between += token[1];
        break;
      } else {
        if (token[0] === 'word' && /\w/.test(token[1])) {
          this.unknownWord([token]);
        }

        node.raws.between += token[1];
      }
    }

    if (node.prop[0] === '_' || node.prop[0] === '*') {
      node.raws.before += node.prop[0];
      node.prop = node.prop.slice(1);
    }

    node.raws.between += this.spacesAndCommentsFromStart(tokens);
    this.precheckMissedSemicolon(tokens);

    for (var i = tokens.length - 1; i > 0; i--) {
      token = tokens[i];

      if (token[1].toLowerCase() === '!important') {
        node.important = true;
        var string = this.stringFrom(tokens, i);
        string = this.spacesFromEnd(tokens) + string;
        if (string !== ' !important') node.raws.important = string;
        break;
      } else if (token[1].toLowerCase() === 'important') {
        var cache = tokens.slice(0);
        var str = '';

        for (var j = i; j > 0; j--) {
          var _type = cache[j][0];

          if (str.trim().indexOf('!') === 0 && _type !== 'space') {
            break;
          }

          str = cache.pop()[1] + str;
        }

        if (str.trim().indexOf('!') === 0) {
          node.important = true;
          node.raws.important = str;
          tokens = cache;
        }
      }

      if (token[0] !== 'space' && token[0] !== 'comment') {
        break;
      }
    }

    this.raw(node, 'value', tokens);
    if (node.value.indexOf(':') !== -1) this.checkMissedSemicolon(tokens);
  };

  _proto.atrule = function atrule(token) {
    var node = new _atRule.default();
    node.name = token[1].slice(1);

    if (node.name === '') {
      this.unnamedAtrule(node, token);
    }

    this.init(node, token[2], token[3]);
    var prev;
    var shift;
    var last = false;
    var open = false;
    var params = [];

    while (!this.tokenizer.endOfFile()) {
      token = this.tokenizer.nextToken();

      if (token[0] === ';') {
        node.source.end = {
          line: token[2],
          column: token[3]
        };
        this.semicolon = true;
        break;
      } else if (token[0] === '{') {
        open = true;
        break;
      } else if (token[0] === '}') {
        if (params.length > 0) {
          shift = params.length - 1;
          prev = params[shift];

          while (prev && prev[0] === 'space') {
            prev = params[--shift];
          }

          if (prev) {
            node.source.end = {
              line: prev[4],
              column: prev[5]
            };
          }
        }

        this.end(token);
        break;
      } else {
        params.push(token);
      }

      if (this.tokenizer.endOfFile()) {
        last = true;
        break;
      }
    }

    node.raws.between = this.spacesAndCommentsFromEnd(params);

    if (params.length) {
      node.raws.afterName = this.spacesAndCommentsFromStart(params);
      this.raw(node, 'params', params);

      if (last) {
        token = params[params.length - 1];
        node.source.end = {
          line: token[4],
          column: token[5]
        };
        this.spaces = node.raws.between;
        node.raws.between = '';
      }
    } else {
      node.raws.afterName = '';
      node.params = '';
    }

    if (open) {
      node.nodes = [];
      this.current = node;
    }
  };

  _proto.end = function end(token) {
    if (this.current.nodes && this.current.nodes.length) {
      this.current.raws.semicolon = this.semicolon;
    }

    this.semicolon = false;
    this.current.raws.after = (this.current.raws.after || '') + this.spaces;
    this.spaces = '';

    if (this.current.parent) {
      this.current.source.end = {
        line: token[2],
        column: token[3]
      };
      this.current = this.current.parent;
    } else {
      this.unexpectedClose(token);
    }
  };

  _proto.endFile = function endFile() {
    if (this.current.parent) this.unclosedBlock();

    if (this.current.nodes && this.current.nodes.length) {
      this.current.raws.semicolon = this.semicolon;
    }

    this.current.raws.after = (this.current.raws.after || '') + this.spaces;
  };

  _proto.freeSemicolon = function freeSemicolon(token) {
    this.spaces += token[1];

    if (this.current.nodes) {
      var prev = this.current.nodes[this.current.nodes.length - 1];

      if (prev && prev.type === 'rule' && !prev.raws.ownSemicolon) {
        prev.raws.ownSemicolon = this.spaces;
        this.spaces = '';
      }
    }
  } // Helpers
  ;

  _proto.init = function init(node, line, column) {
    this.current.push(node);
    node.source = {
      start: {
        line: line,
        column: column
      },
      input: this.input
    };
    node.raws.before = this.spaces;
    this.spaces = '';
    if (node.type !== 'comment') this.semicolon = false;
  };

  _proto.raw = function raw(node, prop, tokens) {
    var token, type;
    var length = tokens.length;
    var value = '';
    var clean = true;
    var next, prev;
    var pattern = /^([.|#])?([\w])+/i;

    for (var i = 0; i < length; i += 1) {
      token = tokens[i];
      type = token[0];

      if (type === 'comment' && node.type === 'rule') {
        prev = tokens[i - 1];
        next = tokens[i + 1];

        if (prev[0] !== 'space' && next[0] !== 'space' && pattern.test(prev[1]) && pattern.test(next[1])) {
          value += token[1];
        } else {
          clean = false;
        }

        continue;
      }

      if (type === 'comment' || type === 'space' && i === length - 1) {
        clean = false;
      } else {
        value += token[1];
      }
    }

    if (!clean) {
      var raw = tokens.reduce(function (all, i) {
        return all + i[1];
      }, '');
      node.raws[prop] = {
        value: value,
        raw: raw
      };
    }

    node[prop] = value;
  };

  _proto.spacesAndCommentsFromEnd = function spacesAndCommentsFromEnd(tokens) {
    var lastTokenType;
    var spaces = '';

    while (tokens.length) {
      lastTokenType = tokens[tokens.length - 1][0];
      if (lastTokenType !== 'space' && lastTokenType !== 'comment') break;
      spaces = tokens.pop()[1] + spaces;
    }

    return spaces;
  };

  _proto.spacesAndCommentsFromStart = function spacesAndCommentsFromStart(tokens) {
    var next;
    var spaces = '';

    while (tokens.length) {
      next = tokens[0][0];
      if (next !== 'space' && next !== 'comment') break;
      spaces += tokens.shift()[1];
    }

    return spaces;
  };

  _proto.spacesFromEnd = function spacesFromEnd(tokens) {
    var lastTokenType;
    var spaces = '';

    while (tokens.length) {
      lastTokenType = tokens[tokens.length - 1][0];
      if (lastTokenType !== 'space') break;
      spaces = tokens.pop()[1] + spaces;
    }

    return spaces;
  };

  _proto.stringFrom = function stringFrom(tokens, from) {
    var result = '';

    for (var i = from; i < tokens.length; i++) {
      result += tokens[i][1];
    }

    tokens.splice(from, tokens.length - from);
    return result;
  };

  _proto.colon = function colon(tokens) {
    var brackets = 0;
    var token, type, prev;

    for (var i = 0; i < tokens.length; i++) {
      token = tokens[i];
      type = token[0];

      if (type === '(') {
        brackets += 1;
      }

      if (type === ')') {
        brackets -= 1;
      }

      if (brackets === 0 && type === ':') {
        if (!prev) {
          this.doubleColon(token);
        } else if (prev[0] === 'word' && prev[1] === 'progid') {
          continue;
        } else {
          return i;
        }
      }

      prev = token;
    }

    return false;
  } // Errors
  ;

  _proto.unclosedBracket = function unclosedBracket(bracket) {
    throw this.input.error('Unclosed bracket', bracket[2], bracket[3]);
  };

  _proto.unknownWord = function unknownWord(tokens) {
    throw this.input.error('Unknown word', tokens[0][2], tokens[0][3]);
  };

  _proto.unexpectedClose = function unexpectedClose(token) {
    throw this.input.error('Unexpected }', token[2], token[3]);
  };

  _proto.unclosedBlock = function unclosedBlock() {
    var pos = this.current.source.start;
    throw this.input.error('Unclosed block', pos.line, pos.column);
  };

  _proto.doubleColon = function doubleColon(token) {
    throw this.input.error('Double colon', token[2], token[3]);
  };

  _proto.unnamedAtrule = function unnamedAtrule(node, token) {
    throw this.input.error('At-rule without name', token[2], token[3]);
  };

  _proto.precheckMissedSemicolon = function precheckMissedSemicolon()
  /* tokens */
  {// Hook for Safe Parser
  };

  _proto.checkMissedSemicolon = function checkMissedSemicolon(tokens) {
    var colon = this.colon(tokens);
    if (colon === false) return;
    var founded = 0;
    var token;

    for (var j = colon - 1; j >= 0; j--) {
      token = tokens[j];

      if (token[0] !== 'space') {
        founded += 1;
        if (founded === 2) break;
      }
    }

    throw this.input.error('Missed semicolon', token[2], token[3]);
  };

  return Parser;
}();

exports.default = Parser;
module.exports = exports.default;


},{"./at-rule":1062,"./comment":1063,"./declaration":1066,"./root":1078,"./rule":1079,"./tokenize":1082}],1074:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports.default = void 0;

var _declaration = _interopRequireDefault(require("./declaration"));

var _processor = _interopRequireDefault(require("./processor"));

var _stringify = _interopRequireDefault(require("./stringify"));

var _comment = _interopRequireDefault(require("./comment"));

var _atRule = _interopRequireDefault(require("./at-rule"));

var _vendor = _interopRequireDefault(require("./vendor"));

var _parse = _interopRequireDefault(require("./parse"));

var _list = _interopRequireDefault(require("./list"));

var _rule = _interopRequireDefault(require("./rule"));

var _root = _interopRequireDefault(require("./root"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Create a new {@link Processor} instance that will apply `plugins`
 * as CSS processors.
 *
 * @param {Array.<Plugin|pluginFunction>|Processor} plugins PostCSS plugins.
 *        See {@link Processor#use} for plugin format.
 *
 * @return {Processor} Processor to process multiple CSS.
 *
 * @example
 * import postcss from 'postcss'
 *
 * postcss(plugins).process(css, { from, to }).then(result => {
 *   console.log(result.css)
 * })
 *
 * @namespace postcss
 */
function postcss() {
  for (var _len = arguments.length, plugins = new Array(_len), _key = 0; _key < _len; _key++) {
    plugins[_key] = arguments[_key];
  }

  if (plugins.length === 1 && Array.isArray(plugins[0])) {
    plugins = plugins[0];
  }

  return new _processor.default(plugins);
}
/**
 * Creates a PostCSS plugin with a standard API.
 *
 * The newly-wrapped function will provide both the name and PostCSS
 * version of the plugin.
 *
 * ```js
 * const processor = postcss([replace])
 * processor.plugins[0].postcssPlugin  //=> 'postcss-replace'
 * processor.plugins[0].postcssVersion //=> '6.0.0'
 * ```
 *
 * The plugin function receives 2 arguments: {@link Root}
 * and {@link Result} instance. The function should mutate the provided
 * `Root` node. Alternatively, you can create a new `Root` node
 * and override the `result.root` property.
 *
 * ```js
 * const cleaner = postcss.plugin('postcss-cleaner', () => {
 *   return (root, result) => {
 *     result.root = postcss.root()
 *   }
 * })
 * ```
 *
 * As a convenience, plugins also expose a `process` method so that you can use
 * them as standalone tools.
 *
 * ```js
 * cleaner.process(css, processOpts, pluginOpts)
 * // This is equivalent to:
 * postcss([ cleaner(pluginOpts) ]).process(css, processOpts)
 * ```
 *
 * Asynchronous plugins should return a `Promise` instance.
 *
 * ```js
 * postcss.plugin('postcss-import', () => {
 *   return (root, result) => {
 *     return new Promise( (resolve, reject) => {
 *       fs.readFile('base.css', (base) => {
 *         root.prepend(base)
 *         resolve()
 *       })
 *     })
 *   }
 * })
 * ```
 *
 * Add warnings using the {@link Node#warn} method.
 * Send data to other plugins using the {@link Result#messages} array.
 *
 * ```js
 * postcss.plugin('postcss-caniuse-test', () => {
 *   return (root, result) => {
 *     root.walkDecls(decl => {
 *       if (!caniuse.support(decl.prop)) {
 *         decl.warn(result, 'Some browsers do not support ' + decl.prop)
 *       }
 *     })
 *   }
 * })
 * ```
 *
 * @param {string} name          PostCSS plugin name. Same as in `name`
 *                               property in `package.json`. It will be saved
 *                               in `plugin.postcssPlugin` property.
 * @param {function} initializer Will receive plugin options
 *                               and should return {@link pluginFunction}
 *
 * @return {Plugin} PostCSS plugin.
 */


postcss.plugin = function plugin(name, initializer) {
  function creator() {
    var transformer = initializer.apply(void 0, arguments);
    transformer.postcssPlugin = name;
    transformer.postcssVersion = new _processor.default().version;
    return transformer;
  }

  var cache;
  Object.defineProperty(creator, 'postcss', {
    get: function get() {
      if (!cache) cache = creator();
      return cache;
    }
  });

  creator.process = function (css, processOpts, pluginOpts) {
    return postcss([creator(pluginOpts)]).process(css, processOpts);
  };

  return creator;
};
/**
 * Default function to convert a node tree into a CSS string.
 *
 * @param {Node} node       Start node for stringifing. Usually {@link Root}.
 * @param {builder} builder Function to concatenate CSS from nodes parts
 *                          or generate string and source map.
 *
 * @return {void}
 *
 * @function
 */


postcss.stringify = _stringify.default;
/**
 * Parses source css and returns a new {@link Root} node,
 * which contains the source CSS nodes.
 *
 * @param {string|toString} css   String with input CSS or any object
 *                                with toString() method, like a Buffer
 * @param {processOptions} [opts] Options with only `from` and `map` keys.
 *
 * @return {Root} PostCSS AST.
 *
 * @example
 * // Simple CSS concatenation with source map support
 * const root1 = postcss.parse(css1, { from: file1 })
 * const root2 = postcss.parse(css2, { from: file2 })
 * root1.append(root2).toResult().css
 *
 * @function
 */

postcss.parse = _parse.default;
/**
 * Contains the {@link vendor} module.
 *
 * @type {vendor}
 *
 * @example
 * postcss.vendor.unprefixed('-moz-tab') //=> ['tab']
 */

postcss.vendor = _vendor.default;
/**
 * Contains the {@link list} module.
 *
 * @member {list}
 *
 * @example
 * postcss.list.space('5px calc(10% + 5px)') //=> ['5px', 'calc(10% + 5px)']
 */

postcss.list = _list.default;
/**
 * Creates a new {@link Comment} node.
 *
 * @param {object} [defaults] Properties for the new node.
 *
 * @return {Comment} New comment node
 *
 * @example
 * postcss.comment({ text: 'test' })
 */

postcss.comment = function (defaults) {
  return new _comment.default(defaults);
};
/**
 * Creates a new {@link AtRule} node.
 *
 * @param {object} [defaults] Properties for the new node.
 *
 * @return {AtRule} new at-rule node
 *
 * @example
 * postcss.atRule({ name: 'charset' }).toString() //=> "@charset"
 */


postcss.atRule = function (defaults) {
  return new _atRule.default(defaults);
};
/**
 * Creates a new {@link Declaration} node.
 *
 * @param {object} [defaults] Properties for the new node.
 *
 * @return {Declaration} new declaration node
 *
 * @example
 * postcss.decl({ prop: 'color', value: 'red' }).toString() //=> "color: red"
 */


postcss.decl = function (defaults) {
  return new _declaration.default(defaults);
};
/**
 * Creates a new {@link Rule} node.
 *
 * @param {object} [defaults] Properties for the new node.
 *
 * @return {Rule} new rule node
 *
 * @example
 * postcss.rule({ selector: 'a' }).toString() //=> "a {\n}"
 */


postcss.rule = function (defaults) {
  return new _rule.default(defaults);
};
/**
 * Creates a new {@link Root} node.
 *
 * @param {object} [defaults] Properties for the new node.
 *
 * @return {Root} new root node.
 *
 * @example
 * postcss.root({ after: '\n' }).toString() //=> "\n"
 */


postcss.root = function (defaults) {
  return new _root.default(defaults);
};

var _default = postcss;
exports.default = _default;
module.exports = exports.default;


},{"./at-rule":1062,"./comment":1063,"./declaration":1066,"./list":1069,"./parse":1072,"./processor":1076,"./root":1078,"./rule":1079,"./stringify":1081,"./vendor":1083}],1075:[function(require,module,exports){
(function (Buffer){
"use strict";

exports.__esModule = true;
exports.default = void 0;

var _sourceMap = _interopRequireDefault(require("source-map"));

var _path = _interopRequireDefault(require("path"));

var _fs = _interopRequireDefault(require("fs"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function fromBase64(str) {
  if (Buffer) {
    return Buffer.from(str, 'base64').toString();
  } else {
    return window.atob(str);
  }
}
/**
 * Source map information from input CSS.
 * For example, source map after Sass compiler.
 *
 * This class will automatically find source map in input CSS or in file system
 * near input file (according `from` option).
 *
 * @example
 * const root = postcss.parse(css, { from: 'a.sass.css' })
 * root.input.map //=> PreviousMap
 */


var PreviousMap =
/*#__PURE__*/
function () {
  /**
   * @param {string}         css    Input CSS source.
   * @param {processOptions} [opts] {@link Processor#process} options.
   */
  function PreviousMap(css, opts) {
    this.loadAnnotation(css);
    /**
     * Was source map inlined by data-uri to input CSS.
     *
     * @type {boolean}
     */

    this.inline = this.startWith(this.annotation, 'data:');
    var prev = opts.map ? opts.map.prev : undefined;
    var text = this.loadMap(opts.from, prev);
    if (text) this.text = text;
  }
  /**
   * Create a instance of `SourceMapGenerator` class
   * from the `source-map` library to work with source map information.
   *
   * It is lazy method, so it will create object only on first call
   * and then it will use cache.
   *
   * @return {SourceMapGenerator} Object with source map information.
   */


  var _proto = PreviousMap.prototype;

  _proto.consumer = function consumer() {
    if (!this.consumerCache) {
      this.consumerCache = new _sourceMap.default.SourceMapConsumer(this.text);
    }

    return this.consumerCache;
  }
  /**
   * Does source map contains `sourcesContent` with input source text.
   *
   * @return {boolean} Is `sourcesContent` present.
   */
  ;

  _proto.withContent = function withContent() {
    return !!(this.consumer().sourcesContent && this.consumer().sourcesContent.length > 0);
  };

  _proto.startWith = function startWith(string, start) {
    if (!string) return false;
    return string.substr(0, start.length) === start;
  };

  _proto.loadAnnotation = function loadAnnotation(css) {
    var match = css.match(/\/\*\s*# sourceMappingURL=(.*)\s*\*\//);
    if (match) this.annotation = match[1].trim();
  };

  _proto.decodeInline = function decodeInline(text) {
    var baseCharsetUri = /^data:application\/json;charset=utf-?8;base64,/;
    var baseUri = /^data:application\/json;base64,/;
    var uri = 'data:application/json,';

    if (this.startWith(text, uri)) {
      return decodeURIComponent(text.substr(uri.length));
    }

    if (baseCharsetUri.test(text) || baseUri.test(text)) {
      return fromBase64(text.substr(RegExp.lastMatch.length));
    }

    var encoding = text.match(/data:application\/json;([^,]+),/)[1];
    throw new Error('Unsupported source map encoding ' + encoding);
  };

  _proto.loadMap = function loadMap(file, prev) {
    if (prev === false) return false;

    if (prev) {
      if (typeof prev === 'string') {
        return prev;
      } else if (typeof prev === 'function') {
        var prevPath = prev(file);

        if (prevPath && _fs.default.existsSync && _fs.default.existsSync(prevPath)) {
          return _fs.default.readFileSync(prevPath, 'utf-8').toString().trim();
        } else {
          throw new Error('Unable to load previous source map: ' + prevPath.toString());
        }
      } else if (prev instanceof _sourceMap.default.SourceMapConsumer) {
        return _sourceMap.default.SourceMapGenerator.fromSourceMap(prev).toString();
      } else if (prev instanceof _sourceMap.default.SourceMapGenerator) {
        return prev.toString();
      } else if (this.isMap(prev)) {
        return JSON.stringify(prev);
      } else {
        throw new Error('Unsupported previous source map format: ' + prev.toString());
      }
    } else if (this.inline) {
      return this.decodeInline(this.annotation);
    } else if (this.annotation) {
      var map = this.annotation;
      if (file) map = _path.default.join(_path.default.dirname(file), map);
      this.root = _path.default.dirname(map);

      if (_fs.default.existsSync && _fs.default.existsSync(map)) {
        return _fs.default.readFileSync(map, 'utf-8').toString().trim();
      } else {
        return false;
      }
    }
  };

  _proto.isMap = function isMap(map) {
    if (typeof map !== 'object') return false;
    return typeof map.mappings === 'string' || typeof map._mappings === 'string';
  };

  return PreviousMap;
}();

var _default = PreviousMap;
exports.default = _default;
module.exports = exports.default;


}).call(this,require("buffer").Buffer)
},{"buffer":13,"fs":7,"path":802,"source-map":1096}],1076:[function(require,module,exports){
(function (process){
"use strict";

exports.__esModule = true;
exports.default = void 0;

var _lazyResult = _interopRequireDefault(require("./lazy-result"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Contains plugins to process CSS. Create one `Processor` instance,
 * initialize its plugins, and then use that instance on numerous CSS files.
 *
 * @example
 * const processor = postcss([autoprefixer, precss])
 * processor.process(css1).then(result => console.log(result.css))
 * processor.process(css2).then(result => console.log(result.css))
 */
var Processor =
/*#__PURE__*/
function () {
  /**
   * @param {Array.<Plugin|pluginFunction>|Processor} plugins PostCSS plugins.
   *        See {@link Processor#use} for plugin format.
   */
  function Processor(plugins) {
    if (plugins === void 0) {
      plugins = [];
    }

    /**
     * Current PostCSS version.
     *
     * @type {string}
     *
     * @example
     * if (result.processor.version.split('.')[0] !== '6') {
     *   throw new Error('This plugin works only with PostCSS 6')
     * }
     */
    this.version = '7.0.14';
    /**
     * Plugins added to this processor.
     *
     * @type {pluginFunction[]}
     *
     * @example
     * const processor = postcss([autoprefixer, precss])
     * processor.plugins.length //=> 2
     */

    this.plugins = this.normalize(plugins);
  }
  /**
   * Adds a plugin to be used as a CSS processor.
   *
   * PostCSS plugin can be in 4 formats:
   * * A plugin created by {@link postcss.plugin} method.
   * * A function. PostCSS will pass the function a @{link Root}
   *   as the first argument and current {@link Result} instance
   *   as the second.
   * * An object with a `postcss` method. PostCSS will use that method
   *   as described in #2.
   * * Another {@link Processor} instance. PostCSS will copy plugins
   *   from that instance into this one.
   *
   * Plugins can also be added by passing them as arguments when creating
   * a `postcss` instance (see [`postcss(plugins)`]).
   *
   * Asynchronous plugins should return a `Promise` instance.
   *
   * @param {Plugin|pluginFunction|Processor} plugin PostCSS plugin
   *                                                 or {@link Processor}
   *                                                 with plugins.
   *
   * @example
   * const processor = postcss()
   *   .use(autoprefixer)
   *   .use(precss)
   *
   * @return {Processes} Current processor to make methods chain.
   */


  var _proto = Processor.prototype;

  _proto.use = function use(plugin) {
    this.plugins = this.plugins.concat(this.normalize([plugin]));
    return this;
  }
  /**
   * Parses source CSS and returns a {@link LazyResult} Promise proxy.
   * Because some plugins can be asynchronous it doesnt make
   * any transformations. Transformations will be applied
   * in the {@link LazyResult} methods.
   *
   * @param {string|toString|Result} css String with input CSS or any object
   *                                     with a `toString()` method,
   *                                     like a Buffer. Optionally, send
   *                                     a {@link Result} instance
   *                                     and the processor will take
   *                                     the {@link Root} from it.
   * @param {processOptions} [opts]      Options.
   *
   * @return {LazyResult} Promise proxy.
   *
   * @example
   * processor.process(css, { from: 'a.css', to: 'a.out.css' })
   *   .then(result => {
   *      console.log(result.css)
   *   })
   */
  ;

  _proto.process = function (_process) {
    function process(_x) {
      return _process.apply(this, arguments);
    }

    process.toString = function () {
      return _process.toString();
    };

    return process;
  }(function (css, opts) {
    if (opts === void 0) {
      opts = {};
    }

    if (this.plugins.length === 0 && opts.parser === opts.stringifier) {
      if (process.env.NODE_ENV !== 'production') {
        if (typeof console !== 'undefined' && console.warn) {
          console.warn('You did not set any plugins, parser, or stringifier. ' + 'Right now, PostCSS does nothing. Pick plugins for your case ' + 'on https://www.postcss.parts/ and use them in postcss.config.js.');
        }
      }
    }

    return new _lazyResult.default(this, css, opts);
  });

  _proto.normalize = function normalize(plugins) {
    var normalized = [];

    for (var _iterator = plugins, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var i = _ref;
      if (i.postcss) i = i.postcss;

      if (typeof i === 'object' && Array.isArray(i.plugins)) {
        normalized = normalized.concat(i.plugins);
      } else if (typeof i === 'function') {
        normalized.push(i);
      } else if (typeof i === 'object' && (i.parse || i.stringify)) {
        if (process.env.NODE_ENV !== 'production') {
          throw new Error('PostCSS syntaxes cannot be used as plugins. Instead, please use ' + 'one of the syntax/parser/stringifier options as outlined ' + 'in your PostCSS runner documentation.');
        }
      } else {
        throw new Error(i + ' is not a PostCSS plugin');
      }
    }

    return normalized;
  };

  return Processor;
}();

var _default = Processor;
/**
 * @callback builder
 * @param {string} part          Part of generated CSS connected to this node.
 * @param {Node}   node          AST node.
 * @param {"start"|"end"} [type] Nodes part type.
 */

/**
 * @callback parser
 *
 * @param {string|toString} css   String with input CSS or any object
 *                                with toString() method, like a Buffer.
 * @param {processOptions} [opts] Options with only `from` and `map` keys.
 *
 * @return {Root} PostCSS AST
 */

/**
 * @callback stringifier
 *
 * @param {Node} node       Start node for stringifing. Usually {@link Root}.
 * @param {builder} builder Function to concatenate CSS from nodes parts
 *                          or generate string and source map.
 *
 * @return {void}
 */

/**
 * @typedef {object} syntax
 * @property {parser} parse          Function to generate AST by string.
 * @property {stringifier} stringify Function to generate string by AST.
 */

/**
 * @typedef {object} toString
 * @property {function} toString
 */

/**
 * @callback pluginFunction
 * @param {Root} root     Parsed input CSS.
 * @param {Result} result Result to set warnings or check other plugins.
 */

/**
 * @typedef {object} Plugin
 * @property {function} postcss PostCSS plugin function.
 */

/**
 * @typedef {object} processOptions
 * @property {string} from             The path of the CSS source file.
 *                                     You should always set `from`,
 *                                     because it is used in source map
 *                                     generation and syntax error messages.
 * @property {string} to               The path where youll put the output
 *                                     CSS file. You should always set `to`
 *                                     to generate correct source maps.
 * @property {parser} parser           Function to generate AST by string.
 * @property {stringifier} stringifier Class to generate string by AST.
 * @property {syntax} syntax           Object with `parse` and `stringify`.
 * @property {object} map              Source map options.
 * @property {boolean} map.inline                    Does source map should
 *                                                   be embedded in the output
 *                                                   CSS as a base64-encoded
 *                                                   comment.
 * @property {string|object|false|function} map.prev Source map content
 *                                                   from a previous
 *                                                   processing step
 *                                                   (for example, Sass).
 *                                                   PostCSS will try to find
 *                                                   previous map automatically,
 *                                                   so you could disable it by
 *                                                   `false` value.
 * @property {boolean} map.sourcesContent            Does PostCSS should set
 *                                                   the origin content to map.
 * @property {string|false} map.annotation           Does PostCSS should set
 *                                                   annotation comment to map.
 * @property {string} map.from                       Override `from` in maps
 *                                                   sources`.
 */

exports.default = _default;
module.exports = exports.default;


}).call(this,require('_process'))
},{"./lazy-result":1068,"_process":1098}],1077:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports.default = void 0;

var _warning = _interopRequireDefault(require("./warning"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * Provides the result of the PostCSS transformations.
 *
 * A Result instance is returned by {@link LazyResult#then}
 * or {@link Root#toResult} methods.
 *
 * @example
 * postcss([autoprefixer]).process(css).then(result => {
 *  console.log(result.css)
 * })
 *
 * @example
 * const result2 = postcss.parse(css).toResult()
 */
var Result =
/*#__PURE__*/
function () {
  /**
   * @param {Processor} processor Processor used for this transformation.
   * @param {Root}      root      Root node after all transformations.
   * @param {processOptions} opts Options from the {@link Processor#process}
   *                              or {@link Root#toResult}.
   */
  function Result(processor, root, opts) {
    /**
     * The Processor instance used for this transformation.
     *
     * @type {Processor}
     *
     * @example
     * for (const plugin of result.processor.plugins) {
     *   if (plugin.postcssPlugin === 'postcss-bad') {
     *     throw 'postcss-good is incompatible with postcss-bad'
     *   }
     * })
     */
    this.processor = processor;
    /**
     * Contains messages from plugins (e.g., warnings or custom messages).
     * Each message should have type and plugin properties.
     *
     * @type {Message[]}
     *
     * @example
     * postcss.plugin('postcss-min-browser', () => {
     *   return (root, result) => {
     *     const browsers = detectMinBrowsersByCanIUse(root)
     *     result.messages.push({
     *       type: 'min-browser',
     *       plugin: 'postcss-min-browser',
     *       browsers
     *     })
     *   }
     * })
     */

    this.messages = [];
    /**
     * Root node after all transformations.
     *
     * @type {Root}
     *
     * @example
     * root.toResult().root === root
     */

    this.root = root;
    /**
     * Options from the {@link Processor#process} or {@link Root#toResult} call
     * that produced this Result instance.
     *
     * @type {processOptions}
     *
     * @example
     * root.toResult(opts).opts === opts
     */

    this.opts = opts;
    /**
     * A CSS string representing of {@link Result#root}.
     *
     * @type {string}
     *
     * @example
     * postcss.parse('a{}').toResult().css //=> "a{}"
     */

    this.css = undefined;
    /**
     * An instance of `SourceMapGenerator` class from the `source-map` library,
     * representing changes to the {@link Result#root} instance.
     *
     * @type {SourceMapGenerator}
     *
     * @example
     * result.map.toJSON() //=> { version: 3, file: 'a.css',  }
     *
     * @example
     * if (result.map) {
     *   fs.writeFileSync(result.opts.to + '.map', result.map.toString())
     * }
     */

    this.map = undefined;
  }
  /**
   * Returns for @{link Result#css} content.
   *
   * @example
   * result + '' === result.css
   *
   * @return {string} String representing of {@link Result#root}.
   */


  var _proto = Result.prototype;

  _proto.toString = function toString() {
    return this.css;
  }
  /**
   * Creates an instance of {@link Warning} and adds it
   * to {@link Result#messages}.
   *
   * @param {string} text        Warning message.
   * @param {Object} [opts]      Warning options.
   * @param {Node}   opts.node   CSS node that caused the warning.
   * @param {string} opts.word   Word in CSS source that caused the warning.
   * @param {number} opts.index  Index in CSS node string that caused
   *                             the warning.
   * @param {string} opts.plugin Name of the plugin that created
   *                             this warning. {@link Result#warn} fills
   *                             this property automatically.
   *
   * @return {Warning} Created warning.
   */
  ;

  _proto.warn = function warn(text, opts) {
    if (opts === void 0) {
      opts = {};
    }

    if (!opts.plugin) {
      if (this.lastPlugin && this.lastPlugin.postcssPlugin) {
        opts.plugin = this.lastPlugin.postcssPlugin;
      }
    }

    var warning = new _warning.default(text, opts);
    this.messages.push(warning);
    return warning;
  }
  /**
     * Returns warnings from plugins. Filters {@link Warning} instances
     * from {@link Result#messages}.
     *
     * @example
     * result.warnings().forEach(warn => {
     *   console.warn(warn.toString())
     * })
     *
     * @return {Warning[]} Warnings from plugins.
     */
  ;

  _proto.warnings = function warnings() {
    return this.messages.filter(function (i) {
      return i.type === 'warning';
    });
  }
  /**
   * An alias for the {@link Result#css} property.
   * Use it with syntaxes that generate non-CSS output.
   *
   * @type {string}
   *
   * @example
   * result.css === result.content
   */
  ;

  _createClass(Result, [{
    key: "content",
    get: function get() {
      return this.css;
    }
  }]);

  return Result;
}();

var _default = Result;
/**
 * @typedef  {object} Message
 * @property {string} type   Message type.
 * @property {string} plugin Source PostCSS plugin name.
 */

exports.default = _default;
module.exports = exports.default;


},{"./warning":1085}],1078:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports.default = void 0;

var _container = _interopRequireDefault(require("./container"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

/**
 * Represents a CSS file and contains all its parsed nodes.
 *
 * @extends Container
 *
 * @example
 * const root = postcss.parse('a{color:black} b{z-index:2}')
 * root.type         //=> 'root'
 * root.nodes.length //=> 2
 */
var Root =
/*#__PURE__*/
function (_Container) {
  _inheritsLoose(Root, _Container);

  function Root(defaults) {
    var _this;

    _this = _Container.call(this, defaults) || this;
    _this.type = 'root';
    if (!_this.nodes) _this.nodes = [];
    return _this;
  }

  var _proto = Root.prototype;

  _proto.removeChild = function removeChild(child, ignore) {
    var index = this.index(child);

    if (!ignore && index === 0 && this.nodes.length > 1) {
      this.nodes[1].raws.before = this.nodes[index].raws.before;
    }

    return _Container.prototype.removeChild.call(this, child);
  };

  _proto.normalize = function normalize(child, sample, type) {
    var nodes = _Container.prototype.normalize.call(this, child);

    if (sample) {
      if (type === 'prepend') {
        if (this.nodes.length > 1) {
          sample.raws.before = this.nodes[1].raws.before;
        } else {
          delete sample.raws.before;
        }
      } else if (this.first !== sample) {
        for (var _iterator = nodes, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
          var _ref;

          if (_isArray) {
            if (_i >= _iterator.length) break;
            _ref = _iterator[_i++];
          } else {
            _i = _iterator.next();
            if (_i.done) break;
            _ref = _i.value;
          }

          var node = _ref;
          node.raws.before = sample.raws.before;
        }
      }
    }

    return nodes;
  }
  /**
   * Returns a {@link Result} instance representing the roots CSS.
   *
   * @param {processOptions} [opts] Options with only `to` and `map` keys.
   *
   * @return {Result} Result with current roots CSS.
   *
   * @example
   * const root1 = postcss.parse(css1, { from: 'a.css' })
   * const root2 = postcss.parse(css2, { from: 'b.css' })
   * root1.append(root2)
   * const result = root1.toResult({ to: 'all.css', map: true })
   */
  ;

  _proto.toResult = function toResult(opts) {
    if (opts === void 0) {
      opts = {};
    }

    var LazyResult = require('./lazy-result');

    var Processor = require('./processor');

    var lazy = new LazyResult(new Processor(), this, opts);
    return lazy.stringify();
  }
  /**
   * @memberof Root#
   * @member {object} raws Information to generate byte-to-byte equal
   *                       node string as it was in the origin input.
   *
   * Every parser saves its own properties,
   * but the default CSS parser uses:
   *
   * * `after`: the space symbols after the last child to the end of file.
   * * `semicolon`: is the last child has an (optional) semicolon.
   *
   * @example
   * postcss.parse('a {}\n').raws //=> { after: '\n' }
   * postcss.parse('a {}').raws   //=> { after: '' }
   */
  ;

  return Root;
}(_container.default);

var _default = Root;
exports.default = _default;
module.exports = exports.default;


},{"./container":1064,"./lazy-result":1068,"./processor":1076}],1079:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports.default = void 0;

var _container = _interopRequireDefault(require("./container"));

var _list = _interopRequireDefault(require("./list"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

/**
 * Represents a CSS rule: a selector followed by a declaration block.
 *
 * @extends Container
 *
 * @example
 * const root = postcss.parse('a{}')
 * const rule = root.first
 * rule.type       //=> 'rule'
 * rule.toString() //=> 'a{}'
 */
var Rule =
/*#__PURE__*/
function (_Container) {
  _inheritsLoose(Rule, _Container);

  function Rule(defaults) {
    var _this;

    _this = _Container.call(this, defaults) || this;
    _this.type = 'rule';
    if (!_this.nodes) _this.nodes = [];
    return _this;
  }
  /**
   * An array containing the rules individual selectors.
   * Groups of selectors are split at commas.
   *
   * @type {string[]}
   *
   * @example
   * const root = postcss.parse('a, b { }')
   * const rule = root.first
   *
   * rule.selector  //=> 'a, b'
   * rule.selectors //=> ['a', 'b']
   *
   * rule.selectors = ['a', 'strong']
   * rule.selector //=> 'a, strong'
   */


  _createClass(Rule, [{
    key: "selectors",
    get: function get() {
      return _list.default.comma(this.selector);
    },
    set: function set(values) {
      var match = this.selector ? this.selector.match(/,\s*/) : null;
      var sep = match ? match[0] : ',' + this.raw('between', 'beforeOpen');
      this.selector = values.join(sep);
    }
    /**
     * @memberof Rule#
     * @member {string} selector The rules full selector represented
     *                           as a string.
     *
     * @example
     * const root = postcss.parse('a, b { }')
     * const rule = root.first
     * rule.selector //=> 'a, b'
     */

    /**
     * @memberof Rule#
     * @member {object} raws Information to generate byte-to-byte equal
     *                       node string as it was in the origin input.
     *
     * Every parser saves its own properties,
     * but the default CSS parser uses:
     *
     * * `before`: the space symbols before the node. It also stores `*`
     *   and `_` symbols before the declaration (IE hack).
     * * `after`: the space symbols after the last child of the node
     *   to the end of the node.
     * * `between`: the symbols between the property and value
     *   for declarations, selector and `{` for rules, or last parameter
     *   and `{` for at-rules.
     * * `semicolon`: contains `true` if the last child has
     *   an (optional) semicolon.
     * * `ownSemicolon`: contains `true` if there is semicolon after rule.
     *
     * PostCSS cleans selectors from comments and extra spaces,
     * but it stores origin content in raws properties.
     * As such, if you dont change a declarations value,
     * PostCSS will use the raw value with comments.
     *
     * @example
     * const root = postcss.parse('a {\n  color:black\n}')
     * root.first.first.raws //=> { before: '', between: ' ', after: '\n' }
     */

  }]);

  return Rule;
}(_container.default);

var _default = Rule;
exports.default = _default;
module.exports = exports.default;


},{"./container":1064,"./list":1069}],1080:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports.default = void 0;
var DEFAULT_RAW = {
  colon: ': ',
  indent: '    ',
  beforeDecl: '\n',
  beforeRule: '\n',
  beforeOpen: ' ',
  beforeClose: '\n',
  beforeComment: '\n',
  after: '\n',
  emptyBody: '',
  commentLeft: ' ',
  commentRight: ' ',
  semicolon: false
};

function capitalize(str) {
  return str[0].toUpperCase() + str.slice(1);
}

var Stringifier =
/*#__PURE__*/
function () {
  function Stringifier(builder) {
    this.builder = builder;
  }

  var _proto = Stringifier.prototype;

  _proto.stringify = function stringify(node, semicolon) {
    this[node.type](node, semicolon);
  };

  _proto.root = function root(node) {
    this.body(node);
    if (node.raws.after) this.builder(node.raws.after);
  };

  _proto.comment = function comment(node) {
    var left = this.raw(node, 'left', 'commentLeft');
    var right = this.raw(node, 'right', 'commentRight');
    this.builder('/*' + left + node.text + right + '*/', node);
  };

  _proto.decl = function decl(node, semicolon) {
    var between = this.raw(node, 'between', 'colon');
    var string = node.prop + between + this.rawValue(node, 'value');

    if (node.important) {
      string += node.raws.important || ' !important';
    }

    if (semicolon) string += ';';
    this.builder(string, node);
  };

  _proto.rule = function rule(node) {
    this.block(node, this.rawValue(node, 'selector'));

    if (node.raws.ownSemicolon) {
      this.builder(node.raws.ownSemicolon, node, 'end');
    }
  };

  _proto.atrule = function atrule(node, semicolon) {
    var name = '@' + node.name;
    var params = node.params ? this.rawValue(node, 'params') : '';

    if (typeof node.raws.afterName !== 'undefined') {
      name += node.raws.afterName;
    } else if (params) {
      name += ' ';
    }

    if (node.nodes) {
      this.block(node, name + params);
    } else {
      var end = (node.raws.between || '') + (semicolon ? ';' : '');
      this.builder(name + params + end, node);
    }
  };

  _proto.body = function body(node) {
    var last = node.nodes.length - 1;

    while (last > 0) {
      if (node.nodes[last].type !== 'comment') break;
      last -= 1;
    }

    var semicolon = this.raw(node, 'semicolon');

    for (var i = 0; i < node.nodes.length; i++) {
      var child = node.nodes[i];
      var before = this.raw(child, 'before');
      if (before) this.builder(before);
      this.stringify(child, last !== i || semicolon);
    }
  };

  _proto.block = function block(node, start) {
    var between = this.raw(node, 'between', 'beforeOpen');
    this.builder(start + between + '{', node, 'start');
    var after;

    if (node.nodes && node.nodes.length) {
      this.body(node);
      after = this.raw(node, 'after');
    } else {
      after = this.raw(node, 'after', 'emptyBody');
    }

    if (after) this.builder(after);
    this.builder('}', node, 'end');
  };

  _proto.raw = function raw(node, own, detect) {
    var value;
    if (!detect) detect = own; // Already had

    if (own) {
      value = node.raws[own];
      if (typeof value !== 'undefined') return value;
    }

    var parent = node.parent; // Hack for first rule in CSS

    if (detect === 'before') {
      if (!parent || parent.type === 'root' && parent.first === node) {
        return '';
      }
    } // Floating child without parent


    if (!parent) return DEFAULT_RAW[detect]; // Detect style by other nodes

    var root = node.root();
    if (!root.rawCache) root.rawCache = {};

    if (typeof root.rawCache[detect] !== 'undefined') {
      return root.rawCache[detect];
    }

    if (detect === 'before' || detect === 'after') {
      return this.beforeAfter(node, detect);
    } else {
      var method = 'raw' + capitalize(detect);

      if (this[method]) {
        value = this[method](root, node);
      } else {
        root.walk(function (i) {
          value = i.raws[own];
          if (typeof value !== 'undefined') return false;
        });
      }
    }

    if (typeof value === 'undefined') value = DEFAULT_RAW[detect];
    root.rawCache[detect] = value;
    return value;
  };

  _proto.rawSemicolon = function rawSemicolon(root) {
    var value;
    root.walk(function (i) {
      if (i.nodes && i.nodes.length && i.last.type === 'decl') {
        value = i.raws.semicolon;
        if (typeof value !== 'undefined') return false;
      }
    });
    return value;
  };

  _proto.rawEmptyBody = function rawEmptyBody(root) {
    var value;
    root.walk(function (i) {
      if (i.nodes && i.nodes.length === 0) {
        value = i.raws.after;
        if (typeof value !== 'undefined') return false;
      }
    });
    return value;
  };

  _proto.rawIndent = function rawIndent(root) {
    if (root.raws.indent) return root.raws.indent;
    var value;
    root.walk(function (i) {
      var p = i.parent;

      if (p && p !== root && p.parent && p.parent === root) {
        if (typeof i.raws.before !== 'undefined') {
          var parts = i.raws.before.split('\n');
          value = parts[parts.length - 1];
          value = value.replace(/[^\s]/g, '');
          return false;
        }
      }
    });
    return value;
  };

  _proto.rawBeforeComment = function rawBeforeComment(root, node) {
    var value;
    root.walkComments(function (i) {
      if (typeof i.raws.before !== 'undefined') {
        value = i.raws.before;

        if (value.indexOf('\n') !== -1) {
          value = value.replace(/[^\n]+$/, '');
        }

        return false;
      }
    });

    if (typeof value === 'undefined') {
      value = this.raw(node, null, 'beforeDecl');
    } else if (value) {
      value = value.replace(/[^\s]/g, '');
    }

    return value;
  };

  _proto.rawBeforeDecl = function rawBeforeDecl(root, node) {
    var value;
    root.walkDecls(function (i) {
      if (typeof i.raws.before !== 'undefined') {
        value = i.raws.before;

        if (value.indexOf('\n') !== -1) {
          value = value.replace(/[^\n]+$/, '');
        }

        return false;
      }
    });

    if (typeof value === 'undefined') {
      value = this.raw(node, null, 'beforeRule');
    } else if (value) {
      value = value.replace(/[^\s]/g, '');
    }

    return value;
  };

  _proto.rawBeforeRule = function rawBeforeRule(root) {
    var value;
    root.walk(function (i) {
      if (i.nodes && (i.parent !== root || root.first !== i)) {
        if (typeof i.raws.before !== 'undefined') {
          value = i.raws.before;

          if (value.indexOf('\n') !== -1) {
            value = value.replace(/[^\n]+$/, '');
          }

          return false;
        }
      }
    });
    if (value) value = value.replace(/[^\s]/g, '');
    return value;
  };

  _proto.rawBeforeClose = function rawBeforeClose(root) {
    var value;
    root.walk(function (i) {
      if (i.nodes && i.nodes.length > 0) {
        if (typeof i.raws.after !== 'undefined') {
          value = i.raws.after;

          if (value.indexOf('\n') !== -1) {
            value = value.replace(/[^\n]+$/, '');
          }

          return false;
        }
      }
    });
    if (value) value = value.replace(/[^\s]/g, '');
    return value;
  };

  _proto.rawBeforeOpen = function rawBeforeOpen(root) {
    var value;
    root.walk(function (i) {
      if (i.type !== 'decl') {
        value = i.raws.between;
        if (typeof value !== 'undefined') return false;
      }
    });
    return value;
  };

  _proto.rawColon = function rawColon(root) {
    var value;
    root.walkDecls(function (i) {
      if (typeof i.raws.between !== 'undefined') {
        value = i.raws.between.replace(/[^\s:]/g, '');
        return false;
      }
    });
    return value;
  };

  _proto.beforeAfter = function beforeAfter(node, detect) {
    var value;

    if (node.type === 'decl') {
      value = this.raw(node, null, 'beforeDecl');
    } else if (node.type === 'comment') {
      value = this.raw(node, null, 'beforeComment');
    } else if (detect === 'before') {
      value = this.raw(node, null, 'beforeRule');
    } else {
      value = this.raw(node, null, 'beforeClose');
    }

    var buf = node.parent;
    var depth = 0;

    while (buf && buf.type !== 'root') {
      depth += 1;
      buf = buf.parent;
    }

    if (value.indexOf('\n') !== -1) {
      var indent = this.raw(node, null, 'indent');

      if (indent.length) {
        for (var step = 0; step < depth; step++) {
          value += indent;
        }
      }
    }

    return value;
  };

  _proto.rawValue = function rawValue(node, prop) {
    var value = node[prop];
    var raw = node.raws[prop];

    if (raw && raw.value === value) {
      return raw.raw;
    }

    return value;
  };

  return Stringifier;
}();

var _default = Stringifier;
exports.default = _default;
module.exports = exports.default;


},{}],1081:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports.default = void 0;

var _stringifier = _interopRequireDefault(require("./stringifier"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function stringify(node, builder) {
  var str = new _stringifier.default(builder);
  str.stringify(node);
}

var _default = stringify;
exports.default = _default;
module.exports = exports.default;


},{"./stringifier":1080}],1082:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports.default = tokenizer;
var SINGLE_QUOTE = '\''.charCodeAt(0);
var DOUBLE_QUOTE = '"'.charCodeAt(0);
var BACKSLASH = '\\'.charCodeAt(0);
var SLASH = '/'.charCodeAt(0);
var NEWLINE = '\n'.charCodeAt(0);
var SPACE = ' '.charCodeAt(0);
var FEED = '\f'.charCodeAt(0);
var TAB = '\t'.charCodeAt(0);
var CR = '\r'.charCodeAt(0);
var OPEN_SQUARE = '['.charCodeAt(0);
var CLOSE_SQUARE = ']'.charCodeAt(0);
var OPEN_PARENTHESES = '('.charCodeAt(0);
var CLOSE_PARENTHESES = ')'.charCodeAt(0);
var OPEN_CURLY = '{'.charCodeAt(0);
var CLOSE_CURLY = '}'.charCodeAt(0);
var SEMICOLON = ';'.charCodeAt(0);
var ASTERISK = '*'.charCodeAt(0);
var COLON = ':'.charCodeAt(0);
var AT = '@'.charCodeAt(0);
var RE_AT_END = /[ \n\t\r\f{}()'"\\;/[\]#]/g;
var RE_WORD_END = /[ \n\t\r\f(){}:;@!'"\\\][#]|\/(?=\*)/g;
var RE_BAD_BRACKET = /.[\\/("'\n]/;
var RE_HEX_ESCAPE = /[a-f0-9]/i;

function tokenizer(input, options) {
  if (options === void 0) {
    options = {};
  }

  var css = input.css.valueOf();
  var ignore = options.ignoreErrors;
  var code, next, quote, lines, last, content, escape;
  var nextLine, nextOffset, escaped, escapePos, prev, n, currentToken;
  var length = css.length;
  var offset = -1;
  var line = 1;
  var pos = 0;
  var buffer = [];
  var returned = [];

  function position() {
    return pos;
  }

  function unclosed(what) {
    throw input.error('Unclosed ' + what, line, pos - offset);
  }

  function endOfFile() {
    return returned.length === 0 && pos >= length;
  }

  function nextToken(opts) {
    if (returned.length) return returned.pop();
    if (pos >= length) return;
    var ignoreUnclosed = opts ? opts.ignoreUnclosed : false;
    code = css.charCodeAt(pos);

    if (code === NEWLINE || code === FEED || code === CR && css.charCodeAt(pos + 1) !== NEWLINE) {
      offset = pos;
      line += 1;
    }

    switch (code) {
      case NEWLINE:
      case SPACE:
      case TAB:
      case CR:
      case FEED:
        next = pos;

        do {
          next += 1;
          code = css.charCodeAt(next);

          if (code === NEWLINE) {
            offset = next;
            line += 1;
          }
        } while (code === SPACE || code === NEWLINE || code === TAB || code === CR || code === FEED);

        currentToken = ['space', css.slice(pos, next)];
        pos = next - 1;
        break;

      case OPEN_SQUARE:
      case CLOSE_SQUARE:
      case OPEN_CURLY:
      case CLOSE_CURLY:
      case COLON:
      case SEMICOLON:
      case CLOSE_PARENTHESES:
        var controlChar = String.fromCharCode(code);
        currentToken = [controlChar, controlChar, line, pos - offset];
        break;

      case OPEN_PARENTHESES:
        prev = buffer.length ? buffer.pop()[1] : '';
        n = css.charCodeAt(pos + 1);

        if (prev === 'url' && n !== SINGLE_QUOTE && n !== DOUBLE_QUOTE && n !== SPACE && n !== NEWLINE && n !== TAB && n !== FEED && n !== CR) {
          next = pos;

          do {
            escaped = false;
            next = css.indexOf(')', next + 1);

            if (next === -1) {
              if (ignore || ignoreUnclosed) {
                next = pos;
                break;
              } else {
                unclosed('bracket');
              }
            }

            escapePos = next;

            while (css.charCodeAt(escapePos - 1) === BACKSLASH) {
              escapePos -= 1;
              escaped = !escaped;
            }
          } while (escaped);

          currentToken = ['brackets', css.slice(pos, next + 1), line, pos - offset, line, next - offset];
          pos = next;
        } else {
          next = css.indexOf(')', pos + 1);
          content = css.slice(pos, next + 1);

          if (next === -1 || RE_BAD_BRACKET.test(content)) {
            currentToken = ['(', '(', line, pos - offset];
          } else {
            currentToken = ['brackets', content, line, pos - offset, line, next - offset];
            pos = next;
          }
        }

        break;

      case SINGLE_QUOTE:
      case DOUBLE_QUOTE:
        quote = code === SINGLE_QUOTE ? '\'' : '"';
        next = pos;

        do {
          escaped = false;
          next = css.indexOf(quote, next + 1);

          if (next === -1) {
            if (ignore || ignoreUnclosed) {
              next = pos + 1;
              break;
            } else {
              unclosed('string');
            }
          }

          escapePos = next;

          while (css.charCodeAt(escapePos - 1) === BACKSLASH) {
            escapePos -= 1;
            escaped = !escaped;
          }
        } while (escaped);

        content = css.slice(pos, next + 1);
        lines = content.split('\n');
        last = lines.length - 1;

        if (last > 0) {
          nextLine = line + last;
          nextOffset = next - lines[last].length;
        } else {
          nextLine = line;
          nextOffset = offset;
        }

        currentToken = ['string', css.slice(pos, next + 1), line, pos - offset, nextLine, next - nextOffset];
        offset = nextOffset;
        line = nextLine;
        pos = next;
        break;

      case AT:
        RE_AT_END.lastIndex = pos + 1;
        RE_AT_END.test(css);

        if (RE_AT_END.lastIndex === 0) {
          next = css.length - 1;
        } else {
          next = RE_AT_END.lastIndex - 2;
        }

        currentToken = ['at-word', css.slice(pos, next + 1), line, pos - offset, line, next - offset];
        pos = next;
        break;

      case BACKSLASH:
        next = pos;
        escape = true;

        while (css.charCodeAt(next + 1) === BACKSLASH) {
          next += 1;
          escape = !escape;
        }

        code = css.charCodeAt(next + 1);

        if (escape && code !== SLASH && code !== SPACE && code !== NEWLINE && code !== TAB && code !== CR && code !== FEED) {
          next += 1;

          if (RE_HEX_ESCAPE.test(css.charAt(next))) {
            while (RE_HEX_ESCAPE.test(css.charAt(next + 1))) {
              next += 1;
            }

            if (css.charCodeAt(next + 1) === SPACE) {
              next += 1;
            }
          }
        }

        currentToken = ['word', css.slice(pos, next + 1), line, pos - offset, line, next - offset];
        pos = next;
        break;

      default:
        if (code === SLASH && css.charCodeAt(pos + 1) === ASTERISK) {
          next = css.indexOf('*/', pos + 2) + 1;

          if (next === 0) {
            if (ignore || ignoreUnclosed) {
              next = css.length;
            } else {
              unclosed('comment');
            }
          }

          content = css.slice(pos, next + 1);
          lines = content.split('\n');
          last = lines.length - 1;

          if (last > 0) {
            nextLine = line + last;
            nextOffset = next - lines[last].length;
          } else {
            nextLine = line;
            nextOffset = offset;
          }

          currentToken = ['comment', content, line, pos - offset, nextLine, next - nextOffset];
          offset = nextOffset;
          line = nextLine;
          pos = next;
        } else {
          RE_WORD_END.lastIndex = pos + 1;
          RE_WORD_END.test(css);

          if (RE_WORD_END.lastIndex === 0) {
            next = css.length - 1;
          } else {
            next = RE_WORD_END.lastIndex - 2;
          }

          currentToken = ['word', css.slice(pos, next + 1), line, pos - offset, line, next - offset];
          buffer.push(currentToken);
          pos = next;
        }

        break;
    }

    pos++;
    return currentToken;
  }

  function back(token) {
    returned.push(token);
  }

  return {
    back: back,
    nextToken: nextToken,
    endOfFile: endOfFile,
    position: position
  };
}

module.exports = exports.default;


},{}],1083:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports.default = void 0;

/**
 * Contains helpers for working with vendor prefixes.
 *
 * @example
 * const vendor = postcss.vendor
 *
 * @namespace vendor
 */
var vendor = {
  /**
   * Returns the vendor prefix extracted from an input string.
   *
   * @param {string} prop String with or without vendor prefix.
   *
   * @return {string} vendor prefix or empty string
   *
   * @example
   * postcss.vendor.prefix('-moz-tab-size') //=> '-moz-'
   * postcss.vendor.prefix('tab-size')      //=> ''
   */
  prefix: function prefix(prop) {
    var match = prop.match(/^(-\w+-)/);

    if (match) {
      return match[0];
    }

    return '';
  },

  /**
     * Returns the input string stripped of its vendor prefix.
     *
     * @param {string} prop String with or without vendor prefix.
     *
     * @return {string} String name without vendor prefixes.
     *
     * @example
     * postcss.vendor.unprefixed('-moz-tab-size') //=> 'tab-size'
     */
  unprefixed: function unprefixed(prop) {
    return prop.replace(/^-\w+-/, '');
  }
};
var _default = vendor;
exports.default = _default;
module.exports = exports.default;


},{}],1084:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports.default = warnOnce;
var printed = {};

function warnOnce(message) {
  if (printed[message]) return;
  printed[message] = true;

  if (typeof console !== 'undefined' && console.warn) {
    console.warn(message);
  }
}

module.exports = exports.default;


},{}],1085:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports.default = void 0;

/**
 * Represents a plugins warning. It can be created using {@link Node#warn}.
 *
 * @example
 * if (decl.important) {
 *   decl.warn(result, 'Avoid !important', { word: '!important' })
 * }
 */
var Warning =
/*#__PURE__*/
function () {
  /**
   * @param {string} text        Warning message.
   * @param {Object} [opts]      Warning options.
   * @param {Node}   opts.node   CSS node that caused the warning.
   * @param {string} opts.word   Word in CSS source that caused the warning.
   * @param {number} opts.index  Index in CSS node string that caused
   *                             the warning.
   * @param {string} opts.plugin Name of the plugin that created
   *                             this warning. {@link Result#warn} fills
   *                             this property automatically.
   */
  function Warning(text, opts) {
    if (opts === void 0) {
      opts = {};
    }

    /**
     * Type to filter warnings from {@link Result#messages}.
     * Always equal to `"warning"`.
     *
     * @type {string}
     *
     * @example
     * const nonWarning = result.messages.filter(i => i.type !== 'warning')
     */
    this.type = 'warning';
    /**
     * The warning message.
     *
     * @type {string}
     *
     * @example
     * warning.text //=> 'Try to avoid !important'
     */

    this.text = text;

    if (opts.node && opts.node.source) {
      var pos = opts.node.positionBy(opts);
      /**
       * Line in the input file with this warnings source.
       * @type {number}
       *
       * @example
       * warning.line //=> 5
       */

      this.line = pos.line;
      /**
       * Column in the input file with this warnings source.
       *
       * @type {number}
       *
       * @example
       * warning.column //=> 6
       */

      this.column = pos.column;
    }

    for (var opt in opts) {
      this[opt] = opts[opt];
    }
  }
  /**
   * Returns a warning position and message.
   *
   * @example
   * warning.toString() //=> 'postcss-lint:a.css:10:14: Avoid !important'
   *
   * @return {string} Warning position and message.
   */


  var _proto = Warning.prototype;

  _proto.toString = function toString() {
    if (this.node) {
      return this.node.error(this.text, {
        plugin: this.plugin,
        index: this.index,
        word: this.word
      }).message;
    }

    if (this.plugin) {
      return this.plugin + ': ' + this.text;
    }

    return this.text;
  }
  /**
   * @memberof Warning#
   * @member {string} plugin The name of the plugin that created
   *                         it will fill this property automatically.
   *                         this warning. When you call {@link Node#warn}
   *
   * @example
   * warning.plugin //=> 'postcss-important'
   */

  /**
   * @memberof Warning#
   * @member {Node} node Contains the CSS node that caused the warning.
   *
   * @example
   * warning.node.toString() //=> 'color: white !important'
   */
  ;

  return Warning;
}();

var _default = Warning;
exports.default = _default;
module.exports = exports.default;


},{}],1086:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var util = require('./util');
var has = Object.prototype.hasOwnProperty;
var hasNativeMap = typeof Map !== "undefined";

/**
 * A data structure which is a combination of an array and a set. Adding a new
 * member is O(1), testing for membership is O(1), and finding the index of an
 * element is O(1). Removing elements from the set is not supported. Only
 * strings are supported for membership.
 */
function ArraySet() {
  this._array = [];
  this._set = hasNativeMap ? new Map() : Object.create(null);
}

/**
 * Static method for creating ArraySet instances from an existing array.
 */
ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
  var set = new ArraySet();
  for (var i = 0, len = aArray.length; i < len; i++) {
    set.add(aArray[i], aAllowDuplicates);
  }
  return set;
};

/**
 * Return how many unique items are in this ArraySet. If duplicates have been
 * added, than those do not count towards the size.
 *
 * @returns Number
 */
ArraySet.prototype.size = function ArraySet_size() {
  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
};

/**
 * Add the given string to this set.
 *
 * @param String aStr
 */
ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
  var idx = this._array.length;
  if (!isDuplicate || aAllowDuplicates) {
    this._array.push(aStr);
  }
  if (!isDuplicate) {
    if (hasNativeMap) {
      this._set.set(aStr, idx);
    } else {
      this._set[sStr] = idx;
    }
  }
};

/**
 * Is the given string a member of this set?
 *
 * @param String aStr
 */
ArraySet.prototype.has = function ArraySet_has(aStr) {
  if (hasNativeMap) {
    return this._set.has(aStr);
  } else {
    var sStr = util.toSetString(aStr);
    return has.call(this._set, sStr);
  }
};

/**
 * What is the index of the given string in the array?
 *
 * @param String aStr
 */
ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
  if (hasNativeMap) {
    var idx = this._set.get(aStr);
    if (idx >= 0) {
        return idx;
    }
  } else {
    var sStr = util.toSetString(aStr);
    if (has.call(this._set, sStr)) {
      return this._set[sStr];
    }
  }

  throw new Error('"' + aStr + '" is not in the set.');
};

/**
 * What is the element at the given index?
 *
 * @param Number aIdx
 */
ArraySet.prototype.at = function ArraySet_at(aIdx) {
  if (aIdx >= 0 && aIdx < this._array.length) {
    return this._array[aIdx];
  }
  throw new Error('No element indexed by ' + aIdx);
};

/**
 * Returns the array representation of this set (which has the proper indices
 * indicated by indexOf). Note that this is a copy of the internal array used
 * for storing the members so that no one can mess with internal state.
 */
ArraySet.prototype.toArray = function ArraySet_toArray() {
  return this._array.slice();
};

exports.ArraySet = ArraySet;

},{"./util":1095}],1087:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 *
 * Based on the Base 64 VLQ implementation in Closure Compiler:
 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
 *
 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above
 *    copyright notice, this list of conditions and the following
 *    disclaimer in the documentation and/or other materials provided
 *    with the distribution.
 *  * Neither the name of Google Inc. nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

var base64 = require('./base64');

// A single base 64 digit can contain 6 bits of data. For the base 64 variable
// length quantities we use in the source map spec, the first bit is the sign,
// the next four bits are the actual value, and the 6th bit is the
// continuation bit. The continuation bit tells us whether there are more
// digits in this value following this digit.
//
//   Continuation
//   |    Sign
//   |    |
//   V    V
//   101011

var VLQ_BASE_SHIFT = 5;

// binary: 100000
var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

// binary: 011111
var VLQ_BASE_MASK = VLQ_BASE - 1;

// binary: 100000
var VLQ_CONTINUATION_BIT = VLQ_BASE;

/**
 * Converts from a two-complement value to a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
 */
function toVLQSigned(aValue) {
  return aValue < 0
    ? ((-aValue) << 1) + 1
    : (aValue << 1) + 0;
}

/**
 * Converts to a two-complement value from a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
 */
function fromVLQSigned(aValue) {
  var isNegative = (aValue & 1) === 1;
  var shifted = aValue >> 1;
  return isNegative
    ? -shifted
    : shifted;
}

/**
 * Returns the base 64 VLQ encoded value.
 */
exports.encode = function base64VLQ_encode(aValue) {
  var encoded = "";
  var digit;

  var vlq = toVLQSigned(aValue);

  do {
    digit = vlq & VLQ_BASE_MASK;
    vlq >>>= VLQ_BASE_SHIFT;
    if (vlq > 0) {
      // There are still more digits in this value, so we must make sure the
      // continuation bit is marked.
      digit |= VLQ_CONTINUATION_BIT;
    }
    encoded += base64.encode(digit);
  } while (vlq > 0);

  return encoded;
};

/**
 * Decodes the next base 64 VLQ value from the given string and returns the
 * value and the rest of the string via the out parameter.
 */
exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
  var strLen = aStr.length;
  var result = 0;
  var shift = 0;
  var continuation, digit;

  do {
    if (aIndex >= strLen) {
      throw new Error("Expected more digits in base 64 VLQ value.");
    }

    digit = base64.decode(aStr.charCodeAt(aIndex++));
    if (digit === -1) {
      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
    }

    continuation = !!(digit & VLQ_CONTINUATION_BIT);
    digit &= VLQ_BASE_MASK;
    result = result + (digit << shift);
    shift += VLQ_BASE_SHIFT;
  } while (continuation);

  aOutParam.value = fromVLQSigned(result);
  aOutParam.rest = aIndex;
};

},{"./base64":1088}],1088:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

/**
 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
 */
exports.encode = function (number) {
  if (0 <= number && number < intToCharMap.length) {
    return intToCharMap[number];
  }
  throw new TypeError("Must be between 0 and 63: " + number);
};

/**
 * Decode a single base 64 character code digit to an integer. Returns -1 on
 * failure.
 */
exports.decode = function (charCode) {
  var bigA = 65;     // 'A'
  var bigZ = 90;     // 'Z'

  var littleA = 97;  // 'a'
  var littleZ = 122; // 'z'

  var zero = 48;     // '0'
  var nine = 57;     // '9'

  var plus = 43;     // '+'
  var slash = 47;    // '/'

  var littleOffset = 26;
  var numberOffset = 52;

  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
  if (bigA <= charCode && charCode <= bigZ) {
    return (charCode - bigA);
  }

  // 26 - 51: abcdefghijklmnopqrstuvwxyz
  if (littleA <= charCode && charCode <= littleZ) {
    return (charCode - littleA + littleOffset);
  }

  // 52 - 61: 0123456789
  if (zero <= charCode && charCode <= nine) {
    return (charCode - zero + numberOffset);
  }

  // 62: +
  if (charCode == plus) {
    return 62;
  }

  // 63: /
  if (charCode == slash) {
    return 63;
  }

  // Invalid base64 digit.
  return -1;
};

},{}],1089:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

exports.GREATEST_LOWER_BOUND = 1;
exports.LEAST_UPPER_BOUND = 2;

/**
 * Recursive implementation of binary search.
 *
 * @param aLow Indices here and lower do not contain the needle.
 * @param aHigh Indices here and higher do not contain the needle.
 * @param aNeedle The element being searched for.
 * @param aHaystack The non-empty array being searched.
 * @param aCompare Function which takes two elements and returns -1, 0, or 1.
 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 */
function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
  // This function terminates when one of the following is true:
  //
  //   1. We find the exact element we are looking for.
  //
  //   2. We did not find the exact element, but we can return the index of
  //      the next-closest element.
  //
  //   3. We did not find the exact element, and there is no next-closest
  //      element than the one we are searching for, so we return -1.
  var mid = Math.floor((aHigh - aLow) / 2) + aLow;
  var cmp = aCompare(aNeedle, aHaystack[mid], true);
  if (cmp === 0) {
    // Found the element we are looking for.
    return mid;
  }
  else if (cmp > 0) {
    // Our needle is greater than aHaystack[mid].
    if (aHigh - mid > 1) {
      // The element is in the upper half.
      return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
    }

    // The exact needle element was not found in this haystack. Determine if
    // we are in termination case (3) or (2) and return the appropriate thing.
    if (aBias == exports.LEAST_UPPER_BOUND) {
      return aHigh < aHaystack.length ? aHigh : -1;
    } else {
      return mid;
    }
  }
  else {
    // Our needle is less than aHaystack[mid].
    if (mid - aLow > 1) {
      // The element is in the lower half.
      return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
    }

    // we are in termination case (3) or (2) and return the appropriate thing.
    if (aBias == exports.LEAST_UPPER_BOUND) {
      return mid;
    } else {
      return aLow < 0 ? -1 : aLow;
    }
  }
}

/**
 * This is an implementation of binary search which will always try and return
 * the index of the closest element if there is no exact hit. This is because
 * mappings between original and generated line/col pairs are single points,
 * and there is an implicit region between each of them, so a miss just means
 * that you aren't on the very start of a region.
 *
 * @param aNeedle The element you are looking for.
 * @param aHaystack The array that is being searched.
 * @param aCompare A function which takes the needle and an element in the
 *     array and returns -1, 0, or 1 depending on whether the needle is less
 *     than, equal to, or greater than the element, respectively.
 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.
 */
exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
  if (aHaystack.length === 0) {
    return -1;
  }

  var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack,
                              aCompare, aBias || exports.GREATEST_LOWER_BOUND);
  if (index < 0) {
    return -1;
  }

  // We have found either the exact element, or the next-closest element than
  // the one we are searching for. However, there may be more than one such
  // element. Make sure we always return the smallest of these.
  while (index - 1 >= 0) {
    if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
      break;
    }
    --index;
  }

  return index;
};

},{}],1090:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2014 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var util = require('./util');

/**
 * Determine whether mappingB is after mappingA with respect to generated
 * position.
 */
function generatedPositionAfter(mappingA, mappingB) {
  // Optimized for most common case
  var lineA = mappingA.generatedLine;
  var lineB = mappingB.generatedLine;
  var columnA = mappingA.generatedColumn;
  var columnB = mappingB.generatedColumn;
  return lineB > lineA || lineB == lineA && columnB >= columnA ||
         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
}

/**
 * A data structure to provide a sorted view of accumulated mappings in a
 * performance conscious manner. It trades a neglibable overhead in general
 * case for a large speedup in case of mappings being added in order.
 */
function MappingList() {
  this._array = [];
  this._sorted = true;
  // Serves as infimum
  this._last = {generatedLine: -1, generatedColumn: 0};
}

/**
 * Iterate through internal items. This method takes the same arguments that
 * `Array.prototype.forEach` takes.
 *
 * NOTE: The order of the mappings is NOT guaranteed.
 */
MappingList.prototype.unsortedForEach =
  function MappingList_forEach(aCallback, aThisArg) {
    this._array.forEach(aCallback, aThisArg);
  };

/**
 * Add the given source mapping.
 *
 * @param Object aMapping
 */
MappingList.prototype.add = function MappingList_add(aMapping) {
  if (generatedPositionAfter(this._last, aMapping)) {
    this._last = aMapping;
    this._array.push(aMapping);
  } else {
    this._sorted = false;
    this._array.push(aMapping);
  }
};

/**
 * Returns the flat, sorted array of mappings. The mappings are sorted by
 * generated position.
 *
 * WARNING: This method returns internal data without copying, for
 * performance. The return value must NOT be mutated, and should be treated as
 * an immutable borrow. If you want to take ownership, you must make your own
 * copy.
 */
MappingList.prototype.toArray = function MappingList_toArray() {
  if (!this._sorted) {
    this._array.sort(util.compareByGeneratedPositionsInflated);
    this._sorted = true;
  }
  return this._array;
};

exports.MappingList = MappingList;

},{"./util":1095}],1091:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

// It turns out that some (most?) JavaScript engines don't self-host
// `Array.prototype.sort`. This makes sense because C++ will likely remain
// faster than JS when doing raw CPU-intensive sorting. However, when using a
// custom comparator function, calling back and forth between the VM's C++ and
// JIT'd JS is rather slow *and* loses JIT type information, resulting in
// worse generated code for the comparator function than would be optimal. In
// fact, when sorting with a comparator, these costs outweigh the benefits of
// sorting in C++. By using our own JS-implemented Quick Sort (below), we get
// a ~3500ms mean speed-up in `bench/bench.html`.

/**
 * Swap the elements indexed by `x` and `y` in the array `ary`.
 *
 * @param {Array} ary
 *        The array.
 * @param {Number} x
 *        The index of the first item.
 * @param {Number} y
 *        The index of the second item.
 */
function swap(ary, x, y) {
  var temp = ary[x];
  ary[x] = ary[y];
  ary[y] = temp;
}

/**
 * Returns a random integer within the range `low .. high` inclusive.
 *
 * @param {Number} low
 *        The lower bound on the range.
 * @param {Number} high
 *        The upper bound on the range.
 */
function randomIntInRange(low, high) {
  return Math.round(low + (Math.random() * (high - low)));
}

/**
 * The Quick Sort algorithm.
 *
 * @param {Array} ary
 *        An array to sort.
 * @param {function} comparator
 *        Function to use to compare two items.
 * @param {Number} p
 *        Start index of the array
 * @param {Number} r
 *        End index of the array
 */
function doQuickSort(ary, comparator, p, r) {
  // If our lower bound is less than our upper bound, we (1) partition the
  // array into two pieces and (2) recurse on each half. If it is not, this is
  // the empty array and our base case.

  if (p < r) {
    // (1) Partitioning.
    //
    // The partitioning chooses a pivot between `p` and `r` and moves all
    // elements that are less than or equal to the pivot to the before it, and
    // all the elements that are greater than it after it. The effect is that
    // once partition is done, the pivot is in the exact place it will be when
    // the array is put in sorted order, and it will not need to be moved
    // again. This runs in O(n) time.

    // Always choose a random pivot so that an input array which is reverse
    // sorted does not cause O(n^2) running time.
    var pivotIndex = randomIntInRange(p, r);
    var i = p - 1;

    swap(ary, pivotIndex, r);
    var pivot = ary[r];

    // Immediately after `j` is incremented in this loop, the following hold
    // true:
    //
    //   * Every element in `ary[p .. i]` is less than or equal to the pivot.
    //
    //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.
    for (var j = p; j < r; j++) {
      if (comparator(ary[j], pivot) <= 0) {
        i += 1;
        swap(ary, i, j);
      }
    }

    swap(ary, i + 1, j);
    var q = i + 1;

    // (2) Recurse on each half.

    doQuickSort(ary, comparator, p, q - 1);
    doQuickSort(ary, comparator, q + 1, r);
  }
}

/**
 * Sort the given array in-place with the given comparator function.
 *
 * @param {Array} ary
 *        An array to sort.
 * @param {function} comparator
 *        Function to use to compare two items.
 */
exports.quickSort = function (ary, comparator) {
  doQuickSort(ary, comparator, 0, ary.length - 1);
};

},{}],1092:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var util = require('./util');
var binarySearch = require('./binary-search');
var ArraySet = require('./array-set').ArraySet;
var base64VLQ = require('./base64-vlq');
var quickSort = require('./quick-sort').quickSort;

function SourceMapConsumer(aSourceMap, aSourceMapURL) {
  var sourceMap = aSourceMap;
  if (typeof aSourceMap === 'string') {
    sourceMap = util.parseSourceMapInput(aSourceMap);
  }

  return sourceMap.sections != null
    ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL)
    : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
}

SourceMapConsumer.fromSourceMap = function(aSourceMap, aSourceMapURL) {
  return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
}

/**
 * The version of the source mapping spec that we are consuming.
 */
SourceMapConsumer.prototype._version = 3;

// `__generatedMappings` and `__originalMappings` are arrays that hold the
// parsed mapping coordinates from the source map's "mappings" attribute. They
// are lazily instantiated, accessed via the `_generatedMappings` and
// `_originalMappings` getters respectively, and we only parse the mappings
// and create these arrays once queried for a source location. We jump through
// these hoops because there can be many thousands of mappings, and parsing
// them is expensive, so we only want to do it if we must.
//
// Each object in the arrays is of the form:
//
//     {
//       generatedLine: The line number in the generated code,
//       generatedColumn: The column number in the generated code,
//       source: The path to the original source file that generated this
//               chunk of code,
//       originalLine: The line number in the original source that
//                     corresponds to this chunk of generated code,
//       originalColumn: The column number in the original source that
//                       corresponds to this chunk of generated code,
//       name: The name of the original symbol which generated this chunk of
//             code.
//     }
//
// All properties except for `generatedLine` and `generatedColumn` can be
// `null`.
//
// `_generatedMappings` is ordered by the generated positions.
//
// `_originalMappings` is ordered by the original positions.

SourceMapConsumer.prototype.__generatedMappings = null;
Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
  configurable: true,
  enumerable: true,
  get: function () {
    if (!this.__generatedMappings) {
      this._parseMappings(this._mappings, this.sourceRoot);
    }

    return this.__generatedMappings;
  }
});

SourceMapConsumer.prototype.__originalMappings = null;
Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
  configurable: true,
  enumerable: true,
  get: function () {
    if (!this.__originalMappings) {
      this._parseMappings(this._mappings, this.sourceRoot);
    }

    return this.__originalMappings;
  }
});

SourceMapConsumer.prototype._charIsMappingSeparator =
  function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
    var c = aStr.charAt(index);
    return c === ";" || c === ",";
  };

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
SourceMapConsumer.prototype._parseMappings =
  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    throw new Error("Subclasses must implement _parseMappings");
  };

SourceMapConsumer.GENERATED_ORDER = 1;
SourceMapConsumer.ORIGINAL_ORDER = 2;

SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
SourceMapConsumer.LEAST_UPPER_BOUND = 2;

/**
 * Iterate over each mapping between an original source/line/column and a
 * generated line/column in this source map.
 *
 * @param Function aCallback
 *        The function that is called with each mapping.
 * @param Object aContext
 *        Optional. If specified, this object will be the value of `this` every
 *        time that `aCallback` is called.
 * @param aOrder
 *        Either `SourceMapConsumer.GENERATED_ORDER` or
 *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
 *        iterate over the mappings sorted by the generated file's line/column
 *        order or the original's source/line/column order, respectively. Defaults to
 *        `SourceMapConsumer.GENERATED_ORDER`.
 */
SourceMapConsumer.prototype.eachMapping =
  function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
    var context = aContext || null;
    var order = aOrder || SourceMapConsumer.GENERATED_ORDER;

    var mappings;
    switch (order) {
    case SourceMapConsumer.GENERATED_ORDER:
      mappings = this._generatedMappings;
      break;
    case SourceMapConsumer.ORIGINAL_ORDER:
      mappings = this._originalMappings;
      break;
    default:
      throw new Error("Unknown order of iteration.");
    }

    var sourceRoot = this.sourceRoot;
    mappings.map(function (mapping) {
      var source = mapping.source === null ? null : this._sources.at(mapping.source);
      source = util.computeSourceURL(sourceRoot, source, this._sourceMapURL);
      return {
        source: source,
        generatedLine: mapping.generatedLine,
        generatedColumn: mapping.generatedColumn,
        originalLine: mapping.originalLine,
        originalColumn: mapping.originalColumn,
        name: mapping.name === null ? null : this._names.at(mapping.name)
      };
    }, this).forEach(aCallback, context);
  };

/**
 * Returns all generated line and column information for the original source,
 * line, and column provided. If no column is provided, returns all mappings
 * corresponding to a either the line we are searching for or the next
 * closest line that has any mappings. Otherwise, returns all mappings
 * corresponding to the given line and either the column we are searching for
 * or the next closest column that has any offsets.
 *
 * The only argument is an object with the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.  The line number is 1-based.
 *   - column: Optional. the column number in the original source.
 *    The column number is 0-based.
 *
 * and an array of objects is returned, each with the following properties:
 *
 *   - line: The line number in the generated source, or null.  The
 *    line number is 1-based.
 *   - column: The column number in the generated source, or null.
 *    The column number is 0-based.
 */
SourceMapConsumer.prototype.allGeneratedPositionsFor =
  function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
    var line = util.getArg(aArgs, 'line');

    // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping
    // returns the index of the closest mapping less than the needle. By
    // setting needle.originalColumn to 0, we thus find the last mapping for
    // the given line, provided such a mapping exists.
    var needle = {
      source: util.getArg(aArgs, 'source'),
      originalLine: line,
      originalColumn: util.getArg(aArgs, 'column', 0)
    };

    needle.source = this._findSourceIndex(needle.source);
    if (needle.source < 0) {
      return [];
    }

    var mappings = [];

    var index = this._findMapping(needle,
                                  this._originalMappings,
                                  "originalLine",
                                  "originalColumn",
                                  util.compareByOriginalPositions,
                                  binarySearch.LEAST_UPPER_BOUND);
    if (index >= 0) {
      var mapping = this._originalMappings[index];

      if (aArgs.column === undefined) {
        var originalLine = mapping.originalLine;

        // Iterate until either we run out of mappings, or we run into
        // a mapping for a different line than the one we found. Since
        // mappings are sorted, this is guaranteed to find all mappings for
        // the line we found.
        while (mapping && mapping.originalLine === originalLine) {
          mappings.push({
            line: util.getArg(mapping, 'generatedLine', null),
            column: util.getArg(mapping, 'generatedColumn', null),
            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
          });

          mapping = this._originalMappings[++index];
        }
      } else {
        var originalColumn = mapping.originalColumn;

        // Iterate until either we run out of mappings, or we run into
        // a mapping for a different line than the one we were searching for.
        // Since mappings are sorted, this is guaranteed to find all mappings for
        // the line we are searching for.
        while (mapping &&
               mapping.originalLine === line &&
               mapping.originalColumn == originalColumn) {
          mappings.push({
            line: util.getArg(mapping, 'generatedLine', null),
            column: util.getArg(mapping, 'generatedColumn', null),
            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
          });

          mapping = this._originalMappings[++index];
        }
      }
    }

    return mappings;
  };

exports.SourceMapConsumer = SourceMapConsumer;

/**
 * A BasicSourceMapConsumer instance represents a parsed source map which we can
 * query for information about the original file positions by giving it a file
 * position in the generated source.
 *
 * The first parameter is the raw source map (either as a JSON string, or
 * already parsed to an object). According to the spec, source maps have the
 * following attributes:
 *
 *   - version: Which version of the source map spec this map is following.
 *   - sources: An array of URLs to the original source files.
 *   - names: An array of identifiers which can be referrenced by individual mappings.
 *   - sourceRoot: Optional. The URL root from which all sources are relative.
 *   - sourcesContent: Optional. An array of contents of the original source files.
 *   - mappings: A string of base64 VLQs which contain the actual mappings.
 *   - file: Optional. The generated file this source map is associated with.
 *
 * Here is an example source map, taken from the source map spec[0]:
 *
 *     {
 *       version : 3,
 *       file: "out.js",
 *       sourceRoot : "",
 *       sources: ["foo.js", "bar.js"],
 *       names: ["src", "maps", "are", "fun"],
 *       mappings: "AA,AB;;ABCDE;"
 *     }
 *
 * The second parameter, if given, is a string whose value is the URL
 * at which the source map was found.  This URL is used to compute the
 * sources array.
 *
 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
 */
function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {
  var sourceMap = aSourceMap;
  if (typeof aSourceMap === 'string') {
    sourceMap = util.parseSourceMapInput(aSourceMap);
  }

  var version = util.getArg(sourceMap, 'version');
  var sources = util.getArg(sourceMap, 'sources');
  // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
  // requires the array) to play nice here.
  var names = util.getArg(sourceMap, 'names', []);
  var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
  var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
  var mappings = util.getArg(sourceMap, 'mappings');
  var file = util.getArg(sourceMap, 'file', null);

  // Once again, Sass deviates from the spec and supplies the version as a
  // string rather than a number, so we use loose equality checking here.
  if (version != this._version) {
    throw new Error('Unsupported version: ' + version);
  }

  if (sourceRoot) {
    sourceRoot = util.normalize(sourceRoot);
  }

  sources = sources
    .map(String)
    // Some source maps produce relative source paths like "./foo.js" instead of
    // "foo.js".  Normalize these first so that future comparisons will succeed.
    // See bugzil.la/1090768.
    .map(util.normalize)
    // Always ensure that absolute sources are internally stored relative to
    // the source root, if the source root is absolute. Not doing this would
    // be particularly problematic when the source root is a prefix of the
    // source (valid, but why??). See github issue #199 and bugzil.la/1188982.
    .map(function (source) {
      return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source)
        ? util.relative(sourceRoot, source)
        : source;
    });

  // Pass `true` below to allow duplicate names and sources. While source maps
  // are intended to be compressed and deduplicated, the TypeScript compiler
  // sometimes generates source maps with duplicates in them. See Github issue
  // #72 and bugzil.la/889492.
  this._names = ArraySet.fromArray(names.map(String), true);
  this._sources = ArraySet.fromArray(sources, true);

  this._absoluteSources = this._sources.toArray().map(function (s) {
    return util.computeSourceURL(sourceRoot, s, aSourceMapURL);
  });

  this.sourceRoot = sourceRoot;
  this.sourcesContent = sourcesContent;
  this._mappings = mappings;
  this._sourceMapURL = aSourceMapURL;
  this.file = file;
}

BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;

/**
 * Utility function to find the index of a source.  Returns -1 if not
 * found.
 */
BasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {
  var relativeSource = aSource;
  if (this.sourceRoot != null) {
    relativeSource = util.relative(this.sourceRoot, relativeSource);
  }

  if (this._sources.has(relativeSource)) {
    return this._sources.indexOf(relativeSource);
  }

  // Maybe aSource is an absolute URL as returned by |sources|.  In
  // this case we can't simply undo the transform.
  var i;
  for (i = 0; i < this._absoluteSources.length; ++i) {
    if (this._absoluteSources[i] == aSource) {
      return i;
    }
  }

  return -1;
};

/**
 * Create a BasicSourceMapConsumer from a SourceMapGenerator.
 *
 * @param SourceMapGenerator aSourceMap
 *        The source map that will be consumed.
 * @param String aSourceMapURL
 *        The URL at which the source map can be found (optional)
 * @returns BasicSourceMapConsumer
 */
BasicSourceMapConsumer.fromSourceMap =
  function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {
    var smc = Object.create(BasicSourceMapConsumer.prototype);

    var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
    var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
    smc.sourceRoot = aSourceMap._sourceRoot;
    smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),
                                                            smc.sourceRoot);
    smc.file = aSourceMap._file;
    smc._sourceMapURL = aSourceMapURL;
    smc._absoluteSources = smc._sources.toArray().map(function (s) {
      return util.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);
    });

    // Because we are modifying the entries (by converting string sources and
    // names to indices into the sources and names ArraySets), we have to make
    // a copy of the entry or else bad things happen. Shared mutable state
    // strikes again! See github issue #191.

    var generatedMappings = aSourceMap._mappings.toArray().slice();
    var destGeneratedMappings = smc.__generatedMappings = [];
    var destOriginalMappings = smc.__originalMappings = [];

    for (var i = 0, length = generatedMappings.length; i < length; i++) {
      var srcMapping = generatedMappings[i];
      var destMapping = new Mapping;
      destMapping.generatedLine = srcMapping.generatedLine;
      destMapping.generatedColumn = srcMapping.generatedColumn;

      if (srcMapping.source) {
        destMapping.source = sources.indexOf(srcMapping.source);
        destMapping.originalLine = srcMapping.originalLine;
        destMapping.originalColumn = srcMapping.originalColumn;

        if (srcMapping.name) {
          destMapping.name = names.indexOf(srcMapping.name);
        }

        destOriginalMappings.push(destMapping);
      }

      destGeneratedMappings.push(destMapping);
    }

    quickSort(smc.__originalMappings, util.compareByOriginalPositions);

    return smc;
  };

/**
 * The version of the source mapping spec that we are consuming.
 */
BasicSourceMapConsumer.prototype._version = 3;

/**
 * The list of original sources.
 */
Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {
  get: function () {
    return this._absoluteSources.slice();
  }
});

/**
 * Provide the JIT with a nice shape / hidden class.
 */
function Mapping() {
  this.generatedLine = 0;
  this.generatedColumn = 0;
  this.source = null;
  this.originalLine = null;
  this.originalColumn = null;
  this.name = null;
}

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
BasicSourceMapConsumer.prototype._parseMappings =
  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    var generatedLine = 1;
    var previousGeneratedColumn = 0;
    var previousOriginalLine = 0;
    var previousOriginalColumn = 0;
    var previousSource = 0;
    var previousName = 0;
    var length = aStr.length;
    var index = 0;
    var cachedSegments = {};
    var temp = {};
    var originalMappings = [];
    var generatedMappings = [];
    var mapping, str, segment, end, value;

    while (index < length) {
      if (aStr.charAt(index) === ';') {
        generatedLine++;
        index++;
        previousGeneratedColumn = 0;
      }
      else if (aStr.charAt(index) === ',') {
        index++;
      }
      else {
        mapping = new Mapping();
        mapping.generatedLine = generatedLine;

        // Because each offset is encoded relative to the previous one,
        // many segments often have the same encoding. We can exploit this
        // fact by caching the parsed variable length fields of each segment,
        // allowing us to avoid a second parse if we encounter the same
        // segment again.
        for (end = index; end < length; end++) {
          if (this._charIsMappingSeparator(aStr, end)) {
            break;
          }
        }
        str = aStr.slice(index, end);

        segment = cachedSegments[str];
        if (segment) {
          index += str.length;
        } else {
          segment = [];
          while (index < end) {
            base64VLQ.decode(aStr, index, temp);
            value = temp.value;
            index = temp.rest;
            segment.push(value);
          }

          if (segment.length === 2) {
            throw new Error('Found a source, but no line and column');
          }

          if (segment.length === 3) {
            throw new Error('Found a source and line, but no column');
          }

          cachedSegments[str] = segment;
        }

        // Generated column.
        mapping.generatedColumn = previousGeneratedColumn + segment[0];
        previousGeneratedColumn = mapping.generatedColumn;

        if (segment.length > 1) {
          // Original source.
          mapping.source = previousSource + segment[1];
          previousSource += segment[1];

          // Original line.
          mapping.originalLine = previousOriginalLine + segment[2];
          previousOriginalLine = mapping.originalLine;
          // Lines are stored 0-based
          mapping.originalLine += 1;

          // Original column.
          mapping.originalColumn = previousOriginalColumn + segment[3];
          previousOriginalColumn = mapping.originalColumn;

          if (segment.length > 4) {
            // Original name.
            mapping.name = previousName + segment[4];
            previousName += segment[4];
          }
        }

        generatedMappings.push(mapping);
        if (typeof mapping.originalLine === 'number') {
          originalMappings.push(mapping);
        }
      }
    }

    quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);
    this.__generatedMappings = generatedMappings;

    quickSort(originalMappings, util.compareByOriginalPositions);
    this.__originalMappings = originalMappings;
  };

/**
 * Find the mapping that best matches the hypothetical "needle" mapping that
 * we are searching for in the given "haystack" of mappings.
 */
BasicSourceMapConsumer.prototype._findMapping =
  function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,
                                         aColumnName, aComparator, aBias) {
    // To return the position we are searching for, we must first find the
    // mapping for the given position and then return the opposite position it
    // points to. Because the mappings are sorted, we can use binary search to
    // find the best mapping.

    if (aNeedle[aLineName] <= 0) {
      throw new TypeError('Line must be greater than or equal to 1, got '
                          + aNeedle[aLineName]);
    }
    if (aNeedle[aColumnName] < 0) {
      throw new TypeError('Column must be greater than or equal to 0, got '
                          + aNeedle[aColumnName]);
    }

    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
  };

/**
 * Compute the last column for each generated mapping. The last column is
 * inclusive.
 */
BasicSourceMapConsumer.prototype.computeColumnSpans =
  function SourceMapConsumer_computeColumnSpans() {
    for (var index = 0; index < this._generatedMappings.length; ++index) {
      var mapping = this._generatedMappings[index];

      // Mappings do not contain a field for the last generated columnt. We
      // can come up with an optimistic estimate, however, by assuming that
      // mappings are contiguous (i.e. given two consecutive mappings, the
      // first mapping ends where the second one starts).
      if (index + 1 < this._generatedMappings.length) {
        var nextMapping = this._generatedMappings[index + 1];

        if (mapping.generatedLine === nextMapping.generatedLine) {
          mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
          continue;
        }
      }

      // The last mapping for each line spans the entire line.
      mapping.lastGeneratedColumn = Infinity;
    }
  };

/**
 * Returns the original source, line, and column information for the generated
 * source's line and column positions provided. The only argument is an object
 * with the following properties:
 *
 *   - line: The line number in the generated source.  The line number
 *     is 1-based.
 *   - column: The column number in the generated source.  The column
 *     number is 0-based.
 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
 *
 * and an object is returned with the following properties:
 *
 *   - source: The original source file, or null.
 *   - line: The line number in the original source, or null.  The
 *     line number is 1-based.
 *   - column: The column number in the original source, or null.  The
 *     column number is 0-based.
 *   - name: The original identifier, or null.
 */
BasicSourceMapConsumer.prototype.originalPositionFor =
  function SourceMapConsumer_originalPositionFor(aArgs) {
    var needle = {
      generatedLine: util.getArg(aArgs, 'line'),
      generatedColumn: util.getArg(aArgs, 'column')
    };

    var index = this._findMapping(
      needle,
      this._generatedMappings,
      "generatedLine",
      "generatedColumn",
      util.compareByGeneratedPositionsDeflated,
      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
    );

    if (index >= 0) {
      var mapping = this._generatedMappings[index];

      if (mapping.generatedLine === needle.generatedLine) {
        var source = util.getArg(mapping, 'source', null);
        if (source !== null) {
          source = this._sources.at(source);
          source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);
        }
        var name = util.getArg(mapping, 'name', null);
        if (name !== null) {
          name = this._names.at(name);
        }
        return {
          source: source,
          line: util.getArg(mapping, 'originalLine', null),
          column: util.getArg(mapping, 'originalColumn', null),
          name: name
        };
      }
    }

    return {
      source: null,
      line: null,
      column: null,
      name: null
    };
  };

/**
 * Return true if we have the source content for every source in the source
 * map, false otherwise.
 */
BasicSourceMapConsumer.prototype.hasContentsOfAllSources =
  function BasicSourceMapConsumer_hasContentsOfAllSources() {
    if (!this.sourcesContent) {
      return false;
    }
    return this.sourcesContent.length >= this._sources.size() &&
      !this.sourcesContent.some(function (sc) { return sc == null; });
  };

/**
 * Returns the original source content. The only argument is the url of the
 * original source file. Returns null if no original source content is
 * available.
 */
BasicSourceMapConsumer.prototype.sourceContentFor =
  function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
    if (!this.sourcesContent) {
      return null;
    }

    var index = this._findSourceIndex(aSource);
    if (index >= 0) {
      return this.sourcesContent[index];
    }

    var relativeSource = aSource;
    if (this.sourceRoot != null) {
      relativeSource = util.relative(this.sourceRoot, relativeSource);
    }

    var url;
    if (this.sourceRoot != null
        && (url = util.urlParse(this.sourceRoot))) {
      // XXX: file:// URIs and absolute paths lead to unexpected behavior for
      // many users. We can help them out when they expect file:// URIs to
      // behave like it would if they were running a local HTTP server. See
      // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
      var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
      if (url.scheme == "file"
          && this._sources.has(fileUriAbsPath)) {
        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]
      }

      if ((!url.path || url.path == "/")
          && this._sources.has("/" + relativeSource)) {
        return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
      }
    }

    // This function is used recursively from
    // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we
    // don't want to throw if we can't find the source - we just want to
    // return null, so we provide a flag to exit gracefully.
    if (nullOnMissing) {
      return null;
    }
    else {
      throw new Error('"' + relativeSource + '" is not in the SourceMap.');
    }
  };

/**
 * Returns the generated line and column information for the original source,
 * line, and column positions provided. The only argument is an object with
 * the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.  The line number
 *     is 1-based.
 *   - column: The column number in the original source.  The column
 *     number is 0-based.
 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
 *
 * and an object is returned with the following properties:
 *
 *   - line: The line number in the generated source, or null.  The
 *     line number is 1-based.
 *   - column: The column number in the generated source, or null.
 *     The column number is 0-based.
 */
BasicSourceMapConsumer.prototype.generatedPositionFor =
  function SourceMapConsumer_generatedPositionFor(aArgs) {
    var source = util.getArg(aArgs, 'source');
    source = this._findSourceIndex(source);
    if (source < 0) {
      return {
        line: null,
        column: null,
        lastColumn: null
      };
    }

    var needle = {
      source: source,
      originalLine: util.getArg(aArgs, 'line'),
      originalColumn: util.getArg(aArgs, 'column')
    };

    var index = this._findMapping(
      needle,
      this._originalMappings,
      "originalLine",
      "originalColumn",
      util.compareByOriginalPositions,
      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
    );

    if (index >= 0) {
      var mapping = this._originalMappings[index];

      if (mapping.source === needle.source) {
        return {
          line: util.getArg(mapping, 'generatedLine', null),
          column: util.getArg(mapping, 'generatedColumn', null),
          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
        };
      }
    }

    return {
      line: null,
      column: null,
      lastColumn: null
    };
  };

exports.BasicSourceMapConsumer = BasicSourceMapConsumer;

/**
 * An IndexedSourceMapConsumer instance represents a parsed source map which
 * we can query for information. It differs from BasicSourceMapConsumer in
 * that it takes "indexed" source maps (i.e. ones with a "sections" field) as
 * input.
 *
 * The first parameter is a raw source map (either as a JSON string, or already
 * parsed to an object). According to the spec for indexed source maps, they
 * have the following attributes:
 *
 *   - version: Which version of the source map spec this map is following.
 *   - file: Optional. The generated file this source map is associated with.
 *   - sections: A list of section definitions.
 *
 * Each value under the "sections" field has two fields:
 *   - offset: The offset into the original specified at which this section
 *       begins to apply, defined as an object with a "line" and "column"
 *       field.
 *   - map: A source map definition. This source map could also be indexed,
 *       but doesn't have to be.
 *
 * Instead of the "map" field, it's also possible to have a "url" field
 * specifying a URL to retrieve a source map from, but that's currently
 * unsupported.
 *
 * Here's an example source map, taken from the source map spec[0], but
 * modified to omit a section which uses the "url" field.
 *
 *  {
 *    version : 3,
 *    file: "app.js",
 *    sections: [{
 *      offset: {line:100, column:10},
 *      map: {
 *        version : 3,
 *        file: "section.js",
 *        sources: ["foo.js", "bar.js"],
 *        names: ["src", "maps", "are", "fun"],
 *        mappings: "AAAA,E;;ABCDE;"
 *      }
 *    }],
 *  }
 *
 * The second parameter, if given, is a string whose value is the URL
 * at which the source map was found.  This URL is used to compute the
 * sources array.
 *
 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt
 */
function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {
  var sourceMap = aSourceMap;
  if (typeof aSourceMap === 'string') {
    sourceMap = util.parseSourceMapInput(aSourceMap);
  }

  var version = util.getArg(sourceMap, 'version');
  var sections = util.getArg(sourceMap, 'sections');

  if (version != this._version) {
    throw new Error('Unsupported version: ' + version);
  }

  this._sources = new ArraySet();
  this._names = new ArraySet();

  var lastOffset = {
    line: -1,
    column: 0
  };
  this._sections = sections.map(function (s) {
    if (s.url) {
      // The url field will require support for asynchronicity.
      // See https://github.com/mozilla/source-map/issues/16
      throw new Error('Support for url field in sections not implemented.');
    }
    var offset = util.getArg(s, 'offset');
    var offsetLine = util.getArg(offset, 'line');
    var offsetColumn = util.getArg(offset, 'column');

    if (offsetLine < lastOffset.line ||
        (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {
      throw new Error('Section offsets must be ordered and non-overlapping.');
    }
    lastOffset = offset;

    return {
      generatedOffset: {
        // The offset fields are 0-based, but we use 1-based indices when
        // encoding/decoding from VLQ.
        generatedLine: offsetLine + 1,
        generatedColumn: offsetColumn + 1
      },
      consumer: new SourceMapConsumer(util.getArg(s, 'map'), aSourceMapURL)
    }
  });
}

IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;

/**
 * The version of the source mapping spec that we are consuming.
 */
IndexedSourceMapConsumer.prototype._version = 3;

/**
 * The list of original sources.
 */
Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {
  get: function () {
    var sources = [];
    for (var i = 0; i < this._sections.length; i++) {
      for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
        sources.push(this._sections[i].consumer.sources[j]);
      }
    }
    return sources;
  }
});

/**
 * Returns the original source, line, and column information for the generated
 * source's line and column positions provided. The only argument is an object
 * with the following properties:
 *
 *   - line: The line number in the generated source.  The line number
 *     is 1-based.
 *   - column: The column number in the generated source.  The column
 *     number is 0-based.
 *
 * and an object is returned with the following properties:
 *
 *   - source: The original source file, or null.
 *   - line: The line number in the original source, or null.  The
 *     line number is 1-based.
 *   - column: The column number in the original source, or null.  The
 *     column number is 0-based.
 *   - name: The original identifier, or null.
 */
IndexedSourceMapConsumer.prototype.originalPositionFor =
  function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
    var needle = {
      generatedLine: util.getArg(aArgs, 'line'),
      generatedColumn: util.getArg(aArgs, 'column')
    };

    // Find the section containing the generated position we're trying to map
    // to an original position.
    var sectionIndex = binarySearch.search(needle, this._sections,
      function(needle, section) {
        var cmp = needle.generatedLine - section.generatedOffset.generatedLine;
        if (cmp) {
          return cmp;
        }

        return (needle.generatedColumn -
                section.generatedOffset.generatedColumn);
      });
    var section = this._sections[sectionIndex];

    if (!section) {
      return {
        source: null,
        line: null,
        column: null,
        name: null
      };
    }

    return section.consumer.originalPositionFor({
      line: needle.generatedLine -
        (section.generatedOffset.generatedLine - 1),
      column: needle.generatedColumn -
        (section.generatedOffset.generatedLine === needle.generatedLine
         ? section.generatedOffset.generatedColumn - 1
         : 0),
      bias: aArgs.bias
    });
  };

/**
 * Return true if we have the source content for every source in the source
 * map, false otherwise.
 */
IndexedSourceMapConsumer.prototype.hasContentsOfAllSources =
  function IndexedSourceMapConsumer_hasContentsOfAllSources() {
    return this._sections.every(function (s) {
      return s.consumer.hasContentsOfAllSources();
    });
  };

/**
 * Returns the original source content. The only argument is the url of the
 * original source file. Returns null if no original source content is
 * available.
 */
IndexedSourceMapConsumer.prototype.sourceContentFor =
  function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];

      var content = section.consumer.sourceContentFor(aSource, true);
      if (content) {
        return content;
      }
    }
    if (nullOnMissing) {
      return null;
    }
    else {
      throw new Error('"' + aSource + '" is not in the SourceMap.');
    }
  };

/**
 * Returns the generated line and column information for the original source,
 * line, and column positions provided. The only argument is an object with
 * the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.  The line number
 *     is 1-based.
 *   - column: The column number in the original source.  The column
 *     number is 0-based.
 *
 * and an object is returned with the following properties:
 *
 *   - line: The line number in the generated source, or null.  The
 *     line number is 1-based. 
 *   - column: The column number in the generated source, or null.
 *     The column number is 0-based.
 */
IndexedSourceMapConsumer.prototype.generatedPositionFor =
  function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];

      // Only consider this section if the requested source is in the list of
      // sources of the consumer.
      if (section.consumer._findSourceIndex(util.getArg(aArgs, 'source')) === -1) {
        continue;
      }
      var generatedPosition = section.consumer.generatedPositionFor(aArgs);
      if (generatedPosition) {
        var ret = {
          line: generatedPosition.line +
            (section.generatedOffset.generatedLine - 1),
          column: generatedPosition.column +
            (section.generatedOffset.generatedLine === generatedPosition.line
             ? section.generatedOffset.generatedColumn - 1
             : 0)
        };
        return ret;
      }
    }

    return {
      line: null,
      column: null
    };
  };

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
IndexedSourceMapConsumer.prototype._parseMappings =
  function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    this.__generatedMappings = [];
    this.__originalMappings = [];
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];
      var sectionMappings = section.consumer._generatedMappings;
      for (var j = 0; j < sectionMappings.length; j++) {
        var mapping = sectionMappings[j];

        var source = section.consumer._sources.at(mapping.source);
        source = util.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);
        this._sources.add(source);
        source = this._sources.indexOf(source);

        var name = null;
        if (mapping.name) {
          name = section.consumer._names.at(mapping.name);
          this._names.add(name);
          name = this._names.indexOf(name);
        }

        // The mappings coming from the consumer for the section have
        // generated positions relative to the start of the section, so we
        // need to offset them to be relative to the start of the concatenated
        // generated file.
        var adjustedMapping = {
          source: source,
          generatedLine: mapping.generatedLine +
            (section.generatedOffset.generatedLine - 1),
          generatedColumn: mapping.generatedColumn +
            (section.generatedOffset.generatedLine === mapping.generatedLine
            ? section.generatedOffset.generatedColumn - 1
            : 0),
          originalLine: mapping.originalLine,
          originalColumn: mapping.originalColumn,
          name: name
        };

        this.__generatedMappings.push(adjustedMapping);
        if (typeof adjustedMapping.originalLine === 'number') {
          this.__originalMappings.push(adjustedMapping);
        }
      }
    }

    quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
    quickSort(this.__originalMappings, util.compareByOriginalPositions);
  };

exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;

},{"./array-set":1086,"./base64-vlq":1087,"./binary-search":1089,"./quick-sort":1091,"./util":1095}],1093:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var base64VLQ = require('./base64-vlq');
var util = require('./util');
var ArraySet = require('./array-set').ArraySet;
var MappingList = require('./mapping-list').MappingList;

/**
 * An instance of the SourceMapGenerator represents a source map which is
 * being built incrementally. You may pass an object with the following
 * properties:
 *
 *   - file: The filename of the generated source.
 *   - sourceRoot: A root for all relative URLs in this source map.
 */
function SourceMapGenerator(aArgs) {
  if (!aArgs) {
    aArgs = {};
  }
  this._file = util.getArg(aArgs, 'file', null);
  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
  this._sources = new ArraySet();
  this._names = new ArraySet();
  this._mappings = new MappingList();
  this._sourcesContents = null;
}

SourceMapGenerator.prototype._version = 3;

/**
 * Creates a new SourceMapGenerator based on a SourceMapConsumer
 *
 * @param aSourceMapConsumer The SourceMap.
 */
SourceMapGenerator.fromSourceMap =
  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
    var sourceRoot = aSourceMapConsumer.sourceRoot;
    var generator = new SourceMapGenerator({
      file: aSourceMapConsumer.file,
      sourceRoot: sourceRoot
    });
    aSourceMapConsumer.eachMapping(function (mapping) {
      var newMapping = {
        generated: {
          line: mapping.generatedLine,
          column: mapping.generatedColumn
        }
      };

      if (mapping.source != null) {
        newMapping.source = mapping.source;
        if (sourceRoot != null) {
          newMapping.source = util.relative(sourceRoot, newMapping.source);
        }

        newMapping.original = {
          line: mapping.originalLine,
          column: mapping.originalColumn
        };

        if (mapping.name != null) {
          newMapping.name = mapping.name;
        }
      }

      generator.addMapping(newMapping);
    });
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var sourceRelative = sourceFile;
      if (sourceRoot !== null) {
        sourceRelative = util.relative(sourceRoot, sourceFile);
      }

      if (!generator._sources.has(sourceRelative)) {
        generator._sources.add(sourceRelative);
      }

      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        generator.setSourceContent(sourceFile, content);
      }
    });
    return generator;
  };

/**
 * Add a single mapping from original source line and column to the generated
 * source's line and column for this source map being created. The mapping
 * object should have the following properties:
 *
 *   - generated: An object with the generated line and column positions.
 *   - original: An object with the original line and column positions.
 *   - source: The original source file (relative to the sourceRoot).
 *   - name: An optional original token name for this mapping.
 */
SourceMapGenerator.prototype.addMapping =
  function SourceMapGenerator_addMapping(aArgs) {
    var generated = util.getArg(aArgs, 'generated');
    var original = util.getArg(aArgs, 'original', null);
    var source = util.getArg(aArgs, 'source', null);
    var name = util.getArg(aArgs, 'name', null);

    if (!this._skipValidation) {
      this._validateMapping(generated, original, source, name);
    }

    if (source != null) {
      source = String(source);
      if (!this._sources.has(source)) {
        this._sources.add(source);
      }
    }

    if (name != null) {
      name = String(name);
      if (!this._names.has(name)) {
        this._names.add(name);
      }
    }

    this._mappings.add({
      generatedLine: generated.line,
      generatedColumn: generated.column,
      originalLine: original != null && original.line,
      originalColumn: original != null && original.column,
      source: source,
      name: name
    });
  };

/**
 * Set the source content for a source file.
 */
SourceMapGenerator.prototype.setSourceContent =
  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
    var source = aSourceFile;
    if (this._sourceRoot != null) {
      source = util.relative(this._sourceRoot, source);
    }

    if (aSourceContent != null) {
      // Add the source content to the _sourcesContents map.
      // Create a new _sourcesContents map if the property is null.
      if (!this._sourcesContents) {
        this._sourcesContents = Object.create(null);
      }
      this._sourcesContents[util.toSetString(source)] = aSourceContent;
    } else if (this._sourcesContents) {
      // Remove the source file from the _sourcesContents map.
      // If the _sourcesContents map is empty, set the property to null.
      delete this._sourcesContents[util.toSetString(source)];
      if (Object.keys(this._sourcesContents).length === 0) {
        this._sourcesContents = null;
      }
    }
  };

/**
 * Applies the mappings of a sub-source-map for a specific source file to the
 * source map being generated. Each mapping to the supplied source file is
 * rewritten using the supplied source map. Note: The resolution for the
 * resulting mappings is the minimium of this map and the supplied map.
 *
 * @param aSourceMapConsumer The source map to be applied.
 * @param aSourceFile Optional. The filename of the source file.
 *        If omitted, SourceMapConsumer's file property will be used.
 * @param aSourceMapPath Optional. The dirname of the path to the source map
 *        to be applied. If relative, it is relative to the SourceMapConsumer.
 *        This parameter is needed when the two source maps aren't in the same
 *        directory, and the source map to be applied contains relative source
 *        paths. If so, those relative source paths need to be rewritten
 *        relative to the SourceMapGenerator.
 */
SourceMapGenerator.prototype.applySourceMap =
  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
    var sourceFile = aSourceFile;
    // If aSourceFile is omitted, we will use the file property of the SourceMap
    if (aSourceFile == null) {
      if (aSourceMapConsumer.file == null) {
        throw new Error(
          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
          'or the source map\'s "file" property. Both were omitted.'
        );
      }
      sourceFile = aSourceMapConsumer.file;
    }
    var sourceRoot = this._sourceRoot;
    // Make "sourceFile" relative if an absolute Url is passed.
    if (sourceRoot != null) {
      sourceFile = util.relative(sourceRoot, sourceFile);
    }
    // Applying the SourceMap can add and remove items from the sources and
    // the names array.
    var newSources = new ArraySet();
    var newNames = new ArraySet();

    // Find mappings for the "sourceFile"
    this._mappings.unsortedForEach(function (mapping) {
      if (mapping.source === sourceFile && mapping.originalLine != null) {
        // Check if it can be mapped by the source map, then update the mapping.
        var original = aSourceMapConsumer.originalPositionFor({
          line: mapping.originalLine,
          column: mapping.originalColumn
        });
        if (original.source != null) {
          // Copy mapping
          mapping.source = original.source;
          if (aSourceMapPath != null) {
            mapping.source = util.join(aSourceMapPath, mapping.source)
          }
          if (sourceRoot != null) {
            mapping.source = util.relative(sourceRoot, mapping.source);
          }
          mapping.originalLine = original.line;
          mapping.originalColumn = original.column;
          if (original.name != null) {
            mapping.name = original.name;
          }
        }
      }

      var source = mapping.source;
      if (source != null && !newSources.has(source)) {
        newSources.add(source);
      }

      var name = mapping.name;
      if (name != null && !newNames.has(name)) {
        newNames.add(name);
      }

    }, this);
    this._sources = newSources;
    this._names = newNames;

    // Copy sourcesContents of applied map.
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        if (aSourceMapPath != null) {
          sourceFile = util.join(aSourceMapPath, sourceFile);
        }
        if (sourceRoot != null) {
          sourceFile = util.relative(sourceRoot, sourceFile);
        }
        this.setSourceContent(sourceFile, content);
      }
    }, this);
  };

/**
 * A mapping can have one of the three levels of data:
 *
 *   1. Just the generated position.
 *   2. The Generated position, original position, and original source.
 *   3. Generated and original position, original source, as well as a name
 *      token.
 *
 * To maintain consistency, we validate that any new mapping being added falls
 * in to one of these categories.
 */
SourceMapGenerator.prototype._validateMapping =
  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
                                              aName) {
    // When aOriginal is truthy but has empty values for .line and .column,
    // it is most likely a programmer error. In this case we throw a very
    // specific error message to try to guide them the right way.
    // For example: https://github.com/Polymer/polymer-bundler/pull/519
    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
        throw new Error(
            'original.line and original.column are not numbers -- you probably meant to omit ' +
            'the original mapping entirely and only map the generated position. If so, pass ' +
            'null for the original mapping instead of an object with empty or null values.'
        );
    }

    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
        && aGenerated.line > 0 && aGenerated.column >= 0
        && !aOriginal && !aSource && !aName) {
      // Case 1.
      return;
    }
    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
             && aOriginal && 'line' in aOriginal && 'column' in aOriginal
             && aGenerated.line > 0 && aGenerated.column >= 0
             && aOriginal.line > 0 && aOriginal.column >= 0
             && aSource) {
      // Cases 2 and 3.
      return;
    }
    else {
      throw new Error('Invalid mapping: ' + JSON.stringify({
        generated: aGenerated,
        source: aSource,
        original: aOriginal,
        name: aName
      }));
    }
  };

/**
 * Serialize the accumulated mappings in to the stream of base 64 VLQs
 * specified by the source map format.
 */
SourceMapGenerator.prototype._serializeMappings =
  function SourceMapGenerator_serializeMappings() {
    var previousGeneratedColumn = 0;
    var previousGeneratedLine = 1;
    var previousOriginalColumn = 0;
    var previousOriginalLine = 0;
    var previousName = 0;
    var previousSource = 0;
    var result = '';
    var next;
    var mapping;
    var nameIdx;
    var sourceIdx;

    var mappings = this._mappings.toArray();
    for (var i = 0, len = mappings.length; i < len; i++) {
      mapping = mappings[i];
      next = ''

      if (mapping.generatedLine !== previousGeneratedLine) {
        previousGeneratedColumn = 0;
        while (mapping.generatedLine !== previousGeneratedLine) {
          next += ';';
          previousGeneratedLine++;
        }
      }
      else {
        if (i > 0) {
          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
            continue;
          }
          next += ',';
        }
      }

      next += base64VLQ.encode(mapping.generatedColumn
                                 - previousGeneratedColumn);
      previousGeneratedColumn = mapping.generatedColumn;

      if (mapping.source != null) {
        sourceIdx = this._sources.indexOf(mapping.source);
        next += base64VLQ.encode(sourceIdx - previousSource);
        previousSource = sourceIdx;

        // lines are stored 0-based in SourceMap spec version 3
        next += base64VLQ.encode(mapping.originalLine - 1
                                   - previousOriginalLine);
        previousOriginalLine = mapping.originalLine - 1;

        next += base64VLQ.encode(mapping.originalColumn
                                   - previousOriginalColumn);
        previousOriginalColumn = mapping.originalColumn;

        if (mapping.name != null) {
          nameIdx = this._names.indexOf(mapping.name);
          next += base64VLQ.encode(nameIdx - previousName);
          previousName = nameIdx;
        }
      }

      result += next;
    }

    return result;
  };

SourceMapGenerator.prototype._generateSourcesContent =
  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
    return aSources.map(function (source) {
      if (!this._sourcesContents) {
        return null;
      }
      if (aSourceRoot != null) {
        source = util.relative(aSourceRoot, source);
      }
      var key = util.toSetString(source);
      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
        ? this._sourcesContents[key]
        : null;
    }, this);
  };

/**
 * Externalize the source map.
 */
SourceMapGenerator.prototype.toJSON =
  function SourceMapGenerator_toJSON() {
    var map = {
      version: this._version,
      sources: this._sources.toArray(),
      names: this._names.toArray(),
      mappings: this._serializeMappings()
    };
    if (this._file != null) {
      map.file = this._file;
    }
    if (this._sourceRoot != null) {
      map.sourceRoot = this._sourceRoot;
    }
    if (this._sourcesContents) {
      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
    }

    return map;
  };

/**
 * Render the source map being generated to a string.
 */
SourceMapGenerator.prototype.toString =
  function SourceMapGenerator_toString() {
    return JSON.stringify(this.toJSON());
  };

exports.SourceMapGenerator = SourceMapGenerator;

},{"./array-set":1086,"./base64-vlq":1087,"./mapping-list":1090,"./util":1095}],1094:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var SourceMapGenerator = require('./source-map-generator').SourceMapGenerator;
var util = require('./util');

// Matches a Windows-style `\r\n` newline or a `\n` newline used by all other
// operating systems these days (capturing the result).
var REGEX_NEWLINE = /(\r?\n)/;

// Newline character code for charCodeAt() comparisons
var NEWLINE_CODE = 10;

// Private symbol for identifying `SourceNode`s when multiple versions of
// the source-map library are loaded. This MUST NOT CHANGE across
// versions!
var isSourceNode = "$$$isSourceNode$$$";

/**
 * SourceNodes provide a way to abstract over interpolating/concatenating
 * snippets of generated JavaScript source code while maintaining the line and
 * column information associated with the original source code.
 *
 * @param aLine The original line number.
 * @param aColumn The original column number.
 * @param aSource The original source's filename.
 * @param aChunks Optional. An array of strings which are snippets of
 *        generated JS, or other SourceNodes.
 * @param aName The original identifier.
 */
function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
  this.children = [];
  this.sourceContents = {};
  this.line = aLine == null ? null : aLine;
  this.column = aColumn == null ? null : aColumn;
  this.source = aSource == null ? null : aSource;
  this.name = aName == null ? null : aName;
  this[isSourceNode] = true;
  if (aChunks != null) this.add(aChunks);
}

/**
 * Creates a SourceNode from generated code and a SourceMapConsumer.
 *
 * @param aGeneratedCode The generated code
 * @param aSourceMapConsumer The SourceMap for the generated code
 * @param aRelativePath Optional. The path that relative sources in the
 *        SourceMapConsumer should be relative to.
 */
SourceNode.fromStringWithSourceMap =
  function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
    // The SourceNode we want to fill with the generated code
    // and the SourceMap
    var node = new SourceNode();

    // All even indices of this array are one line of the generated code,
    // while all odd indices are the newlines between two adjacent lines
    // (since `REGEX_NEWLINE` captures its match).
    // Processed fragments are accessed by calling `shiftNextLine`.
    var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
    var remainingLinesIndex = 0;
    var shiftNextLine = function() {
      var lineContents = getNextLine();
      // The last line of a file might not have a newline.
      var newLine = getNextLine() || "";
      return lineContents + newLine;

      function getNextLine() {
        return remainingLinesIndex < remainingLines.length ?
            remainingLines[remainingLinesIndex++] : undefined;
      }
    };

    // We need to remember the position of "remainingLines"
    var lastGeneratedLine = 1, lastGeneratedColumn = 0;

    // The generate SourceNodes we need a code range.
    // To extract it current and last mapping is used.
    // Here we store the last mapping.
    var lastMapping = null;

    aSourceMapConsumer.eachMapping(function (mapping) {
      if (lastMapping !== null) {
        // We add the code from "lastMapping" to "mapping":
        // First check if there is a new line in between.
        if (lastGeneratedLine < mapping.generatedLine) {
          // Associate first line with "lastMapping"
          addMappingWithCode(lastMapping, shiftNextLine());
          lastGeneratedLine++;
          lastGeneratedColumn = 0;
          // The remaining code is added without mapping
        } else {
          // There is no new line in between.
          // Associate the code between "lastGeneratedColumn" and
          // "mapping.generatedColumn" with "lastMapping"
          var nextLine = remainingLines[remainingLinesIndex] || '';
          var code = nextLine.substr(0, mapping.generatedColumn -
                                        lastGeneratedColumn);
          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn -
                                              lastGeneratedColumn);
          lastGeneratedColumn = mapping.generatedColumn;
          addMappingWithCode(lastMapping, code);
          // No more remaining code, continue
          lastMapping = mapping;
          return;
        }
      }
      // We add the generated code until the first mapping
      // to the SourceNode without any mapping.
      // Each line is added as separate string.
      while (lastGeneratedLine < mapping.generatedLine) {
        node.add(shiftNextLine());
        lastGeneratedLine++;
      }
      if (lastGeneratedColumn < mapping.generatedColumn) {
        var nextLine = remainingLines[remainingLinesIndex] || '';
        node.add(nextLine.substr(0, mapping.generatedColumn));
        remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
        lastGeneratedColumn = mapping.generatedColumn;
      }
      lastMapping = mapping;
    }, this);
    // We have processed all mappings.
    if (remainingLinesIndex < remainingLines.length) {
      if (lastMapping) {
        // Associate the remaining code in the current line with "lastMapping"
        addMappingWithCode(lastMapping, shiftNextLine());
      }
      // and add the remaining lines without any mapping
      node.add(remainingLines.splice(remainingLinesIndex).join(""));
    }

    // Copy sourcesContent into SourceNode
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        if (aRelativePath != null) {
          sourceFile = util.join(aRelativePath, sourceFile);
        }
        node.setSourceContent(sourceFile, content);
      }
    });

    return node;

    function addMappingWithCode(mapping, code) {
      if (mapping === null || mapping.source === undefined) {
        node.add(code);
      } else {
        var source = aRelativePath
          ? util.join(aRelativePath, mapping.source)
          : mapping.source;
        node.add(new SourceNode(mapping.originalLine,
                                mapping.originalColumn,
                                source,
                                code,
                                mapping.name));
      }
    }
  };

/**
 * Add a chunk of generated JS to this source node.
 *
 * @param aChunk A string snippet of generated JS code, another instance of
 *        SourceNode, or an array where each member is one of those things.
 */
SourceNode.prototype.add = function SourceNode_add(aChunk) {
  if (Array.isArray(aChunk)) {
    aChunk.forEach(function (chunk) {
      this.add(chunk);
    }, this);
  }
  else if (aChunk[isSourceNode] || typeof aChunk === "string") {
    if (aChunk) {
      this.children.push(aChunk);
    }
  }
  else {
    throw new TypeError(
      "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
    );
  }
  return this;
};

/**
 * Add a chunk of generated JS to the beginning of this source node.
 *
 * @param aChunk A string snippet of generated JS code, another instance of
 *        SourceNode, or an array where each member is one of those things.
 */
SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
  if (Array.isArray(aChunk)) {
    for (var i = aChunk.length-1; i >= 0; i--) {
      this.prepend(aChunk[i]);
    }
  }
  else if (aChunk[isSourceNode] || typeof aChunk === "string") {
    this.children.unshift(aChunk);
  }
  else {
    throw new TypeError(
      "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
    );
  }
  return this;
};

/**
 * Walk over the tree of JS snippets in this node and its children. The
 * walking function is called once for each snippet of JS and is passed that
 * snippet and the its original associated source's line/column location.
 *
 * @param aFn The traversal function.
 */
SourceNode.prototype.walk = function SourceNode_walk(aFn) {
  var chunk;
  for (var i = 0, len = this.children.length; i < len; i++) {
    chunk = this.children[i];
    if (chunk[isSourceNode]) {
      chunk.walk(aFn);
    }
    else {
      if (chunk !== '') {
        aFn(chunk, { source: this.source,
                     line: this.line,
                     column: this.column,
                     name: this.name });
      }
    }
  }
};

/**
 * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
 * each of `this.children`.
 *
 * @param aSep The separator.
 */
SourceNode.prototype.join = function SourceNode_join(aSep) {
  var newChildren;
  var i;
  var len = this.children.length;
  if (len > 0) {
    newChildren = [];
    for (i = 0; i < len-1; i++) {
      newChildren.push(this.children[i]);
      newChildren.push(aSep);
    }
    newChildren.push(this.children[i]);
    this.children = newChildren;
  }
  return this;
};

/**
 * Call String.prototype.replace on the very right-most source snippet. Useful
 * for trimming whitespace from the end of a source node, etc.
 *
 * @param aPattern The pattern to replace.
 * @param aReplacement The thing to replace the pattern with.
 */
SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
  var lastChild = this.children[this.children.length - 1];
  if (lastChild[isSourceNode]) {
    lastChild.replaceRight(aPattern, aReplacement);
  }
  else if (typeof lastChild === 'string') {
    this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
  }
  else {
    this.children.push(''.replace(aPattern, aReplacement));
  }
  return this;
};

/**
 * Set the source content for a source file. This will be added to the SourceMapGenerator
 * in the sourcesContent field.
 *
 * @param aSourceFile The filename of the source file
 * @param aSourceContent The content of the source file
 */
SourceNode.prototype.setSourceContent =
  function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
  };

/**
 * Walk over the tree of SourceNodes. The walking function is called for each
 * source file content and is passed the filename and source content.
 *
 * @param aFn The traversal function.
 */
SourceNode.prototype.walkSourceContents =
  function SourceNode_walkSourceContents(aFn) {
    for (var i = 0, len = this.children.length; i < len; i++) {
      if (this.children[i][isSourceNode]) {
        this.children[i].walkSourceContents(aFn);
      }
    }

    var sources = Object.keys(this.sourceContents);
    for (var i = 0, len = sources.length; i < len; i++) {
      aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
    }
  };

/**
 * Return the string representation of this source node. Walks over the tree
 * and concatenates all the various snippets together to one string.
 */
SourceNode.prototype.toString = function SourceNode_toString() {
  var str = "";
  this.walk(function (chunk) {
    str += chunk;
  });
  return str;
};

/**
 * Returns the string representation of this source node along with a source
 * map.
 */
SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
  var generated = {
    code: "",
    line: 1,
    column: 0
  };
  var map = new SourceMapGenerator(aArgs);
  var sourceMappingActive = false;
  var lastOriginalSource = null;
  var lastOriginalLine = null;
  var lastOriginalColumn = null;
  var lastOriginalName = null;
  this.walk(function (chunk, original) {
    generated.code += chunk;
    if (original.source !== null
        && original.line !== null
        && original.column !== null) {
      if(lastOriginalSource !== original.source
         || lastOriginalLine !== original.line
         || lastOriginalColumn !== original.column
         || lastOriginalName !== original.name) {
        map.addMapping({
          source: original.source,
          original: {
            line: original.line,
            column: original.column
          },
          generated: {
            line: generated.line,
            column: generated.column
          },
          name: original.name
        });
      }
      lastOriginalSource = original.source;
      lastOriginalLine = original.line;
      lastOriginalColumn = original.column;
      lastOriginalName = original.name;
      sourceMappingActive = true;
    } else if (sourceMappingActive) {
      map.addMapping({
        generated: {
          line: generated.line,
          column: generated.column
        }
      });
      lastOriginalSource = null;
      sourceMappingActive = false;
    }
    for (var idx = 0, length = chunk.length; idx < length; idx++) {
      if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
        generated.line++;
        generated.column = 0;
        // Mappings end at eol
        if (idx + 1 === length) {
          lastOriginalSource = null;
          sourceMappingActive = false;
        } else if (sourceMappingActive) {
          map.addMapping({
            source: original.source,
            original: {
              line: original.line,
              column: original.column
            },
            generated: {
              line: generated.line,
              column: generated.column
            },
            name: original.name
          });
        }
      } else {
        generated.column++;
      }
    }
  });
  this.walkSourceContents(function (sourceFile, sourceContent) {
    map.setSourceContent(sourceFile, sourceContent);
  });

  return { code: generated.code, map: map };
};

exports.SourceNode = SourceNode;

},{"./source-map-generator":1093,"./util":1095}],1095:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

/**
 * This is a helper function for getting values from parameter/options
 * objects.
 *
 * @param args The object we are extracting values from
 * @param name The name of the property we are getting.
 * @param defaultValue An optional value to return if the property is missing
 * from the object. If this is not specified and the property is missing, an
 * error will be thrown.
 */
function getArg(aArgs, aName, aDefaultValue) {
  if (aName in aArgs) {
    return aArgs[aName];
  } else if (arguments.length === 3) {
    return aDefaultValue;
  } else {
    throw new Error('"' + aName + '" is a required argument.');
  }
}
exports.getArg = getArg;

var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
var dataUrlRegexp = /^data:.+\,.+$/;

function urlParse(aUrl) {
  var match = aUrl.match(urlRegexp);
  if (!match) {
    return null;
  }
  return {
    scheme: match[1],
    auth: match[2],
    host: match[3],
    port: match[4],
    path: match[5]
  };
}
exports.urlParse = urlParse;

function urlGenerate(aParsedUrl) {
  var url = '';
  if (aParsedUrl.scheme) {
    url += aParsedUrl.scheme + ':';
  }
  url += '//';
  if (aParsedUrl.auth) {
    url += aParsedUrl.auth + '@';
  }
  if (aParsedUrl.host) {
    url += aParsedUrl.host;
  }
  if (aParsedUrl.port) {
    url += ":" + aParsedUrl.port
  }
  if (aParsedUrl.path) {
    url += aParsedUrl.path;
  }
  return url;
}
exports.urlGenerate = urlGenerate;

/**
 * Normalizes a path, or the path portion of a URL:
 *
 * - Replaces consecutive slashes with one slash.
 * - Removes unnecessary '.' parts.
 * - Removes unnecessary '<dir>/..' parts.
 *
 * Based on code in the Node.js 'path' core module.
 *
 * @param aPath The path or url to normalize.
 */
function normalize(aPath) {
  var path = aPath;
  var url = urlParse(aPath);
  if (url) {
    if (!url.path) {
      return aPath;
    }
    path = url.path;
  }
  var isAbsolute = exports.isAbsolute(path);

  var parts = path.split(/\/+/);
  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
    part = parts[i];
    if (part === '.') {
      parts.splice(i, 1);
    } else if (part === '..') {
      up++;
    } else if (up > 0) {
      if (part === '') {
        // The first part is blank if the path is absolute. Trying to go
        // above the root is a no-op. Therefore we can remove all '..' parts
        // directly after the root.
        parts.splice(i + 1, up);
        up = 0;
      } else {
        parts.splice(i, 2);
        up--;
      }
    }
  }
  path = parts.join('/');

  if (path === '') {
    path = isAbsolute ? '/' : '.';
  }

  if (url) {
    url.path = path;
    return urlGenerate(url);
  }
  return path;
}
exports.normalize = normalize;

/**
 * Joins two paths/URLs.
 *
 * @param aRoot The root path or URL.
 * @param aPath The path or URL to be joined with the root.
 *
 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
 *   first.
 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
 *   is updated with the result and aRoot is returned. Otherwise the result
 *   is returned.
 *   - If aPath is absolute, the result is aPath.
 *   - Otherwise the two paths are joined with a slash.
 * - Joining for example 'http://' and 'www.example.com' is also supported.
 */
function join(aRoot, aPath) {
  if (aRoot === "") {
    aRoot = ".";
  }
  if (aPath === "") {
    aPath = ".";
  }
  var aPathUrl = urlParse(aPath);
  var aRootUrl = urlParse(aRoot);
  if (aRootUrl) {
    aRoot = aRootUrl.path || '/';
  }

  // `join(foo, '//www.example.org')`
  if (aPathUrl && !aPathUrl.scheme) {
    if (aRootUrl) {
      aPathUrl.scheme = aRootUrl.scheme;
    }
    return urlGenerate(aPathUrl);
  }

  if (aPathUrl || aPath.match(dataUrlRegexp)) {
    return aPath;
  }

  // `join('http://', 'www.example.com')`
  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
    aRootUrl.host = aPath;
    return urlGenerate(aRootUrl);
  }

  var joined = aPath.charAt(0) === '/'
    ? aPath
    : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

  if (aRootUrl) {
    aRootUrl.path = joined;
    return urlGenerate(aRootUrl);
  }
  return joined;
}
exports.join = join;

exports.isAbsolute = function (aPath) {
  return aPath.charAt(0) === '/' || urlRegexp.test(aPath);
};

/**
 * Make a path relative to a URL or another path.
 *
 * @param aRoot The root path or URL.
 * @param aPath The path or URL to be made relative to aRoot.
 */
function relative(aRoot, aPath) {
  if (aRoot === "") {
    aRoot = ".";
  }

  aRoot = aRoot.replace(/\/$/, '');

  // It is possible for the path to be above the root. In this case, simply
  // checking whether the root is a prefix of the path won't work. Instead, we
  // need to remove components from the root one by one, until either we find
  // a prefix that fits, or we run out of components to remove.
  var level = 0;
  while (aPath.indexOf(aRoot + '/') !== 0) {
    var index = aRoot.lastIndexOf("/");
    if (index < 0) {
      return aPath;
    }

    // If the only part of the root that is left is the scheme (i.e. http://,
    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
    // have exhausted all components, so the path is not relative to the root.
    aRoot = aRoot.slice(0, index);
    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
      return aPath;
    }

    ++level;
  }

  // Make sure we add a "../" for each component we removed from the root.
  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
}
exports.relative = relative;

var supportsNullProto = (function () {
  var obj = Object.create(null);
  return !('__proto__' in obj);
}());

function identity (s) {
  return s;
}

/**
 * Because behavior goes wacky when you set `__proto__` on objects, we
 * have to prefix all the strings in our set with an arbitrary character.
 *
 * See https://github.com/mozilla/source-map/pull/31 and
 * https://github.com/mozilla/source-map/issues/30
 *
 * @param String aStr
 */
function toSetString(aStr) {
  if (isProtoString(aStr)) {
    return '$' + aStr;
  }

  return aStr;
}
exports.toSetString = supportsNullProto ? identity : toSetString;

function fromSetString(aStr) {
  if (isProtoString(aStr)) {
    return aStr.slice(1);
  }

  return aStr;
}
exports.fromSetString = supportsNullProto ? identity : fromSetString;

function isProtoString(s) {
  if (!s) {
    return false;
  }

  var length = s.length;

  if (length < 9 /* "__proto__".length */) {
    return false;
  }

  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||
      s.charCodeAt(length - 2) !== 95  /* '_' */ ||
      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
      s.charCodeAt(length - 4) !== 116 /* 't' */ ||
      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
      s.charCodeAt(length - 8) !== 95  /* '_' */ ||
      s.charCodeAt(length - 9) !== 95  /* '_' */) {
    return false;
  }

  for (var i = length - 10; i >= 0; i--) {
    if (s.charCodeAt(i) !== 36 /* '$' */) {
      return false;
    }
  }

  return true;
}

/**
 * Comparator between two mappings where the original positions are compared.
 *
 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
 * mappings with the same original source/line/column, but different generated
 * line and column the same. Useful when searching for a mapping with a
 * stubbed out mapping.
 */
function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
  var cmp = strcmp(mappingA.source, mappingB.source);
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0 || onlyCompareOriginal) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  return strcmp(mappingA.name, mappingB.name);
}
exports.compareByOriginalPositions = compareByOriginalPositions;

/**
 * Comparator between two mappings with deflated source and name indices where
 * the generated positions are compared.
 *
 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
 * mappings with the same generated line and column, but different
 * source/name/original line and column the same. Useful when searching for a
 * mapping with a stubbed out mapping.
 */
function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
  var cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0 || onlyCompareGenerated) {
    return cmp;
  }

  cmp = strcmp(mappingA.source, mappingB.source);
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0) {
    return cmp;
  }

  return strcmp(mappingA.name, mappingB.name);
}
exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

function strcmp(aStr1, aStr2) {
  if (aStr1 === aStr2) {
    return 0;
  }

  if (aStr1 === null) {
    return 1; // aStr2 !== null
  }

  if (aStr2 === null) {
    return -1; // aStr1 !== null
  }

  if (aStr1 > aStr2) {
    return 1;
  }

  return -1;
}

/**
 * Comparator between two mappings with inflated source and name strings where
 * the generated positions are compared.
 */
function compareByGeneratedPositionsInflated(mappingA, mappingB) {
  var cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = strcmp(mappingA.source, mappingB.source);
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0) {
    return cmp;
  }

  return strcmp(mappingA.name, mappingB.name);
}
exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;

/**
 * Strip any JSON XSSI avoidance prefix from the string (as documented
 * in the source maps specification), and then parse the string as
 * JSON.
 */
function parseSourceMapInput(str) {
  return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ''));
}
exports.parseSourceMapInput = parseSourceMapInput;

/**
 * Compute the URL of a source given the the source root, the source's
 * URL, and the source map's URL.
 */
function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
  sourceURL = sourceURL || '';

  if (sourceRoot) {
    // This follows what Chrome does.
    if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {
      sourceRoot += '/';
    }
    // The spec says:
    //   Line 4: An optional source root, useful for relocating source
    //   files on a server or removing repeated values in the
    //   sources entry.  This value is prepended to the individual
    //   entries in the source field.
    sourceURL = sourceRoot + sourceURL;
  }

  // Historically, SourceMapConsumer did not take the sourceMapURL as
  // a parameter.  This mode is still somewhat supported, which is why
  // this code block is conditional.  However, it's preferable to pass
  // the source map URL to SourceMapConsumer, so that this function
  // can implement the source URL resolution algorithm as outlined in
  // the spec.  This block is basically the equivalent of:
  //    new URL(sourceURL, sourceMapURL).toString()
  // ... except it avoids using URL, which wasn't available in the
  // older releases of node still supported by this library.
  //
  // The spec says:
  //   If the sources are not absolute URLs after prepending of the
  //   sourceRoot, the sources are resolved relative to the
  //   SourceMap (like resolving script src in a html document).
  if (sourceMapURL) {
    var parsed = urlParse(sourceMapURL);
    if (!parsed) {
      throw new Error("sourceMapURL could not be parsed");
    }
    if (parsed.path) {
      // Strip the last path component, but keep the "/".
      var index = parsed.path.lastIndexOf('/');
      if (index >= 0) {
        parsed.path = parsed.path.substring(0, index + 1);
      }
    }
    sourceURL = join(urlGenerate(parsed), sourceURL);
  }

  return normalize(sourceURL);
}
exports.computeSourceURL = computeSourceURL;

},{}],1096:[function(require,module,exports){
/*
 * Copyright 2009-2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE.txt or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
exports.SourceMapGenerator = require('./lib/source-map-generator').SourceMapGenerator;
exports.SourceMapConsumer = require('./lib/source-map-consumer').SourceMapConsumer;
exports.SourceNode = require('./lib/source-node').SourceNode;

},{"./lib/source-map-consumer":1092,"./lib/source-map-generator":1093,"./lib/source-node":1094}],1097:[function(require,module,exports){
(function (process){
'use strict';

if (!process.version ||
    process.version.indexOf('v0.') === 0 ||
    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
  module.exports = { nextTick: nextTick };
} else {
  module.exports = process
}

function nextTick(fn, arg1, arg2, arg3) {
  if (typeof fn !== 'function') {
    throw new TypeError('"callback" argument must be a function');
  }
  var len = arguments.length;
  var args, i;
  switch (len) {
  case 0:
  case 1:
    return process.nextTick(fn);
  case 2:
    return process.nextTick(function afterTickOne() {
      fn.call(null, arg1);
    });
  case 3:
    return process.nextTick(function afterTickTwo() {
      fn.call(null, arg1, arg2);
    });
  case 4:
    return process.nextTick(function afterTickThree() {
      fn.call(null, arg1, arg2, arg3);
    });
  default:
    args = new Array(len - 1);
    i = 0;
    while (i < args.length) {
      args[i++] = arguments[i];
    }
    return process.nextTick(function afterTick() {
      fn.apply(null, args);
    });
  }
}


}).call(this,require('_process'))
},{"_process":1098}],1098:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],1099:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

},{}],1100:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};

},{}],1101:[function(require,module,exports){
'use strict';

exports.decode = exports.parse = require('./decode');
exports.encode = exports.stringify = require('./encode');

},{"./decode":1099,"./encode":1100}],1102:[function(require,module,exports){
module.exports = require('./lib/_stream_duplex.js');

},{"./lib/_stream_duplex.js":1103}],1103:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    keys.push(key);
  }return keys;
};
/*</replacement>*/

module.exports = Duplex;

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

var Readable = require('./_stream_readable');
var Writable = require('./_stream_writable');

util.inherits(Duplex, Readable);

{
  // avoid scope creep, the keys array can then be collected
  var keys = objectKeys(Writable.prototype);
  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false) this.readable = false;

  if (options && options.writable === false) this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

  this.once('end', onend);
}

Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
});

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended) return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  pna.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }
    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});

Duplex.prototype._destroy = function (err, cb) {
  this.push(null);
  this.end();

  pna.nextTick(cb, err);
};
},{"./_stream_readable":1105,"./_stream_writable":1107,"core-util-is":543,"inherits":728,"process-nextick-args":1097}],1104:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

'use strict';

module.exports = PassThrough;

var Transform = require('./_stream_transform');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};
},{"./_stream_transform":1106,"core-util-is":543,"inherits":728}],1105:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

module.exports = Readable;

/*<replacement>*/
var isArray = require('isarray');
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;

/*<replacement>*/
var EE = require('events').EventEmitter;

var EElistenerCount = function (emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/
var Stream = require('./internal/streams/stream');
/*</replacement>*/

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/
var debugUtil = require('util');
var debug = void 0;
if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function () {};
}
/*</replacement>*/

var BufferList = require('./internal/streams/BufferList');
var destroyImpl = require('./internal/streams/destroy');
var StringDecoder;

util.inherits(Readable, Stream);

var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);

  // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.
  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');

  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  var readableHwm = options.readableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()
  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;

  // has it been destroyed
  this.destroyed = false;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  if (!(this instanceof Readable)) return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined) {
      return false;
    }
    return this._readableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
  }
});

Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;
Readable.prototype._destroy = function (err, cb) {
  this.push(null);
  cb(err);
};

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;
      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }
      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  var state = stream._readableState;
  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);
    if (er) {
      stream.emit('error', er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        stream.emit('error', new Error('stream.push() after EOF'));
      } else {
        state.reading = false;
        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
    }
  }

  return needMoreData(state);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    stream.emit('data', chunk);
    stream.read(0);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);

    if (state.needReadable) emitReadable(stream);
  }
  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;
  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}

// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
};

// backwards compatibility.
Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};

// Don't raise the hwm > 8MB
var MAX_HWM = 0x800000;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}

// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;
  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  }
  // If we're asking for more than the current hwm, then raise the hwm.
  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n;
  // Don't have enough
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;

  if (n !== 0) state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0) state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
    // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.
    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  } else {
    state.length -= n;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true;

    // If we tried to read() past the EOF, then emit end on the next tick.
    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);

  return ret;
};

function onEofChunk(stream, state) {
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // emit 'readable' now to make sure it gets picked up.
  emitReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
}

// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    pna.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;else len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function (n) {
  this.emit('error', new Error('_read() is not implemented'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;

  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');
    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  var cleanedUp = false;
  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);

    cleanedUp = true;

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  // If the user pushes more data while we're writing to dest then we'll end up
  // in ondata again. However, we only want to increase awaitDrain once because
  // dest will only emit one 'drain' event for the multiple writes.
  // => Introduce a guard on increasing awaitDrain.
  var increasedAwaitDrain = false;
  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    increasedAwaitDrain = false;
    var ret = dest.write(chunk);
    if (false === ret && !increasedAwaitDrain) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', src._readableState.awaitDrain);
        src._readableState.awaitDrain++;
        increasedAwaitDrain = true;
      }
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
  }

  // Make sure our error handler is attached before userland ones.
  prependListener(dest, 'error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function () {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;
    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = { hasUnpiped: false };

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0) return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;

    if (!dest) dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, unpipeInfo);
    }return this;
  }

  // try to find the right one.
  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;

  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];

  dest.emit('unpipe', this, unpipeInfo);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  if (ev === 'data') {
    // Start flowing on next tick if stream isn't explicitly paused
    if (this._readableState.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    var state = this._readableState;
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.emittedReadable = false;
      if (!state.reading) {
        pna.nextTick(nReadingNextTick, this);
      } else if (state.length) {
        emitReadable(this);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function () {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    resume(this, state);
  }
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    pna.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  if (!state.reading) {
    debug('resume read 0');
    stream.read(0);
  }

  state.resumeScheduled = false;
  state.awaitDrain = 0;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  while (state.flowing && stream.read() !== null) {}
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;

  stream.on('end', function () {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });

  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function (method) {
        return function () {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  }

  // proxy certain important events.
  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  }

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  this._read = function (n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._readableState.highWaterMark;
  }
});

// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;

  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = fromListPartial(n, state.buffer, state.decoder);
  }

  return ret;
}

// Extracts only enough buffered data to satisfy the amount requested.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromListPartial(n, list, hasStrings) {
  var ret;
  if (n < list.head.data.length) {
    // slice is the same for buffers and strings
    ret = list.head.data.slice(0, n);
    list.head.data = list.head.data.slice(n);
  } else if (n === list.head.data.length) {
    // first chunk is a perfect match
    ret = list.shift();
  } else {
    // result spans more than one buffer
    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
  }
  return ret;
}

// Copies a specified amount of characters from the list of buffered data
// chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBufferString(n, list) {
  var p = list.head;
  var c = 1;
  var ret = p.data;
  n -= ret.length;
  while (p = p.next) {
    var str = p.data;
    var nb = n > str.length ? str.length : n;
    if (nb === str.length) ret += str;else ret += str.slice(0, n);
    n -= nb;
    if (n === 0) {
      if (nb === str.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = str.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

// Copies a specified amount of bytes from the list of buffered data chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBuffer(n, list) {
  var ret = Buffer.allocUnsafe(n);
  var p = list.head;
  var c = 1;
  p.data.copy(ret);
  n -= p.data.length;
  while (p = p.next) {
    var buf = p.data;
    var nb = n > buf.length ? buf.length : n;
    buf.copy(ret, ret.length - n, 0, nb);
    n -= nb;
    if (n === 0) {
      if (nb === buf.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = buf.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    pna.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
  }
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./_stream_duplex":1103,"./internal/streams/BufferList":1108,"./internal/streams/destroy":1109,"./internal/streams/stream":1110,"_process":1098,"core-util-is":543,"events":713,"inherits":728,"isarray":751,"process-nextick-args":1097,"safe-buffer":1118,"string_decoder/":1136,"util":7}],1106:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

'use strict';

module.exports = Transform;

var Duplex = require('./_stream_duplex');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(Transform, Duplex);

function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb) {
    return this.emit('error', new Error('write callback called multiple times'));
  }

  ts.writechunk = null;
  ts.writecb = null;

  if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);

  cb(er);

  var rs = this._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);

  Duplex.call(this, options);

  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  };

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;

    if (typeof options.flush === 'function') this._flush = options.flush;
  }

  // When the writable side finishes, then flush out anything remaining.
  this.on('prefinish', prefinish);
}

function prefinish() {
  var _this = this;

  if (typeof this._flush === 'function') {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function (chunk, encoding, cb) {
  throw new Error('_transform() is not implemented');
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  var _this2 = this;

  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
    _this2.emit('close');
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);

  if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');

  if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');

  return stream.push(null);
}
},{"./_stream_duplex":1103,"core-util-is":543,"inherits":728}],1107:[function(require,module,exports){
(function (process,global,setImmediate){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.

'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

module.exports = Writable;

/* <replacement> */
function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}

// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;
  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/
var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/
var internalUtil = {
  deprecate: require('util-deprecate')
};
/*</replacement>*/

/*<replacement>*/
var Stream = require('./internal/streams/stream');
/*</replacement>*/

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

var destroyImpl = require('./internal/streams/destroy');

util.inherits(Writable, Stream);

function nop() {}

function WritableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');

  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  var writableHwm = options.writableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // if _final has been called
  this.finalCalled = false;

  // drain event flag.
  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // has it been destroyed
  this.destroyed = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function (er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.bufferedRequest = null;
  this.lastBufferedRequest = null;

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;

  // count buffered requests
  this.bufferedRequestCount = 0;

  // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two
  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function () {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})();

// Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.
var realHasInstance;
if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function (object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;

      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function (object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.

  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
    return new Writable(options);
  }

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;

    if (typeof options.writev === 'function') this._writev = options.writev;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;

    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function () {
  this.emit('error', new Error('Cannot pipe, not readable'));
};

function writeAfterEnd(stream, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  pna.nextTick(cb, er);
}

// Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  var er = false;

  if (chunk === null) {
    er = new TypeError('May not write null values to stream');
  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  if (er) {
    stream.emit('error', er);
    pna.nextTick(cb, er);
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;
  var isBuf = !state.objectMode && _isUint8Array(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;

  if (typeof cb !== 'function') cb = nop;

  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }

  return ret;
};

Writable.prototype.cork = function () {
  var state = this._writableState;

  state.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;

    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }
  return chunk;
}

Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
});

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);
    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    pna.nextTick(cb, er);
    // this can emit finish, and it will always happen
    // after error
    pna.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
    // this can emit finish, but finish must
    // always follow error
    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state);

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      /*<replacement>*/
      asyncWrite(afterWrite, stream, state, finished, cb);
      /*</replacement>*/
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}

// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;

    var count = 0;
    var allBuffers = true;
    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }
    buffer.allBuffers = allBuffers;

    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

    // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;

      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--;
      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new Error('_write() is not implemented'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished) endWritable(this, state, cb);
};

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;
    if (err) {
      stream.emit('error', err);
    }
    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}
function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function') {
      state.pendingcb++;
      state.finalCalled = true;
      pna.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    prefinish(stream, state);
    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');
    }
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished) pna.nextTick(cb);else stream.once('finish', cb);
  }
  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;
  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  }
  if (state.corkedRequestsFree) {
    state.corkedRequestsFree.next = corkReq;
  } else {
    state.corkedRequestsFree = corkReq;
  }
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  get: function () {
    if (this._writableState === undefined) {
      return false;
    }
    return this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._writableState.destroyed = value;
  }
});

Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;
Writable.prototype._destroy = function (err, cb) {
  this.end();
  cb(err);
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("timers").setImmediate)
},{"./_stream_duplex":1103,"./internal/streams/destroy":1109,"./internal/streams/stream":1110,"_process":1098,"core-util-is":543,"inherits":728,"process-nextick-args":1097,"safe-buffer":1118,"timers":1195,"util-deprecate":1202}],1108:[function(require,module,exports){
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Buffer = require('safe-buffer').Buffer;
var util = require('util');

function copyBuffer(src, target, offset) {
  src.copy(target, offset);
}

module.exports = function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  BufferList.prototype.push = function push(v) {
    var entry = { data: v, next: null };
    if (this.length > 0) this.tail.next = entry;else this.head = entry;
    this.tail = entry;
    ++this.length;
  };

  BufferList.prototype.unshift = function unshift(v) {
    var entry = { data: v, next: this.head };
    if (this.length === 0) this.tail = entry;
    this.head = entry;
    ++this.length;
  };

  BufferList.prototype.shift = function shift() {
    if (this.length === 0) return;
    var ret = this.head.data;
    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
    --this.length;
    return ret;
  };

  BufferList.prototype.clear = function clear() {
    this.head = this.tail = null;
    this.length = 0;
  };

  BufferList.prototype.join = function join(s) {
    if (this.length === 0) return '';
    var p = this.head;
    var ret = '' + p.data;
    while (p = p.next) {
      ret += s + p.data;
    }return ret;
  };

  BufferList.prototype.concat = function concat(n) {
    if (this.length === 0) return Buffer.alloc(0);
    if (this.length === 1) return this.head.data;
    var ret = Buffer.allocUnsafe(n >>> 0);
    var p = this.head;
    var i = 0;
    while (p) {
      copyBuffer(p.data, ret, i);
      i += p.data.length;
      p = p.next;
    }
    return ret;
  };

  return BufferList;
}();

if (util && util.inspect && util.inspect.custom) {
  module.exports.prototype[util.inspect.custom] = function () {
    var obj = util.inspect({ length: this.length });
    return this.constructor.name + ' ' + obj;
  };
}
},{"safe-buffer":1118,"util":7}],1109:[function(require,module,exports){
'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

// undocumented cb() API, needed for core, not for public API
function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
      pna.nextTick(emitErrorNT, this, err);
    }
    return this;
  }

  // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks

  if (this._readableState) {
    this._readableState.destroyed = true;
  }

  // if this is a duplex stream mark the writable part as destroyed as well
  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      pna.nextTick(emitErrorNT, _this, err);
      if (_this._writableState) {
        _this._writableState.errorEmitted = true;
      }
    } else if (cb) {
      cb(err);
    }
  });

  return this;
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy
};
},{"process-nextick-args":1097}],1110:[function(require,module,exports){
module.exports = require('events').EventEmitter;

},{"events":713}],1111:[function(require,module,exports){
module.exports = require('./readable').PassThrough

},{"./readable":1112}],1112:[function(require,module,exports){
exports = module.exports = require('./lib/_stream_readable.js');
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = require('./lib/_stream_writable.js');
exports.Duplex = require('./lib/_stream_duplex.js');
exports.Transform = require('./lib/_stream_transform.js');
exports.PassThrough = require('./lib/_stream_passthrough.js');

},{"./lib/_stream_duplex.js":1103,"./lib/_stream_passthrough.js":1104,"./lib/_stream_readable.js":1105,"./lib/_stream_transform.js":1106,"./lib/_stream_writable.js":1107}],1113:[function(require,module,exports){
module.exports = require('./readable').Transform

},{"./readable":1112}],1114:[function(require,module,exports){
module.exports = require('./lib/_stream_writable.js');

},{"./lib/_stream_writable.js":1107}],1115:[function(require,module,exports){
'use strict';
const path = require('path');
const Module = require('module');

const resolveFrom = (fromDir, moduleId, silent) => {
	if (typeof fromDir !== 'string') {
		throw new TypeError(`Expected \`fromDir\` to be of type \`string\`, got \`${typeof fromDir}\``);
	}

	if (typeof moduleId !== 'string') {
		throw new TypeError(`Expected \`moduleId\` to be of type \`string\`, got \`${typeof moduleId}\``);
	}

	fromDir = path.resolve(fromDir);
	const fromFile = path.join(fromDir, 'noop.js');

	const resolveFileName = () => Module._resolveFilename(moduleId, {
		id: fromFile,
		filename: fromFile,
		paths: Module._nodeModulePaths(fromDir)
	});

	if (silent) {
		try {
			return resolveFileName();
		} catch (err) {
			return null;
		}
	}

	return resolveFileName();
};

module.exports = (fromDir, moduleId) => resolveFrom(fromDir, moduleId);
module.exports.silent = (fromDir, moduleId) => resolveFrom(fromDir, moduleId, true);

},{"module":8,"path":802}],1116:[function(require,module,exports){
'use strict';

module.exports = function rgbRegex(options) {
  options = options || {};

  return options.exact ?
    /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/ :
    /rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)/ig;
}

},{}],1117:[function(require,module,exports){
'use strict';

module.exports = function rgbaRegex(options) {
  options = options || {};

  return options.exact ?
    /^rgba\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3}),\s*(\d*(?:\.\d+)?)\)$/ :
    /rgba\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3}),\s*(\d*(?:\.\d+)?)\)/ig;
}

},{}],1118:[function(require,module,exports){
/* eslint-disable node/no-deprecated-api */
var buffer = require('buffer')
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}

},{"buffer":13}],1119:[function(require,module,exports){
(function (Buffer){
;(function (sax) { // wrapper for non-node envs
  sax.parser = function (strict, opt) { return new SAXParser(strict, opt) }
  sax.SAXParser = SAXParser
  sax.SAXStream = SAXStream
  sax.createStream = createStream

  // When we pass the MAX_BUFFER_LENGTH position, start checking for buffer overruns.
  // When we check, schedule the next check for MAX_BUFFER_LENGTH - (max(buffer lengths)),
  // since that's the earliest that a buffer overrun could occur.  This way, checks are
  // as rare as required, but as often as necessary to ensure never crossing this bound.
  // Furthermore, buffers are only tested at most once per write(), so passing a very
  // large string into write() might have undesirable effects, but this is manageable by
  // the caller, so it is assumed to be safe.  Thus, a call to write() may, in the extreme
  // edge case, result in creating at most one complete copy of the string passed in.
  // Set to Infinity to have unlimited buffers.
  sax.MAX_BUFFER_LENGTH = 64 * 1024

  var buffers = [
    'comment', 'sgmlDecl', 'textNode', 'tagName', 'doctype',
    'procInstName', 'procInstBody', 'entity', 'attribName',
    'attribValue', 'cdata', 'script'
  ]

  sax.EVENTS = [
    'text',
    'processinginstruction',
    'sgmldeclaration',
    'doctype',
    'comment',
    'opentagstart',
    'attribute',
    'opentag',
    'closetag',
    'opencdata',
    'cdata',
    'closecdata',
    'error',
    'end',
    'ready',
    'script',
    'opennamespace',
    'closenamespace'
  ]

  function SAXParser (strict, opt) {
    if (!(this instanceof SAXParser)) {
      return new SAXParser(strict, opt)
    }

    var parser = this
    clearBuffers(parser)
    parser.q = parser.c = ''
    parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH
    parser.opt = opt || {}
    parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags
    parser.looseCase = parser.opt.lowercase ? 'toLowerCase' : 'toUpperCase'
    parser.tags = []
    parser.closed = parser.closedRoot = parser.sawRoot = false
    parser.tag = parser.error = null
    parser.strict = !!strict
    parser.noscript = !!(strict || parser.opt.noscript)
    parser.state = S.BEGIN
    parser.strictEntities = parser.opt.strictEntities
    parser.ENTITIES = parser.strictEntities ? Object.create(sax.XML_ENTITIES) : Object.create(sax.ENTITIES)
    parser.attribList = []

    // namespaces form a prototype chain.
    // it always points at the current tag,
    // which protos to its parent tag.
    if (parser.opt.xmlns) {
      parser.ns = Object.create(rootNS)
    }

    // mostly just for error reporting
    parser.trackPosition = parser.opt.position !== false
    if (parser.trackPosition) {
      parser.position = parser.line = parser.column = 0
    }
    emit(parser, 'onready')
  }

  if (!Object.create) {
    Object.create = function (o) {
      function F () {}
      F.prototype = o
      var newf = new F()
      return newf
    }
  }

  if (!Object.keys) {
    Object.keys = function (o) {
      var a = []
      for (var i in o) if (o.hasOwnProperty(i)) a.push(i)
      return a
    }
  }

  function checkBufferLength (parser) {
    var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10)
    var maxActual = 0
    for (var i = 0, l = buffers.length; i < l; i++) {
      var len = parser[buffers[i]].length
      if (len > maxAllowed) {
        // Text/cdata nodes can get big, and since they're buffered,
        // we can get here under normal conditions.
        // Avoid issues by emitting the text node now,
        // so at least it won't get any bigger.
        switch (buffers[i]) {
          case 'textNode':
            closeText(parser)
            break

          case 'cdata':
            emitNode(parser, 'oncdata', parser.cdata)
            parser.cdata = ''
            break

          case 'script':
            emitNode(parser, 'onscript', parser.script)
            parser.script = ''
            break

          default:
            error(parser, 'Max buffer length exceeded: ' + buffers[i])
        }
      }
      maxActual = Math.max(maxActual, len)
    }
    // schedule the next check for the earliest possible buffer overrun.
    var m = sax.MAX_BUFFER_LENGTH - maxActual
    parser.bufferCheckPosition = m + parser.position
  }

  function clearBuffers (parser) {
    for (var i = 0, l = buffers.length; i < l; i++) {
      parser[buffers[i]] = ''
    }
  }

  function flushBuffers (parser) {
    closeText(parser)
    if (parser.cdata !== '') {
      emitNode(parser, 'oncdata', parser.cdata)
      parser.cdata = ''
    }
    if (parser.script !== '') {
      emitNode(parser, 'onscript', parser.script)
      parser.script = ''
    }
  }

  SAXParser.prototype = {
    end: function () { end(this) },
    write: write,
    resume: function () { this.error = null; return this },
    close: function () { return this.write(null) },
    flush: function () { flushBuffers(this) }
  }

  var Stream
  try {
    Stream = require('stream').Stream
  } catch (ex) {
    Stream = function () {}
  }

  var streamWraps = sax.EVENTS.filter(function (ev) {
    return ev !== 'error' && ev !== 'end'
  })

  function createStream (strict, opt) {
    return new SAXStream(strict, opt)
  }

  function SAXStream (strict, opt) {
    if (!(this instanceof SAXStream)) {
      return new SAXStream(strict, opt)
    }

    Stream.apply(this)

    this._parser = new SAXParser(strict, opt)
    this.writable = true
    this.readable = true

    var me = this

    this._parser.onend = function () {
      me.emit('end')
    }

    this._parser.onerror = function (er) {
      me.emit('error', er)

      // if didn't throw, then means error was handled.
      // go ahead and clear error, so we can write again.
      me._parser.error = null
    }

    this._decoder = null

    streamWraps.forEach(function (ev) {
      Object.defineProperty(me, 'on' + ev, {
        get: function () {
          return me._parser['on' + ev]
        },
        set: function (h) {
          if (!h) {
            me.removeAllListeners(ev)
            me._parser['on' + ev] = h
            return h
          }
          me.on(ev, h)
        },
        enumerable: true,
        configurable: false
      })
    })
  }

  SAXStream.prototype = Object.create(Stream.prototype, {
    constructor: {
      value: SAXStream
    }
  })

  SAXStream.prototype.write = function (data) {
    if (typeof Buffer === 'function' &&
      typeof Buffer.isBuffer === 'function' &&
      Buffer.isBuffer(data)) {
      if (!this._decoder) {
        var SD = require('string_decoder').StringDecoder
        this._decoder = new SD('utf8')
      }
      data = this._decoder.write(data)
    }

    this._parser.write(data.toString())
    this.emit('data', data)
    return true
  }

  SAXStream.prototype.end = function (chunk) {
    if (chunk && chunk.length) {
      this.write(chunk)
    }
    this._parser.end()
    return true
  }

  SAXStream.prototype.on = function (ev, handler) {
    var me = this
    if (!me._parser['on' + ev] && streamWraps.indexOf(ev) !== -1) {
      me._parser['on' + ev] = function () {
        var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments)
        args.splice(0, 0, ev)
        me.emit.apply(me, args)
      }
    }

    return Stream.prototype.on.call(me, ev, handler)
  }

  // this really needs to be replaced with character classes.
  // XML allows all manner of ridiculous numbers and digits.
  var CDATA = '[CDATA['
  var DOCTYPE = 'DOCTYPE'
  var XML_NAMESPACE = 'http://www.w3.org/XML/1998/namespace'
  var XMLNS_NAMESPACE = 'http://www.w3.org/2000/xmlns/'
  var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE }

  // http://www.w3.org/TR/REC-xml/#NT-NameStartChar
  // This implementation works on strings, a single character at a time
  // as such, it cannot ever support astral-plane characters (10000-EFFFF)
  // without a significant breaking change to either this  parser, or the
  // JavaScript language.  Implementation of an emoji-capable xml parser
  // is left as an exercise for the reader.
  var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/

  var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/

  var entityStart = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/
  var entityBody = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/

  function isWhitespace (c) {
    return c === ' ' || c === '\n' || c === '\r' || c === '\t'
  }

  function isQuote (c) {
    return c === '"' || c === '\''
  }

  function isAttribEnd (c) {
    return c === '>' || isWhitespace(c)
  }

  function isMatch (regex, c) {
    return regex.test(c)
  }

  function notMatch (regex, c) {
    return !isMatch(regex, c)
  }

  var S = 0
  sax.STATE = {
    BEGIN: S++, // leading byte order mark or whitespace
    BEGIN_WHITESPACE: S++, // leading whitespace
    TEXT: S++, // general stuff
    TEXT_ENTITY: S++, // &amp and such.
    OPEN_WAKA: S++, // <
    SGML_DECL: S++, // <!BLARG
    SGML_DECL_QUOTED: S++, // <!BLARG foo "bar
    DOCTYPE: S++, // <!DOCTYPE
    DOCTYPE_QUOTED: S++, // <!DOCTYPE "//blah
    DOCTYPE_DTD: S++, // <!DOCTYPE "//blah" [ ...
    DOCTYPE_DTD_QUOTED: S++, // <!DOCTYPE "//blah" [ "foo
    COMMENT_STARTING: S++, // <!-
    COMMENT: S++, // <!--
    COMMENT_ENDING: S++, // <!-- blah -
    COMMENT_ENDED: S++, // <!-- blah --
    CDATA: S++, // <![CDATA[ something
    CDATA_ENDING: S++, // ]
    CDATA_ENDING_2: S++, // ]]
    PROC_INST: S++, // <?hi
    PROC_INST_BODY: S++, // <?hi there
    PROC_INST_ENDING: S++, // <?hi "there" ?
    OPEN_TAG: S++, // <strong
    OPEN_TAG_SLASH: S++, // <strong /
    ATTRIB: S++, // <a
    ATTRIB_NAME: S++, // <a foo
    ATTRIB_NAME_SAW_WHITE: S++, // <a foo _
    ATTRIB_VALUE: S++, // <a foo=
    ATTRIB_VALUE_QUOTED: S++, // <a foo="bar
    ATTRIB_VALUE_CLOSED: S++, // <a foo="bar"
    ATTRIB_VALUE_UNQUOTED: S++, // <a foo=bar
    ATTRIB_VALUE_ENTITY_Q: S++, // <foo bar="&quot;"
    ATTRIB_VALUE_ENTITY_U: S++, // <foo bar=&quot
    CLOSE_TAG: S++, // </a
    CLOSE_TAG_SAW_WHITE: S++, // </a   >
    SCRIPT: S++, // <script> ...
    SCRIPT_ENDING: S++ // <script> ... <
  }

  sax.XML_ENTITIES = {
    'amp': '&',
    'gt': '>',
    'lt': '<',
    'quot': '"',
    'apos': "'"
  }

  sax.ENTITIES = {
    'amp': '&',
    'gt': '>',
    'lt': '<',
    'quot': '"',
    'apos': "'",
    'AElig': 198,
    'Aacute': 193,
    'Acirc': 194,
    'Agrave': 192,
    'Aring': 197,
    'Atilde': 195,
    'Auml': 196,
    'Ccedil': 199,
    'ETH': 208,
    'Eacute': 201,
    'Ecirc': 202,
    'Egrave': 200,
    'Euml': 203,
    'Iacute': 205,
    'Icirc': 206,
    'Igrave': 204,
    'Iuml': 207,
    'Ntilde': 209,
    'Oacute': 211,
    'Ocirc': 212,
    'Ograve': 210,
    'Oslash': 216,
    'Otilde': 213,
    'Ouml': 214,
    'THORN': 222,
    'Uacute': 218,
    'Ucirc': 219,
    'Ugrave': 217,
    'Uuml': 220,
    'Yacute': 221,
    'aacute': 225,
    'acirc': 226,
    'aelig': 230,
    'agrave': 224,
    'aring': 229,
    'atilde': 227,
    'auml': 228,
    'ccedil': 231,
    'eacute': 233,
    'ecirc': 234,
    'egrave': 232,
    'eth': 240,
    'euml': 235,
    'iacute': 237,
    'icirc': 238,
    'igrave': 236,
    'iuml': 239,
    'ntilde': 241,
    'oacute': 243,
    'ocirc': 244,
    'ograve': 242,
    'oslash': 248,
    'otilde': 245,
    'ouml': 246,
    'szlig': 223,
    'thorn': 254,
    'uacute': 250,
    'ucirc': 251,
    'ugrave': 249,
    'uuml': 252,
    'yacute': 253,
    'yuml': 255,
    'copy': 169,
    'reg': 174,
    'nbsp': 160,
    'iexcl': 161,
    'cent': 162,
    'pound': 163,
    'curren': 164,
    'yen': 165,
    'brvbar': 166,
    'sect': 167,
    'uml': 168,
    'ordf': 170,
    'laquo': 171,
    'not': 172,
    'shy': 173,
    'macr': 175,
    'deg': 176,
    'plusmn': 177,
    'sup1': 185,
    'sup2': 178,
    'sup3': 179,
    'acute': 180,
    'micro': 181,
    'para': 182,
    'middot': 183,
    'cedil': 184,
    'ordm': 186,
    'raquo': 187,
    'frac14': 188,
    'frac12': 189,
    'frac34': 190,
    'iquest': 191,
    'times': 215,
    'divide': 247,
    'OElig': 338,
    'oelig': 339,
    'Scaron': 352,
    'scaron': 353,
    'Yuml': 376,
    'fnof': 402,
    'circ': 710,
    'tilde': 732,
    'Alpha': 913,
    'Beta': 914,
    'Gamma': 915,
    'Delta': 916,
    'Epsilon': 917,
    'Zeta': 918,
    'Eta': 919,
    'Theta': 920,
    'Iota': 921,
    'Kappa': 922,
    'Lambda': 923,
    'Mu': 924,
    'Nu': 925,
    'Xi': 926,
    'Omicron': 927,
    'Pi': 928,
    'Rho': 929,
    'Sigma': 931,
    'Tau': 932,
    'Upsilon': 933,
    'Phi': 934,
    'Chi': 935,
    'Psi': 936,
    'Omega': 937,
    'alpha': 945,
    'beta': 946,
    'gamma': 947,
    'delta': 948,
    'epsilon': 949,
    'zeta': 950,
    'eta': 951,
    'theta': 952,
    'iota': 953,
    'kappa': 954,
    'lambda': 955,
    'mu': 956,
    'nu': 957,
    'xi': 958,
    'omicron': 959,
    'pi': 960,
    'rho': 961,
    'sigmaf': 962,
    'sigma': 963,
    'tau': 964,
    'upsilon': 965,
    'phi': 966,
    'chi': 967,
    'psi': 968,
    'omega': 969,
    'thetasym': 977,
    'upsih': 978,
    'piv': 982,
    'ensp': 8194,
    'emsp': 8195,
    'thinsp': 8201,
    'zwnj': 8204,
    'zwj': 8205,
    'lrm': 8206,
    'rlm': 8207,
    'ndash': 8211,
    'mdash': 8212,
    'lsquo': 8216,
    'rsquo': 8217,
    'sbquo': 8218,
    'ldquo': 8220,
    'rdquo': 8221,
    'bdquo': 8222,
    'dagger': 8224,
    'Dagger': 8225,
    'bull': 8226,
    'hellip': 8230,
    'permil': 8240,
    'prime': 8242,
    'Prime': 8243,
    'lsaquo': 8249,
    'rsaquo': 8250,
    'oline': 8254,
    'frasl': 8260,
    'euro': 8364,
    'image': 8465,
    'weierp': 8472,
    'real': 8476,
    'trade': 8482,
    'alefsym': 8501,
    'larr': 8592,
    'uarr': 8593,
    'rarr': 8594,
    'darr': 8595,
    'harr': 8596,
    'crarr': 8629,
    'lArr': 8656,
    'uArr': 8657,
    'rArr': 8658,
    'dArr': 8659,
    'hArr': 8660,
    'forall': 8704,
    'part': 8706,
    'exist': 8707,
    'empty': 8709,
    'nabla': 8711,
    'isin': 8712,
    'notin': 8713,
    'ni': 8715,
    'prod': 8719,
    'sum': 8721,
    'minus': 8722,
    'lowast': 8727,
    'radic': 8730,
    'prop': 8733,
    'infin': 8734,
    'ang': 8736,
    'and': 8743,
    'or': 8744,
    'cap': 8745,
    'cup': 8746,
    'int': 8747,
    'there4': 8756,
    'sim': 8764,
    'cong': 8773,
    'asymp': 8776,
    'ne': 8800,
    'equiv': 8801,
    'le': 8804,
    'ge': 8805,
    'sub': 8834,
    'sup': 8835,
    'nsub': 8836,
    'sube': 8838,
    'supe': 8839,
    'oplus': 8853,
    'otimes': 8855,
    'perp': 8869,
    'sdot': 8901,
    'lceil': 8968,
    'rceil': 8969,
    'lfloor': 8970,
    'rfloor': 8971,
    'lang': 9001,
    'rang': 9002,
    'loz': 9674,
    'spades': 9824,
    'clubs': 9827,
    'hearts': 9829,
    'diams': 9830
  }

  Object.keys(sax.ENTITIES).forEach(function (key) {
    var e = sax.ENTITIES[key]
    var s = typeof e === 'number' ? String.fromCharCode(e) : e
    sax.ENTITIES[key] = s
  })

  for (var s in sax.STATE) {
    sax.STATE[sax.STATE[s]] = s
  }

  // shorthand
  S = sax.STATE

  function emit (parser, event, data) {
    parser[event] && parser[event](data)
  }

  function emitNode (parser, nodeType, data) {
    if (parser.textNode) closeText(parser)
    emit(parser, nodeType, data)
  }

  function closeText (parser) {
    parser.textNode = textopts(parser.opt, parser.textNode)
    if (parser.textNode) emit(parser, 'ontext', parser.textNode)
    parser.textNode = ''
  }

  function textopts (opt, text) {
    if (opt.trim) text = text.trim()
    if (opt.normalize) text = text.replace(/\s+/g, ' ')
    return text
  }

  function error (parser, er) {
    closeText(parser)
    if (parser.trackPosition) {
      er += '\nLine: ' + parser.line +
        '\nColumn: ' + parser.column +
        '\nChar: ' + parser.c
    }
    er = new Error(er)
    parser.error = er
    emit(parser, 'onerror', er)
    return parser
  }

  function end (parser) {
    if (parser.sawRoot && !parser.closedRoot) strictFail(parser, 'Unclosed root tag')
    if ((parser.state !== S.BEGIN) &&
      (parser.state !== S.BEGIN_WHITESPACE) &&
      (parser.state !== S.TEXT)) {
      error(parser, 'Unexpected end')
    }
    closeText(parser)
    parser.c = ''
    parser.closed = true
    emit(parser, 'onend')
    SAXParser.call(parser, parser.strict, parser.opt)
    return parser
  }

  function strictFail (parser, message) {
    if (typeof parser !== 'object' || !(parser instanceof SAXParser)) {
      throw new Error('bad call to strictFail')
    }
    if (parser.strict) {
      error(parser, message)
    }
  }

  function newTag (parser) {
    if (!parser.strict) parser.tagName = parser.tagName[parser.looseCase]()
    var parent = parser.tags[parser.tags.length - 1] || parser
    var tag = parser.tag = { name: parser.tagName, attributes: {} }

    // will be overridden if tag contails an xmlns="foo" or xmlns:foo="bar"
    if (parser.opt.xmlns) {
      tag.ns = parent.ns
    }
    parser.attribList.length = 0
    emitNode(parser, 'onopentagstart', tag)
  }

  function qname (name, attribute) {
    var i = name.indexOf(':')
    var qualName = i < 0 ? [ '', name ] : name.split(':')
    var prefix = qualName[0]
    var local = qualName[1]

    // <x "xmlns"="http://foo">
    if (attribute && name === 'xmlns') {
      prefix = 'xmlns'
      local = ''
    }

    return { prefix: prefix, local: local }
  }

  function attrib (parser) {
    if (!parser.strict) {
      parser.attribName = parser.attribName[parser.looseCase]()
    }

    if (parser.attribList.indexOf(parser.attribName) !== -1 ||
      parser.tag.attributes.hasOwnProperty(parser.attribName)) {
      parser.attribName = parser.attribValue = ''
      return
    }

    if (parser.opt.xmlns) {
      var qn = qname(parser.attribName, true)
      var prefix = qn.prefix
      var local = qn.local

      if (prefix === 'xmlns') {
        // namespace binding attribute. push the binding into scope
        if (local === 'xml' && parser.attribValue !== XML_NAMESPACE) {
          strictFail(parser,
            'xml: prefix must be bound to ' + XML_NAMESPACE + '\n' +
            'Actual: ' + parser.attribValue)
        } else if (local === 'xmlns' && parser.attribValue !== XMLNS_NAMESPACE) {
          strictFail(parser,
            'xmlns: prefix must be bound to ' + XMLNS_NAMESPACE + '\n' +
            'Actual: ' + parser.attribValue)
        } else {
          var tag = parser.tag
          var parent = parser.tags[parser.tags.length - 1] || parser
          if (tag.ns === parent.ns) {
            tag.ns = Object.create(parent.ns)
          }
          tag.ns[local] = parser.attribValue
        }
      }

      // defer onattribute events until all attributes have been seen
      // so any new bindings can take effect. preserve attribute order
      // so deferred events can be emitted in document order
      parser.attribList.push([parser.attribName, parser.attribValue])
    } else {
      // in non-xmlns mode, we can emit the event right away
      parser.tag.attributes[parser.attribName] = parser.attribValue
      emitNode(parser, 'onattribute', {
        name: parser.attribName,
        value: parser.attribValue
      })
    }

    parser.attribName = parser.attribValue = ''
  }

  function openTag (parser, selfClosing) {
    if (parser.opt.xmlns) {
      // emit namespace binding events
      var tag = parser.tag

      // add namespace info to tag
      var qn = qname(parser.tagName)
      tag.prefix = qn.prefix
      tag.local = qn.local
      tag.uri = tag.ns[qn.prefix] || ''

      if (tag.prefix && !tag.uri) {
        strictFail(parser, 'Unbound namespace prefix: ' +
          JSON.stringify(parser.tagName))
        tag.uri = qn.prefix
      }

      var parent = parser.tags[parser.tags.length - 1] || parser
      if (tag.ns && parent.ns !== tag.ns) {
        Object.keys(tag.ns).forEach(function (p) {
          emitNode(parser, 'onopennamespace', {
            prefix: p,
            uri: tag.ns[p]
          })
        })
      }

      // handle deferred onattribute events
      // Note: do not apply default ns to attributes:
      //   http://www.w3.org/TR/REC-xml-names/#defaulting
      for (var i = 0, l = parser.attribList.length; i < l; i++) {
        var nv = parser.attribList[i]
        var name = nv[0]
        var value = nv[1]
        var qualName = qname(name, true)
        var prefix = qualName.prefix
        var local = qualName.local
        var uri = prefix === '' ? '' : (tag.ns[prefix] || '')
        var a = {
          name: name,
          value: value,
          prefix: prefix,
          local: local,
          uri: uri
        }

        // if there's any attributes with an undefined namespace,
        // then fail on them now.
        if (prefix && prefix !== 'xmlns' && !uri) {
          strictFail(parser, 'Unbound namespace prefix: ' +
            JSON.stringify(prefix))
          a.uri = prefix
        }
        parser.tag.attributes[name] = a
        emitNode(parser, 'onattribute', a)
      }
      parser.attribList.length = 0
    }

    parser.tag.isSelfClosing = !!selfClosing

    // process the tag
    parser.sawRoot = true
    parser.tags.push(parser.tag)
    emitNode(parser, 'onopentag', parser.tag)
    if (!selfClosing) {
      // special case for <script> in non-strict mode.
      if (!parser.noscript && parser.tagName.toLowerCase() === 'script') {
        parser.state = S.SCRIPT
      } else {
        parser.state = S.TEXT
      }
      parser.tag = null
      parser.tagName = ''
    }
    parser.attribName = parser.attribValue = ''
    parser.attribList.length = 0
  }

  function closeTag (parser) {
    if (!parser.tagName) {
      strictFail(parser, 'Weird empty close tag.')
      parser.textNode += '</>'
      parser.state = S.TEXT
      return
    }

    if (parser.script) {
      if (parser.tagName !== 'script') {
        parser.script += '</' + parser.tagName + '>'
        parser.tagName = ''
        parser.state = S.SCRIPT
        return
      }
      emitNode(parser, 'onscript', parser.script)
      parser.script = ''
    }

    // first make sure that the closing tag actually exists.
    // <a><b></c></b></a> will close everything, otherwise.
    var t = parser.tags.length
    var tagName = parser.tagName
    if (!parser.strict) {
      tagName = tagName[parser.looseCase]()
    }
    var closeTo = tagName
    while (t--) {
      var close = parser.tags[t]
      if (close.name !== closeTo) {
        // fail the first time in strict mode
        strictFail(parser, 'Unexpected close tag')
      } else {
        break
      }
    }

    // didn't find it.  we already failed for strict, so just abort.
    if (t < 0) {
      strictFail(parser, 'Unmatched closing tag: ' + parser.tagName)
      parser.textNode += '</' + parser.tagName + '>'
      parser.state = S.TEXT
      return
    }
    parser.tagName = tagName
    var s = parser.tags.length
    while (s-- > t) {
      var tag = parser.tag = parser.tags.pop()
      parser.tagName = parser.tag.name
      emitNode(parser, 'onclosetag', parser.tagName)

      var x = {}
      for (var i in tag.ns) {
        x[i] = tag.ns[i]
      }

      var parent = parser.tags[parser.tags.length - 1] || parser
      if (parser.opt.xmlns && tag.ns !== parent.ns) {
        // remove namespace bindings introduced by tag
        Object.keys(tag.ns).forEach(function (p) {
          var n = tag.ns[p]
          emitNode(parser, 'onclosenamespace', { prefix: p, uri: n })
        })
      }
    }
    if (t === 0) parser.closedRoot = true
    parser.tagName = parser.attribValue = parser.attribName = ''
    parser.attribList.length = 0
    parser.state = S.TEXT
  }

  function parseEntity (parser) {
    var entity = parser.entity
    var entityLC = entity.toLowerCase()
    var num
    var numStr = ''

    if (parser.ENTITIES[entity]) {
      return parser.ENTITIES[entity]
    }
    if (parser.ENTITIES[entityLC]) {
      return parser.ENTITIES[entityLC]
    }
    entity = entityLC
    if (entity.charAt(0) === '#') {
      if (entity.charAt(1) === 'x') {
        entity = entity.slice(2)
        num = parseInt(entity, 16)
        numStr = num.toString(16)
      } else {
        entity = entity.slice(1)
        num = parseInt(entity, 10)
        numStr = num.toString(10)
      }
    }
    entity = entity.replace(/^0+/, '')
    if (isNaN(num) || numStr.toLowerCase() !== entity) {
      strictFail(parser, 'Invalid character entity')
      return '&' + parser.entity + ';'
    }

    return String.fromCodePoint(num)
  }

  function beginWhiteSpace (parser, c) {
    if (c === '<') {
      parser.state = S.OPEN_WAKA
      parser.startTagPosition = parser.position
    } else if (!isWhitespace(c)) {
      // have to process this as a text node.
      // weird, but happens.
      strictFail(parser, 'Non-whitespace before first tag.')
      parser.textNode = c
      parser.state = S.TEXT
    }
  }

  function charAt (chunk, i) {
    var result = ''
    if (i < chunk.length) {
      result = chunk.charAt(i)
    }
    return result
  }

  function write (chunk) {
    var parser = this
    if (this.error) {
      throw this.error
    }
    if (parser.closed) {
      return error(parser,
        'Cannot write after close. Assign an onready handler.')
    }
    if (chunk === null) {
      return end(parser)
    }
    if (typeof chunk === 'object') {
      chunk = chunk.toString()
    }
    var i = 0
    var c = ''
    while (true) {
      c = charAt(chunk, i++)
      parser.c = c

      if (!c) {
        break
      }

      if (parser.trackPosition) {
        parser.position++
        if (c === '\n') {
          parser.line++
          parser.column = 0
        } else {
          parser.column++
        }
      }

      switch (parser.state) {
        case S.BEGIN:
          parser.state = S.BEGIN_WHITESPACE
          if (c === '\uFEFF') {
            continue
          }
          beginWhiteSpace(parser, c)
          continue

        case S.BEGIN_WHITESPACE:
          beginWhiteSpace(parser, c)
          continue

        case S.TEXT:
          if (parser.sawRoot && !parser.closedRoot) {
            var starti = i - 1
            while (c && c !== '<' && c !== '&') {
              c = charAt(chunk, i++)
              if (c && parser.trackPosition) {
                parser.position++
                if (c === '\n') {
                  parser.line++
                  parser.column = 0
                } else {
                  parser.column++
                }
              }
            }
            parser.textNode += chunk.substring(starti, i - 1)
          }
          if (c === '<' && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {
            parser.state = S.OPEN_WAKA
            parser.startTagPosition = parser.position
          } else {
            if (!isWhitespace(c) && (!parser.sawRoot || parser.closedRoot)) {
              strictFail(parser, 'Text data outside of root node.')
            }
            if (c === '&') {
              parser.state = S.TEXT_ENTITY
            } else {
              parser.textNode += c
            }
          }
          continue

        case S.SCRIPT:
          // only non-strict
          if (c === '<') {
            parser.state = S.SCRIPT_ENDING
          } else {
            parser.script += c
          }
          continue

        case S.SCRIPT_ENDING:
          if (c === '/') {
            parser.state = S.CLOSE_TAG
          } else {
            parser.script += '<' + c
            parser.state = S.SCRIPT
          }
          continue

        case S.OPEN_WAKA:
          // either a /, ?, !, or text is coming next.
          if (c === '!') {
            parser.state = S.SGML_DECL
            parser.sgmlDecl = ''
          } else if (isWhitespace(c)) {
            // wait for it...
          } else if (isMatch(nameStart, c)) {
            parser.state = S.OPEN_TAG
            parser.tagName = c
          } else if (c === '/') {
            parser.state = S.CLOSE_TAG
            parser.tagName = ''
          } else if (c === '?') {
            parser.state = S.PROC_INST
            parser.procInstName = parser.procInstBody = ''
          } else {
            strictFail(parser, 'Unencoded <')
            // if there was some whitespace, then add that in.
            if (parser.startTagPosition + 1 < parser.position) {
              var pad = parser.position - parser.startTagPosition
              c = new Array(pad).join(' ') + c
            }
            parser.textNode += '<' + c
            parser.state = S.TEXT
          }
          continue

        case S.SGML_DECL:
          if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {
            emitNode(parser, 'onopencdata')
            parser.state = S.CDATA
            parser.sgmlDecl = ''
            parser.cdata = ''
          } else if (parser.sgmlDecl + c === '--') {
            parser.state = S.COMMENT
            parser.comment = ''
            parser.sgmlDecl = ''
          } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {
            parser.state = S.DOCTYPE
            if (parser.doctype || parser.sawRoot) {
              strictFail(parser,
                'Inappropriately located doctype declaration')
            }
            parser.doctype = ''
            parser.sgmlDecl = ''
          } else if (c === '>') {
            emitNode(parser, 'onsgmldeclaration', parser.sgmlDecl)
            parser.sgmlDecl = ''
            parser.state = S.TEXT
          } else if (isQuote(c)) {
            parser.state = S.SGML_DECL_QUOTED
            parser.sgmlDecl += c
          } else {
            parser.sgmlDecl += c
          }
          continue

        case S.SGML_DECL_QUOTED:
          if (c === parser.q) {
            parser.state = S.SGML_DECL
            parser.q = ''
          }
          parser.sgmlDecl += c
          continue

        case S.DOCTYPE:
          if (c === '>') {
            parser.state = S.TEXT
            emitNode(parser, 'ondoctype', parser.doctype)
            parser.doctype = true // just remember that we saw it.
          } else {
            parser.doctype += c
            if (c === '[') {
              parser.state = S.DOCTYPE_DTD
            } else if (isQuote(c)) {
              parser.state = S.DOCTYPE_QUOTED
              parser.q = c
            }
          }
          continue

        case S.DOCTYPE_QUOTED:
          parser.doctype += c
          if (c === parser.q) {
            parser.q = ''
            parser.state = S.DOCTYPE
          }
          continue

        case S.DOCTYPE_DTD:
          parser.doctype += c
          if (c === ']') {
            parser.state = S.DOCTYPE
          } else if (isQuote(c)) {
            parser.state = S.DOCTYPE_DTD_QUOTED
            parser.q = c
          }
          continue

        case S.DOCTYPE_DTD_QUOTED:
          parser.doctype += c
          if (c === parser.q) {
            parser.state = S.DOCTYPE_DTD
            parser.q = ''
          }
          continue

        case S.COMMENT:
          if (c === '-') {
            parser.state = S.COMMENT_ENDING
          } else {
            parser.comment += c
          }
          continue

        case S.COMMENT_ENDING:
          if (c === '-') {
            parser.state = S.COMMENT_ENDED
            parser.comment = textopts(parser.opt, parser.comment)
            if (parser.comment) {
              emitNode(parser, 'oncomment', parser.comment)
            }
            parser.comment = ''
          } else {
            parser.comment += '-' + c
            parser.state = S.COMMENT
          }
          continue

        case S.COMMENT_ENDED:
          if (c !== '>') {
            strictFail(parser, 'Malformed comment')
            // allow <!-- blah -- bloo --> in non-strict mode,
            // which is a comment of " blah -- bloo "
            parser.comment += '--' + c
            parser.state = S.COMMENT
          } else {
            parser.state = S.TEXT
          }
          continue

        case S.CDATA:
          if (c === ']') {
            parser.state = S.CDATA_ENDING
          } else {
            parser.cdata += c
          }
          continue

        case S.CDATA_ENDING:
          if (c === ']') {
            parser.state = S.CDATA_ENDING_2
          } else {
            parser.cdata += ']' + c
            parser.state = S.CDATA
          }
          continue

        case S.CDATA_ENDING_2:
          if (c === '>') {
            if (parser.cdata) {
              emitNode(parser, 'oncdata', parser.cdata)
            }
            emitNode(parser, 'onclosecdata')
            parser.cdata = ''
            parser.state = S.TEXT
          } else if (c === ']') {
            parser.cdata += ']'
          } else {
            parser.cdata += ']]' + c
            parser.state = S.CDATA
          }
          continue

        case S.PROC_INST:
          if (c === '?') {
            parser.state = S.PROC_INST_ENDING
          } else if (isWhitespace(c)) {
            parser.state = S.PROC_INST_BODY
          } else {
            parser.procInstName += c
          }
          continue

        case S.PROC_INST_BODY:
          if (!parser.procInstBody && isWhitespace(c)) {
            continue
          } else if (c === '?') {
            parser.state = S.PROC_INST_ENDING
          } else {
            parser.procInstBody += c
          }
          continue

        case S.PROC_INST_ENDING:
          if (c === '>') {
            emitNode(parser, 'onprocessinginstruction', {
              name: parser.procInstName,
              body: parser.procInstBody
            })
            parser.procInstName = parser.procInstBody = ''
            parser.state = S.TEXT
          } else {
            parser.procInstBody += '?' + c
            parser.state = S.PROC_INST_BODY
          }
          continue

        case S.OPEN_TAG:
          if (isMatch(nameBody, c)) {
            parser.tagName += c
          } else {
            newTag(parser)
            if (c === '>') {
              openTag(parser)
            } else if (c === '/') {
              parser.state = S.OPEN_TAG_SLASH
            } else {
              if (!isWhitespace(c)) {
                strictFail(parser, 'Invalid character in tag name')
              }
              parser.state = S.ATTRIB
            }
          }
          continue

        case S.OPEN_TAG_SLASH:
          if (c === '>') {
            openTag(parser, true)
            closeTag(parser)
          } else {
            strictFail(parser, 'Forward-slash in opening tag not followed by >')
            parser.state = S.ATTRIB
          }
          continue

        case S.ATTRIB:
          // haven't read the attribute name yet.
          if (isWhitespace(c)) {
            continue
          } else if (c === '>') {
            openTag(parser)
          } else if (c === '/') {
            parser.state = S.OPEN_TAG_SLASH
          } else if (isMatch(nameStart, c)) {
            parser.attribName = c
            parser.attribValue = ''
            parser.state = S.ATTRIB_NAME
          } else {
            strictFail(parser, 'Invalid attribute name')
          }
          continue

        case S.ATTRIB_NAME:
          if (c === '=') {
            parser.state = S.ATTRIB_VALUE
          } else if (c === '>') {
            strictFail(parser, 'Attribute without value')
            parser.attribValue = parser.attribName
            attrib(parser)
            openTag(parser)
          } else if (isWhitespace(c)) {
            parser.state = S.ATTRIB_NAME_SAW_WHITE
          } else if (isMatch(nameBody, c)) {
            parser.attribName += c
          } else {
            strictFail(parser, 'Invalid attribute name')
          }
          continue

        case S.ATTRIB_NAME_SAW_WHITE:
          if (c === '=') {
            parser.state = S.ATTRIB_VALUE
          } else if (isWhitespace(c)) {
            continue
          } else {
            strictFail(parser, 'Attribute without value')
            parser.tag.attributes[parser.attribName] = ''
            parser.attribValue = ''
            emitNode(parser, 'onattribute', {
              name: parser.attribName,
              value: ''
            })
            parser.attribName = ''
            if (c === '>') {
              openTag(parser)
            } else if (isMatch(nameStart, c)) {
              parser.attribName = c
              parser.state = S.ATTRIB_NAME
            } else {
              strictFail(parser, 'Invalid attribute name')
              parser.state = S.ATTRIB
            }
          }
          continue

        case S.ATTRIB_VALUE:
          if (isWhitespace(c)) {
            continue
          } else if (isQuote(c)) {
            parser.q = c
            parser.state = S.ATTRIB_VALUE_QUOTED
          } else {
            strictFail(parser, 'Unquoted attribute value')
            parser.state = S.ATTRIB_VALUE_UNQUOTED
            parser.attribValue = c
          }
          continue

        case S.ATTRIB_VALUE_QUOTED:
          if (c !== parser.q) {
            if (c === '&') {
              parser.state = S.ATTRIB_VALUE_ENTITY_Q
            } else {
              parser.attribValue += c
            }
            continue
          }
          attrib(parser)
          parser.q = ''
          parser.state = S.ATTRIB_VALUE_CLOSED
          continue

        case S.ATTRIB_VALUE_CLOSED:
          if (isWhitespace(c)) {
            parser.state = S.ATTRIB
          } else if (c === '>') {
            openTag(parser)
          } else if (c === '/') {
            parser.state = S.OPEN_TAG_SLASH
          } else if (isMatch(nameStart, c)) {
            strictFail(parser, 'No whitespace between attributes')
            parser.attribName = c
            parser.attribValue = ''
            parser.state = S.ATTRIB_NAME
          } else {
            strictFail(parser, 'Invalid attribute name')
          }
          continue

        case S.ATTRIB_VALUE_UNQUOTED:
          if (!isAttribEnd(c)) {
            if (c === '&') {
              parser.state = S.ATTRIB_VALUE_ENTITY_U
            } else {
              parser.attribValue += c
            }
            continue
          }
          attrib(parser)
          if (c === '>') {
            openTag(parser)
          } else {
            parser.state = S.ATTRIB
          }
          continue

        case S.CLOSE_TAG:
          if (!parser.tagName) {
            if (isWhitespace(c)) {
              continue
            } else if (notMatch(nameStart, c)) {
              if (parser.script) {
                parser.script += '</' + c
                parser.state = S.SCRIPT
              } else {
                strictFail(parser, 'Invalid tagname in closing tag.')
              }
            } else {
              parser.tagName = c
            }
          } else if (c === '>') {
            closeTag(parser)
          } else if (isMatch(nameBody, c)) {
            parser.tagName += c
          } else if (parser.script) {
            parser.script += '</' + parser.tagName
            parser.tagName = ''
            parser.state = S.SCRIPT
          } else {
            if (!isWhitespace(c)) {
              strictFail(parser, 'Invalid tagname in closing tag')
            }
            parser.state = S.CLOSE_TAG_SAW_WHITE
          }
          continue

        case S.CLOSE_TAG_SAW_WHITE:
          if (isWhitespace(c)) {
            continue
          }
          if (c === '>') {
            closeTag(parser)
          } else {
            strictFail(parser, 'Invalid characters in closing tag')
          }
          continue

        case S.TEXT_ENTITY:
        case S.ATTRIB_VALUE_ENTITY_Q:
        case S.ATTRIB_VALUE_ENTITY_U:
          var returnState
          var buffer
          switch (parser.state) {
            case S.TEXT_ENTITY:
              returnState = S.TEXT
              buffer = 'textNode'
              break

            case S.ATTRIB_VALUE_ENTITY_Q:
              returnState = S.ATTRIB_VALUE_QUOTED
              buffer = 'attribValue'
              break

            case S.ATTRIB_VALUE_ENTITY_U:
              returnState = S.ATTRIB_VALUE_UNQUOTED
              buffer = 'attribValue'
              break
          }

          if (c === ';') {
            parser[buffer] += parseEntity(parser)
            parser.entity = ''
            parser.state = returnState
          } else if (isMatch(parser.entity.length ? entityBody : entityStart, c)) {
            parser.entity += c
          } else {
            strictFail(parser, 'Invalid character in entity name')
            parser[buffer] += '&' + parser.entity + c
            parser.entity = ''
            parser.state = returnState
          }

          continue

        default:
          throw new Error(parser, 'Unknown state: ' + parser.state)
      }
    } // while

    if (parser.position >= parser.bufferCheckPosition) {
      checkBufferLength(parser)
    }
    return parser
  }

  /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */
  /* istanbul ignore next */
  if (!String.fromCodePoint) {
    (function () {
      var stringFromCharCode = String.fromCharCode
      var floor = Math.floor
      var fromCodePoint = function () {
        var MAX_SIZE = 0x4000
        var codeUnits = []
        var highSurrogate
        var lowSurrogate
        var index = -1
        var length = arguments.length
        if (!length) {
          return ''
        }
        var result = ''
        while (++index < length) {
          var codePoint = Number(arguments[index])
          if (
            !isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`
            codePoint < 0 || // not a valid Unicode code point
            codePoint > 0x10FFFF || // not a valid Unicode code point
            floor(codePoint) !== codePoint // not an integer
          ) {
            throw RangeError('Invalid code point: ' + codePoint)
          }
          if (codePoint <= 0xFFFF) { // BMP code point
            codeUnits.push(codePoint)
          } else { // Astral code point; split in surrogate halves
            // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
            codePoint -= 0x10000
            highSurrogate = (codePoint >> 10) + 0xD800
            lowSurrogate = (codePoint % 0x400) + 0xDC00
            codeUnits.push(highSurrogate, lowSurrogate)
          }
          if (index + 1 === length || codeUnits.length > MAX_SIZE) {
            result += stringFromCharCode.apply(null, codeUnits)
            codeUnits.length = 0
          }
        }
        return result
      }
      /* istanbul ignore next */
      if (Object.defineProperty) {
        Object.defineProperty(String, 'fromCodePoint', {
          value: fromCodePoint,
          configurable: true,
          writable: true
        })
      } else {
        String.fromCodePoint = fromCodePoint
      }
    }())
  }
})(typeof exports === 'undefined' ? this.sax = {} : exports)

}).call(this,require("buffer").Buffer)
},{"buffer":13,"stream":1134,"string_decoder":1136}],1120:[function(require,module,exports){
'use strict';

var isArrayish = require('is-arrayish');

var concat = Array.prototype.concat;
var slice = Array.prototype.slice;

var swizzle = module.exports = function swizzle(args) {
	var results = [];

	for (var i = 0, len = args.length; i < len; i++) {
		var arg = args[i];

		if (isArrayish(arg)) {
			// http://jsperf.com/javascript-array-concat-vs-push/98
			results = concat.call(results, slice.call(arg));
		} else {
			results.push(arg);
		}
	}

	return results;
};

swizzle.wrap = function (fn) {
	return function () {
		return fn(swizzle(arguments));
	};
};

},{"is-arrayish":1121}],1121:[function(require,module,exports){
module.exports = function isArrayish(obj) {
	if (!obj || typeof obj === 'string') {
		return false;
	}

	return obj instanceof Array || Array.isArray(obj) ||
		(obj.length >= 0 && (obj.splice instanceof Function ||
			(Object.getOwnPropertyDescriptor(obj, (obj.length - 1)) && obj.constructor.name !== 'String')));
};

},{}],1122:[function(require,module,exports){
arguments[4][1086][0].apply(exports,arguments)
},{"./util":1131,"dup":1086}],1123:[function(require,module,exports){
arguments[4][1087][0].apply(exports,arguments)
},{"./base64":1124,"dup":1087}],1124:[function(require,module,exports){
arguments[4][1088][0].apply(exports,arguments)
},{"dup":1088}],1125:[function(require,module,exports){
arguments[4][1089][0].apply(exports,arguments)
},{"dup":1089}],1126:[function(require,module,exports){
arguments[4][1090][0].apply(exports,arguments)
},{"./util":1131,"dup":1090}],1127:[function(require,module,exports){
arguments[4][1091][0].apply(exports,arguments)
},{"dup":1091}],1128:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var util = require('./util');
var binarySearch = require('./binary-search');
var ArraySet = require('./array-set').ArraySet;
var base64VLQ = require('./base64-vlq');
var quickSort = require('./quick-sort').quickSort;

function SourceMapConsumer(aSourceMap) {
  var sourceMap = aSourceMap;
  if (typeof aSourceMap === 'string') {
    sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
  }

  return sourceMap.sections != null
    ? new IndexedSourceMapConsumer(sourceMap)
    : new BasicSourceMapConsumer(sourceMap);
}

SourceMapConsumer.fromSourceMap = function(aSourceMap) {
  return BasicSourceMapConsumer.fromSourceMap(aSourceMap);
}

/**
 * The version of the source mapping spec that we are consuming.
 */
SourceMapConsumer.prototype._version = 3;

// `__generatedMappings` and `__originalMappings` are arrays that hold the
// parsed mapping coordinates from the source map's "mappings" attribute. They
// are lazily instantiated, accessed via the `_generatedMappings` and
// `_originalMappings` getters respectively, and we only parse the mappings
// and create these arrays once queried for a source location. We jump through
// these hoops because there can be many thousands of mappings, and parsing
// them is expensive, so we only want to do it if we must.
//
// Each object in the arrays is of the form:
//
//     {
//       generatedLine: The line number in the generated code,
//       generatedColumn: The column number in the generated code,
//       source: The path to the original source file that generated this
//               chunk of code,
//       originalLine: The line number in the original source that
//                     corresponds to this chunk of generated code,
//       originalColumn: The column number in the original source that
//                       corresponds to this chunk of generated code,
//       name: The name of the original symbol which generated this chunk of
//             code.
//     }
//
// All properties except for `generatedLine` and `generatedColumn` can be
// `null`.
//
// `_generatedMappings` is ordered by the generated positions.
//
// `_originalMappings` is ordered by the original positions.

SourceMapConsumer.prototype.__generatedMappings = null;
Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
  get: function () {
    if (!this.__generatedMappings) {
      this._parseMappings(this._mappings, this.sourceRoot);
    }

    return this.__generatedMappings;
  }
});

SourceMapConsumer.prototype.__originalMappings = null;
Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
  get: function () {
    if (!this.__originalMappings) {
      this._parseMappings(this._mappings, this.sourceRoot);
    }

    return this.__originalMappings;
  }
});

SourceMapConsumer.prototype._charIsMappingSeparator =
  function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
    var c = aStr.charAt(index);
    return c === ";" || c === ",";
  };

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
SourceMapConsumer.prototype._parseMappings =
  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    throw new Error("Subclasses must implement _parseMappings");
  };

SourceMapConsumer.GENERATED_ORDER = 1;
SourceMapConsumer.ORIGINAL_ORDER = 2;

SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
SourceMapConsumer.LEAST_UPPER_BOUND = 2;

/**
 * Iterate over each mapping between an original source/line/column and a
 * generated line/column in this source map.
 *
 * @param Function aCallback
 *        The function that is called with each mapping.
 * @param Object aContext
 *        Optional. If specified, this object will be the value of `this` every
 *        time that `aCallback` is called.
 * @param aOrder
 *        Either `SourceMapConsumer.GENERATED_ORDER` or
 *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
 *        iterate over the mappings sorted by the generated file's line/column
 *        order or the original's source/line/column order, respectively. Defaults to
 *        `SourceMapConsumer.GENERATED_ORDER`.
 */
SourceMapConsumer.prototype.eachMapping =
  function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
    var context = aContext || null;
    var order = aOrder || SourceMapConsumer.GENERATED_ORDER;

    var mappings;
    switch (order) {
    case SourceMapConsumer.GENERATED_ORDER:
      mappings = this._generatedMappings;
      break;
    case SourceMapConsumer.ORIGINAL_ORDER:
      mappings = this._originalMappings;
      break;
    default:
      throw new Error("Unknown order of iteration.");
    }

    var sourceRoot = this.sourceRoot;
    mappings.map(function (mapping) {
      var source = mapping.source === null ? null : this._sources.at(mapping.source);
      if (source != null && sourceRoot != null) {
        source = util.join(sourceRoot, source);
      }
      return {
        source: source,
        generatedLine: mapping.generatedLine,
        generatedColumn: mapping.generatedColumn,
        originalLine: mapping.originalLine,
        originalColumn: mapping.originalColumn,
        name: mapping.name === null ? null : this._names.at(mapping.name)
      };
    }, this).forEach(aCallback, context);
  };

/**
 * Returns all generated line and column information for the original source,
 * line, and column provided. If no column is provided, returns all mappings
 * corresponding to a either the line we are searching for or the next
 * closest line that has any mappings. Otherwise, returns all mappings
 * corresponding to the given line and either the column we are searching for
 * or the next closest column that has any offsets.
 *
 * The only argument is an object with the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.
 *   - column: Optional. the column number in the original source.
 *
 * and an array of objects is returned, each with the following properties:
 *
 *   - line: The line number in the generated source, or null.
 *   - column: The column number in the generated source, or null.
 */
SourceMapConsumer.prototype.allGeneratedPositionsFor =
  function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
    var line = util.getArg(aArgs, 'line');

    // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping
    // returns the index of the closest mapping less than the needle. By
    // setting needle.originalColumn to 0, we thus find the last mapping for
    // the given line, provided such a mapping exists.
    var needle = {
      source: util.getArg(aArgs, 'source'),
      originalLine: line,
      originalColumn: util.getArg(aArgs, 'column', 0)
    };

    if (this.sourceRoot != null) {
      needle.source = util.relative(this.sourceRoot, needle.source);
    }
    if (!this._sources.has(needle.source)) {
      return [];
    }
    needle.source = this._sources.indexOf(needle.source);

    var mappings = [];

    var index = this._findMapping(needle,
                                  this._originalMappings,
                                  "originalLine",
                                  "originalColumn",
                                  util.compareByOriginalPositions,
                                  binarySearch.LEAST_UPPER_BOUND);
    if (index >= 0) {
      var mapping = this._originalMappings[index];

      if (aArgs.column === undefined) {
        var originalLine = mapping.originalLine;

        // Iterate until either we run out of mappings, or we run into
        // a mapping for a different line than the one we found. Since
        // mappings are sorted, this is guaranteed to find all mappings for
        // the line we found.
        while (mapping && mapping.originalLine === originalLine) {
          mappings.push({
            line: util.getArg(mapping, 'generatedLine', null),
            column: util.getArg(mapping, 'generatedColumn', null),
            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
          });

          mapping = this._originalMappings[++index];
        }
      } else {
        var originalColumn = mapping.originalColumn;

        // Iterate until either we run out of mappings, or we run into
        // a mapping for a different line than the one we were searching for.
        // Since mappings are sorted, this is guaranteed to find all mappings for
        // the line we are searching for.
        while (mapping &&
               mapping.originalLine === line &&
               mapping.originalColumn == originalColumn) {
          mappings.push({
            line: util.getArg(mapping, 'generatedLine', null),
            column: util.getArg(mapping, 'generatedColumn', null),
            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
          });

          mapping = this._originalMappings[++index];
        }
      }
    }

    return mappings;
  };

exports.SourceMapConsumer = SourceMapConsumer;

/**
 * A BasicSourceMapConsumer instance represents a parsed source map which we can
 * query for information about the original file positions by giving it a file
 * position in the generated source.
 *
 * The only parameter is the raw source map (either as a JSON string, or
 * already parsed to an object). According to the spec, source maps have the
 * following attributes:
 *
 *   - version: Which version of the source map spec this map is following.
 *   - sources: An array of URLs to the original source files.
 *   - names: An array of identifiers which can be referrenced by individual mappings.
 *   - sourceRoot: Optional. The URL root from which all sources are relative.
 *   - sourcesContent: Optional. An array of contents of the original source files.
 *   - mappings: A string of base64 VLQs which contain the actual mappings.
 *   - file: Optional. The generated file this source map is associated with.
 *
 * Here is an example source map, taken from the source map spec[0]:
 *
 *     {
 *       version : 3,
 *       file: "out.js",
 *       sourceRoot : "",
 *       sources: ["foo.js", "bar.js"],
 *       names: ["src", "maps", "are", "fun"],
 *       mappings: "AA,AB;;ABCDE;"
 *     }
 *
 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
 */
function BasicSourceMapConsumer(aSourceMap) {
  var sourceMap = aSourceMap;
  if (typeof aSourceMap === 'string') {
    sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
  }

  var version = util.getArg(sourceMap, 'version');
  var sources = util.getArg(sourceMap, 'sources');
  // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
  // requires the array) to play nice here.
  var names = util.getArg(sourceMap, 'names', []);
  var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
  var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
  var mappings = util.getArg(sourceMap, 'mappings');
  var file = util.getArg(sourceMap, 'file', null);

  // Once again, Sass deviates from the spec and supplies the version as a
  // string rather than a number, so we use loose equality checking here.
  if (version != this._version) {
    throw new Error('Unsupported version: ' + version);
  }

  sources = sources
    .map(String)
    // Some source maps produce relative source paths like "./foo.js" instead of
    // "foo.js".  Normalize these first so that future comparisons will succeed.
    // See bugzil.la/1090768.
    .map(util.normalize)
    // Always ensure that absolute sources are internally stored relative to
    // the source root, if the source root is absolute. Not doing this would
    // be particularly problematic when the source root is a prefix of the
    // source (valid, but why??). See github issue #199 and bugzil.la/1188982.
    .map(function (source) {
      return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source)
        ? util.relative(sourceRoot, source)
        : source;
    });

  // Pass `true` below to allow duplicate names and sources. While source maps
  // are intended to be compressed and deduplicated, the TypeScript compiler
  // sometimes generates source maps with duplicates in them. See Github issue
  // #72 and bugzil.la/889492.
  this._names = ArraySet.fromArray(names.map(String), true);
  this._sources = ArraySet.fromArray(sources, true);

  this.sourceRoot = sourceRoot;
  this.sourcesContent = sourcesContent;
  this._mappings = mappings;
  this.file = file;
}

BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;

/**
 * Create a BasicSourceMapConsumer from a SourceMapGenerator.
 *
 * @param SourceMapGenerator aSourceMap
 *        The source map that will be consumed.
 * @returns BasicSourceMapConsumer
 */
BasicSourceMapConsumer.fromSourceMap =
  function SourceMapConsumer_fromSourceMap(aSourceMap) {
    var smc = Object.create(BasicSourceMapConsumer.prototype);

    var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
    var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
    smc.sourceRoot = aSourceMap._sourceRoot;
    smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),
                                                            smc.sourceRoot);
    smc.file = aSourceMap._file;

    // Because we are modifying the entries (by converting string sources and
    // names to indices into the sources and names ArraySets), we have to make
    // a copy of the entry or else bad things happen. Shared mutable state
    // strikes again! See github issue #191.

    var generatedMappings = aSourceMap._mappings.toArray().slice();
    var destGeneratedMappings = smc.__generatedMappings = [];
    var destOriginalMappings = smc.__originalMappings = [];

    for (var i = 0, length = generatedMappings.length; i < length; i++) {
      var srcMapping = generatedMappings[i];
      var destMapping = new Mapping;
      destMapping.generatedLine = srcMapping.generatedLine;
      destMapping.generatedColumn = srcMapping.generatedColumn;

      if (srcMapping.source) {
        destMapping.source = sources.indexOf(srcMapping.source);
        destMapping.originalLine = srcMapping.originalLine;
        destMapping.originalColumn = srcMapping.originalColumn;

        if (srcMapping.name) {
          destMapping.name = names.indexOf(srcMapping.name);
        }

        destOriginalMappings.push(destMapping);
      }

      destGeneratedMappings.push(destMapping);
    }

    quickSort(smc.__originalMappings, util.compareByOriginalPositions);

    return smc;
  };

/**
 * The version of the source mapping spec that we are consuming.
 */
BasicSourceMapConsumer.prototype._version = 3;

/**
 * The list of original sources.
 */
Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {
  get: function () {
    return this._sources.toArray().map(function (s) {
      return this.sourceRoot != null ? util.join(this.sourceRoot, s) : s;
    }, this);
  }
});

/**
 * Provide the JIT with a nice shape / hidden class.
 */
function Mapping() {
  this.generatedLine = 0;
  this.generatedColumn = 0;
  this.source = null;
  this.originalLine = null;
  this.originalColumn = null;
  this.name = null;
}

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
BasicSourceMapConsumer.prototype._parseMappings =
  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    var generatedLine = 1;
    var previousGeneratedColumn = 0;
    var previousOriginalLine = 0;
    var previousOriginalColumn = 0;
    var previousSource = 0;
    var previousName = 0;
    var length = aStr.length;
    var index = 0;
    var cachedSegments = {};
    var temp = {};
    var originalMappings = [];
    var generatedMappings = [];
    var mapping, str, segment, end, value;

    while (index < length) {
      if (aStr.charAt(index) === ';') {
        generatedLine++;
        index++;
        previousGeneratedColumn = 0;
      }
      else if (aStr.charAt(index) === ',') {
        index++;
      }
      else {
        mapping = new Mapping();
        mapping.generatedLine = generatedLine;

        // Because each offset is encoded relative to the previous one,
        // many segments often have the same encoding. We can exploit this
        // fact by caching the parsed variable length fields of each segment,
        // allowing us to avoid a second parse if we encounter the same
        // segment again.
        for (end = index; end < length; end++) {
          if (this._charIsMappingSeparator(aStr, end)) {
            break;
          }
        }
        str = aStr.slice(index, end);

        segment = cachedSegments[str];
        if (segment) {
          index += str.length;
        } else {
          segment = [];
          while (index < end) {
            base64VLQ.decode(aStr, index, temp);
            value = temp.value;
            index = temp.rest;
            segment.push(value);
          }

          if (segment.length === 2) {
            throw new Error('Found a source, but no line and column');
          }

          if (segment.length === 3) {
            throw new Error('Found a source and line, but no column');
          }

          cachedSegments[str] = segment;
        }

        // Generated column.
        mapping.generatedColumn = previousGeneratedColumn + segment[0];
        previousGeneratedColumn = mapping.generatedColumn;

        if (segment.length > 1) {
          // Original source.
          mapping.source = previousSource + segment[1];
          previousSource += segment[1];

          // Original line.
          mapping.originalLine = previousOriginalLine + segment[2];
          previousOriginalLine = mapping.originalLine;
          // Lines are stored 0-based
          mapping.originalLine += 1;

          // Original column.
          mapping.originalColumn = previousOriginalColumn + segment[3];
          previousOriginalColumn = mapping.originalColumn;

          if (segment.length > 4) {
            // Original name.
            mapping.name = previousName + segment[4];
            previousName += segment[4];
          }
        }

        generatedMappings.push(mapping);
        if (typeof mapping.originalLine === 'number') {
          originalMappings.push(mapping);
        }
      }
    }

    quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);
    this.__generatedMappings = generatedMappings;

    quickSort(originalMappings, util.compareByOriginalPositions);
    this.__originalMappings = originalMappings;
  };

/**
 * Find the mapping that best matches the hypothetical "needle" mapping that
 * we are searching for in the given "haystack" of mappings.
 */
BasicSourceMapConsumer.prototype._findMapping =
  function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,
                                         aColumnName, aComparator, aBias) {
    // To return the position we are searching for, we must first find the
    // mapping for the given position and then return the opposite position it
    // points to. Because the mappings are sorted, we can use binary search to
    // find the best mapping.

    if (aNeedle[aLineName] <= 0) {
      throw new TypeError('Line must be greater than or equal to 1, got '
                          + aNeedle[aLineName]);
    }
    if (aNeedle[aColumnName] < 0) {
      throw new TypeError('Column must be greater than or equal to 0, got '
                          + aNeedle[aColumnName]);
    }

    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
  };

/**
 * Compute the last column for each generated mapping. The last column is
 * inclusive.
 */
BasicSourceMapConsumer.prototype.computeColumnSpans =
  function SourceMapConsumer_computeColumnSpans() {
    for (var index = 0; index < this._generatedMappings.length; ++index) {
      var mapping = this._generatedMappings[index];

      // Mappings do not contain a field for the last generated columnt. We
      // can come up with an optimistic estimate, however, by assuming that
      // mappings are contiguous (i.e. given two consecutive mappings, the
      // first mapping ends where the second one starts).
      if (index + 1 < this._generatedMappings.length) {
        var nextMapping = this._generatedMappings[index + 1];

        if (mapping.generatedLine === nextMapping.generatedLine) {
          mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
          continue;
        }
      }

      // The last mapping for each line spans the entire line.
      mapping.lastGeneratedColumn = Infinity;
    }
  };

/**
 * Returns the original source, line, and column information for the generated
 * source's line and column positions provided. The only argument is an object
 * with the following properties:
 *
 *   - line: The line number in the generated source.
 *   - column: The column number in the generated source.
 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
 *
 * and an object is returned with the following properties:
 *
 *   - source: The original source file, or null.
 *   - line: The line number in the original source, or null.
 *   - column: The column number in the original source, or null.
 *   - name: The original identifier, or null.
 */
BasicSourceMapConsumer.prototype.originalPositionFor =
  function SourceMapConsumer_originalPositionFor(aArgs) {
    var needle = {
      generatedLine: util.getArg(aArgs, 'line'),
      generatedColumn: util.getArg(aArgs, 'column')
    };

    var index = this._findMapping(
      needle,
      this._generatedMappings,
      "generatedLine",
      "generatedColumn",
      util.compareByGeneratedPositionsDeflated,
      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
    );

    if (index >= 0) {
      var mapping = this._generatedMappings[index];

      if (mapping.generatedLine === needle.generatedLine) {
        var source = util.getArg(mapping, 'source', null);
        if (source !== null) {
          source = this._sources.at(source);
          if (this.sourceRoot != null) {
            source = util.join(this.sourceRoot, source);
          }
        }
        var name = util.getArg(mapping, 'name', null);
        if (name !== null) {
          name = this._names.at(name);
        }
        return {
          source: source,
          line: util.getArg(mapping, 'originalLine', null),
          column: util.getArg(mapping, 'originalColumn', null),
          name: name
        };
      }
    }

    return {
      source: null,
      line: null,
      column: null,
      name: null
    };
  };

/**
 * Return true if we have the source content for every source in the source
 * map, false otherwise.
 */
BasicSourceMapConsumer.prototype.hasContentsOfAllSources =
  function BasicSourceMapConsumer_hasContentsOfAllSources() {
    if (!this.sourcesContent) {
      return false;
    }
    return this.sourcesContent.length >= this._sources.size() &&
      !this.sourcesContent.some(function (sc) { return sc == null; });
  };

/**
 * Returns the original source content. The only argument is the url of the
 * original source file. Returns null if no original source content is
 * available.
 */
BasicSourceMapConsumer.prototype.sourceContentFor =
  function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
    if (!this.sourcesContent) {
      return null;
    }

    if (this.sourceRoot != null) {
      aSource = util.relative(this.sourceRoot, aSource);
    }

    if (this._sources.has(aSource)) {
      return this.sourcesContent[this._sources.indexOf(aSource)];
    }

    var url;
    if (this.sourceRoot != null
        && (url = util.urlParse(this.sourceRoot))) {
      // XXX: file:// URIs and absolute paths lead to unexpected behavior for
      // many users. We can help them out when they expect file:// URIs to
      // behave like it would if they were running a local HTTP server. See
      // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
      var fileUriAbsPath = aSource.replace(/^file:\/\//, "");
      if (url.scheme == "file"
          && this._sources.has(fileUriAbsPath)) {
        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]
      }

      if ((!url.path || url.path == "/")
          && this._sources.has("/" + aSource)) {
        return this.sourcesContent[this._sources.indexOf("/" + aSource)];
      }
    }

    // This function is used recursively from
    // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we
    // don't want to throw if we can't find the source - we just want to
    // return null, so we provide a flag to exit gracefully.
    if (nullOnMissing) {
      return null;
    }
    else {
      throw new Error('"' + aSource + '" is not in the SourceMap.');
    }
  };

/**
 * Returns the generated line and column information for the original source,
 * line, and column positions provided. The only argument is an object with
 * the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.
 *   - column: The column number in the original source.
 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
 *
 * and an object is returned with the following properties:
 *
 *   - line: The line number in the generated source, or null.
 *   - column: The column number in the generated source, or null.
 */
BasicSourceMapConsumer.prototype.generatedPositionFor =
  function SourceMapConsumer_generatedPositionFor(aArgs) {
    var source = util.getArg(aArgs, 'source');
    if (this.sourceRoot != null) {
      source = util.relative(this.sourceRoot, source);
    }
    if (!this._sources.has(source)) {
      return {
        line: null,
        column: null,
        lastColumn: null
      };
    }
    source = this._sources.indexOf(source);

    var needle = {
      source: source,
      originalLine: util.getArg(aArgs, 'line'),
      originalColumn: util.getArg(aArgs, 'column')
    };

    var index = this._findMapping(
      needle,
      this._originalMappings,
      "originalLine",
      "originalColumn",
      util.compareByOriginalPositions,
      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
    );

    if (index >= 0) {
      var mapping = this._originalMappings[index];

      if (mapping.source === needle.source) {
        return {
          line: util.getArg(mapping, 'generatedLine', null),
          column: util.getArg(mapping, 'generatedColumn', null),
          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
        };
      }
    }

    return {
      line: null,
      column: null,
      lastColumn: null
    };
  };

exports.BasicSourceMapConsumer = BasicSourceMapConsumer;

/**
 * An IndexedSourceMapConsumer instance represents a parsed source map which
 * we can query for information. It differs from BasicSourceMapConsumer in
 * that it takes "indexed" source maps (i.e. ones with a "sections" field) as
 * input.
 *
 * The only parameter is a raw source map (either as a JSON string, or already
 * parsed to an object). According to the spec for indexed source maps, they
 * have the following attributes:
 *
 *   - version: Which version of the source map spec this map is following.
 *   - file: Optional. The generated file this source map is associated with.
 *   - sections: A list of section definitions.
 *
 * Each value under the "sections" field has two fields:
 *   - offset: The offset into the original specified at which this section
 *       begins to apply, defined as an object with a "line" and "column"
 *       field.
 *   - map: A source map definition. This source map could also be indexed,
 *       but doesn't have to be.
 *
 * Instead of the "map" field, it's also possible to have a "url" field
 * specifying a URL to retrieve a source map from, but that's currently
 * unsupported.
 *
 * Here's an example source map, taken from the source map spec[0], but
 * modified to omit a section which uses the "url" field.
 *
 *  {
 *    version : 3,
 *    file: "app.js",
 *    sections: [{
 *      offset: {line:100, column:10},
 *      map: {
 *        version : 3,
 *        file: "section.js",
 *        sources: ["foo.js", "bar.js"],
 *        names: ["src", "maps", "are", "fun"],
 *        mappings: "AAAA,E;;ABCDE;"
 *      }
 *    }],
 *  }
 *
 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt
 */
function IndexedSourceMapConsumer(aSourceMap) {
  var sourceMap = aSourceMap;
  if (typeof aSourceMap === 'string') {
    sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
  }

  var version = util.getArg(sourceMap, 'version');
  var sections = util.getArg(sourceMap, 'sections');

  if (version != this._version) {
    throw new Error('Unsupported version: ' + version);
  }

  this._sources = new ArraySet();
  this._names = new ArraySet();

  var lastOffset = {
    line: -1,
    column: 0
  };
  this._sections = sections.map(function (s) {
    if (s.url) {
      // The url field will require support for asynchronicity.
      // See https://github.com/mozilla/source-map/issues/16
      throw new Error('Support for url field in sections not implemented.');
    }
    var offset = util.getArg(s, 'offset');
    var offsetLine = util.getArg(offset, 'line');
    var offsetColumn = util.getArg(offset, 'column');

    if (offsetLine < lastOffset.line ||
        (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {
      throw new Error('Section offsets must be ordered and non-overlapping.');
    }
    lastOffset = offset;

    return {
      generatedOffset: {
        // The offset fields are 0-based, but we use 1-based indices when
        // encoding/decoding from VLQ.
        generatedLine: offsetLine + 1,
        generatedColumn: offsetColumn + 1
      },
      consumer: new SourceMapConsumer(util.getArg(s, 'map'))
    }
  });
}

IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;

/**
 * The version of the source mapping spec that we are consuming.
 */
IndexedSourceMapConsumer.prototype._version = 3;

/**
 * The list of original sources.
 */
Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {
  get: function () {
    var sources = [];
    for (var i = 0; i < this._sections.length; i++) {
      for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
        sources.push(this._sections[i].consumer.sources[j]);
      }
    }
    return sources;
  }
});

/**
 * Returns the original source, line, and column information for the generated
 * source's line and column positions provided. The only argument is an object
 * with the following properties:
 *
 *   - line: The line number in the generated source.
 *   - column: The column number in the generated source.
 *
 * and an object is returned with the following properties:
 *
 *   - source: The original source file, or null.
 *   - line: The line number in the original source, or null.
 *   - column: The column number in the original source, or null.
 *   - name: The original identifier, or null.
 */
IndexedSourceMapConsumer.prototype.originalPositionFor =
  function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
    var needle = {
      generatedLine: util.getArg(aArgs, 'line'),
      generatedColumn: util.getArg(aArgs, 'column')
    };

    // Find the section containing the generated position we're trying to map
    // to an original position.
    var sectionIndex = binarySearch.search(needle, this._sections,
      function(needle, section) {
        var cmp = needle.generatedLine - section.generatedOffset.generatedLine;
        if (cmp) {
          return cmp;
        }

        return (needle.generatedColumn -
                section.generatedOffset.generatedColumn);
      });
    var section = this._sections[sectionIndex];

    if (!section) {
      return {
        source: null,
        line: null,
        column: null,
        name: null
      };
    }

    return section.consumer.originalPositionFor({
      line: needle.generatedLine -
        (section.generatedOffset.generatedLine - 1),
      column: needle.generatedColumn -
        (section.generatedOffset.generatedLine === needle.generatedLine
         ? section.generatedOffset.generatedColumn - 1
         : 0),
      bias: aArgs.bias
    });
  };

/**
 * Return true if we have the source content for every source in the source
 * map, false otherwise.
 */
IndexedSourceMapConsumer.prototype.hasContentsOfAllSources =
  function IndexedSourceMapConsumer_hasContentsOfAllSources() {
    return this._sections.every(function (s) {
      return s.consumer.hasContentsOfAllSources();
    });
  };

/**
 * Returns the original source content. The only argument is the url of the
 * original source file. Returns null if no original source content is
 * available.
 */
IndexedSourceMapConsumer.prototype.sourceContentFor =
  function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];

      var content = section.consumer.sourceContentFor(aSource, true);
      if (content) {
        return content;
      }
    }
    if (nullOnMissing) {
      return null;
    }
    else {
      throw new Error('"' + aSource + '" is not in the SourceMap.');
    }
  };

/**
 * Returns the generated line and column information for the original source,
 * line, and column positions provided. The only argument is an object with
 * the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.
 *   - column: The column number in the original source.
 *
 * and an object is returned with the following properties:
 *
 *   - line: The line number in the generated source, or null.
 *   - column: The column number in the generated source, or null.
 */
IndexedSourceMapConsumer.prototype.generatedPositionFor =
  function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];

      // Only consider this section if the requested source is in the list of
      // sources of the consumer.
      if (section.consumer.sources.indexOf(util.getArg(aArgs, 'source')) === -1) {
        continue;
      }
      var generatedPosition = section.consumer.generatedPositionFor(aArgs);
      if (generatedPosition) {
        var ret = {
          line: generatedPosition.line +
            (section.generatedOffset.generatedLine - 1),
          column: generatedPosition.column +
            (section.generatedOffset.generatedLine === generatedPosition.line
             ? section.generatedOffset.generatedColumn - 1
             : 0)
        };
        return ret;
      }
    }

    return {
      line: null,
      column: null
    };
  };

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
IndexedSourceMapConsumer.prototype._parseMappings =
  function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    this.__generatedMappings = [];
    this.__originalMappings = [];
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];
      var sectionMappings = section.consumer._generatedMappings;
      for (var j = 0; j < sectionMappings.length; j++) {
        var mapping = sectionMappings[j];

        var source = section.consumer._sources.at(mapping.source);
        if (section.consumer.sourceRoot !== null) {
          source = util.join(section.consumer.sourceRoot, source);
        }
        this._sources.add(source);
        source = this._sources.indexOf(source);

        var name = section.consumer._names.at(mapping.name);
        this._names.add(name);
        name = this._names.indexOf(name);

        // The mappings coming from the consumer for the section have
        // generated positions relative to the start of the section, so we
        // need to offset them to be relative to the start of the concatenated
        // generated file.
        var adjustedMapping = {
          source: source,
          generatedLine: mapping.generatedLine +
            (section.generatedOffset.generatedLine - 1),
          generatedColumn: mapping.generatedColumn +
            (section.generatedOffset.generatedLine === mapping.generatedLine
            ? section.generatedOffset.generatedColumn - 1
            : 0),
          originalLine: mapping.originalLine,
          originalColumn: mapping.originalColumn,
          name: name
        };

        this.__generatedMappings.push(adjustedMapping);
        if (typeof adjustedMapping.originalLine === 'number') {
          this.__originalMappings.push(adjustedMapping);
        }
      }
    }

    quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
    quickSort(this.__originalMappings, util.compareByOriginalPositions);
  };

exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;

},{"./array-set":1122,"./base64-vlq":1123,"./binary-search":1125,"./quick-sort":1127,"./util":1131}],1129:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var base64VLQ = require('./base64-vlq');
var util = require('./util');
var ArraySet = require('./array-set').ArraySet;
var MappingList = require('./mapping-list').MappingList;

/**
 * An instance of the SourceMapGenerator represents a source map which is
 * being built incrementally. You may pass an object with the following
 * properties:
 *
 *   - file: The filename of the generated source.
 *   - sourceRoot: A root for all relative URLs in this source map.
 */
function SourceMapGenerator(aArgs) {
  if (!aArgs) {
    aArgs = {};
  }
  this._file = util.getArg(aArgs, 'file', null);
  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
  this._sources = new ArraySet();
  this._names = new ArraySet();
  this._mappings = new MappingList();
  this._sourcesContents = null;
}

SourceMapGenerator.prototype._version = 3;

/**
 * Creates a new SourceMapGenerator based on a SourceMapConsumer
 *
 * @param aSourceMapConsumer The SourceMap.
 */
SourceMapGenerator.fromSourceMap =
  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
    var sourceRoot = aSourceMapConsumer.sourceRoot;
    var generator = new SourceMapGenerator({
      file: aSourceMapConsumer.file,
      sourceRoot: sourceRoot
    });
    aSourceMapConsumer.eachMapping(function (mapping) {
      var newMapping = {
        generated: {
          line: mapping.generatedLine,
          column: mapping.generatedColumn
        }
      };

      if (mapping.source != null) {
        newMapping.source = mapping.source;
        if (sourceRoot != null) {
          newMapping.source = util.relative(sourceRoot, newMapping.source);
        }

        newMapping.original = {
          line: mapping.originalLine,
          column: mapping.originalColumn
        };

        if (mapping.name != null) {
          newMapping.name = mapping.name;
        }
      }

      generator.addMapping(newMapping);
    });
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        generator.setSourceContent(sourceFile, content);
      }
    });
    return generator;
  };

/**
 * Add a single mapping from original source line and column to the generated
 * source's line and column for this source map being created. The mapping
 * object should have the following properties:
 *
 *   - generated: An object with the generated line and column positions.
 *   - original: An object with the original line and column positions.
 *   - source: The original source file (relative to the sourceRoot).
 *   - name: An optional original token name for this mapping.
 */
SourceMapGenerator.prototype.addMapping =
  function SourceMapGenerator_addMapping(aArgs) {
    var generated = util.getArg(aArgs, 'generated');
    var original = util.getArg(aArgs, 'original', null);
    var source = util.getArg(aArgs, 'source', null);
    var name = util.getArg(aArgs, 'name', null);

    if (!this._skipValidation) {
      this._validateMapping(generated, original, source, name);
    }

    if (source != null) {
      source = String(source);
      if (!this._sources.has(source)) {
        this._sources.add(source);
      }
    }

    if (name != null) {
      name = String(name);
      if (!this._names.has(name)) {
        this._names.add(name);
      }
    }

    this._mappings.add({
      generatedLine: generated.line,
      generatedColumn: generated.column,
      originalLine: original != null && original.line,
      originalColumn: original != null && original.column,
      source: source,
      name: name
    });
  };

/**
 * Set the source content for a source file.
 */
SourceMapGenerator.prototype.setSourceContent =
  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
    var source = aSourceFile;
    if (this._sourceRoot != null) {
      source = util.relative(this._sourceRoot, source);
    }

    if (aSourceContent != null) {
      // Add the source content to the _sourcesContents map.
      // Create a new _sourcesContents map if the property is null.
      if (!this._sourcesContents) {
        this._sourcesContents = Object.create(null);
      }
      this._sourcesContents[util.toSetString(source)] = aSourceContent;
    } else if (this._sourcesContents) {
      // Remove the source file from the _sourcesContents map.
      // If the _sourcesContents map is empty, set the property to null.
      delete this._sourcesContents[util.toSetString(source)];
      if (Object.keys(this._sourcesContents).length === 0) {
        this._sourcesContents = null;
      }
    }
  };

/**
 * Applies the mappings of a sub-source-map for a specific source file to the
 * source map being generated. Each mapping to the supplied source file is
 * rewritten using the supplied source map. Note: The resolution for the
 * resulting mappings is the minimium of this map and the supplied map.
 *
 * @param aSourceMapConsumer The source map to be applied.
 * @param aSourceFile Optional. The filename of the source file.
 *        If omitted, SourceMapConsumer's file property will be used.
 * @param aSourceMapPath Optional. The dirname of the path to the source map
 *        to be applied. If relative, it is relative to the SourceMapConsumer.
 *        This parameter is needed when the two source maps aren't in the same
 *        directory, and the source map to be applied contains relative source
 *        paths. If so, those relative source paths need to be rewritten
 *        relative to the SourceMapGenerator.
 */
SourceMapGenerator.prototype.applySourceMap =
  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
    var sourceFile = aSourceFile;
    // If aSourceFile is omitted, we will use the file property of the SourceMap
    if (aSourceFile == null) {
      if (aSourceMapConsumer.file == null) {
        throw new Error(
          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
          'or the source map\'s "file" property. Both were omitted.'
        );
      }
      sourceFile = aSourceMapConsumer.file;
    }
    var sourceRoot = this._sourceRoot;
    // Make "sourceFile" relative if an absolute Url is passed.
    if (sourceRoot != null) {
      sourceFile = util.relative(sourceRoot, sourceFile);
    }
    // Applying the SourceMap can add and remove items from the sources and
    // the names array.
    var newSources = new ArraySet();
    var newNames = new ArraySet();

    // Find mappings for the "sourceFile"
    this._mappings.unsortedForEach(function (mapping) {
      if (mapping.source === sourceFile && mapping.originalLine != null) {
        // Check if it can be mapped by the source map, then update the mapping.
        var original = aSourceMapConsumer.originalPositionFor({
          line: mapping.originalLine,
          column: mapping.originalColumn
        });
        if (original.source != null) {
          // Copy mapping
          mapping.source = original.source;
          if (aSourceMapPath != null) {
            mapping.source = util.join(aSourceMapPath, mapping.source)
          }
          if (sourceRoot != null) {
            mapping.source = util.relative(sourceRoot, mapping.source);
          }
          mapping.originalLine = original.line;
          mapping.originalColumn = original.column;
          if (original.name != null) {
            mapping.name = original.name;
          }
        }
      }

      var source = mapping.source;
      if (source != null && !newSources.has(source)) {
        newSources.add(source);
      }

      var name = mapping.name;
      if (name != null && !newNames.has(name)) {
        newNames.add(name);
      }

    }, this);
    this._sources = newSources;
    this._names = newNames;

    // Copy sourcesContents of applied map.
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        if (aSourceMapPath != null) {
          sourceFile = util.join(aSourceMapPath, sourceFile);
        }
        if (sourceRoot != null) {
          sourceFile = util.relative(sourceRoot, sourceFile);
        }
        this.setSourceContent(sourceFile, content);
      }
    }, this);
  };

/**
 * A mapping can have one of the three levels of data:
 *
 *   1. Just the generated position.
 *   2. The Generated position, original position, and original source.
 *   3. Generated and original position, original source, as well as a name
 *      token.
 *
 * To maintain consistency, we validate that any new mapping being added falls
 * in to one of these categories.
 */
SourceMapGenerator.prototype._validateMapping =
  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
                                              aName) {
    // When aOriginal is truthy but has empty values for .line and .column,
    // it is most likely a programmer error. In this case we throw a very
    // specific error message to try to guide them the right way.
    // For example: https://github.com/Polymer/polymer-bundler/pull/519
    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
        throw new Error(
            'original.line and original.column are not numbers -- you probably meant to omit ' +
            'the original mapping entirely and only map the generated position. If so, pass ' +
            'null for the original mapping instead of an object with empty or null values.'
        );
    }

    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
        && aGenerated.line > 0 && aGenerated.column >= 0
        && !aOriginal && !aSource && !aName) {
      // Case 1.
      return;
    }
    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
             && aOriginal && 'line' in aOriginal && 'column' in aOriginal
             && aGenerated.line > 0 && aGenerated.column >= 0
             && aOriginal.line > 0 && aOriginal.column >= 0
             && aSource) {
      // Cases 2 and 3.
      return;
    }
    else {
      throw new Error('Invalid mapping: ' + JSON.stringify({
        generated: aGenerated,
        source: aSource,
        original: aOriginal,
        name: aName
      }));
    }
  };

/**
 * Serialize the accumulated mappings in to the stream of base 64 VLQs
 * specified by the source map format.
 */
SourceMapGenerator.prototype._serializeMappings =
  function SourceMapGenerator_serializeMappings() {
    var previousGeneratedColumn = 0;
    var previousGeneratedLine = 1;
    var previousOriginalColumn = 0;
    var previousOriginalLine = 0;
    var previousName = 0;
    var previousSource = 0;
    var result = '';
    var next;
    var mapping;
    var nameIdx;
    var sourceIdx;

    var mappings = this._mappings.toArray();
    for (var i = 0, len = mappings.length; i < len; i++) {
      mapping = mappings[i];
      next = ''

      if (mapping.generatedLine !== previousGeneratedLine) {
        previousGeneratedColumn = 0;
        while (mapping.generatedLine !== previousGeneratedLine) {
          next += ';';
          previousGeneratedLine++;
        }
      }
      else {
        if (i > 0) {
          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
            continue;
          }
          next += ',';
        }
      }

      next += base64VLQ.encode(mapping.generatedColumn
                                 - previousGeneratedColumn);
      previousGeneratedColumn = mapping.generatedColumn;

      if (mapping.source != null) {
        sourceIdx = this._sources.indexOf(mapping.source);
        next += base64VLQ.encode(sourceIdx - previousSource);
        previousSource = sourceIdx;

        // lines are stored 0-based in SourceMap spec version 3
        next += base64VLQ.encode(mapping.originalLine - 1
                                   - previousOriginalLine);
        previousOriginalLine = mapping.originalLine - 1;

        next += base64VLQ.encode(mapping.originalColumn
                                   - previousOriginalColumn);
        previousOriginalColumn = mapping.originalColumn;

        if (mapping.name != null) {
          nameIdx = this._names.indexOf(mapping.name);
          next += base64VLQ.encode(nameIdx - previousName);
          previousName = nameIdx;
        }
      }

      result += next;
    }

    return result;
  };

SourceMapGenerator.prototype._generateSourcesContent =
  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
    return aSources.map(function (source) {
      if (!this._sourcesContents) {
        return null;
      }
      if (aSourceRoot != null) {
        source = util.relative(aSourceRoot, source);
      }
      var key = util.toSetString(source);
      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
        ? this._sourcesContents[key]
        : null;
    }, this);
  };

/**
 * Externalize the source map.
 */
SourceMapGenerator.prototype.toJSON =
  function SourceMapGenerator_toJSON() {
    var map = {
      version: this._version,
      sources: this._sources.toArray(),
      names: this._names.toArray(),
      mappings: this._serializeMappings()
    };
    if (this._file != null) {
      map.file = this._file;
    }
    if (this._sourceRoot != null) {
      map.sourceRoot = this._sourceRoot;
    }
    if (this._sourcesContents) {
      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
    }

    return map;
  };

/**
 * Render the source map being generated to a string.
 */
SourceMapGenerator.prototype.toString =
  function SourceMapGenerator_toString() {
    return JSON.stringify(this.toJSON());
  };

exports.SourceMapGenerator = SourceMapGenerator;

},{"./array-set":1122,"./base64-vlq":1123,"./mapping-list":1126,"./util":1131}],1130:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var SourceMapGenerator = require('./source-map-generator').SourceMapGenerator;
var util = require('./util');

// Matches a Windows-style `\r\n` newline or a `\n` newline used by all other
// operating systems these days (capturing the result).
var REGEX_NEWLINE = /(\r?\n)/;

// Newline character code for charCodeAt() comparisons
var NEWLINE_CODE = 10;

// Private symbol for identifying `SourceNode`s when multiple versions of
// the source-map library are loaded. This MUST NOT CHANGE across
// versions!
var isSourceNode = "$$$isSourceNode$$$";

/**
 * SourceNodes provide a way to abstract over interpolating/concatenating
 * snippets of generated JavaScript source code while maintaining the line and
 * column information associated with the original source code.
 *
 * @param aLine The original line number.
 * @param aColumn The original column number.
 * @param aSource The original source's filename.
 * @param aChunks Optional. An array of strings which are snippets of
 *        generated JS, or other SourceNodes.
 * @param aName The original identifier.
 */
function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
  this.children = [];
  this.sourceContents = {};
  this.line = aLine == null ? null : aLine;
  this.column = aColumn == null ? null : aColumn;
  this.source = aSource == null ? null : aSource;
  this.name = aName == null ? null : aName;
  this[isSourceNode] = true;
  if (aChunks != null) this.add(aChunks);
}

/**
 * Creates a SourceNode from generated code and a SourceMapConsumer.
 *
 * @param aGeneratedCode The generated code
 * @param aSourceMapConsumer The SourceMap for the generated code
 * @param aRelativePath Optional. The path that relative sources in the
 *        SourceMapConsumer should be relative to.
 */
SourceNode.fromStringWithSourceMap =
  function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
    // The SourceNode we want to fill with the generated code
    // and the SourceMap
    var node = new SourceNode();

    // All even indices of this array are one line of the generated code,
    // while all odd indices are the newlines between two adjacent lines
    // (since `REGEX_NEWLINE` captures its match).
    // Processed fragments are accessed by calling `shiftNextLine`.
    var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
    var remainingLinesIndex = 0;
    var shiftNextLine = function() {
      var lineContents = getNextLine();
      // The last line of a file might not have a newline.
      var newLine = getNextLine() || "";
      return lineContents + newLine;

      function getNextLine() {
        return remainingLinesIndex < remainingLines.length ?
            remainingLines[remainingLinesIndex++] : undefined;
      }
    };

    // We need to remember the position of "remainingLines"
    var lastGeneratedLine = 1, lastGeneratedColumn = 0;

    // The generate SourceNodes we need a code range.
    // To extract it current and last mapping is used.
    // Here we store the last mapping.
    var lastMapping = null;

    aSourceMapConsumer.eachMapping(function (mapping) {
      if (lastMapping !== null) {
        // We add the code from "lastMapping" to "mapping":
        // First check if there is a new line in between.
        if (lastGeneratedLine < mapping.generatedLine) {
          // Associate first line with "lastMapping"
          addMappingWithCode(lastMapping, shiftNextLine());
          lastGeneratedLine++;
          lastGeneratedColumn = 0;
          // The remaining code is added without mapping
        } else {
          // There is no new line in between.
          // Associate the code between "lastGeneratedColumn" and
          // "mapping.generatedColumn" with "lastMapping"
          var nextLine = remainingLines[remainingLinesIndex];
          var code = nextLine.substr(0, mapping.generatedColumn -
                                        lastGeneratedColumn);
          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn -
                                              lastGeneratedColumn);
          lastGeneratedColumn = mapping.generatedColumn;
          addMappingWithCode(lastMapping, code);
          // No more remaining code, continue
          lastMapping = mapping;
          return;
        }
      }
      // We add the generated code until the first mapping
      // to the SourceNode without any mapping.
      // Each line is added as separate string.
      while (lastGeneratedLine < mapping.generatedLine) {
        node.add(shiftNextLine());
        lastGeneratedLine++;
      }
      if (lastGeneratedColumn < mapping.generatedColumn) {
        var nextLine = remainingLines[remainingLinesIndex];
        node.add(nextLine.substr(0, mapping.generatedColumn));
        remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
        lastGeneratedColumn = mapping.generatedColumn;
      }
      lastMapping = mapping;
    }, this);
    // We have processed all mappings.
    if (remainingLinesIndex < remainingLines.length) {
      if (lastMapping) {
        // Associate the remaining code in the current line with "lastMapping"
        addMappingWithCode(lastMapping, shiftNextLine());
      }
      // and add the remaining lines without any mapping
      node.add(remainingLines.splice(remainingLinesIndex).join(""));
    }

    // Copy sourcesContent into SourceNode
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        if (aRelativePath != null) {
          sourceFile = util.join(aRelativePath, sourceFile);
        }
        node.setSourceContent(sourceFile, content);
      }
    });

    return node;

    function addMappingWithCode(mapping, code) {
      if (mapping === null || mapping.source === undefined) {
        node.add(code);
      } else {
        var source = aRelativePath
          ? util.join(aRelativePath, mapping.source)
          : mapping.source;
        node.add(new SourceNode(mapping.originalLine,
                                mapping.originalColumn,
                                source,
                                code,
                                mapping.name));
      }
    }
  };

/**
 * Add a chunk of generated JS to this source node.
 *
 * @param aChunk A string snippet of generated JS code, another instance of
 *        SourceNode, or an array where each member is one of those things.
 */
SourceNode.prototype.add = function SourceNode_add(aChunk) {
  if (Array.isArray(aChunk)) {
    aChunk.forEach(function (chunk) {
      this.add(chunk);
    }, this);
  }
  else if (aChunk[isSourceNode] || typeof aChunk === "string") {
    if (aChunk) {
      this.children.push(aChunk);
    }
  }
  else {
    throw new TypeError(
      "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
    );
  }
  return this;
};

/**
 * Add a chunk of generated JS to the beginning of this source node.
 *
 * @param aChunk A string snippet of generated JS code, another instance of
 *        SourceNode, or an array where each member is one of those things.
 */
SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
  if (Array.isArray(aChunk)) {
    for (var i = aChunk.length-1; i >= 0; i--) {
      this.prepend(aChunk[i]);
    }
  }
  else if (aChunk[isSourceNode] || typeof aChunk === "string") {
    this.children.unshift(aChunk);
  }
  else {
    throw new TypeError(
      "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
    );
  }
  return this;
};

/**
 * Walk over the tree of JS snippets in this node and its children. The
 * walking function is called once for each snippet of JS and is passed that
 * snippet and the its original associated source's line/column location.
 *
 * @param aFn The traversal function.
 */
SourceNode.prototype.walk = function SourceNode_walk(aFn) {
  var chunk;
  for (var i = 0, len = this.children.length; i < len; i++) {
    chunk = this.children[i];
    if (chunk[isSourceNode]) {
      chunk.walk(aFn);
    }
    else {
      if (chunk !== '') {
        aFn(chunk, { source: this.source,
                     line: this.line,
                     column: this.column,
                     name: this.name });
      }
    }
  }
};

/**
 * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
 * each of `this.children`.
 *
 * @param aSep The separator.
 */
SourceNode.prototype.join = function SourceNode_join(aSep) {
  var newChildren;
  var i;
  var len = this.children.length;
  if (len > 0) {
    newChildren = [];
    for (i = 0; i < len-1; i++) {
      newChildren.push(this.children[i]);
      newChildren.push(aSep);
    }
    newChildren.push(this.children[i]);
    this.children = newChildren;
  }
  return this;
};

/**
 * Call String.prototype.replace on the very right-most source snippet. Useful
 * for trimming whitespace from the end of a source node, etc.
 *
 * @param aPattern The pattern to replace.
 * @param aReplacement The thing to replace the pattern with.
 */
SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
  var lastChild = this.children[this.children.length - 1];
  if (lastChild[isSourceNode]) {
    lastChild.replaceRight(aPattern, aReplacement);
  }
  else if (typeof lastChild === 'string') {
    this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
  }
  else {
    this.children.push(''.replace(aPattern, aReplacement));
  }
  return this;
};

/**
 * Set the source content for a source file. This will be added to the SourceMapGenerator
 * in the sourcesContent field.
 *
 * @param aSourceFile The filename of the source file
 * @param aSourceContent The content of the source file
 */
SourceNode.prototype.setSourceContent =
  function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
  };

/**
 * Walk over the tree of SourceNodes. The walking function is called for each
 * source file content and is passed the filename and source content.
 *
 * @param aFn The traversal function.
 */
SourceNode.prototype.walkSourceContents =
  function SourceNode_walkSourceContents(aFn) {
    for (var i = 0, len = this.children.length; i < len; i++) {
      if (this.children[i][isSourceNode]) {
        this.children[i].walkSourceContents(aFn);
      }
    }

    var sources = Object.keys(this.sourceContents);
    for (var i = 0, len = sources.length; i < len; i++) {
      aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
    }
  };

/**
 * Return the string representation of this source node. Walks over the tree
 * and concatenates all the various snippets together to one string.
 */
SourceNode.prototype.toString = function SourceNode_toString() {
  var str = "";
  this.walk(function (chunk) {
    str += chunk;
  });
  return str;
};

/**
 * Returns the string representation of this source node along with a source
 * map.
 */
SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
  var generated = {
    code: "",
    line: 1,
    column: 0
  };
  var map = new SourceMapGenerator(aArgs);
  var sourceMappingActive = false;
  var lastOriginalSource = null;
  var lastOriginalLine = null;
  var lastOriginalColumn = null;
  var lastOriginalName = null;
  this.walk(function (chunk, original) {
    generated.code += chunk;
    if (original.source !== null
        && original.line !== null
        && original.column !== null) {
      if(lastOriginalSource !== original.source
         || lastOriginalLine !== original.line
         || lastOriginalColumn !== original.column
         || lastOriginalName !== original.name) {
        map.addMapping({
          source: original.source,
          original: {
            line: original.line,
            column: original.column
          },
          generated: {
            line: generated.line,
            column: generated.column
          },
          name: original.name
        });
      }
      lastOriginalSource = original.source;
      lastOriginalLine = original.line;
      lastOriginalColumn = original.column;
      lastOriginalName = original.name;
      sourceMappingActive = true;
    } else if (sourceMappingActive) {
      map.addMapping({
        generated: {
          line: generated.line,
          column: generated.column
        }
      });
      lastOriginalSource = null;
      sourceMappingActive = false;
    }
    for (var idx = 0, length = chunk.length; idx < length; idx++) {
      if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
        generated.line++;
        generated.column = 0;
        // Mappings end at eol
        if (idx + 1 === length) {
          lastOriginalSource = null;
          sourceMappingActive = false;
        } else if (sourceMappingActive) {
          map.addMapping({
            source: original.source,
            original: {
              line: original.line,
              column: original.column
            },
            generated: {
              line: generated.line,
              column: generated.column
            },
            name: original.name
          });
        }
      } else {
        generated.column++;
      }
    }
  });
  this.walkSourceContents(function (sourceFile, sourceContent) {
    map.setSourceContent(sourceFile, sourceContent);
  });

  return { code: generated.code, map: map };
};

exports.SourceNode = SourceNode;

},{"./source-map-generator":1129,"./util":1131}],1131:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

/**
 * This is a helper function for getting values from parameter/options
 * objects.
 *
 * @param args The object we are extracting values from
 * @param name The name of the property we are getting.
 * @param defaultValue An optional value to return if the property is missing
 * from the object. If this is not specified and the property is missing, an
 * error will be thrown.
 */
function getArg(aArgs, aName, aDefaultValue) {
  if (aName in aArgs) {
    return aArgs[aName];
  } else if (arguments.length === 3) {
    return aDefaultValue;
  } else {
    throw new Error('"' + aName + '" is a required argument.');
  }
}
exports.getArg = getArg;

var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.]*)(?::(\d+))?(\S*)$/;
var dataUrlRegexp = /^data:.+\,.+$/;

function urlParse(aUrl) {
  var match = aUrl.match(urlRegexp);
  if (!match) {
    return null;
  }
  return {
    scheme: match[1],
    auth: match[2],
    host: match[3],
    port: match[4],
    path: match[5]
  };
}
exports.urlParse = urlParse;

function urlGenerate(aParsedUrl) {
  var url = '';
  if (aParsedUrl.scheme) {
    url += aParsedUrl.scheme + ':';
  }
  url += '//';
  if (aParsedUrl.auth) {
    url += aParsedUrl.auth + '@';
  }
  if (aParsedUrl.host) {
    url += aParsedUrl.host;
  }
  if (aParsedUrl.port) {
    url += ":" + aParsedUrl.port
  }
  if (aParsedUrl.path) {
    url += aParsedUrl.path;
  }
  return url;
}
exports.urlGenerate = urlGenerate;

/**
 * Normalizes a path, or the path portion of a URL:
 *
 * - Replaces consecutive slashes with one slash.
 * - Removes unnecessary '.' parts.
 * - Removes unnecessary '<dir>/..' parts.
 *
 * Based on code in the Node.js 'path' core module.
 *
 * @param aPath The path or url to normalize.
 */
function normalize(aPath) {
  var path = aPath;
  var url = urlParse(aPath);
  if (url) {
    if (!url.path) {
      return aPath;
    }
    path = url.path;
  }
  var isAbsolute = exports.isAbsolute(path);

  var parts = path.split(/\/+/);
  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
    part = parts[i];
    if (part === '.') {
      parts.splice(i, 1);
    } else if (part === '..') {
      up++;
    } else if (up > 0) {
      if (part === '') {
        // The first part is blank if the path is absolute. Trying to go
        // above the root is a no-op. Therefore we can remove all '..' parts
        // directly after the root.
        parts.splice(i + 1, up);
        up = 0;
      } else {
        parts.splice(i, 2);
        up--;
      }
    }
  }
  path = parts.join('/');

  if (path === '') {
    path = isAbsolute ? '/' : '.';
  }

  if (url) {
    url.path = path;
    return urlGenerate(url);
  }
  return path;
}
exports.normalize = normalize;

/**
 * Joins two paths/URLs.
 *
 * @param aRoot The root path or URL.
 * @param aPath The path or URL to be joined with the root.
 *
 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
 *   first.
 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
 *   is updated with the result and aRoot is returned. Otherwise the result
 *   is returned.
 *   - If aPath is absolute, the result is aPath.
 *   - Otherwise the two paths are joined with a slash.
 * - Joining for example 'http://' and 'www.example.com' is also supported.
 */
function join(aRoot, aPath) {
  if (aRoot === "") {
    aRoot = ".";
  }
  if (aPath === "") {
    aPath = ".";
  }
  var aPathUrl = urlParse(aPath);
  var aRootUrl = urlParse(aRoot);
  if (aRootUrl) {
    aRoot = aRootUrl.path || '/';
  }

  // `join(foo, '//www.example.org')`
  if (aPathUrl && !aPathUrl.scheme) {
    if (aRootUrl) {
      aPathUrl.scheme = aRootUrl.scheme;
    }
    return urlGenerate(aPathUrl);
  }

  if (aPathUrl || aPath.match(dataUrlRegexp)) {
    return aPath;
  }

  // `join('http://', 'www.example.com')`
  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
    aRootUrl.host = aPath;
    return urlGenerate(aRootUrl);
  }

  var joined = aPath.charAt(0) === '/'
    ? aPath
    : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

  if (aRootUrl) {
    aRootUrl.path = joined;
    return urlGenerate(aRootUrl);
  }
  return joined;
}
exports.join = join;

exports.isAbsolute = function (aPath) {
  return aPath.charAt(0) === '/' || !!aPath.match(urlRegexp);
};

/**
 * Make a path relative to a URL or another path.
 *
 * @param aRoot The root path or URL.
 * @param aPath The path or URL to be made relative to aRoot.
 */
function relative(aRoot, aPath) {
  if (aRoot === "") {
    aRoot = ".";
  }

  aRoot = aRoot.replace(/\/$/, '');

  // It is possible for the path to be above the root. In this case, simply
  // checking whether the root is a prefix of the path won't work. Instead, we
  // need to remove components from the root one by one, until either we find
  // a prefix that fits, or we run out of components to remove.
  var level = 0;
  while (aPath.indexOf(aRoot + '/') !== 0) {
    var index = aRoot.lastIndexOf("/");
    if (index < 0) {
      return aPath;
    }

    // If the only part of the root that is left is the scheme (i.e. http://,
    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
    // have exhausted all components, so the path is not relative to the root.
    aRoot = aRoot.slice(0, index);
    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
      return aPath;
    }

    ++level;
  }

  // Make sure we add a "../" for each component we removed from the root.
  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
}
exports.relative = relative;

var supportsNullProto = (function () {
  var obj = Object.create(null);
  return !('__proto__' in obj);
}());

function identity (s) {
  return s;
}

/**
 * Because behavior goes wacky when you set `__proto__` on objects, we
 * have to prefix all the strings in our set with an arbitrary character.
 *
 * See https://github.com/mozilla/source-map/pull/31 and
 * https://github.com/mozilla/source-map/issues/30
 *
 * @param String aStr
 */
function toSetString(aStr) {
  if (isProtoString(aStr)) {
    return '$' + aStr;
  }

  return aStr;
}
exports.toSetString = supportsNullProto ? identity : toSetString;

function fromSetString(aStr) {
  if (isProtoString(aStr)) {
    return aStr.slice(1);
  }

  return aStr;
}
exports.fromSetString = supportsNullProto ? identity : fromSetString;

function isProtoString(s) {
  if (!s) {
    return false;
  }

  var length = s.length;

  if (length < 9 /* "__proto__".length */) {
    return false;
  }

  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||
      s.charCodeAt(length - 2) !== 95  /* '_' */ ||
      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
      s.charCodeAt(length - 4) !== 116 /* 't' */ ||
      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
      s.charCodeAt(length - 8) !== 95  /* '_' */ ||
      s.charCodeAt(length - 9) !== 95  /* '_' */) {
    return false;
  }

  for (var i = length - 10; i >= 0; i--) {
    if (s.charCodeAt(i) !== 36 /* '$' */) {
      return false;
    }
  }

  return true;
}

/**
 * Comparator between two mappings where the original positions are compared.
 *
 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
 * mappings with the same original source/line/column, but different generated
 * line and column the same. Useful when searching for a mapping with a
 * stubbed out mapping.
 */
function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
  var cmp = mappingA.source - mappingB.source;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0 || onlyCompareOriginal) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  return mappingA.name - mappingB.name;
}
exports.compareByOriginalPositions = compareByOriginalPositions;

/**
 * Comparator between two mappings with deflated source and name indices where
 * the generated positions are compared.
 *
 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
 * mappings with the same generated line and column, but different
 * source/name/original line and column the same. Useful when searching for a
 * mapping with a stubbed out mapping.
 */
function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
  var cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0 || onlyCompareGenerated) {
    return cmp;
  }

  cmp = mappingA.source - mappingB.source;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0) {
    return cmp;
  }

  return mappingA.name - mappingB.name;
}
exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

function strcmp(aStr1, aStr2) {
  if (aStr1 === aStr2) {
    return 0;
  }

  if (aStr1 > aStr2) {
    return 1;
  }

  return -1;
}

/**
 * Comparator between two mappings with inflated source and name strings where
 * the generated positions are compared.
 */
function compareByGeneratedPositionsInflated(mappingA, mappingB) {
  var cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = strcmp(mappingA.source, mappingB.source);
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0) {
    return cmp;
  }

  return strcmp(mappingA.name, mappingB.name);
}
exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;

},{}],1132:[function(require,module,exports){
arguments[4][1096][0].apply(exports,arguments)
},{"./lib/source-map-consumer":1128,"./lib/source-map-generator":1129,"./lib/source-node":1130,"dup":1096}],1133:[function(require,module,exports){
//! stable.js 0.1.8, https://github.com/Two-Screen/stable
//!  2018 Angry Bytes and contributors. MIT licensed.

(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global.stable = factory());
}(this, (function () { 'use strict';

  // A stable array sort, because `Array#sort()` is not guaranteed stable.
  // This is an implementation of merge sort, without recursion.

  var stable = function (arr, comp) {
    return exec(arr.slice(), comp)
  };

  stable.inplace = function (arr, comp) {
    var result = exec(arr, comp);

    // This simply copies back if the result isn't in the original array,
    // which happens on an odd number of passes.
    if (result !== arr) {
      pass(result, null, arr.length, arr);
    }

    return arr
  };

  // Execute the sort using the input array and a second buffer as work space.
  // Returns one of those two, containing the final result.
  function exec(arr, comp) {
    if (typeof(comp) !== 'function') {
      comp = function (a, b) {
        return String(a).localeCompare(b)
      };
    }

    // Short-circuit when there's nothing to sort.
    var len = arr.length;
    if (len <= 1) {
      return arr
    }

    // Rather than dividing input, simply iterate chunks of 1, 2, 4, 8, etc.
    // Chunks are the size of the left or right hand in merge sort.
    // Stop when the left-hand covers all of the array.
    var buffer = new Array(len);
    for (var chk = 1; chk < len; chk *= 2) {
      pass(arr, comp, chk, buffer);

      var tmp = arr;
      arr = buffer;
      buffer = tmp;
    }

    return arr
  }

  // Run a single pass with the given chunk size.
  var pass = function (arr, comp, chk, result) {
    var len = arr.length;
    var i = 0;
    // Step size / double chunk size.
    var dbl = chk * 2;
    // Bounds of the left and right chunks.
    var l, r, e;
    // Iterators over the left and right chunk.
    var li, ri;

    // Iterate over pairs of chunks.
    for (l = 0; l < len; l += dbl) {
      r = l + chk;
      e = r + chk;
      if (r > len) r = len;
      if (e > len) e = len;

      // Iterate both chunks in parallel.
      li = l;
      ri = r;
      while (true) {
        // Compare the chunks.
        if (li < r && ri < e) {
          // This works for a regular `sort()` compatible comparator,
          // but also for a simple comparator like: `a > b`
          if (comp(arr[li], arr[ri]) <= 0) {
            result[i++] = arr[li++];
          }
          else {
            result[i++] = arr[ri++];
          }
        }
        // Nothing to compare, just flush what's left.
        else if (li < r) {
          result[i++] = arr[li++];
        }
        else if (ri < e) {
          result[i++] = arr[ri++];
        }
        // Both iterators are at the chunk ends.
        else {
          break
        }
      }
    }
  };

  return stable;

})));

},{}],1134:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Stream;

var EE = require('events').EventEmitter;
var inherits = require('inherits');

inherits(Stream, EE);
Stream.Readable = require('readable-stream/readable.js');
Stream.Writable = require('readable-stream/writable.js');
Stream.Duplex = require('readable-stream/duplex.js');
Stream.Transform = require('readable-stream/transform.js');
Stream.PassThrough = require('readable-stream/passthrough.js');

// Backwards-compat with node 0.4.x
Stream.Stream = Stream;



// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function(dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest.end();
  }


  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    if (typeof dest.destroy === 'function') dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);

    source.removeListener('end', onend);
    source.removeListener('close', onclose);

    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);

    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);

    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('close', cleanup);

  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};

},{"events":713,"inherits":728,"readable-stream/duplex.js":1102,"readable-stream/passthrough.js":1111,"readable-stream/readable.js":1112,"readable-stream/transform.js":1113,"readable-stream/writable.js":1114}],1135:[function(require,module,exports){
/*! http://mths.be/repeat v0.2.0 by @mathias */
if (!String.prototype.repeat) {
	(function() {
		'use strict'; // needed to support `apply`/`call` with `undefined`/`null`
		var defineProperty = (function() {
			// IE 8 only supports `Object.defineProperty` on DOM elements
			try {
				var object = {};
				var $defineProperty = Object.defineProperty;
				var result = $defineProperty(object, object, object) && $defineProperty;
			} catch(error) {}
			return result;
		}());
		var repeat = function(count) {
			if (this == null) {
				throw TypeError();
			}
			var string = String(this);
			// `ToInteger`
			var n = count ? Number(count) : 0;
			if (n != n) { // better `isNaN`
				n = 0;
			}
			// Account for out-of-bounds indices
			if (n < 0 || n == Infinity) {
				throw RangeError();
			}
			var result = '';
			while (n) {
				if (n % 2 == 1) {
					result += string;
				}
				if (n > 1) {
					string += string;
				}
				n >>= 1;
			}
			return result;
		};
		if (defineProperty) {
			defineProperty(String.prototype, 'repeat', {
				'value': repeat,
				'configurable': true,
				'writable': true
			});
		} else {
			String.prototype.repeat = repeat;
		}
	}());
}

},{}],1136:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
/*</replacement>*/

var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
      return true;
    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
};

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return byte >> 6 === 0x02 ? -1 : -2;
}

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\ufffd';
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\ufffd';
    }
    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\ufffd';
      }
    }
  }
}

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\ufffd';
  return r;
}

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);
    if (r) {
      var c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
}

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}
},{"safe-buffer":1118}],1137:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
const FF_2 = exports.FF_2 = 'firefox 2';
const IE_5_5 = exports.IE_5_5 = 'ie 5.5';
const IE_6 = exports.IE_6 = 'ie 6';
const IE_7 = exports.IE_7 = 'ie 7';
const IE_8 = exports.IE_8 = 'ie 8';
const OP_9 = exports.OP_9 = 'opera 9';
},{}],1138:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
const MEDIA_QUERY = exports.MEDIA_QUERY = 'media query';
const PROPERTY = exports.PROPERTY = 'property';
const SELECTOR = exports.SELECTOR = 'selector';
const VALUE = exports.VALUE = 'value';
},{}],1139:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
const ATRULE = exports.ATRULE = 'atrule';
const DECL = exports.DECL = 'decl';
const RULE = exports.RULE = 'rule';
},{}],1140:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
const BODY = exports.BODY = 'body';
const HTML = exports.HTML = 'html';
},{}],1141:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = exists;
function exists(selector, index, value) {
    const node = selector.at(index);

    return node && node.value && node.value.toLowerCase() === value;
}
module.exports = exports["default"];
},{}],1142:[function(require,module,exports){
(function (__dirname){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _postcss = require('postcss');

var _postcss2 = _interopRequireDefault(_postcss);

var _browserslist = require('browserslist');

var _browserslist2 = _interopRequireDefault(_browserslist);

var _plugins = require('./plugins');

var _plugins2 = _interopRequireDefault(_plugins);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const stylehacks = _postcss2.default.plugin('stylehacks', (opts = {}) => {
    return (css, result) => {
        const resultOpts = result.opts || {};
        const browsers = (0, _browserslist2.default)(null, {
            stats: resultOpts.stats,
            path: __dirname,
            env: resultOpts.env
        });
        const processors = _plugins2.default.reduce((list, Plugin) => {
            const hack = new Plugin(result);
            const applied = browsers.some(browser => {
                return hack.targets.some(target => browser === target);
            });

            if (applied) {
                return list;
            }

            return [...list, hack];
        }, []);

        css.walk(node => {
            processors.forEach(proc => {
                if (!~proc.nodeTypes.indexOf(node.type)) {
                    return;
                }

                if (opts.lint) {
                    return proc.detectAndWarn(node);
                }

                return proc.detectAndResolve(node);
            });
        });
    };
});

stylehacks.detect = node => {
    return _plugins2.default.some(Plugin => {
        const hack = new Plugin();

        return hack.any(node);
    });
};

exports.default = stylehacks;
module.exports = exports['default'];
}).call(this,"/node_modules/stylehacks/dist")
},{"./plugins":1149,"browserslist":12,"postcss":1074}],1143:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = isMixin;
function isMixin(node) {
    const { selector } = node;

    // If the selector ends with a ':' it is likely a part of a custom mixin.
    if (!selector || selector[selector.length - 1] === ':') {
        return true;
    }

    return false;
}
module.exports = exports['default'];
},{}],1144:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = plugin;
function plugin(targets, nodeTypes, detect) {
    class Plugin {
        constructor(result) {
            this.nodes = [];
            this.result = result;
            this.targets = targets;
            this.nodeTypes = nodeTypes;
        }

        push(node, metadata) {
            node._stylehacks = Object.assign({}, metadata, {
                message: `Bad ${metadata.identifier}: ${metadata.hack}`,
                browsers: this.targets
            });

            this.nodes.push(node);
        }

        any(node) {
            if (~this.nodeTypes.indexOf(node.type)) {
                detect.apply(this, arguments);

                return !!node._stylehacks;
            }

            return false;
        }

        detectAndResolve(...args) {
            this.nodes = [];

            detect.apply(this, args);

            return this.resolve();
        }

        detectAndWarn(...args) {
            this.nodes = [];

            detect.apply(this, args);

            return this.warn();
        }

        resolve() {
            return this.nodes.forEach(node => node.remove());
        }

        warn() {
            return this.nodes.forEach(node => {
                const { message, browsers, identifier, hack } = node._stylehacks;

                return node.warn(this.result, message, { browsers, identifier, hack });
            });
        }
    }

    return Plugin;
}
module.exports = exports["default"];
},{}],1145:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _postcssSelectorParser = require('postcss-selector-parser');

var _postcssSelectorParser2 = _interopRequireDefault(_postcssSelectorParser);

var _exists = require('../exists');

var _exists2 = _interopRequireDefault(_exists);

var _isMixin = require('../isMixin');

var _isMixin2 = _interopRequireDefault(_isMixin);

var _plugin = require('../plugin');

var _plugin2 = _interopRequireDefault(_plugin);

var _browsers = require('../dictionary/browsers');

var _identifiers = require('../dictionary/identifiers');

var _postcss = require('../dictionary/postcss');

var _tags = require('../dictionary/tags');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function analyse(ctx, rule) {
    return selectors => {
        selectors.each(selector => {
            if ((0, _exists2.default)(selector, 0, _tags.BODY) && (0, _exists2.default)(selector, 1, ':empty') && (0, _exists2.default)(selector, 2, ' ') && selector.at(3)) {
                ctx.push(rule, {
                    identifier: _identifiers.SELECTOR,
                    hack: selector.toString()
                });
            }
        });
    };
}

exports.default = (0, _plugin2.default)([_browsers.FF_2], [_postcss.RULE], function (rule) {
    if ((0, _isMixin2.default)(rule)) {
        return;
    }
    (0, _postcssSelectorParser2.default)(analyse(this, rule)).processSync(rule.selector);
});
module.exports = exports['default'];
},{"../dictionary/browsers":1137,"../dictionary/identifiers":1138,"../dictionary/postcss":1139,"../dictionary/tags":1140,"../exists":1141,"../isMixin":1143,"../plugin":1144,"postcss-selector-parser":1158}],1146:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _postcssSelectorParser = require('postcss-selector-parser');

var _postcssSelectorParser2 = _interopRequireDefault(_postcssSelectorParser);

var _exists = require('../exists');

var _exists2 = _interopRequireDefault(_exists);

var _isMixin = require('../isMixin');

var _isMixin2 = _interopRequireDefault(_isMixin);

var _plugin = require('../plugin');

var _plugin2 = _interopRequireDefault(_plugin);

var _browsers = require('../dictionary/browsers');

var _identifiers = require('../dictionary/identifiers');

var _postcss = require('../dictionary/postcss');

var _tags = require('../dictionary/tags');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function analyse(ctx, rule) {
    return selectors => {
        selectors.each(selector => {
            if ((0, _exists2.default)(selector, 0, _tags.HTML) && ((0, _exists2.default)(selector, 1, '>') || (0, _exists2.default)(selector, 1, '~')) && selector.at(2) && selector.at(2).type === 'comment' && (0, _exists2.default)(selector, 3, ' ') && (0, _exists2.default)(selector, 4, _tags.BODY) && (0, _exists2.default)(selector, 5, ' ') && selector.at(6)) {
                ctx.push(rule, {
                    identifier: _identifiers.SELECTOR,
                    hack: selector.toString()
                });
            }
        });
    };
}

exports.default = (0, _plugin2.default)([_browsers.IE_5_5, _browsers.IE_6, _browsers.IE_7], [_postcss.RULE], function (rule) {
    if ((0, _isMixin2.default)(rule)) {
        return;
    }
    if (rule.raws.selector && rule.raws.selector.raw) {
        (0, _postcssSelectorParser2.default)(analyse(this, rule)).processSync(rule.raws.selector.raw);
    }
});
module.exports = exports['default'];
},{"../dictionary/browsers":1137,"../dictionary/identifiers":1138,"../dictionary/postcss":1139,"../dictionary/tags":1140,"../exists":1141,"../isMixin":1143,"../plugin":1144,"postcss-selector-parser":1158}],1147:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _postcssSelectorParser = require('postcss-selector-parser');

var _postcssSelectorParser2 = _interopRequireDefault(_postcssSelectorParser);

var _exists = require('../exists');

var _exists2 = _interopRequireDefault(_exists);

var _isMixin = require('../isMixin');

var _isMixin2 = _interopRequireDefault(_isMixin);

var _plugin = require('../plugin');

var _plugin2 = _interopRequireDefault(_plugin);

var _browsers = require('../dictionary/browsers');

var _identifiers = require('../dictionary/identifiers');

var _postcss = require('../dictionary/postcss');

var _tags = require('../dictionary/tags');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function analyse(ctx, rule) {
    return selectors => {
        selectors.each(selector => {
            if ((0, _exists2.default)(selector, 0, _tags.HTML) && (0, _exists2.default)(selector, 1, ':first-child') && (0, _exists2.default)(selector, 2, ' ') && selector.at(3)) {
                ctx.push(rule, {
                    identifier: _identifiers.SELECTOR,
                    hack: selector.toString()
                });
            }
        });
    };
}

exports.default = (0, _plugin2.default)([_browsers.OP_9], [_postcss.RULE], function (rule) {
    if ((0, _isMixin2.default)(rule)) {
        return;
    }
    (0, _postcssSelectorParser2.default)(analyse(this, rule)).processSync(rule.selector);
});
module.exports = exports['default'];
},{"../dictionary/browsers":1137,"../dictionary/identifiers":1138,"../dictionary/postcss":1139,"../dictionary/tags":1140,"../exists":1141,"../isMixin":1143,"../plugin":1144,"postcss-selector-parser":1158}],1148:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _plugin = require('../plugin');

var _plugin2 = _interopRequireDefault(_plugin);

var _browsers = require('../dictionary/browsers');

var _postcss = require('../dictionary/postcss');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = (0, _plugin2.default)([_browsers.IE_5_5, _browsers.IE_6, _browsers.IE_7], [_postcss.DECL], function (decl) {
    const match = decl.value.match(/!\w/);
    if (match) {
        const hack = decl.value.substr(match.index, decl.value.length - 1);
        this.push(decl, {
            identifier: '!important',
            hack
        });
    }
});
module.exports = exports['default'];
},{"../dictionary/browsers":1137,"../dictionary/postcss":1139,"../plugin":1144}],1149:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _bodyEmpty = require('./bodyEmpty');

var _bodyEmpty2 = _interopRequireDefault(_bodyEmpty);

var _htmlCombinatorCommentBody = require('./htmlCombinatorCommentBody');

var _htmlCombinatorCommentBody2 = _interopRequireDefault(_htmlCombinatorCommentBody);

var _htmlFirstChild = require('./htmlFirstChild');

var _htmlFirstChild2 = _interopRequireDefault(_htmlFirstChild);

var _important = require('./important');

var _important2 = _interopRequireDefault(_important);

var _leadingStar = require('./leadingStar');

var _leadingStar2 = _interopRequireDefault(_leadingStar);

var _leadingUnderscore = require('./leadingUnderscore');

var _leadingUnderscore2 = _interopRequireDefault(_leadingUnderscore);

var _mediaSlash = require('./mediaSlash0');

var _mediaSlash2 = _interopRequireDefault(_mediaSlash);

var _mediaSlash0Slash = require('./mediaSlash0Slash9');

var _mediaSlash0Slash2 = _interopRequireDefault(_mediaSlash0Slash);

var _mediaSlash3 = require('./mediaSlash9');

var _mediaSlash4 = _interopRequireDefault(_mediaSlash3);

var _slash = require('./slash9');

var _slash2 = _interopRequireDefault(_slash);

var _starHtml = require('./starHtml');

var _starHtml2 = _interopRequireDefault(_starHtml);

var _trailingSlashComma = require('./trailingSlashComma');

var _trailingSlashComma2 = _interopRequireDefault(_trailingSlashComma);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = [_bodyEmpty2.default, _htmlCombinatorCommentBody2.default, _htmlFirstChild2.default, _important2.default, _leadingStar2.default, _leadingUnderscore2.default, _mediaSlash2.default, _mediaSlash0Slash2.default, _mediaSlash4.default, _slash2.default, _starHtml2.default, _trailingSlashComma2.default];
module.exports = exports['default'];
},{"./bodyEmpty":1145,"./htmlCombinatorCommentBody":1146,"./htmlFirstChild":1147,"./important":1148,"./leadingStar":1150,"./leadingUnderscore":1151,"./mediaSlash0":1152,"./mediaSlash0Slash9":1153,"./mediaSlash9":1154,"./slash9":1155,"./starHtml":1156,"./trailingSlashComma":1157}],1150:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _plugin = require('../plugin');

var _plugin2 = _interopRequireDefault(_plugin);

var _browsers = require('../dictionary/browsers');

var _identifiers = require('../dictionary/identifiers');

var _postcss = require('../dictionary/postcss');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const hacks = '!_$_&_*_)_=_%_+_,_._/_`_]_#_~_?_:_|'.split('_');

exports.default = (0, _plugin2.default)([_browsers.IE_5_5, _browsers.IE_6, _browsers.IE_7], [_postcss.ATRULE, _postcss.DECL], function (node) {
    if (node.type === _postcss.DECL) {
        // some values are not picked up by before, so ensure they are
        // at the beginning of the value
        hacks.some(hack => {
            if (!node.prop.indexOf(hack)) {
                this.push(node, {
                    identifier: _identifiers.PROPERTY,
                    hack: node.prop
                });
                return true;
            }
        });
        let { before } = node.raws;
        if (!before) {
            return;
        }
        hacks.some(hack => {
            if (~before.indexOf(hack)) {
                this.push(node, {
                    identifier: _identifiers.PROPERTY,
                    hack: `${before.trim()}${node.prop}`
                });
                return true;
            }
        });
    } else {
        // test for the @property: value; hack
        let { name } = node;
        let len = name.length - 1;
        if (name.lastIndexOf(':') === len) {
            this.push(node, {
                identifier: _identifiers.PROPERTY,
                hack: `@${name.substr(0, len)}`
            });
        }
    }
});
module.exports = exports['default'];
},{"../dictionary/browsers":1137,"../dictionary/identifiers":1138,"../dictionary/postcss":1139,"../plugin":1144}],1151:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _postcss = require('postcss');

var _postcss2 = _interopRequireDefault(_postcss);

var _plugin = require('../plugin');

var _plugin2 = _interopRequireDefault(_plugin);

var _browsers = require('../dictionary/browsers');

var _identifiers = require('../dictionary/identifiers');

var _postcss3 = require('../dictionary/postcss');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = (0, _plugin2.default)([_browsers.IE_6], [_postcss3.DECL], function (decl) {
    const { before } = decl.raws;

    if (before && ~before.indexOf('_')) {
        this.push(decl, {
            identifier: _identifiers.PROPERTY,
            hack: `${before.trim()}${decl.prop}`
        });
    }

    if (decl.prop[0] === '-' && decl.prop[1] !== '-' && _postcss2.default.vendor.prefix(decl.prop) === '') {
        this.push(decl, {
            identifier: _identifiers.PROPERTY,
            hack: decl.prop
        });
    }
});
module.exports = exports['default'];
},{"../dictionary/browsers":1137,"../dictionary/identifiers":1138,"../dictionary/postcss":1139,"../plugin":1144,"postcss":1074}],1152:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _plugin = require('../plugin');

var _plugin2 = _interopRequireDefault(_plugin);

var _browsers = require('../dictionary/browsers');

var _identifiers = require('../dictionary/identifiers');

var _postcss = require('../dictionary/postcss');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = (0, _plugin2.default)([_browsers.IE_8], [_postcss.ATRULE], function (rule) {
    const params = rule.params.trim();

    if (params.toLowerCase() === '\\0screen') {
        this.push(rule, {
            identifier: _identifiers.MEDIA_QUERY,
            hack: params
        });
    }
});
module.exports = exports['default'];
},{"../dictionary/browsers":1137,"../dictionary/identifiers":1138,"../dictionary/postcss":1139,"../plugin":1144}],1153:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _plugin = require('../plugin');

var _plugin2 = _interopRequireDefault(_plugin);

var _browsers = require('../dictionary/browsers');

var _identifiers = require('../dictionary/identifiers');

var _postcss = require('../dictionary/postcss');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = (0, _plugin2.default)([_browsers.IE_5_5, _browsers.IE_6, _browsers.IE_7, _browsers.IE_8], [_postcss.ATRULE], function (rule) {
    const params = rule.params.trim();

    if (params.toLowerCase() === '\\0screen\\,screen\\9') {
        this.push(rule, {
            identifier: _identifiers.MEDIA_QUERY,
            hack: params
        });
    }
});
module.exports = exports['default'];
},{"../dictionary/browsers":1137,"../dictionary/identifiers":1138,"../dictionary/postcss":1139,"../plugin":1144}],1154:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _plugin = require('../plugin');

var _plugin2 = _interopRequireDefault(_plugin);

var _browsers = require('../dictionary/browsers');

var _identifiers = require('../dictionary/identifiers');

var _postcss = require('../dictionary/postcss');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = (0, _plugin2.default)([_browsers.IE_5_5, _browsers.IE_6, _browsers.IE_7], [_postcss.ATRULE], function (rule) {
    const params = rule.params.trim();

    if (params.toLowerCase() === 'screen\\9') {
        this.push(rule, {
            identifier: _identifiers.MEDIA_QUERY,
            hack: params
        });
    }
});
module.exports = exports['default'];
},{"../dictionary/browsers":1137,"../dictionary/identifiers":1138,"../dictionary/postcss":1139,"../plugin":1144}],1155:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _plugin = require('../plugin');

var _plugin2 = _interopRequireDefault(_plugin);

var _browsers = require('../dictionary/browsers');

var _identifiers = require('../dictionary/identifiers');

var _postcss = require('../dictionary/postcss');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = (0, _plugin2.default)([_browsers.IE_6, _browsers.IE_7, _browsers.IE_8], [_postcss.DECL], function (decl) {
    let v = decl.value;
    if (v && v.length > 2 && v.indexOf('\\9') === v.length - 2) {
        this.push(decl, {
            identifier: _identifiers.VALUE,
            hack: v
        });
    }
});
module.exports = exports['default'];
},{"../dictionary/browsers":1137,"../dictionary/identifiers":1138,"../dictionary/postcss":1139,"../plugin":1144}],1156:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _postcssSelectorParser = require('postcss-selector-parser');

var _postcssSelectorParser2 = _interopRequireDefault(_postcssSelectorParser);

var _exists = require('../exists');

var _exists2 = _interopRequireDefault(_exists);

var _isMixin = require('../isMixin');

var _isMixin2 = _interopRequireDefault(_isMixin);

var _plugin = require('../plugin');

var _plugin2 = _interopRequireDefault(_plugin);

var _browsers = require('../dictionary/browsers');

var _identifiers = require('../dictionary/identifiers');

var _postcss = require('../dictionary/postcss');

var _tags = require('../dictionary/tags');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function analyse(ctx, rule) {
    return selectors => {
        selectors.each(selector => {
            if ((0, _exists2.default)(selector, 0, '*') && (0, _exists2.default)(selector, 1, ' ') && (0, _exists2.default)(selector, 2, _tags.HTML) && (0, _exists2.default)(selector, 3, ' ') && selector.at(4)) {
                ctx.push(rule, {
                    identifier: _identifiers.SELECTOR,
                    hack: selector.toString()
                });
            }
        });
    };
}

exports.default = (0, _plugin2.default)([_browsers.IE_5_5, _browsers.IE_6], [_postcss.RULE], function (rule) {
    if ((0, _isMixin2.default)(rule)) {
        return;
    }

    (0, _postcssSelectorParser2.default)(analyse(this, rule)).processSync(rule.selector);
});
module.exports = exports['default'];
},{"../dictionary/browsers":1137,"../dictionary/identifiers":1138,"../dictionary/postcss":1139,"../dictionary/tags":1140,"../exists":1141,"../isMixin":1143,"../plugin":1144,"postcss-selector-parser":1158}],1157:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _plugin = require('../plugin');

var _plugin2 = _interopRequireDefault(_plugin);

var _isMixin = require('../isMixin');

var _isMixin2 = _interopRequireDefault(_isMixin);

var _browsers = require('../dictionary/browsers');

var _identifiers = require('../dictionary/identifiers');

var _postcss = require('../dictionary/postcss');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = (0, _plugin2.default)([_browsers.IE_5_5, _browsers.IE_6, _browsers.IE_7], [_postcss.RULE], function (rule) {
    if ((0, _isMixin2.default)(rule)) {
        return;
    }

    const { selector } = rule;
    const trim = selector.trim();

    if (trim.lastIndexOf(',') === selector.length - 1 || trim.lastIndexOf('\\') === selector.length - 1) {
        this.push(rule, {
            identifier: _identifiers.SELECTOR,
            hack: selector
        });
    }
});
module.exports = exports['default'];
},{"../dictionary/browsers":1137,"../dictionary/identifiers":1138,"../dictionary/postcss":1139,"../isMixin":1143,"../plugin":1144}],1158:[function(require,module,exports){
arguments[4][902][0].apply(exports,arguments)
},{"./processor":1160,"./selectors":1169,"dup":902}],1159:[function(require,module,exports){
arguments[4][903][0].apply(exports,arguments)
},{"./selectors/attribute":1161,"./selectors/className":1162,"./selectors/combinator":1163,"./selectors/comment":1164,"./selectors/id":1168,"./selectors/nesting":1171,"./selectors/pseudo":1173,"./selectors/root":1174,"./selectors/selector":1175,"./selectors/string":1176,"./selectors/tag":1177,"./selectors/types":1178,"./selectors/universal":1179,"./sortAscending":1180,"./tokenTypes":1181,"./tokenize":1182,"dot-prop":685,"dup":903,"indexes-of":727,"uniq":1198}],1160:[function(require,module,exports){
arguments[4][904][0].apply(exports,arguments)
},{"./parser":1159,"dup":904}],1161:[function(require,module,exports){
arguments[4][905][0].apply(exports,arguments)
},{"./namespace":1170,"./types":1178,"dup":905}],1162:[function(require,module,exports){
arguments[4][906][0].apply(exports,arguments)
},{"./namespace":1170,"./types":1178,"dup":906}],1163:[function(require,module,exports){
arguments[4][907][0].apply(exports,arguments)
},{"./node":1172,"./types":1178,"dup":907}],1164:[function(require,module,exports){
arguments[4][908][0].apply(exports,arguments)
},{"./node":1172,"./types":1178,"dup":908}],1165:[function(require,module,exports){
arguments[4][909][0].apply(exports,arguments)
},{"./attribute":1161,"./className":1162,"./combinator":1163,"./comment":1164,"./id":1168,"./nesting":1171,"./pseudo":1173,"./root":1174,"./selector":1175,"./string":1176,"./tag":1177,"./universal":1179,"dup":909}],1166:[function(require,module,exports){
arguments[4][910][0].apply(exports,arguments)
},{"./node":1172,"./types":1178,"dup":910}],1167:[function(require,module,exports){
arguments[4][911][0].apply(exports,arguments)
},{"./types":1178,"dup":911}],1168:[function(require,module,exports){
arguments[4][912][0].apply(exports,arguments)
},{"./namespace":1170,"./types":1178,"dup":912}],1169:[function(require,module,exports){
arguments[4][913][0].apply(exports,arguments)
},{"./constructors":1165,"./guards":1167,"./types":1178,"dup":913}],1170:[function(require,module,exports){
arguments[4][914][0].apply(exports,arguments)
},{"./node":1172,"dup":914}],1171:[function(require,module,exports){
arguments[4][915][0].apply(exports,arguments)
},{"./node":1172,"./types":1178,"dup":915}],1172:[function(require,module,exports){
arguments[4][916][0].apply(exports,arguments)
},{"dup":916}],1173:[function(require,module,exports){
arguments[4][917][0].apply(exports,arguments)
},{"./container":1166,"./types":1178,"dup":917}],1174:[function(require,module,exports){
arguments[4][918][0].apply(exports,arguments)
},{"./container":1166,"./types":1178,"dup":918}],1175:[function(require,module,exports){
arguments[4][919][0].apply(exports,arguments)
},{"./container":1166,"./types":1178,"dup":919}],1176:[function(require,module,exports){
arguments[4][920][0].apply(exports,arguments)
},{"./node":1172,"./types":1178,"dup":920}],1177:[function(require,module,exports){
arguments[4][921][0].apply(exports,arguments)
},{"./namespace":1170,"./types":1178,"dup":921}],1178:[function(require,module,exports){
arguments[4][922][0].apply(exports,arguments)
},{"dup":922}],1179:[function(require,module,exports){
arguments[4][923][0].apply(exports,arguments)
},{"./namespace":1170,"./types":1178,"dup":923}],1180:[function(require,module,exports){
arguments[4][924][0].apply(exports,arguments)
},{"dup":924}],1181:[function(require,module,exports){
arguments[4][925][0].apply(exports,arguments)
},{"dup":925}],1182:[function(require,module,exports){
arguments[4][926][0].apply(exports,arguments)
},{"./tokenTypes":1181,"dup":926}],1183:[function(require,module,exports){
'use strict';

var csstree     = require('css-tree'),
    List        = csstree.List,
    stable      = require('stable'),
    specificity = require('csso/lib/restructure/prepare/specificity');


/**
 * Flatten a CSS AST to a selectors list.
 *
 * @param {Object} cssAst css-tree AST to flatten
 * @return {Array} selectors
 */
function flattenToSelectors(cssAst) {
    var selectors = [];

    csstree.walk(cssAst, {visit: 'Rule', enter: function(node) {
        if (node.type !== 'Rule') {
            return;
        }

        var atrule = this.atrule;
        var rule = node;

        node.prelude.children.each(function(selectorNode, selectorItem) {
            var selector = {
                item: selectorItem,
                atrule: atrule,
                rule: rule,
                pseudos: []
            };

            selectorNode.children.each(function(selectorChildNode, selectorChildItem, selectorChildList) {
                if (selectorChildNode.type === 'PseudoClassSelector' ||
                    selectorChildNode.type === 'PseudoElementSelector') {
                    selector.pseudos.push({
                        item: selectorChildItem,
                        list: selectorChildList
                    });
                }
            });

            selectors.push(selector);
        });
    }});

    return selectors;
}

/**
 * Filter selectors by Media Query.
 *
 * @param {Array} selectors to filter
 * @param {Array} useMqs Array with strings of media queries that should pass (<name> <expression>)
 * @return {Array} Filtered selectors that match the passed media queries
 */
function filterByMqs(selectors, useMqs) {
    return selectors.filter(function(selector) {
        if (selector.atrule === null) {
            return ~useMqs.indexOf('');
        }

        var mqName = selector.atrule.name;
        var mqStr = mqName;
        if (selector.atrule.expression &&
            selector.atrule.expression.children.first().type === 'MediaQueryList') {
            var mqExpr = csstree.generate(selector.atrule.expression);
            mqStr = [mqName, mqExpr].join(' ');
        }

        return ~useMqs.indexOf(mqStr);
    });
}

/**
 * Filter selectors by the pseudo-elements and/or -classes they contain.
 *
 * @param {Array} selectors to filter
 * @param {Array} usePseudos Array with strings of single or sequence of pseudo-elements and/or -classes that should pass
 * @return {Array} Filtered selectors that match the passed pseudo-elements and/or -classes
 */
function filterByPseudos(selectors, usePseudos) {
    return selectors.filter(function(selector) {
        var pseudoSelectorsStr = csstree.generate({
            type: 'Selector',
            children: new List().fromArray(selector.pseudos.map(function(pseudo) {
                return pseudo.item.data;
            }))
        });
        return ~usePseudos.indexOf(pseudoSelectorsStr);
    });
}

/**
 * Remove pseudo-elements and/or -classes from the selectors for proper matching.
 *
 * @param {Array} selectors to clean
 * @return {Array} Selectors without pseudo-elements and/or -classes
 */
function cleanPseudos(selectors) {
    selectors.forEach(function(selector) {
        selector.pseudos.forEach(function(pseudo) {
            pseudo.list.remove(pseudo.item);
        });
    });
}


/**
 * Compares two selector specificities.
 * extracted from https://github.com/keeganstreet/specificity/blob/master/specificity.js#L211
 *
 * @param {Array} aSpecificity Specificity of selector A
 * @param {Array} bSpecificity Specificity of selector B
 * @return {Number} Score of selector specificity A compared to selector specificity B
 */
function compareSpecificity(aSpecificity, bSpecificity) {
    for (var i = 0; i < 4; i += 1) {
        if (aSpecificity[i] < bSpecificity[i]) {
            return -1;
        } else if (aSpecificity[i] > bSpecificity[i]) {
            return 1;
        }
    }

    return 0;
}


/**
 * Compare two simple selectors.
 *
 * @param {Object} aSimpleSelectorNode Simple selector A
 * @param {Object} bSimpleSelectorNode Simple selector B
 * @return {Number} Score of selector A compared to selector B
 */
function compareSimpleSelectorNode(aSimpleSelectorNode, bSimpleSelectorNode) {
    var aSpecificity = specificity(aSimpleSelectorNode),
        bSpecificity = specificity(bSimpleSelectorNode);
    return compareSpecificity(aSpecificity, bSpecificity);
}

function _bySelectorSpecificity(selectorA, selectorB) {
    return compareSimpleSelectorNode(selectorA.item.data, selectorB.item.data);
}


/**
 * Sort selectors stably by their specificity.
 *
 * @param {Array} selectors to be sorted
 * @return {Array} Stable sorted selectors
 */
function sortSelectors(selectors) {
    return stable(selectors, _bySelectorSpecificity);
}


/**
 * Convert a css-tree AST style declaration to CSSStyleDeclaration property.
 *
 * @param {Object} declaration css-tree style declaration
 * @return {Object} CSSStyleDeclaration property
 */
function csstreeToStyleDeclaration(declaration) {
    var propertyName = declaration.property,
        propertyValue = csstree.generate(declaration.value),
        propertyPriority = (declaration.important ? 'important' : '');
    return {
        name: propertyName,
        value: propertyValue,
        priority: propertyPriority
    };
}


/**
 * Gets the CSS string of a style element
 *
 * @param {Object} element style element
 * @return {String|Array} CSS string or empty array if no styles are set
 */
function getCssStr(elem) {
    return elem.content[0].text || elem.content[0].cdata || [];
}

/**
 * Sets the CSS string of a style element
 *
 * @param {Object} element style element
 * @param {String} CSS string to be set
 * @return {Object} reference to field with CSS
 */
function setCssStr(elem, css) {
    // in case of cdata field
    if(elem.content[0].cdata) {
        elem.content[0].cdata = css;
        return elem.content[0].cdata;
    }

    // in case of text field + if nothing was set yet
    elem.content[0].text  = css;
    return elem.content[0].text;
}


module.exports.flattenToSelectors = flattenToSelectors;

module.exports.filterByMqs = filterByMqs;
module.exports.filterByPseudos = filterByPseudos;
module.exports.cleanPseudos = cleanPseudos;

module.exports.compareSpecificity = compareSpecificity;
module.exports.compareSimpleSelectorNode = compareSimpleSelectorNode;

module.exports.sortSelectors = sortSelectors;

module.exports.csstreeToStyleDeclaration = csstreeToStyleDeclaration;

module.exports.getCssStr = getCssStr;
module.exports.setCssStr = setCssStr;

},{"css-tree":564,"csso/lib/restructure/prepare/specificity":673,"stable":1133}],1184:[function(require,module,exports){
'use strict';

/**
 * SVGO is a Nodejs-based tool for optimizing SVG vector graphics files.
 *
 * @see https://github.com/svg/svgo
 *
 * @author Kir Belevich <kir@soulshine.in> (https://github.com/deepsweet)
 * @copyright  2012 Kir Belevich
 * @license MIT https://raw.githubusercontent.com/svg/svgo/master/LICENSE
 */

var CONFIG = require('./svgo/config.js'),
    SVG2JS = require('./svgo/svg2js.js'),
    PLUGINS = require('./svgo/plugins.js'),
    JSAPI = require('./svgo/jsAPI.js'),
    encodeSVGDatauri = require('./svgo/tools.js').encodeSVGDatauri,
    JS2SVG = require('./svgo/js2svg.js');

var SVGO = function(config) {
    this.config = CONFIG(config);
};

SVGO.prototype.optimize = function(svgstr, info) {
    return new Promise((resolve, reject) => {
        if (this.config.error) {
            reject(this.config.error);
            return;
        }

        var config = this.config,
            maxPassCount = config.multipass ? 10 : 1,
            counter = 0,
            prevResultSize = Number.POSITIVE_INFINITY,
            optimizeOnceCallback = (svgjs) => {
                if (svgjs.error) {
                    reject(svgjs.error);
                    return;
                }

                if (++counter < maxPassCount && svgjs.data.length < prevResultSize) {
                    prevResultSize = svgjs.data.length;
                    this._optimizeOnce(svgjs.data, info, optimizeOnceCallback);
                } else {
                    if (config.datauri) {
                        svgjs.data = encodeSVGDatauri(svgjs.data, config.datauri);
                    }
                    if (info && info.path) {
                        svgjs.path = info.path;
                    }
                    resolve(svgjs);
                }
            };

        this._optimizeOnce(svgstr, info, optimizeOnceCallback);
    });
};

SVGO.prototype._optimizeOnce = function(svgstr, info, callback) {
    var config = this.config;

    SVG2JS(svgstr, function(svgjs) {
        if (svgjs.error) {
            callback(svgjs);
            return;
        }

        svgjs = PLUGINS(svgjs, info, config.plugins);

        callback(JS2SVG(svgjs, config.js2svg));
    });
};

/**
 * The factory that creates a content item with the helper methods.
 *
 * @param {Object} data which passed to jsAPI constructor
 * @returns {JSAPI} content item
 */
SVGO.prototype.createContentItem = function(data) {
    return new JSAPI(data);
};

module.exports = SVGO;
// Offer ES module interop compatibility.
module.exports.default = SVGO;

},{"./svgo/config.js":1185,"./svgo/js2svg.js":1189,"./svgo/jsAPI.js":1190,"./svgo/plugins.js":1191,"./svgo/svg2js.js":1192,"./svgo/tools.js":1193}],1185:[function(require,module,exports){
(function (__dirname){
'use strict';

var FS = require('fs');
var yaml = require('js-yaml');

/**
 * Read and/or extend/replace default config file,
 * prepare and optimize plugins array.
 *
 * @param {Object} [config] input config
 * @return {Object} output config
 */
module.exports = function(config) {

    var defaults;
    config = typeof config == 'object' && config || {};

    if (config.plugins && !Array.isArray(config.plugins)) {
        return { error: 'Error: Invalid plugins list. Provided \'plugins\' in config should be an array.' };
    }

    if (config.full) {
        defaults = config;

        if (Array.isArray(defaults.plugins)) {
            defaults.plugins = preparePluginsArray(defaults.plugins);
        }
    } else {
        defaults = Object.assign({}, yaml.safeLoad(FS.readFileSync(__dirname + '/../../.svgo.yml', 'utf8')));
        defaults.plugins = preparePluginsArray(defaults.plugins || []);
        defaults = extendConfig(defaults, config);
    }

    if ('floatPrecision' in config && Array.isArray(defaults.plugins)) {
        defaults.plugins.forEach(function(plugin) {
            if (plugin.params && ('floatPrecision' in plugin.params)) {
                // Don't touch default plugin params
                plugin.params = Object.assign({}, plugin.params, { floatPrecision: config.floatPrecision });
            }
        });
    }

    if ('datauri' in config) {
        defaults.datauri = config.datauri;
    }

    if (Array.isArray(defaults.plugins)) {
        defaults.plugins = optimizePluginsArray(defaults.plugins);
    }

    return defaults;

};

/**
 * Require() all plugins in array.
 *
 * @param {Array} plugins input plugins array
 * @return {Array} input plugins array of arrays
 */
function preparePluginsArray(plugins) {

    var plugin,
        key;

    return plugins.map(function(item) {

        // {}
        if (typeof item === 'object') {

            key = Object.keys(item)[0];

            // custom
            if (typeof item[key] === 'object' && item[key].fn && typeof item[key].fn === 'function') {
                plugin = setupCustomPlugin(key, item[key]);

            } else {

              plugin = Object.assign({}, require('../../plugins/' + key));

              // name: {}
              if (typeof item[key] === 'object') {
                  plugin.params = Object.assign({}, plugin.params || {}, item[key]);
                  plugin.active = true;

              // name: false
              } else if (item[key] === false) {
                 plugin.active = false;

              // name: true
              } else if (item[key] === true) {
                 plugin.active = true;
              }

              plugin.name = key;
            }

        // name
        } else {

            plugin = Object.assign({}, require('../../plugins/' + item));
            plugin.name = item;

        }

        return plugin;

    });

}

/**
 * Extend plugins with the custom config object.
 *
 * @param {Array} plugins input plugins
 * @param {Object} config config
 * @return {Array} output plugins
 */
function extendConfig(defaults, config) {

    var key;

    // plugins
    if (config.plugins) {

        config.plugins.forEach(function(item) {

            // {}
            if (typeof item === 'object') {

                key = Object.keys(item)[0];

                // custom
                if (typeof item[key] === 'object' && item[key].fn && typeof item[key].fn === 'function') {
                    defaults.plugins.push(setupCustomPlugin(key, item[key]));

                } else {
                    defaults.plugins.forEach(function(plugin) {

                        if (plugin.name === key) {
                            // name: {}
                            if (typeof item[key] === 'object') {
                                plugin.params = Object.assign({}, plugin.params || {}, item[key]);
                                plugin.active = true;

                            // name: false
                            } else if (item[key] === false) {
                               plugin.active = false;

                            // name: true
                            } else if (item[key] === true) {
                               plugin.active = true;
                            }
                        }
                    });
                }

            }

        });

    }

    defaults.multipass = config.multipass;

    // svg2js
    if (config.svg2js) {
        defaults.svg2js = config.svg2js;
    }

    // js2svg
    if (config.js2svg) {
        defaults.js2svg = config.js2svg;
    }

    return defaults;

}

/**
 * Setup and enable a custom plugin
 *
 * @param {String} plugin name
 * @param {Object} custom plugin
 * @return {Array} enabled plugin
 */
function setupCustomPlugin(name, plugin) {
    plugin.active = true;
    plugin.params = Object.assign({}, plugin.params || {});
    plugin.name = name;

    return plugin;
}

/**
 * Try to group sequential elements of plugins array.
 *
 * @param {Object} plugins input plugins
 * @return {Array} output plugins
 */
function optimizePluginsArray(plugins) {

    var prev;

    return plugins.reduce(function(plugins, item) {
        if (prev && item.type == prev[0].type) {
            prev.push(item);
        } else {
            plugins.push(prev = [item]);
        }
        return plugins;
    }, []);

}

}).call(this,"/node_modules/svgo/lib/svgo")
},{"fs":8,"js-yaml":753}],1186:[function(require,module,exports){
'use strict';

var values = require('object.values');
if (!Object.values) {
    values.shim();
}


var CSSClassList = function(node) {
    this.parentNode = node;
    this.classNames = new Set();
    this.classAttr = null;
    //this.classValue = null;
};

/**
 * Performs a deep clone of this object.
 *
 * @param parentNode the parentNode to assign to the cloned result
 */
CSSClassList.prototype.clone = function(parentNode) {
    var node = this;
    var nodeData = {};

    Object.keys(node).forEach(function(key) {
        if (key !== 'parentNode') {
            nodeData[key] = node[key];
        }
    });

    // Deep-clone node data.
    nodeData = JSON.parse(JSON.stringify(nodeData));

    var clone = new CSSClassList(parentNode);
   Object.assign(clone, nodeData);
    return clone;
};

CSSClassList.prototype.hasClass = function() {
    this.classAttr = { // empty class attr
        'name': 'class',
        'value': null
    };

    this.addClassHandler();
};


// attr.class

CSSClassList.prototype.addClassHandler = function() {

    Object.defineProperty(this.parentNode.attrs, 'class', {
        get: this.getClassAttr.bind(this),
        set: this.setClassAttr.bind(this),
        enumerable: true,
        configurable: true
    });

    this.addClassValueHandler();
};

// attr.class.value

CSSClassList.prototype.addClassValueHandler = function() {

    Object.defineProperty(this.classAttr, 'value', {
        get: this.getClassValue.bind(this),
        set: this.setClassValue.bind(this),
        enumerable: true,
        configurable: true
    });
};

CSSClassList.prototype.getClassAttr = function() {
    return this.classAttr;
};

CSSClassList.prototype.setClassAttr = function(newClassAttr) {
    this.setClassValue(newClassAttr.value); // must before applying value handler!

    this.classAttr = newClassAttr;
    this.addClassValueHandler();
};

CSSClassList.prototype.getClassValue = function() {
    var arrClassNames = Array.from(this.classNames);
    return arrClassNames.join(' ');
};

CSSClassList.prototype.setClassValue = function(newValue) {
    if(typeof newValue === 'undefined') {
      this.classNames.clear();
      return;
    }
    var arrClassNames = newValue.split(' ');
    this.classNames = new Set(arrClassNames);
};


CSSClassList.prototype.add = function(/* variadic */) {
    this.hasClass();
    Object.values(arguments).forEach(this._addSingle.bind(this));
};

CSSClassList.prototype._addSingle = function(className) {
    this.classNames.add(className);
};


CSSClassList.prototype.remove = function(/* variadic */) {
    this.hasClass();
    Object.values(arguments).forEach(this._removeSingle.bind(this));
};

CSSClassList.prototype._removeSingle = function(className) {
    this.classNames.delete(className);
};


CSSClassList.prototype.item = function(index) {
    var arrClassNames = Array.from(this.classNames);
    return arrClassNames[index];
};

CSSClassList.prototype.toggle = function(className, force) {
    if(this.contains(className) || force === false) {
        this.classNames.delete(className);
    }
    this.classNames.add(className);
};

CSSClassList.prototype.contains = function(className) {
    return this.classNames.has(className);
};


module.exports = CSSClassList;
},{"object.values":797}],1187:[function(require,module,exports){
'use strict';

var baseCssAdapter = require('css-select-base-adapter');

/**
 * DOMUtils API for SVGO AST (used by css-select)
 */
var svgoCssSelectAdapterMin = {

    // is the node a tag?
    // isTag: ( node:Node ) => isTag:Boolean
    isTag: function(node) {
        return node.isElem();
    },

    // get the parent of the node
    // getParent: ( node:Node ) => parentNode:Node
    // returns null when no parent exists
    getParent: function(node) {
        return node.parentNode || null;
    },

    // get the node's children
    // getChildren: ( node:Node ) => children:[Node]
    getChildren: function(node) {
        return node.content || [];
    },

    // get the name of the tag
    // getName: ( elem:ElementNode ) => tagName:String
    getName: function(elemAst) {
        return elemAst.elem;
    },

    // get the text content of the node, and its children if it has any
    // getText: ( node:Node ) => text:String
    // returns empty string when there is no text
    getText: function(node) {
        return node.content[0].text || node.content[0].cdata || '';
    },

    // get the attribute value
    // getAttributeValue: ( elem:ElementNode, name:String ) => value:String
    // returns null when attribute doesn't exist
    getAttributeValue: function(elem, name) {
        return elem.hasAttr(name) ? elem.attr(name).value : null;
    }
};

// use base adapter for default implementation
var svgoCssSelectAdapter = baseCssAdapter(svgoCssSelectAdapterMin);

module.exports = svgoCssSelectAdapter;

},{"css-select-base-adapter":552}],1188:[function(require,module,exports){
'use strict';

var csstree = require('css-tree'),
    csstools = require('../css-tools');


var CSSStyleDeclaration = function(node) {
    this.parentNode = node;

    this.properties = new Map();
    this.hasSynced = false;

    this.styleAttr = null;
    this.styleValue = null;

    this.parseError = false;
};

/**
 * Performs a deep clone of this object.
 *
 * @param parentNode the parentNode to assign to the cloned result
 */
CSSStyleDeclaration.prototype.clone = function(parentNode) {
    var node = this;
    var nodeData = {};

    Object.keys(node).forEach(function(key) {
        if (key !== 'parentNode') {
            nodeData[key] = node[key];
        }
    });

    // Deep-clone node data.
    nodeData = JSON.parse(JSON.stringify(nodeData));

    var clone = new CSSStyleDeclaration(parentNode);
    Object.assign(clone, nodeData);
    return clone;
};

CSSStyleDeclaration.prototype.hasStyle = function() {
    this.addStyleHandler();
};




// attr.style

CSSStyleDeclaration.prototype.addStyleHandler = function() {

    this.styleAttr = { // empty style attr
        'name': 'style',
        'value': null
    };

    Object.defineProperty(this.parentNode.attrs, 'style', {
        get: this.getStyleAttr.bind(this),
        set: this.setStyleAttr.bind(this),
        enumerable: true,
        configurable: true
    });

    this.addStyleValueHandler();
};

// attr.style.value

CSSStyleDeclaration.prototype.addStyleValueHandler = function() {

    Object.defineProperty(this.styleAttr, 'value', {
        get: this.getStyleValue.bind(this),
        set: this.setStyleValue.bind(this),
        enumerable: true,
        configurable: true
    });
};

CSSStyleDeclaration.prototype.getStyleAttr = function() {
    return this.styleAttr;
};

CSSStyleDeclaration.prototype.setStyleAttr = function(newStyleAttr) {
    this.setStyleValue(newStyleAttr.value); // must before applying value handler!

    this.styleAttr = newStyleAttr;
    this.addStyleValueHandler();
    this.hasSynced = false; // raw css changed
};

CSSStyleDeclaration.prototype.getStyleValue = function() {
    return this.getCssText();
};

CSSStyleDeclaration.prototype.setStyleValue = function(newValue) {
    this.properties.clear(); // reset all existing properties
    this.styleValue = newValue;
    this.hasSynced = false; // raw css changed
};




CSSStyleDeclaration.prototype._loadCssText = function() {
    if (this.hasSynced) {
        return;
    }
    this.hasSynced = true; // must be set here to prevent loop in setProperty(...)

    if (!this.styleValue || this.styleValue.length === 0) {
        return;
    }
    var inlineCssStr = this.styleValue;

    var declarations = {};
    try {
        declarations = csstree.parse(inlineCssStr, {
            context: 'declarationList',
            parseValue: false
        });
    } catch (parseError) {
        this.parseError = parseError;
        return;
    }
    this.parseError = false;

    var self = this;
    declarations.children.each(function(declaration) {
        try {
          var styleDeclaration = csstools.csstreeToStyleDeclaration(declaration);
          self.setProperty(styleDeclaration.name, styleDeclaration.value, styleDeclaration.priority);
        } catch(styleError) {
            if(styleError.message !== 'Unknown node type: undefined') {
                self.parseError = styleError;
            }
        }
    });
};


// only reads from properties

/**
 * Get the textual representation of the declaration block (equivalent to .cssText attribute).
 *
 * @return {String} Textual representation of the declaration block (empty string for no properties)
 */
CSSStyleDeclaration.prototype.getCssText = function() {
    var properties = this.getProperties();

    if (this.parseError) {
        // in case of a parse error, pass through original styles
        return this.styleValue;
    }

    var cssText = [];
    properties.forEach(function(property, propertyName) {
        var strImportant = property.priority === 'important' ? '!important' : '';
        cssText.push(propertyName.trim() + ':' + property.value.trim() + strImportant);
    });
    return cssText.join(';');
};

CSSStyleDeclaration.prototype._handleParseError = function() {
    if (this.parseError) {
        console.warn('Warning: Parse error when parsing inline styles, style properties of this element cannot be used. The raw styles can still be get/set using .attr(\'style\').value. Error details: ' + this.parseError);
    }
};


CSSStyleDeclaration.prototype._getProperty = function(propertyName) {
    if(typeof propertyName === 'undefined') {
        throw Error('1 argument required, but only 0 present.');
    }

    var properties = this.getProperties();
    this._handleParseError();

    var property = properties.get(propertyName.trim());
    return property;
};

/**
 * Return the optional priority, "important".
 *
 * @param {String} propertyName representing the property name to be checked.
 * @return {String} priority that represents the priority (e.g. "important") if one exists. If none exists, returns the empty string.
 */
CSSStyleDeclaration.prototype.getPropertyPriority = function(propertyName) {
    var property = this._getProperty(propertyName);
    return property ? property.priority : '';
};

/**
 * Return the property value given a property name.
 *
 * @param {String} propertyName representing the property name to be checked.
 * @return {String} value containing the value of the property. If not set, returns the empty string.
 */
CSSStyleDeclaration.prototype.getPropertyValue = function(propertyName) {
    var property = this._getProperty(propertyName);
    return property ? property.value : null;
};

/**
 * Return a property name.
 *
 * @param {Number} index of the node to be fetched. The index is zero-based.
 * @return {String} propertyName that is the name of the CSS property at the specified index.
 */
CSSStyleDeclaration.prototype.item = function(index) {
    if(typeof index === 'undefined') {
        throw Error('1 argument required, but only 0 present.');
    }

    var properties = this.getProperties();
    this._handleParseError();

    return Array.from(properties.keys())[index];
};

/**
 * Return all properties of the node.
 *
 * @return {Map} properties that is a Map with propertyName as key and property (propertyValue + propertyPriority) as value.
 */
CSSStyleDeclaration.prototype.getProperties = function() {
    this._loadCssText();
    return this.properties;
};


// writes to properties

/**
 * Remove a property from the CSS declaration block.
 *
 * @param {String} propertyName representing the property name to be removed.
 * @return {String} oldValue equal to the value of the CSS property before it was removed.
 */
CSSStyleDeclaration.prototype.removeProperty = function(propertyName) {
    if(typeof propertyName === 'undefined') {
        throw Error('1 argument required, but only 0 present.');
    }

    this.hasStyle();

    var properties = this.getProperties();
    this._handleParseError();

    var oldValue = this.getPropertyValue(propertyName);
    properties.delete(propertyName.trim());
    return oldValue;
};

/**
 * Modify an existing CSS property or creates a new CSS property in the declaration block.
 *
 * @param {String} propertyName representing the CSS property name to be modified.
 * @param {String} [value] containing the new property value. If not specified, treated as the empty string. value must not contain "!important" -- that should be set using the priority parameter.
 * @param {String} [priority] allowing the "important" CSS priority to be set. If not specified, treated as the empty string.
 * @return {undefined}
 */
CSSStyleDeclaration.prototype.setProperty = function(propertyName, value, priority) {
    if(typeof propertyName === 'undefined') {
        throw Error('propertyName argument required, but only not present.');
    }

    this.hasStyle();

    var properties = this.getProperties();
    this._handleParseError();

    var property = {
        value: value.trim(),
        priority: priority.trim()
    };
    properties.set(propertyName.trim(), property);

    return property;
};


module.exports = CSSStyleDeclaration;

},{"../css-tools":1183,"css-tree":564}],1189:[function(require,module,exports){
'use strict';

var EOL = require('os').EOL,
    textElem = require('../../plugins/_collections.js').elemsGroups.textContent.concat('title');

var defaults = {
    doctypeStart: '<!DOCTYPE',
    doctypeEnd: '>',
    procInstStart: '<?',
    procInstEnd: '?>',
    tagOpenStart: '<',
    tagOpenEnd: '>',
    tagCloseStart: '</',
    tagCloseEnd: '>',
    tagShortStart: '<',
    tagShortEnd: '/>',
    attrStart: '="',
    attrEnd: '"',
    commentStart: '<!--',
    commentEnd: '-->',
    cdataStart: '<![CDATA[',
    cdataEnd: ']]>',
    textStart: '',
    textEnd: '',
    indent: 4,
    regEntities: /[&'"<>]/g,
    regValEntities: /[&"<>]/g,
    encodeEntity: encodeEntity,
    pretty: false,
    useShortTags: true
};

var entities = {
      '&': '&amp;',
      '\'': '&apos;',
      '"': '&quot;',
      '>': '&gt;',
      '<': '&lt;',
    };

/**
 * Convert SVG-as-JS object to SVG (XML) string.
 *
 * @param {Object} data input data
 * @param {Object} config config
 *
 * @return {Object} output data
 */
module.exports = function(data, config) {

    return new JS2SVG(config).convert(data);

};

function JS2SVG(config) {

    if (config) {
        this.config = Object.assign({}, defaults, config);
    } else {
        this.config = Object.assign({}, defaults);
    }

    var indent = this.config.indent;
    if (typeof indent == 'number' && !isNaN(indent)) {
        this.config.indent = (indent < 0) ? '\t' : ' '.repeat(indent);
    } else if (typeof indent != 'string') {
        this.config.indent = '    ';
    }

    if (this.config.pretty) {
        this.config.doctypeEnd += EOL;
        this.config.procInstEnd += EOL;
        this.config.commentEnd += EOL;
        this.config.cdataEnd += EOL;
        this.config.tagShortEnd += EOL;
        this.config.tagOpenEnd += EOL;
        this.config.tagCloseEnd += EOL;
        this.config.textEnd += EOL;
    }

    this.indentLevel = 0;
    this.textContext = null;

}

function encodeEntity(char) {
    return entities[char];
}

/**
 * Start conversion.
 *
 * @param {Object} data input data
 *
 * @return {String}
 */
JS2SVG.prototype.convert = function(data) {

    var svg = '';

    if (data.content) {

        this.indentLevel++;

        data.content.forEach(function(item) {

            if (item.elem) {
               svg += this.createElem(item);
            } else if (item.text) {
               svg += this.createText(item.text);
            } else if (item.doctype) {
                svg += this.createDoctype(item.doctype);
            } else if (item.processinginstruction) {
                svg += this.createProcInst(item.processinginstruction);
            } else if (item.comment) {
                svg += this.createComment(item.comment);
            } else if (item.cdata) {
                svg += this.createCDATA(item.cdata);
            }

        }, this);

    }

    this.indentLevel--;

    return {
        data: svg,
        info: {
            width: this.width,
            height: this.height
        }
    };

};

/**
 * Create indent string in accordance with the current node level.
 *
 * @return {String}
 */
JS2SVG.prototype.createIndent = function() {

    var indent = '';

    if (this.config.pretty && !this.textContext) {
        indent = this.config.indent.repeat(this.indentLevel - 1);
    }

    return indent;

};

/**
 * Create doctype tag.
 *
 * @param {String} doctype doctype body string
 *
 * @return {String}
 */
JS2SVG.prototype.createDoctype = function(doctype) {

    return  this.config.doctypeStart +
            doctype +
            this.config.doctypeEnd;

};

/**
 * Create XML Processing Instruction tag.
 *
 * @param {Object} instruction instruction object
 *
 * @return {String}
 */
JS2SVG.prototype.createProcInst = function(instruction) {

    return  this.config.procInstStart +
            instruction.name +
            ' ' +
            instruction.body +
            this.config.procInstEnd;

};

/**
 * Create comment tag.
 *
 * @param {String} comment comment body
 *
 * @return {String}
 */
JS2SVG.prototype.createComment = function(comment) {

    return  this.config.commentStart +
            comment +
            this.config.commentEnd;

};

/**
 * Create CDATA section.
 *
 * @param {String} cdata CDATA body
 *
 * @return {String}
 */
JS2SVG.prototype.createCDATA = function(cdata) {

    return  this.createIndent() +
            this.config.cdataStart +
            cdata +
            this.config.cdataEnd;

};

/**
 * Create element tag.
 *
 * @param {Object} data element object
 *
 * @return {String}
 */
JS2SVG.prototype.createElem = function(data) {

    // beautiful injection for obtaining SVG information :)
    if (
        data.isElem('svg') &&
        data.hasAttr('width') &&
        data.hasAttr('height')
    ) {
        this.width = data.attr('width').value;
        this.height = data.attr('height').value;
    }

    // empty element and short tag
    if (data.isEmpty()) {
        if (this.config.useShortTags) {
            return this.createIndent() +
                   this.config.tagShortStart +
                   data.elem +
                   this.createAttrs(data) +
                   this.config.tagShortEnd;
        } else {
            return this.createIndent() +
                   this.config.tagShortStart +
                   data.elem +
                   this.createAttrs(data) +
                   this.config.tagOpenEnd +
                   this.config.tagCloseStart +
                   data.elem +
                   this.config.tagCloseEnd;
        }
    // non-empty element
    } else {
        var tagOpenStart = this.config.tagOpenStart,
            tagOpenEnd = this.config.tagOpenEnd,
            tagCloseStart = this.config.tagCloseStart,
            tagCloseEnd = this.config.tagCloseEnd,
            openIndent = this.createIndent(),
            textIndent = '',
            processedData = '',
            dataEnd = '';

        if (this.textContext) {
            tagOpenStart = defaults.tagOpenStart;
            tagOpenEnd = defaults.tagOpenEnd;
            tagCloseStart = defaults.tagCloseStart;
            tagCloseEnd = defaults.tagCloseEnd;
            openIndent = '';
        } else if (data.isElem(textElem)) {
            if (this.config.pretty) {
                textIndent += openIndent + this.config.indent;
            }
            this.textContext = data;
        }

        processedData += this.convert(data).data;

        if (this.textContext == data) {
            this.textContext = null;
            if (this.config.pretty) dataEnd = EOL;
        }

        return  openIndent +
                tagOpenStart +
                data.elem +
                this.createAttrs(data) +
                tagOpenEnd +
                textIndent +
                processedData +
                dataEnd +
                this.createIndent() +
                tagCloseStart +
                data.elem +
                tagCloseEnd;

    }

};

/**
 * Create element attributes.
 *
 * @param {Object} elem attributes object
 *
 * @return {String}
 */
JS2SVG.prototype.createAttrs = function(elem) {

    var attrs = '';

    elem.eachAttr(function(attr) {

        if (attr.value !== undefined) {
            attrs +=    ' ' +
                        attr.name +
                        this.config.attrStart +
                        String(attr.value).replace(this.config.regValEntities, this.config.encodeEntity) +
                        this.config.attrEnd;
        }
        else {
            attrs +=    ' ' +
                        attr.name;
        }


    }, this);

    return attrs;

};

/**
 * Create text node.
 *
 * @param {String} text text
 *
 * @return {String}
 */
JS2SVG.prototype.createText = function(text) {

    return  this.createIndent() +
            this.config.textStart +
            text.replace(this.config.regEntities, this.config.encodeEntity) +
            (this.textContext ? '' : this.config.textEnd);

};

},{"../../plugins/_collections.js":1194,"os":800}],1190:[function(require,module,exports){
'use strict';

var cssSelect = require('css-select');

var svgoCssSelectAdapter = require('./css-select-adapter');
var cssSelectOpts = {
  xmlMode: true,
  adapter: svgoCssSelectAdapter
};

var JSAPI = module.exports = function(data, parentNode) {
    Object.assign(this, data);
    if (parentNode) {
        Object.defineProperty(this, 'parentNode', {
            writable: true,
            value: parentNode
        });
    }
};

/**
 * Perform a deep clone of this node.
 *
 * @return {Object} element
 */
JSAPI.prototype.clone = function() {
    var node = this;
    var nodeData = {};

    Object.keys(node).forEach(function(key) {
        if (key !== 'class' && key !== 'style' && key !== 'content') {
            nodeData[key] = node[key];
        }
    });

    // Deep-clone node data.
    nodeData = JSON.parse(JSON.stringify(nodeData));

    // parentNode gets set to a proper object by the parent clone,
    // but it needs to be true/false now to do the right thing
    // in the constructor.
    var clonedNode = new JSAPI(nodeData, !!node.parentNode);

    if (node.class) {
        clonedNode.class = node.class.clone(clonedNode);
    }
    if (node.style) {
        clonedNode.style = node.style.clone(clonedNode);
    }
    if (node.content) {
        clonedNode.content = node.content.map(function(childNode) {
            var clonedChild = childNode.clone();
            clonedChild.parentNode = clonedNode;
            return clonedChild;
        });
    }

    return clonedNode;
};

/**
 * Determine if item is an element
 * (any, with a specific name or in a names array).
 *
 * @param {String|Array} [param] element name or names arrays
 * @return {Boolean}
 */
JSAPI.prototype.isElem = function(param) {

    if (!param) return !!this.elem;

    if (Array.isArray(param)) return !!this.elem && (param.indexOf(this.elem) > -1);

    return !!this.elem && this.elem === param;

};

/**
 * Renames an element
 *
 * @param {String} name new element name
 * @return {Object} element
 */
JSAPI.prototype.renameElem = function(name) {

    if (name && typeof name === 'string')
        this.elem = this.local = name;

    return this;

};

/**
 * Determine if element is empty.
 *
 * @return {Boolean}
 */
 JSAPI.prototype.isEmpty = function() {

    return !this.content || !this.content.length;

};

/**
 * Find the closest ancestor of the current element.
 * @param elemName
 *
 * @return {?Object}
 */
 JSAPI.prototype.closestElem = function(elemName) {
    var elem = this;

    while ((elem = elem.parentNode) && !elem.isElem(elemName));

    return elem;
};

/**
 * Changes content by removing elements and/or adding new elements.
 *
 * @param {Number} start Index at which to start changing the content.
 * @param {Number} n Number of elements to remove.
 * @param {Array|Object} [insertion] Elements to add to the content.
 * @return {Array} Removed elements.
 */
 JSAPI.prototype.spliceContent = function(start, n, insertion) {

    if (arguments.length < 2) return [];

    if (!Array.isArray(insertion))
        insertion = Array.apply(null, arguments).slice(2);

    insertion.forEach(function(inner) { inner.parentNode = this }, this);

    return this.content.splice.apply(this.content, [start, n].concat(insertion));


};

/**
 * Determine if element has an attribute
 * (any, or by name or by name + value).
 *
 * @param {String} [name] attribute name
 * @param {String} [val] attribute value (will be toString()'ed)
 * @return {Boolean}
 */
 JSAPI.prototype.hasAttr = function(name, val) {

    if (!this.attrs || !Object.keys(this.attrs).length) return false;

    if (!arguments.length) return !!this.attrs;

    if (val !== undefined) return !!this.attrs[name] && this.attrs[name].value === val.toString();

    return !!this.attrs[name];

};

/**
 * Determine if element has an attribute by local name
 * (any, or by name or by name + value).
 *
 * @param {String} [localName] local attribute name
 * @param {Number|String|RegExp|Function} [val] attribute value (will be toString()'ed or executed, otherwise ignored)
 * @return {Boolean}
 */
 JSAPI.prototype.hasAttrLocal = function(localName, val) {

    if (!this.attrs || !Object.keys(this.attrs).length) return false;

    if (!arguments.length) return !!this.attrs;

    var callback;

    switch (val != null && val.constructor && val.constructor.name) {
        case 'Number':   // same as String
        case 'String':   callback = stringValueTest; break;
        case 'RegExp':   callback = regexpValueTest; break;
        case 'Function': callback = funcValueTest; break;
        default:         callback = nameTest;
    }
    return this.someAttr(callback);

    function nameTest(attr) {
        return attr.local === localName;
    }

    function stringValueTest(attr) {
        return attr.local === localName && val == attr.value;
    }

    function regexpValueTest(attr) {
        return attr.local === localName && val.test(attr.value);
    }

    function funcValueTest(attr) {
        return attr.local === localName && val(attr.value);
    }

};

/**
 * Get a specific attribute from an element
 * (by name or name + value).
 *
 * @param {String} name attribute name
 * @param {String} [val] attribute value (will be toString()'ed)
 * @return {Object|Undefined}
 */
 JSAPI.prototype.attr = function(name, val) {

    if (!this.hasAttr() || !arguments.length) return undefined;

    if (val !== undefined) return this.hasAttr(name, val) ? this.attrs[name] : undefined;

    return this.attrs[name];

};

/**
 * Get computed attribute value from an element
 *
 * @param {String} name attribute name
 * @return {Object|Undefined}
 */
 JSAPI.prototype.computedAttr = function(name, val) {
    /* jshint eqnull: true */
    if (!arguments.length) return;

    for (var elem = this; elem && (!elem.hasAttr(name) || !elem.attr(name).value); elem = elem.parentNode);

    if (val != null) {
        return elem ? elem.hasAttr(name, val) : false;
    } else if (elem && elem.hasAttr(name)) {
        return elem.attrs[name].value;
    }

};

/**
 * Remove a specific attribute.
 *
 * @param {String|Array} name attribute name
 * @param {String} [val] attribute value
 * @return {Boolean}
 */
 JSAPI.prototype.removeAttr = function(name, val, recursive) {

    if (!arguments.length) return false;

    if (Array.isArray(name)) {
        name.forEach(this.removeAttr, this);
        return false;
    }

    if (!this.hasAttr(name)) return false;

    if (!recursive && val && this.attrs[name].value !== val) return false;

    delete this.attrs[name];

    if (!Object.keys(this.attrs).length) delete this.attrs;

    return true;

};

/**
 * Add attribute.
 *
 * @param {Object} [attr={}] attribute object
 * @return {Object|Boolean} created attribute or false if no attr was passed in
 */
 JSAPI.prototype.addAttr = function(attr) {
    attr = attr || {};

    if (attr.name === undefined ||
        attr.prefix === undefined ||
        attr.local === undefined
    ) return false;

    this.attrs = this.attrs || {};
    this.attrs[attr.name] = attr;

    if(attr.name === 'class') { // newly added class attribute
        this.class.hasClass();
    }

    if(attr.name === 'style') { // newly added style attribute
        this.style.hasStyle();
    }

    return this.attrs[attr.name];

};

/**
 * Iterates over all attributes.
 *
 * @param {Function} callback callback
 * @param {Object} [context] callback context
 * @return {Boolean} false if there are no any attributes
 */
 JSAPI.prototype.eachAttr = function(callback, context) {

    if (!this.hasAttr()) return false;

    for (var name in this.attrs) {
        callback.call(context, this.attrs[name]);
    }

    return true;

};

/**
 * Tests whether some attribute passes the test.
 *
 * @param {Function} callback callback
 * @param {Object} [context] callback context
 * @return {Boolean} false if there are no any attributes
 */
 JSAPI.prototype.someAttr = function(callback, context) {

    if (!this.hasAttr()) return false;

    for (var name in this.attrs) {
        if (callback.call(context, this.attrs[name])) return true;
    }

    return false;

};

/**
 * Evaluate a string of CSS selectors against the element and returns matched elements.
 *
 * @param {String} selectors CSS selector(s) string
 * @return {Array} null if no elements matched
 */
 JSAPI.prototype.querySelectorAll = function(selectors) {

   var matchedEls = cssSelect(selectors, this, cssSelectOpts);

   return matchedEls.length > 0 ? matchedEls : null;

};

/**
 * Evaluate a string of CSS selectors against the element and returns only the first matched element.
 *
 * @param {String} selectors CSS selector(s) string
 * @return {Array} null if no element matched
 */
 JSAPI.prototype.querySelector = function(selectors) {

   return cssSelect.selectOne(selectors, this, cssSelectOpts);

};

/**
 * Test if a selector matches a given element.
 *
 * @param {String} selector CSS selector string
 * @return {Boolean} true if element would be selected by selector string, false if it does not
 */
 JSAPI.prototype.matches = function(selector) {

   return cssSelect.is(this, selector, cssSelectOpts);

};

},{"./css-select-adapter":1187,"css-select":553}],1191:[function(require,module,exports){
'use strict';

/**
 * Plugins engine.
 *
 * @module plugins
 *
 * @param {Object} data input data
 * @param {Object} info extra information
 * @param {Object} plugins plugins object from config
 * @return {Object} output data
 */
module.exports = function(data, info, plugins) {

    plugins.forEach(function(group) {

        switch(group[0].type) {
            case 'perItem':
                data = perItem(data, info, group);
                break;
            case 'perItemReverse':
                data = perItem(data, info, group, true);
                break;
            case 'full':
                data = full(data, info, group);
                break;
        }

    });

    return data;

};

/**
 * Direct or reverse per-item loop.
 *
 * @param {Object} data input data
 * @param {Object} info extra information
 * @param {Array} plugins plugins list to process
 * @param {Boolean} [reverse] reverse pass?
 * @return {Object} output data
 */
function perItem(data, info, plugins, reverse) {

    function monkeys(items) {

        items.content = items.content.filter(function(item) {

            // reverse pass
            if (reverse && item.content) {
                monkeys(item);
            }

            // main filter
            var filter = true;

            for (var i = 0; filter && i < plugins.length; i++) {
                var plugin = plugins[i];

                if (plugin.active && plugin.fn(item, plugin.params, info) === false) {
                    filter = false;
                }
            }

            // direct pass
            if (!reverse && item.content) {
                monkeys(item);
            }

            return filter;

        });

        return items;

    }

    return monkeys(data);

}

/**
 * "Full" plugins.
 *
 * @param {Object} data input data
 * @param {Object} info extra information
 * @param {Array} plugins plugins list to process
 * @return {Object} output data
 */
function full(data, info, plugins) {

    plugins.forEach(function(plugin) {
        if (plugin.active) {
            data = plugin.fn(data, plugin.params, info);
        }
    });

    return data;

}

},{}],1192:[function(require,module,exports){
'use strict';

var SAX = require('sax'),
    JSAPI = require('./jsAPI.js'),
    CSSClassList = require('./css-class-list'),
    CSSStyleDeclaration = require('./css-style-declaration'),
    entityDeclaration = /<!ENTITY\s+(\S+)\s+(?:'([^\']+)'|"([^\"]+)")\s*>/g;

var config = {
    strict: true,
    trim: false,
    normalize: true,
    lowercase: true,
    xmlns: true,
    position: true
};

/**
 * Convert SVG (XML) string to SVG-as-JS object.
 *
 * @param {String} data input data
 * @param {Function} callback
 */
module.exports = function(data, callback) {

    var sax = SAX.parser(config.strict, config),
        root = new JSAPI({ elem: '#document', content: [] }),
        current = root,
        stack = [root],
        textContext = null,
        parsingError = false;

    function pushToContent(content) {

        content = new JSAPI(content, current);

        (current.content = current.content || []).push(content);

        return content;

    }

    sax.ondoctype = function(doctype) {

        pushToContent({
            doctype: doctype
        });

        var subsetStart = doctype.indexOf('['),
            entityMatch;

        if (subsetStart >= 0) {
            entityDeclaration.lastIndex = subsetStart;

            while ((entityMatch = entityDeclaration.exec(data)) != null) {
                sax.ENTITIES[entityMatch[1]] = entityMatch[2] || entityMatch[3];
            }
        }
    };

    sax.onprocessinginstruction = function(data) {

        pushToContent({
            processinginstruction: data
        });

    };

    sax.oncomment = function(comment) {

        pushToContent({
            comment: comment.trim()
        });

    };

    sax.oncdata = function(cdata) {

        pushToContent({
            cdata: cdata
        });

    };

    sax.onopentag = function(data) {

        var elem = {
            elem: data.name,
            prefix: data.prefix,
            local: data.local,
            attrs: {}
        };

        elem.class = new CSSClassList(elem);
        elem.style = new CSSStyleDeclaration(elem);

        if (Object.keys(data.attributes).length) {
            for (var name in data.attributes) {

                if (name === 'class') { // has class attribute
                    elem.class.hasClass();
                }

                if (name === 'style') { // has style attribute
                    elem.style.hasStyle();
                }

                elem.attrs[name] = {
                    name: name,
                    value: data.attributes[name].value,
                    prefix: data.attributes[name].prefix,
                    local: data.attributes[name].local
                };
            }
        }

        elem = pushToContent(elem);
        current = elem;

        // Save info about <text> tag to prevent trimming of meaningful whitespace
        if (data.name == 'text' && !data.prefix) {
            textContext = current;
        }

        stack.push(elem);

    };

    sax.ontext = function(text) {

        if (/\S/.test(text) || textContext) {

            if (!textContext)
                text = text.trim();

            pushToContent({
                text: text
            });

        }

    };

    sax.onclosetag = function() {

        var last = stack.pop();

        // Trim text inside <text> tag.
        if (last == textContext) {
            trim(textContext);
            textContext = null;
        }
        current = stack[stack.length - 1];

    };

    sax.onerror = function(e) {

        e.message = 'Error in parsing SVG: ' + e.message;
        if (e.message.indexOf('Unexpected end') < 0) {
            throw e;
        }

    };

    sax.onend = function() {

        if (!this.error) {
            callback(root);
        } else {
            callback({ error: this.error.message });
        }

    };

    try {
        sax.write(data);
    } catch (e) {
        callback({ error: e.message });
        parsingError = true;
    }
    if (!parsingError) sax.close();

    function trim(elem) {
        if (!elem.content) return elem;

        var start = elem.content[0],
            end = elem.content[elem.content.length - 1];

        while (start && start.content && !start.text) start = start.content[0];
        if (start && start.text) start.text = start.text.replace(/^\s+/, '');

        while (end && end.content && !end.text) end = end.content[end.content.length - 1];
        if (end && end.text) end.text = end.text.replace(/\s+$/, '');

        return elem;

    }

};

},{"./css-class-list":1186,"./css-style-declaration":1188,"./jsAPI.js":1190,"sax":1119}],1193:[function(require,module,exports){
(function (Buffer){
'use strict';

var FS = require('fs');

/**
 * Encode plain SVG data string into Data URI string.
 *
 * @param {String} str input string
 * @param {String} type Data URI type
 * @return {String} output string
 */
exports.encodeSVGDatauri = function(str, type) {

    var prefix = 'data:image/svg+xml';

    // base64
    if (!type || type === 'base64') {

        prefix += ';base64,';
        if (Buffer.from) {
            str = prefix + Buffer.from(str).toString('base64');
        } else {
            str = prefix + new Buffer(str).toString('base64');
        }
        
    // URI encoded
    } else if (type === 'enc') {

        str = prefix + ',' + encodeURIComponent(str);

    // unencoded
    } else if (type === 'unenc') {

        str = prefix + ',' + str;

    }

    return str;

};

/**
 * Decode SVG Data URI string into plain SVG string.
 *
 * @param {string} str input string
 * @return {String} output string
 */
exports.decodeSVGDatauri = function(str) {
    var regexp = /data:image\/svg\+xml(;charset=[^;,]*)?(;base64)?,(.*)/;
    var match = regexp.exec(str);

    // plain string
    if (!match) return str;

    var data = match[3];

    // base64
    if (match[2]) {

        str = new Buffer(data, 'base64').toString('utf8');

    // URI encoded
    } else if (data.charAt(0) === '%') {

        str = decodeURIComponent(data);

    // unencoded
    } else if (data.charAt(0) === '<') {

        str = data;

    }

    return str;
};

exports.intersectArrays = function(a, b) {
    return a.filter(function(n) {
        return b.indexOf(n) > -1;
    });
};

exports.cleanupOutData = function(data, params) {

    var str = '',
        delimiter,
        prev;

    data.forEach(function(item, i) {

        // space delimiter by default
        delimiter = ' ';

        // no extra space in front of first number
        if (i === 0) {
            delimiter = '';
        }

        // remove floating-point numbers leading zeros
        // 0.5  .5
        // -0.5  -.5
        if (params.leadingZero) {
            item = removeLeadingZero(item);
        }

        // no extra space in front of negative number or
        // in front of a floating number if a previous number is floating too
        if (
            params.negativeExtraSpace &&
            (item < 0 ||
                (String(item).charCodeAt(0) == 46 && prev % 1 !== 0)
            )
        ) {
            delimiter = '';
        }

        // save prev item value
        prev = item;

        str += delimiter + item;

    });

    return str;

};

/**
 * Remove floating-point numbers leading zero.
 *
 * @example
 * 0.5  .5
 *
 * @example
 * -0.5  -.5
 *
 * @param {Float} num input number
 *
 * @return {String} output number as string
 */
var removeLeadingZero = exports.removeLeadingZero = function(num) {
    var strNum = num.toString();

    if (0 < num && num < 1 && strNum.charCodeAt(0) == 48) {
        strNum = strNum.slice(1);
    } else if (-1 < num && num < 0 && strNum.charCodeAt(1) == 48) {
        strNum = strNum.charAt(0) + strNum.slice(2);
    }

    return strNum;

};


/**
 * Synchronously check if path is a directory. Tolerant to errors like ENOENT.
 * @param {string} path
 */
exports.checkIsDir = function(path) {
    try {
        return FS.lstatSync(path).isDirectory();
    } catch(e) {
        return false;
    }
};

}).call(this,require("buffer").Buffer)
},{"buffer":13,"fs":8}],1194:[function(require,module,exports){
'use strict';

// http://www.w3.org/TR/SVG11/intro.html#Definitions
exports.elemsGroups = {
    animation: ['animate', 'animateColor', 'animateMotion', 'animateTransform', 'set'],
    descriptive: ['desc', 'metadata', 'title'],
    shape: ['circle', 'ellipse', 'line', 'path', 'polygon', 'polyline', 'rect'],
    structural: ['defs', 'g', 'svg', 'symbol', 'use'],
    paintServer: ['solidColor', 'linearGradient', 'radialGradient', 'meshGradient', 'pattern', 'hatch'],
    nonRendering: ['linearGradient', 'radialGradient', 'pattern', 'clipPath', 'mask', 'marker', 'symbol', 'filter', 'solidColor'],
    container: ['a', 'defs', 'g', 'marker', 'mask', 'missing-glyph', 'pattern', 'svg', 'switch', 'symbol', 'foreignObject'],
    textContent: ['altGlyph', 'altGlyphDef', 'altGlyphItem', 'glyph', 'glyphRef', 'textPath', 'text', 'tref', 'tspan'],
    textContentChild: ['altGlyph', 'textPath', 'tref', 'tspan'],
    lightSource: ['feDiffuseLighting', 'feSpecularLighting', 'feDistantLight', 'fePointLight', 'feSpotLight'],
    filterPrimitive: ['feBlend', 'feColorMatrix', 'feComponentTransfer', 'feComposite', 'feConvolveMatrix', 'feDiffuseLighting', 'feDisplacementMap', 'feFlood', 'feGaussianBlur', 'feImage', 'feMerge', 'feMorphology', 'feOffset', 'feSpecularLighting', 'feTile', 'feTurbulence']
};

exports.pathElems = ['path', 'glyph', 'missing-glyph'];

// http://www.w3.org/TR/SVG11/intro.html#Definitions
exports.attrsGroups = {
    animationAddition: ['additive', 'accumulate'],
    animationAttributeTarget: ['attributeType', 'attributeName'],
    animationEvent: ['onbegin', 'onend', 'onrepeat', 'onload'],
    animationTiming: ['begin', 'dur', 'end', 'min', 'max', 'restart', 'repeatCount', 'repeatDur', 'fill'],
    animationValue: ['calcMode', 'values', 'keyTimes', 'keySplines', 'from', 'to', 'by'],
    conditionalProcessing: ['requiredFeatures', 'requiredExtensions', 'systemLanguage'],
    core: ['id', 'tabindex', 'xml:base', 'xml:lang', 'xml:space'],
    graphicalEvent: ['onfocusin', 'onfocusout', 'onactivate', 'onclick', 'onmousedown', 'onmouseup', 'onmouseover', 'onmousemove', 'onmouseout', 'onload'],
    presentation: [
        'alignment-baseline',
        'baseline-shift',
        'clip',
        'clip-path',
        'clip-rule',
        'color',
        'color-interpolation',
        'color-interpolation-filters',
        'color-profile',
        'color-rendering',
        'cursor',
        'direction',
        'display',
        'dominant-baseline',
        'enable-background',
        'fill',
        'fill-opacity',
        'fill-rule',
        'filter',
        'flood-color',
        'flood-opacity',
        'font-family',
        'font-size',
        'font-size-adjust',
        'font-stretch',
        'font-style',
        'font-variant',
        'font-weight',
        'glyph-orientation-horizontal',
        'glyph-orientation-vertical',
        'image-rendering',
        'letter-spacing',
        'lighting-color',
        'marker-end',
        'marker-mid',
        'marker-start',
        'mask',
        'opacity',
        'overflow',
        'paint-order',
        'pointer-events',
        'shape-rendering',
        'stop-color',
        'stop-opacity',
        'stroke',
        'stroke-dasharray',
        'stroke-dashoffset',
        'stroke-linecap',
        'stroke-linejoin',
        'stroke-miterlimit',
        'stroke-opacity',
        'stroke-width',
        'text-anchor',
        'text-decoration',
        'text-overflow',
        'text-rendering',
        'transform',
        'unicode-bidi',
        'vector-effect',
        'visibility',
        'word-spacing',
        'writing-mode'
    ],
    xlink: ['xlink:href', 'xlink:show', 'xlink:actuate', 'xlink:type', 'xlink:role', 'xlink:arcrole', 'xlink:title'],
    documentEvent: ['onunload', 'onabort', 'onerror', 'onresize', 'onscroll', 'onzoom'],
    filterPrimitive: ['x', 'y', 'width', 'height', 'result'],
    transferFunction: ['type', 'tableValues', 'slope', 'intercept', 'amplitude', 'exponent', 'offset']
};

exports.attrsGroupsDefaults = {
    core: {'xml:space': 'preserve'},
    filterPrimitive: {x: '0', y: '0', width: '100%', height: '100%'},
    presentation: {
        clip: 'auto',
        'clip-path': 'none',
        'clip-rule': 'nonzero',
        mask: 'none',
        opacity: '1',
        'stop-color': '#000',
        'stop-opacity': '1',
        'fill-opacity': '1',
        'fill-rule': 'nonzero',
        fill: '#000',
        stroke: 'none',
        'stroke-width': '1',
        'stroke-linecap': 'butt',
        'stroke-linejoin': 'miter',
        'stroke-miterlimit': '4',
        'stroke-dasharray': 'none',
        'stroke-dashoffset': '0',
        'stroke-opacity': '1',
        'paint-order': 'normal',
        'vector-effect': 'none',
        display: 'inline',
        visibility: 'visible',
        'marker-start': 'none',
        'marker-mid': 'none',
        'marker-end': 'none',
        'color-interpolation': 'sRGB',
        'color-interpolation-filters': 'linearRGB',
        'color-rendering': 'auto',
        'shape-rendering': 'auto',
        'text-rendering': 'auto',
        'image-rendering': 'auto',
        'font-style': 'normal',
        'font-variant': 'normal',
        'font-weight': 'normal',
        'font-stretch': 'normal',
        'font-size': 'medium',
        'font-size-adjust': 'none',
        kerning: 'auto',
        'letter-spacing': 'normal',
        'word-spacing': 'normal',
        'text-decoration': 'none',
        'text-anchor': 'start',
        'text-overflow': 'clip',
        'writing-mode': 'lr-tb',
        'glyph-orientation-vertical': 'auto',
        'glyph-orientation-horizontal': '0deg',
        direction: 'ltr',
        'unicode-bidi': 'normal',
        'dominant-baseline': 'auto',
        'alignment-baseline': 'baseline',
        'baseline-shift': 'baseline'
    },
    transferFunction: {slope: '1', intercept: '0', amplitude: '1', exponent: '1', offset: '0'}
};

// http://www.w3.org/TR/SVG11/eltindex.html
exports.elems = {
    a: {
        attrsGroups: [
            'conditionalProcessing',
            'core',
            'graphicalEvent',
            'presentation',
            'xlink'
        ],
        attrs: [
            'class',
            'style',
            'externalResourcesRequired',
            'transform',
            'target'
        ],
        defaults: {
            target: '_self'
        },
        contentGroups: [
            'animation',
            'descriptive',
            'shape',
            'structural',
            'paintServer'
        ],
        content: [
            'a',
            'altGlyphDef',
            'clipPath',
            'color-profile',
            'cursor',
            'filter',
            'font',
            'font-face',
            'foreignObject',
            'image',
            'marker',
            'mask',
            'pattern',
            'script',
            'style',
            'switch',
            'text',
            'view'
        ]
    },
    altGlyph: {
        attrsGroups: [
            'conditionalProcessing',
            'core',
            'graphicalEvent',
            'presentation',
            'xlink'
        ],
        attrs: [
            'class',
            'style',
            'externalResourcesRequired',
            'x',
            'y',
            'dx',
            'dy',
            'glyphRef',
            'format',
            'rotate'
        ]
    },
    altGlyphDef: {
        attrsGroups: [
            'core'
        ],
        content: [
            'glyphRef'
        ]
    },
    altGlyphItem: {
        attrsGroups: [
            'core'
        ],
        content: [
            'glyphRef',
            'altGlyphItem'
        ]
    },
    animate: {
        attrsGroups: [
            'conditionalProcessing',
            'core',
            'animationAddition',
            'animationAttributeTarget',
            'animationEvent',
            'animationTiming',
            'animationValue',
            'presentation',
            'xlink'
        ],
        attrs: [
            'externalResourcesRequired'
        ],
        contentGroups: [
            'descriptive'
        ]
    },
    animateColor: {
        attrsGroups: [
            'conditionalProcessing',
            'core',
            'animationEvent',
            'xlink',
            'animationAttributeTarget',
            'animationTiming',
            'animationValue',
            'animationAddition',
            'presentation'
        ],
        attrs: [
            'externalResourcesRequired'
        ],
        contentGroups: [
            'descriptive'
        ]
    },
    animateMotion: {
        attrsGroups: [
            'conditionalProcessing',
            'core',
            'animationEvent',
            'xlink',
            'animationTiming',
            'animationValue',
            'animationAddition'
        ],
        attrs: [
            'externalResourcesRequired',
            'path',
            'keyPoints',
            'rotate',
            'origin'
        ],
        defaults: {
            'rotate': '0'
        },
        contentGroups: [
            'descriptive'
        ],
        content: [
            'mpath'
        ]
    },
    animateTransform: {
        attrsGroups: [
            'conditionalProcessing',
            'core',
            'animationEvent',
            'xlink',
            'animationAttributeTarget',
            'animationTiming',
            'animationValue',
            'animationAddition'
        ],
        attrs: [
            'externalResourcesRequired',
            'type'
        ],
        contentGroups: [
            'descriptive'
        ]
    },
    circle: {
        attrsGroups: [
            'conditionalProcessing',
            'core',
            'graphicalEvent',
            'presentation'
        ],
        attrs: [
            'class',
            'style',
            'externalResourcesRequired',
            'transform',
            'cx',
            'cy',
            'r'
        ],
        defaults: {
            cx: '0',
            cy: '0'
        },
        contentGroups: [
            'animation',
            'descriptive'
        ]
    },
    clipPath: {
        attrsGroups: [
            'conditionalProcessing',
            'core',
            'presentation'
        ],
        attrs: [
            'class',
            'style',
            'externalResourcesRequired',
            'transform',
            'clipPathUnits'
        ],
        defaults: {
            clipPathUnits: 'userSpaceOnUse'
        },
        contentGroups: [
            'animation',
            'descriptive',
            'shape'
        ],
        content: [
            'text',
            'use'
        ]
    },
    'color-profile': {
        attrsGroups: [
            'core',
            'xlink'
        ],
        attrs: [
            'local',
            'name',
            'rendering-intent'
        ],
        defaults: {
            name: 'sRGB',
            'rendering-intent': 'auto'
        },
        contentGroups: [
            'descriptive'
        ]
    },
    cursor: {
        attrsGroups: [
            'core',
            'conditionalProcessing',
            'xlink'
        ],
        attrs: [
            'externalResourcesRequired',
            'x',
            'y'
        ],
        defaults: {
            x: '0',
            y: '0'
        },
        contentGroups: [
            'descriptive'
        ]
    },
    defs: {
        attrsGroups: [
            'conditionalProcessing',
            'core',
            'graphicalEvent',
            'presentation'
        ],
        attrs: [
            'class',
            'style',
            'externalResourcesRequired',
            'transform'
        ],
        contentGroups: [
            'animation',
            'descriptive',
            'shape',
            'structural',
            'paintServer'
        ],
        content: [
            'a',
            'altGlyphDef',
            'clipPath',
            'color-profile',
            'cursor',
            'filter',
            'font',
            'font-face',
            'foreignObject',
            'image',
            'marker',
            'mask',
            'pattern',
            'script',
            'style',
            'switch',
            'text',
            'view'
        ]
    },
    desc: {
        attrsGroups: [
            'core'
        ],
        attrs: [
            'class',
            'style'
        ]
    },
    ellipse: {
        attrsGroups: [
            'conditionalProcessing',
            'core',
            'graphicalEvent',
            'presentation'
        ],
        attrs: [
            'class',
            'style',
            'externalResourcesRequired',
            'transform',
            'cx',
            'cy',
            'rx',
            'ry'
        ],
        defaults: {
            cx: '0',
            cy: '0'
        },
        contentGroups: [
            'animation',
            'descriptive'
        ]
    },
    feBlend: {
        attrsGroups: [
            'core',
            'presentation',
            'filterPrimitive'
        ],
        attrs: [
            'class',
            'style',
            // TODO: in - 'If no value is provided and this is the first filter primitive,
            // then this filter primitive will use SourceGraphic as its input'
            'in',
            'in2',
            'mode'
        ],
        defaults: {
            mode: 'normal'
        },
        content: [
            'animate',
            'set'
        ]
    },
    feColorMatrix: {
        attrsGroups: [
            'core',
            'presentation',
            'filterPrimitive'
        ],
        attrs: [
            'class',
            'style',
            'in',
            'type',
            'values'
        ],
        defaults: {
            type: 'matrix'
        },
        content: [
            'animate',
            'set'
        ]
    },
    feComponentTransfer: {
        attrsGroups: [
            'core',
            'presentation',
            'filterPrimitive'
        ],
        attrs: [
            'class',
            'style',
            'in'
        ],
        content: [
            'feFuncA',
            'feFuncB',
            'feFuncG',
            'feFuncR'
        ]
    },
    feComposite: {
        attrsGroups: [
            'core',
            'presentation',
            'filterPrimitive'
        ],
        attrs: [
            'class',
            'style',
            'in',
            'in2',
            'operator',
            'k1',
            'k2',
            'k3',
            'k4'
        ],
        defaults: {
            operator: 'over',
            k1: '0',
            k2: '0',
            k3: '0',
            k4: '0'
        },
        content: [
            'animate',
            'set'
        ]
    },
    feConvolveMatrix: {
        attrsGroups: [
            'core',
            'presentation',
            'filterPrimitive'
        ],
        attrs: [
            'class',
            'style',
            'in',
            'order',
            'kernelMatrix',
            // TODO: divisor - 'The default value is the sum of all values in kernelMatrix,
            // with the exception that if the sum is zero, then the divisor is set to 1'
            'divisor',
            'bias',
            // TODO: targetX - 'By default, the convolution matrix is centered in X over each
            // pixel of the input image (i.e., targetX = floor ( orderX / 2 ))'
            'targetX',
            'targetY',
            'edgeMode',
            // TODO: kernelUnitLength - 'The first number is the <dx> value. The second number
            // is the <dy> value. If the <dy> value is not specified, it defaults to the same value as <dx>'
            'kernelUnitLength',
            'preserveAlpha'
        ],
        defaults: {
            order: '3',
            bias: '0',
            edgeMode: 'duplicate',
            preserveAlpha: 'false'
        },
        content: [
            'animate',
            'set'
        ]
    },
    feDiffuseLighting: {
        attrsGroups: [
            'core',
            'presentation',
            'filterPrimitive'
        ],
        attrs: [
            'class',
            'style',
            'in',
            'surfaceScale',
            'diffuseConstant',
            'kernelUnitLength'
        ],
        defaults: {
            surfaceScale: '1',
            diffuseConstant: '1'
        },
        contentGroups: [
            'descriptive'
        ],
        content: [
            // TODO: 'exactly one light source element, in any order'
            'feDistantLight',
            'fePointLight',
            'feSpotLight'
        ]
    },
    feDisplacementMap: {
        attrsGroups: [
            'core',
            'presentation',
            'filterPrimitive'
        ],
        attrs: [
            'class',
            'style',
            'in',
            'in2',
            'scale',
            'xChannelSelector',
            'yChannelSelector'
        ],
        defaults: {
            scale: '0',
            xChannelSelector: 'A',
            yChannelSelector: 'A'
        },
        content: [
            'animate',
            'set'
        ]
    },
    feDistantLight: {
        attrsGroups: [
            'core'
        ],
        attrs: [
            'azimuth',
            'elevation'
        ],
        defaults: {
            azimuth: '0',
            elevation: '0'
        },
        content: [
            'animate',
            'set'
        ]
    },
    feFlood: {
        attrsGroups: [
            'core',
            'presentation',
            'filterPrimitive'
        ],
        attrs: [
            'class',
            'style'
        ],
        content: [
            'animate',
            'animateColor',
            'set'
        ]
    },
    feFuncA: {
        attrsGroups: [
            'core',
            'transferFunction'
        ],
        content: [
            'set',
            'animate'
        ]
    },
    feFuncB: {
        attrsGroups: [
            'core',
            'transferFunction'
        ],
        content: [
            'set',
            'animate'
        ]
    },
    feFuncG: {
        attrsGroups: [
            'core',
            'transferFunction'
        ],
        content: [
            'set',
            'animate'
        ]
    },
    feFuncR: {
        attrsGroups: [
            'core',
            'transferFunction'
        ],
        content: [
            'set',
            'animate'
        ]
    },
    feGaussianBlur: {
        attrsGroups: [
            'core',
            'presentation',
            'filterPrimitive'
        ],
        attrs: [
            'class',
            'style',
            'in',
            'stdDeviation'
        ],
        defaults: {
            stdDeviation: '0'
        },
        content: [
            'set',
            'animate'
        ]
    },
    feImage: {
        attrsGroups: [
            'core',
            'presentation',
            'filterPrimitive',
            'xlink'
        ],
        attrs: [
            'class',
            'style',
            'externalResourcesRequired',
            'preserveAspectRatio',
            'href',
            'xlink:href'
        ],
        defaults: {
            preserveAspectRatio: 'xMidYMid meet'
        },
        content: [
            'animate',
            'animateTransform',
            'set'
        ]
    },
    feMerge: {
        attrsGroups: [
            'core',
            'presentation',
            'filterPrimitive'
        ],
        attrs: [
            'class',
            'style'
        ],
        content: [
            'feMergeNode'
        ]
    },
    feMergeNode: {
        attrsGroups: [
            'core'
        ],
        attrs: [
            'in'
        ],
        content: [
            'animate',
            'set'
        ]
    },
    feMorphology: {
        attrsGroups: [
            'core',
            'presentation',
            'filterPrimitive'
        ],
        attrs: [
            'class',
            'style',
            'in',
            'operator',
            'radius'
        ],
        defaults: {
            operator: 'erode',
            radius: '0'
        },
        content: [
            'animate',
            'set'
        ]
    },
    feOffset: {
        attrsGroups: [
            'core',
            'presentation',
            'filterPrimitive'
        ],
        attrs: [
            'class',
            'style',
            'in',
            'dx',
            'dy'
        ],
        defaults: {
            dx: '0',
            dy: '0'
        },
        content: [
            'animate',
            'set'
        ]
    },
    fePointLight: {
        attrsGroups: [
            'core'
        ],
        attrs: [
            'x',
            'y',
            'z'
        ],
        defaults: {
            x: '0',
            y: '0',
            z: '0'
        },
        content: [
            'animate',
            'set'
        ]
    },
    feSpecularLighting: {
        attrsGroups: [
            'core',
            'presentation',
            'filterPrimitive'
        ],
        attrs: [
            'class',
            'style',
            'in',
            'surfaceScale',
            'specularConstant',
            'specularExponent',
            'kernelUnitLength'
        ],
        defaults: {
            surfaceScale: '1',
            specularConstant: '1',
            specularExponent: '1'
        },
        contentGroups: [
            'descriptive',
            // TODO: exactly one 'light source element'
            'lightSource'
        ]
    },
    feSpotLight: {
        attrsGroups: [
            'core'
        ],
        attrs: [
            'x',
            'y',
            'z',
            'pointsAtX',
            'pointsAtY',
            'pointsAtZ',
            'specularExponent',
            'limitingConeAngle'
        ],
        defaults: {
            x: '0',
            y: '0',
            z: '0',
            pointsAtX: '0',
            pointsAtY: '0',
            pointsAtZ: '0',
            specularExponent: '1'
        },
        content: [
            'animate',
            'set'
        ]
    },
    feTile: {
        attrsGroups: [
            'core',
            'presentation',
            'filterPrimitive'
        ],
        attrs: [
            'class',
            'style',
            'in'
        ],
        content: [
            'animate',
            'set'
        ]
    },
    feTurbulence: {
        attrsGroups: [
            'core',
            'presentation',
            'filterPrimitive'
        ],
        attrs: [
            'class',
            'style',
            'baseFrequency',
            'numOctaves',
            'seed',
            'stitchTiles',
            'type'
        ],
        defaults: {
            baseFrequency: '0',
            numOctaves: '1',
            seed: '0',
            stitchTiles: 'noStitch',
            type: 'turbulence'
        },
        content: [
            'animate',
            'set'
        ]
    },
    filter: {
        attrsGroups: [
            'core',
            'presentation',
            'xlink'
        ],
        attrs: [
            'class',
            'style',
            'externalResourcesRequired',
            'x',
            'y',
            'width',
            'height',
            'filterRes',
            'filterUnits',
            'primitiveUnits',
            'href',
            'xlink:href'
        ],
        defaults: {
            primitiveUnits: 'userSpaceOnUse',
            x: '-10%',
            y: '-10%',
            width: '120%',
            height: '120%'
        },
        contentGroups: [
            'descriptive',
            'filterPrimitive'
        ],
        content: [
            'animate',
            'set'
        ]
    },
    font: {
        attrsGroups: [
            'core',
            'presentation'
        ],
        attrs: [
            'class',
            'style',
            'externalResourcesRequired',
            'horiz-origin-x',
            'horiz-origin-y',
            'horiz-adv-x',
            'vert-origin-x',
            'vert-origin-y',
            'vert-adv-y'
        ],
        defaults: {
            'horiz-origin-x': '0',
            'horiz-origin-y': '0'
        },
        contentGroups: [
            'descriptive'
        ],
        content: [
            'font-face',
            'glyph',
            'hkern',
            'missing-glyph',
            'vkern'
        ]
    },
    'font-face': {
        attrsGroups: [
            'core'
        ],
        attrs: [
            'font-family',
            'font-style',
            'font-variant',
            'font-weight',
            'font-stretch',
            'font-size',
            'unicode-range',
            'units-per-em',
            'panose-1',
            'stemv',
            'stemh',
            'slope',
            'cap-height',
            'x-height',
            'accent-height',
            'ascent',
            'descent',
            'widths',
            'bbox',
            'ideographic',
            'alphabetic',
            'mathematical',
            'hanging',
            'v-ideographic',
            'v-alphabetic',
            'v-mathematical',
            'v-hanging',
            'underline-position',
            'underline-thickness',
            'strikethrough-position',
            'strikethrough-thickness',
            'overline-position',
            'overline-thickness'
        ],
        defaults: {
            'font-style': 'all',
            'font-variant': 'normal',
            'font-weight': 'all',
            'font-stretch': 'normal',
            'unicode-range': 'U+0-10FFFF',
            'units-per-em': '1000',
            'panose-1': '0 0 0 0 0 0 0 0 0 0',
            'slope': '0'
        },
        contentGroups: [
            'descriptive'
        ],
        content: [
            // TODO: "at most one 'font-face-src' element"
            'font-face-src'
        ]
    },
    // TODO: empty content
    'font-face-format': {
        attrsGroups: [
            'core'
        ],
        attrs: [
            'string'
        ]
    },
    'font-face-name': {
        attrsGroups: [
            'core'
        ],
        attrs: [
            'name'
        ]
    },
    'font-face-src': {
        attrsGroups: [
            'core'
        ],
        content: [
            'font-face-name',
            'font-face-uri'
        ]
    },
    'font-face-uri': {
        attrsGroups: [
            'core',
            'xlink'
        ],
        attrs: [
            'href',
            'xlink:href'
        ],
        content: [
            'font-face-format'
        ]
    },
    foreignObject: {
        attrsGroups: [
            'core',
            'conditionalProcessing',
            'graphicalEvent',
            'presentation'
        ],
        attrs: [
            'class',
            'style',
            'externalResourcesRequired',
            'transform',
            'x',
            'y',
            'width',
            'height'
        ],
        defaults: {
            x: 0,
            y: 0
        }
    },
    g: {
        attrsGroups: [
            'conditionalProcessing',
            'core',
            'graphicalEvent',
            'presentation'
        ],
        attrs: [
            'class',
            'style',
            'externalResourcesRequired',
            'transform'
        ],
        contentGroups: [
            'animation',
            'descriptive',
            'shape',
            'structural',
            'paintServer'
        ],
        content: [
            'a',
            'altGlyphDef',
            'clipPath',
            'color-profile',
            'cursor',
            'filter',
            'font',
            'font-face',
            'foreignObject',
            'image',
            'marker',
            'mask',
            'pattern',
            'script',
            'style',
            'switch',
            'text',
            'view'
        ]
    },
    glyph: {
        attrsGroups: [
            'core',
            'presentation'
        ],
        attrs: [
            'class',
            'style',
            'd',
            'horiz-adv-x',
            'vert-origin-x',
            'vert-origin-y',
            'vert-adv-y',
            'unicode',
            'glyph-name',
            'orientation',
            'arabic-form',
            'lang'
        ],
        defaults: {
            'arabic-form': 'initial'
        },
        contentGroups: [
            'animation',
            'descriptive',
            'shape',
            'structural',
            'paintServer'
        ],
        content: [
            'a',
            'altGlyphDef',
            'clipPath',
            'color-profile',
            'cursor',
            'filter',
            'font',
            'font-face',
            'foreignObject',
            'image',
            'marker',
            'mask',
            'pattern',
            'script',
            'style',
            'switch',
            'text',
            'view'
        ],
    },
    glyphRef: {
        attrsGroups: [
            'core',
            'presentation'
        ],
        attrs: [
            'class',
            'style',
            'd',
            'horiz-adv-x',
            'vert-origin-x',
            'vert-origin-y',
            'vert-adv-y'
        ],
        contentGroups: [
            'animation',
            'descriptive',
            'shape',
            'structural',
            'paintServer'
        ],
        content: [
            'a',
            'altGlyphDef',
            'clipPath',
            'color-profile',
            'cursor',
            'filter',
            'font',
            'font-face',
            'foreignObject',
            'image',
            'marker',
            'mask',
            'pattern',
            'script',
            'style',
            'switch',
            'text',
            'view'
        ]
    },
    hatch: {
        attrsGroups: [
            'core',
            'presentation',
            'xlink'
        ],
        attrs: [
            'class',
            'style',
            'x',
            'y',
            'pitch',
            'rotate',
            'hatchUnits',
            'hatchContentUnits',
            'transform'
        ],
        defaults: {
            hatchUnits: 'objectBoundingBox',
            hatchContentUnits: 'userSpaceOnUse',
            x: '0',
            y: '0',
            pitch: '0',
            rotate: '0'
        },
        contentGroups: [
            'animation',
            'descriptive'
        ],
        content: [
            'hatchPath'
        ]
    },
    hatchPath: {
        attrsGroups: [
            'core',
            'presentation',
            'xlink'
        ],
        attrs: [
            'class',
            'style',
            'd',
            'offset'
        ],
        defaults: {
            offset: '0'
        },
        contentGroups: [
            'animation',
            'descriptive'
        ]
    },
    hkern: {
        attrsGroups: [
            'core'
        ],
        attrs: [
            'u1',
            'g1',
            'u2',
            'g2',
            'k'
        ]
    },
    image: {
        attrsGroups: [
            'core',
            'conditionalProcessing',
            'graphicalEvent',
            'xlink',
            'presentation'
        ],
        attrs: [
            'class',
            'style',
            'externalResourcesRequired',
            'preserveAspectRatio',
            'transform',
            'x',
            'y',
            'width',
            'height',
            'href',
            'xlink:href'
        ],
        defaults: {
            x: '0',
            y: '0',
            preserveAspectRatio: 'xMidYMid meet'
        },
        contentGroups: [
            'animation',
            'descriptive'
        ]
    },
    line: {
        attrsGroups: [
            'conditionalProcessing',
            'core',
            'graphicalEvent',
            'presentation'
        ],
        attrs: [
            'class',
            'style',
            'externalResourcesRequired',
            'transform',
            'x1',
            'y1',
            'x2',
            'y2'
        ],
        defaults: {
            x1: '0',
            y1: '0',
            x2: '0',
            y2: '0'
        },
        contentGroups: [
            'animation',
            'descriptive'
        ]
    },
    linearGradient: {
        attrsGroups: [
            'core',
            'presentation',
            'xlink'
        ],
        attrs: [
            'class',
            'style',
            'externalResourcesRequired',
            'x1',
            'y1',
            'x2',
            'y2',
            'gradientUnits',
            'gradientTransform',
            'spreadMethod',
            'href',
            'xlink:href'
        ],
        defaults: {
            x1: '0',
            y1: '0',
            x2: '100%',
            y2: '0',
            spreadMethod: 'pad'
        },
        contentGroups: [
            'descriptive'
        ],
        content: [
            'animate',
            'animateTransform',
            'set',
            'stop'
        ]
    },
    marker: {
        attrsGroups: [
            'core',
            'presentation'
        ],
        attrs: [
            'class',
            'style',
            'externalResourcesRequired',
            'viewBox',
            'preserveAspectRatio',
            'refX',
            'refY',
            'markerUnits',
            'markerWidth',
            'markerHeight',
            'orient'
        ],
        defaults: {
            markerUnits: 'strokeWidth',
            refX: '0',
            refY: '0',
            markerWidth: '3',
            markerHeight: '3'
        },
        contentGroups: [
            'animation',
            'descriptive',
            'shape',
            'structural',
            'paintServer'
        ],
        content: [
            'a',
            'altGlyphDef',
            'clipPath',
            'color-profile',
            'cursor',
            'filter',
            'font',
            'font-face',
            'foreignObject',
            'image',
            'marker',
            'mask',
            'pattern',
            'script',
            'style',
            'switch',
            'text',
            'view'
        ]
    },
    mask: {
        attrsGroups: [
            'conditionalProcessing',
            'core',
            'presentation'
        ],
        attrs: [
            'class',
            'style',
            'externalResourcesRequired',
            'x',
            'y',
            'width',
            'height',
            'maskUnits',
            'maskContentUnits'
        ],
        defaults: {
            maskUnits: 'objectBoundingBox',
            maskContentUnits: 'userSpaceOnUse',
            x: '-10%',
            y: '-10%',
            width: '120%',
            height: '120%'
        },
        contentGroups: [
            'animation',
            'descriptive',
            'shape',
            'structural',
            'paintServer'
        ],
        content: [
            'a',
            'altGlyphDef',
            'clipPath',
            'color-profile',
            'cursor',
            'filter',
            'font',
            'font-face',
            'foreignObject',
            'image',
            'marker',
            'mask',
            'pattern',
            'script',
            'style',
            'switch',
            'text',
            'view'
        ]
    },
    metadata: {
        attrsGroups: [
            'core'
        ]
    },
    'missing-glyph': {
        attrsGroups: [
            'core',
            'presentation'
        ],
        attrs: [
            'class',
            'style',
            'd',
            'horiz-adv-x',
            'vert-origin-x',
            'vert-origin-y',
            'vert-adv-y'
        ],
        contentGroups: [
            'animation',
            'descriptive',
            'shape',
            'structural',
            'paintServer'
        ],
        content: [
            'a',
            'altGlyphDef',
            'clipPath',
            'color-profile',
            'cursor',
            'filter',
            'font',
            'font-face',
            'foreignObject',
            'image',
            'marker',
            'mask',
            'pattern',
            'script',
            'style',
            'switch',
            'text',
            'view'
        ]
    },
    mpath: {
        attrsGroups: [
            'core',
            'xlink'
        ],
        attrs: [
            'externalResourcesRequired',
            'href',
            'xlink:href'
        ],
        contentGroups: [
            'descriptive'
        ]
    },
    path: {
        attrsGroups: [
            'conditionalProcessing',
            'core',
            'graphicalEvent',
            'presentation'
        ],
        attrs: [
            'class',
            'style',
            'externalResourcesRequired',
            'transform',
            'd',
            'pathLength'
        ],
        contentGroups: [
            'animation',
            'descriptive'
        ]
    },
    pattern: {
        attrsGroups: [
            'conditionalProcessing',
            'core',
            'presentation',
            'xlink'
        ],
        attrs: [
            'class',
            'style',
            'externalResourcesRequired',
            'viewBox',
            'preserveAspectRatio',
            'x',
            'y',
            'width',
            'height',
            'patternUnits',
            'patternContentUnits',
            'patternTransform',
            'href',
            'xlink:href'
        ],
        defaults: {
            patternUnits: 'objectBoundingBox',
            patternContentUnits: 'userSpaceOnUse',
            x: '0',
            y: '0',
            width: '0',
            height: '0',
            preserveAspectRatio: 'xMidYMid meet'
        },
        contentGroups: [
            'animation',
            'descriptive',
            'paintServer',
            'shape',
            'structural'
        ],
        content: [
            'a',
            'altGlyphDef',
            'clipPath',
            'color-profile',
            'cursor',
            'filter',
            'font',
            'font-face',
            'foreignObject',
            'image',
            'marker',
            'mask',
            'pattern',
            'script',
            'style',
            'switch',
            'text',
            'view'
        ]
    },
    polygon: {
        attrsGroups: [
            'conditionalProcessing',
            'core',
            'graphicalEvent',
            'presentation'
        ],
        attrs: [
            'class',
            'style',
            'externalResourcesRequired',
            'transform',
            'points'
        ],
        contentGroups: [
            'animation',
            'descriptive'
        ]
    },
    polyline: {
        attrsGroups: [
            'conditionalProcessing',
            'core',
            'graphicalEvent',
            'presentation'
        ],
        attrs: [
            'class',
            'style',
            'externalResourcesRequired',
            'transform',
            'points'
        ],
        contentGroups: [
            'animation',
            'descriptive'
        ]
    },
    radialGradient: {
        attrsGroups: [
            'core',
            'presentation',
            'xlink'
        ],
        attrs: [
            'class',
            'style',
            'externalResourcesRequired',
            'cx',
            'cy',
            'r',
            'fx',
            'fy',
            'fr',
            'gradientUnits',
            'gradientTransform',
            'spreadMethod',
            'href',
            'xlink:href'
        ],
        defaults: {
            gradientUnits: 'objectBoundingBox',
            cx: '50%',
            cy: '50%',
            r: '50%'
        },
        contentGroups: [
            'descriptive'
        ],
        content: [
            'animate',
            'animateTransform',
            'set',
            'stop'
        ]
    },
    meshGradient: {
        attrsGroups: [
            'core',
            'presentation',
            'xlink'
        ],
        attrs: [
            'class',
            'style',
            'x',
            'y',
            'gradientUnits',
            'transform'
        ],
        contentGroups: [
            'descriptive',
            'paintServer',
            'animation',
        ],
        content: [
            'meshRow'
        ]
    },
    meshRow: {
        attrsGroups: [
            'core',
            'presentation'
        ],
        attrs: [
            'class',
            'style'
        ],
        contentGroups: [
            'descriptive'
        ],
        content: [
            'meshPatch'
        ]
    },
    meshPatch: {
        attrsGroups: [
            'core',
            'presentation'
        ],
        attrs: [
            'class',
            'style'
        ],
        contentGroups: [
            'descriptive'
        ],
        content: [
            'stop'
        ]
    },
    rect: {
        attrsGroups: [
            'conditionalProcessing',
            'core',
            'graphicalEvent',
            'presentation'
        ],
        attrs: [
            'class',
            'style',
            'externalResourcesRequired',
            'transform',
            'x',
            'y',
            'width',
            'height',
            'rx',
            'ry'
        ],
        defaults: {
            x: '0',
            y: '0'
        },
        contentGroups: [
            'animation',
            'descriptive'
        ]
    },
    script: {
        attrsGroups: [
            'core',
            'xlink'
        ],
        attrs: [
            'externalResourcesRequired',
            'type',
            'href',
            'xlink:href'
        ]
    },
    set: {
        attrsGroups: [
            'conditionalProcessing',
            'core',
            'animation',
            'xlink',
            'animationAttributeTarget',
            'animationTiming',
        ],
        attrs: [
            'externalResourcesRequired',
            'to'
        ],
        contentGroups: [
            'descriptive'
        ]
    },
    solidColor: {
        attrsGroups: [
            'core',
            'presentation'
        ],
        attrs: [
            'class',
            'style'
        ],
        contentGroups: [
            'paintServer'
        ]
    },
    stop: {
        attrsGroups: [
            'core',
            'presentation'
        ],
        attrs: [
            'class',
            'style',
            'offset',
            'path'
        ],
        content: [
            'animate',
            'animateColor',
            'set'
        ]
    },
    style: {
        attrsGroups: [
            'core'
        ],
        attrs: [
            'type',
            'media',
            'title'
        ],
        defaults: {
            type: 'text/css'
        }
    },
    svg: {
        attrsGroups: [
            'conditionalProcessing',
            'core',
            'documentEvent',
            'graphicalEvent',
            'presentation'
        ],
        attrs: [
            'class',
            'style',
            'x',
            'y',
            'width',
            'height',
            'viewBox',
            'preserveAspectRatio',
            'zoomAndPan',
            'version',
            'baseProfile',
            'contentScriptType',
            'contentStyleType'
        ],
        defaults: {
            x: '0',
            y: '0',
            width: '100%',
            height: '100%',
            preserveAspectRatio: 'xMidYMid meet',
            zoomAndPan: 'magnify',
            version: '1.1',
            baseProfile: 'none',
            contentScriptType: 'application/ecmascript',
            contentStyleType: 'text/css'
        },
        contentGroups: [
            'animation',
            'descriptive',
            'shape',
            'structural',
            'paintServer'
        ],
        content: [
            'a',
            'altGlyphDef',
            'clipPath',
            'color-profile',
            'cursor',
            'filter',
            'font',
            'font-face',
            'foreignObject',
            'image',
            'marker',
            'mask',
            'pattern',
            'script',
            'style',
            'switch',
            'text',
            'view'
        ]
    },
    switch: {
        attrsGroups: [
            'conditionalProcessing',
            'core',
            'graphicalEvent',
            'presentation'
        ],
        attrs: [
            'class',
            'style',
            'externalResourcesRequired',
            'transform'
        ],
        contentGroups: [
            'animation',
            'descriptive',
            'shape'
        ],
        content: [
            'a',
            'foreignObject',
            'g',
            'image',
            'svg',
            'switch',
            'text',
            'use'
        ]
    },
    symbol: {
        attrsGroups: [
            'core',
            'graphicalEvent',
            'presentation'
        ],
        attrs: [
            'class',
            'style',
            'externalResourcesRequired',
            'preserveAspectRatio',
            'viewBox',
            'refX',
            'refY'
        ],
        defaults: {
            refX: 0,
            refY: 0
        },
        contentGroups: [
            'animation',
            'descriptive',
            'shape',
            'structural',
            'paintServer'
        ],
        content: [
            'a',
            'altGlyphDef',
            'clipPath',
            'color-profile',
            'cursor',
            'filter',
            'font',
            'font-face',
            'foreignObject',
            'image',
            'marker',
            'mask',
            'pattern',
            'script',
            'style',
            'switch',
            'text',
            'view'
        ]
    },
    text: {
        attrsGroups: [
            'conditionalProcessing',
            'core',
            'graphicalEvent',
            'presentation'
        ],
        attrs: [
            'class',
            'style',
            'externalResourcesRequired',
            'transform',
            'lengthAdjust',
            'x',
            'y',
            'dx',
            'dy',
            'rotate',
            'textLength'
        ],
        defaults: {
            x: '0',
            y: '0',
            lengthAdjust: 'spacing'
        },
        contentGroups: [
            'animation',
            'descriptive',
            'textContentChild'
        ],
        content: [
            'a'
        ]
    },
    textPath: {
        attrsGroups: [
            'conditionalProcessing',
            'core',
            'graphicalEvent',
            'presentation',
            'xlink'
        ],
        attrs: [
            'class',
            'style',
            'externalResourcesRequired',
            'href',
            'xlink:href',
            'startOffset',
            'method',
            'spacing',
            'd'
        ],
        defaults: {
            startOffset: '0',
            method: 'align',
            spacing: 'exact'
        },
        contentGroups: [
            'descriptive'
        ],
        content: [
            'a',
            'altGlyph',
            'animate',
            'animateColor',
            'set',
            'tref',
            'tspan'
        ]
    },
    title: {
        attrsGroups: [
            'core'
        ],
        attrs: [
            'class',
            'style'
        ]
    },
    tref: {
        attrsGroups: [
            'conditionalProcessing',
            'core',
            'graphicalEvent',
            'presentation',
            'xlink'
        ],
        attrs: [
            'class',
            'style',
            'externalResourcesRequired',
            'href',
            'xlink:href'
        ],
        contentGroups: [
            'descriptive'
        ],
        content: [
            'animate',
            'animateColor',
            'set'
        ]
    },
    tspan: {
        attrsGroups: [
            'conditionalProcessing',
            'core',
            'graphicalEvent',
            'presentation'
        ],
        attrs: [
            'class',
            'style',
            'externalResourcesRequired',
            'x',
            'y',
            'dx',
            'dy',
            'rotate',
            'textLength',
            'lengthAdjust'
        ],
        contentGroups: [
            'descriptive'
        ],
        content: [
            'a',
            'altGlyph',
            'animate',
            'animateColor',
            'set',
            'tref',
            'tspan'
        ]
    },
    use: {
        attrsGroups: [
            'core',
            'conditionalProcessing',
            'graphicalEvent',
            'presentation',
            'xlink'
        ],
        attrs: [
            'class',
            'style',
            'externalResourcesRequired',
            'transform',
            'x',
            'y',
            'width',
            'height',
            'href',
            'xlink:href'
        ],
        defaults: {
            x: '0',
            y: '0'
        },
        contentGroups: [
            'animation',
            'descriptive'
        ]
    },
    view: {
        attrsGroups: [
            'core'
        ],
        attrs: [
            'externalResourcesRequired',
            'viewBox',
            'preserveAspectRatio',
            'zoomAndPan',
            'viewTarget'
        ],
        contentGroups: [
            'descriptive'
        ]
    },
    vkern: {
        attrsGroups: [
            'core'
        ],
        attrs: [
            'u1',
            'g1',
            'u2',
            'g2',
            'k'
        ]
    }
};

// http://wiki.inkscape.org/wiki/index.php/Inkscape-specific_XML_attributes
exports.editorNamespaces = [
    'http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd',
    'http://inkscape.sourceforge.net/DTD/sodipodi-0.dtd',
    'http://www.inkscape.org/namespaces/inkscape',
    'http://www.bohemiancoding.com/sketch/ns',
    'http://ns.adobe.com/AdobeIllustrator/10.0/',
    'http://ns.adobe.com/Graphs/1.0/',
    'http://ns.adobe.com/AdobeSVGViewerExtensions/3.0/',
    'http://ns.adobe.com/Variables/1.0/',
    'http://ns.adobe.com/SaveForWeb/1.0/',
    'http://ns.adobe.com/Extensibility/1.0/',
    'http://ns.adobe.com/Flows/1.0/',
    'http://ns.adobe.com/ImageReplacement/1.0/',
    'http://ns.adobe.com/GenericCustomNamespace/1.0/',
    'http://ns.adobe.com/XPath/1.0/',
    'http://schemas.microsoft.com/visio/2003/SVGExtensions/',
    'http://taptrix.com/vectorillustrator/svg_extensions',
    'http://www.figma.com/figma/ns',
    'http://purl.org/dc/elements/1.1/',
    'http://creativecommons.org/ns#',
    'http://www.w3.org/1999/02/22-rdf-syntax-ns#',
    'http://www.serif.com/',
    'http://www.vector.evaxdesign.sk'
];

// http://www.w3.org/TR/SVG11/linking.html#processingIRI
exports.referencesProps = [
    'clip-path',
    'color-profile',
    'fill',
    'filter',
    'marker-start',
    'marker-mid',
    'marker-end',
    'mask',
    'stroke',
    'style'
];

// http://www.w3.org/TR/SVG11/propidx.html
exports.inheritableAttrs = [
    'clip-rule',
    'color',
    'color-interpolation',
    'color-interpolation-filters',
    'color-profile',
    'color-rendering',
    'cursor',
    'direction',
    'dominant-baseline',
    'fill',
    'fill-opacity',
    'fill-rule',
    'font',
    'font-family',
    'font-size',
    'font-size-adjust',
    'font-stretch',
    'font-style',
    'font-variant',
    'font-weight',
    'glyph-orientation-horizontal',
    'glyph-orientation-vertical',
    'image-rendering',
    'letter-spacing',
    'marker',
    'marker-end',
    'marker-mid',
    'marker-start',
    'paint-order',
    'pointer-events',
    'shape-rendering',
    'stroke',
    'stroke-dasharray',
    'stroke-dashoffset',
    'stroke-linecap',
    'stroke-linejoin',
    'stroke-miterlimit',
    'stroke-opacity',
    'stroke-width',
    'text-anchor',
    'text-rendering',
    'transform',
    'visibility',
    'word-spacing',
    'writing-mode'
];

exports.presentationNonInheritableGroupAttrs = [
    'display',
    'clip-path',
    'filter',
    'mask',
    'opacity',
    'text-decoration',
    'transform',
    'unicode-bidi',
    'visibility'
];

// http://www.w3.org/TR/SVG11/single-page.html#types-ColorKeywords
exports.colorsNames = {
    'aliceblue': '#f0f8ff',
    'antiquewhite': '#faebd7',
    'aqua': '#0ff',
    'aquamarine': '#7fffd4',
    'azure': '#f0ffff',
    'beige': '#f5f5dc',
    'bisque': '#ffe4c4',
    'black': '#000',
    'blanchedalmond': '#ffebcd',
    'blue': '#00f',
    'blueviolet': '#8a2be2',
    'brown': '#a52a2a',
    'burlywood': '#deb887',
    'cadetblue': '#5f9ea0',
    'chartreuse': '#7fff00',
    'chocolate': '#d2691e',
    'coral': '#ff7f50',
    'cornflowerblue': '#6495ed',
    'cornsilk': '#fff8dc',
    'crimson': '#dc143c',
    'cyan': '#0ff',
    'darkblue': '#00008b',
    'darkcyan': '#008b8b',
    'darkgoldenrod': '#b8860b',
    'darkgray': '#a9a9a9',
    'darkgreen': '#006400',
    'darkgrey': '#a9a9a9',
    'darkkhaki': '#bdb76b',
    'darkmagenta': '#8b008b',
    'darkolivegreen': '#556b2f',
    'darkorange': '#ff8c00',
    'darkorchid': '#9932cc',
    'darkred': '#8b0000',
    'darksalmon': '#e9967a',
    'darkseagreen': '#8fbc8f',
    'darkslateblue': '#483d8b',
    'darkslategray': '#2f4f4f',
    'darkslategrey': '#2f4f4f',
    'darkturquoise': '#00ced1',
    'darkviolet': '#9400d3',
    'deeppink': '#ff1493',
    'deepskyblue': '#00bfff',
    'dimgray': '#696969',
    'dimgrey': '#696969',
    'dodgerblue': '#1e90ff',
    'firebrick': '#b22222',
    'floralwhite': '#fffaf0',
    'forestgreen': '#228b22',
    'fuchsia': '#f0f',
    'gainsboro': '#dcdcdc',
    'ghostwhite': '#f8f8ff',
    'gold': '#ffd700',
    'goldenrod': '#daa520',
    'gray': '#808080',
    'green': '#008000',
    'greenyellow': '#adff2f',
    'grey': '#808080',
    'honeydew': '#f0fff0',
    'hotpink': '#ff69b4',
    'indianred': '#cd5c5c',
    'indigo': '#4b0082',
    'ivory': '#fffff0',
    'khaki': '#f0e68c',
    'lavender': '#e6e6fa',
    'lavenderblush': '#fff0f5',
    'lawngreen': '#7cfc00',
    'lemonchiffon': '#fffacd',
    'lightblue': '#add8e6',
    'lightcoral': '#f08080',
    'lightcyan': '#e0ffff',
    'lightgoldenrodyellow': '#fafad2',
    'lightgray': '#d3d3d3',
    'lightgreen': '#90ee90',
    'lightgrey': '#d3d3d3',
    'lightpink': '#ffb6c1',
    'lightsalmon': '#ffa07a',
    'lightseagreen': '#20b2aa',
    'lightskyblue': '#87cefa',
    'lightslategray': '#789',
    'lightslategrey': '#789',
    'lightsteelblue': '#b0c4de',
    'lightyellow': '#ffffe0',
    'lime': '#0f0',
    'limegreen': '#32cd32',
    'linen': '#faf0e6',
    'magenta': '#f0f',
    'maroon': '#800000',
    'mediumaquamarine': '#66cdaa',
    'mediumblue': '#0000cd',
    'mediumorchid': '#ba55d3',
    'mediumpurple': '#9370db',
    'mediumseagreen': '#3cb371',
    'mediumslateblue': '#7b68ee',
    'mediumspringgreen': '#00fa9a',
    'mediumturquoise': '#48d1cc',
    'mediumvioletred': '#c71585',
    'midnightblue': '#191970',
    'mintcream': '#f5fffa',
    'mistyrose': '#ffe4e1',
    'moccasin': '#ffe4b5',
    'navajowhite': '#ffdead',
    'navy': '#000080',
    'oldlace': '#fdf5e6',
    'olive': '#808000',
    'olivedrab': '#6b8e23',
    'orange': '#ffa500',
    'orangered': '#ff4500',
    'orchid': '#da70d6',
    'palegoldenrod': '#eee8aa',
    'palegreen': '#98fb98',
    'paleturquoise': '#afeeee',
    'palevioletred': '#db7093',
    'papayawhip': '#ffefd5',
    'peachpuff': '#ffdab9',
    'peru': '#cd853f',
    'pink': '#ffc0cb',
    'plum': '#dda0dd',
    'powderblue': '#b0e0e6',
    'purple': '#800080',
    'rebeccapurple': '#639',
    'red': '#f00',
    'rosybrown': '#bc8f8f',
    'royalblue': '#4169e1',
    'saddlebrown': '#8b4513',
    'salmon': '#fa8072',
    'sandybrown': '#f4a460',
    'seagreen': '#2e8b57',
    'seashell': '#fff5ee',
    'sienna': '#a0522d',
    'silver': '#c0c0c0',
    'skyblue': '#87ceeb',
    'slateblue': '#6a5acd',
    'slategray': '#708090',
    'slategrey': '#708090',
    'snow': '#fffafa',
    'springgreen': '#00ff7f',
    'steelblue': '#4682b4',
    'tan': '#d2b48c',
    'teal': '#008080',
    'thistle': '#d8bfd8',
    'tomato': '#ff6347',
    'turquoise': '#40e0d0',
    'violet': '#ee82ee',
    'wheat': '#f5deb3',
    'white': '#fff',
    'whitesmoke': '#f5f5f5',
    'yellow': '#ff0',
    'yellowgreen': '#9acd32'
};

exports.colorsShortNames = {
  '#f0ffff': 'azure',
  '#f5f5dc': 'beige',
  '#ffe4c4': 'bisque',
  '#a52a2a': 'brown',
  '#ff7f50': 'coral',
  '#ffd700': 'gold',
  '#808080': 'gray',
  '#008000': 'green',
  '#4b0082': 'indigo',
  '#fffff0': 'ivory',
  '#f0e68c': 'khaki',
  '#faf0e6': 'linen',
  '#800000': 'maroon',
  '#000080': 'navy',
  '#808000': 'olive',
  '#ffa500': 'orange',
  '#da70d6': 'orchid',
  '#cd853f': 'peru',
  '#ffc0cb': 'pink',
  '#dda0dd': 'plum',
  '#800080': 'purple',
  '#f00': 'red',
  '#ff0000': 'red',
  '#fa8072': 'salmon',
  '#a0522d': 'sienna',
  '#c0c0c0': 'silver',
  '#fffafa': 'snow',
  '#d2b48c': 'tan',
  '#008080': 'teal',
  '#ff6347': 'tomato',
  '#ee82ee': 'violet',
  '#f5deb3': 'wheat'
};

// http://www.w3.org/TR/SVG11/single-page.html#types-DataTypeColor
exports.colorsProps = [
    'color', 'fill', 'stroke', 'stop-color', 'flood-color', 'lighting-color'
];

},{}],1195:[function(require,module,exports){
(function (setImmediate,clearImmediate){
var nextTick = require('process/browser.js').nextTick;
var apply = Function.prototype.apply;
var slice = Array.prototype.slice;
var immediateIds = {};
var nextImmediateId = 0;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) { timeout.close(); };

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(window, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// That's not how node.js implements it but the exposed api is the same.
exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
  var id = nextImmediateId++;
  var args = arguments.length < 2 ? false : slice.call(arguments, 1);

  immediateIds[id] = true;

  nextTick(function onNextTick() {
    if (immediateIds[id]) {
      // fn.call() is faster so we optimize for the common use-case
      // @see http://jsperf.com/call-apply-segu
      if (args) {
        fn.apply(null, args);
      } else {
        fn.call(null);
      }
      // Prevent ids from leaking
      exports.clearImmediate(id);
    }
  });

  return id;
};

exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
  delete immediateIds[id];
};
}).call(this,require("timers").setImmediate,require("timers").clearImmediate)
},{"process/browser.js":1098,"timers":1195}],1196:[function(require,module,exports){
/****
 * The MIT License
 *
 * Copyright (c) 2015 Marco Ziccardi
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 ****/
(function (global, factory) {
  if (typeof define === 'function' && define.amd) {
    define('timsort', ['exports'], factory);
  } else if (typeof exports !== 'undefined') {
    factory(exports);
  } else {
    var mod = {
      exports: {}
    };
    factory(mod.exports);
    global.timsort = mod.exports;
  }
})(this, function (exports) {
  'use strict';

  exports.__esModule = true;
  exports.sort = sort;

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError('Cannot call a class as a function');
    }
  }

  var DEFAULT_MIN_MERGE = 32;

  var DEFAULT_MIN_GALLOPING = 7;

  var DEFAULT_TMP_STORAGE_LENGTH = 256;

  var POWERS_OF_TEN = [1e0, 1e1, 1e2, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9];

  function log10(x) {
    if (x < 1e5) {
      if (x < 1e2) {
        return x < 1e1 ? 0 : 1;
      }

      if (x < 1e4) {
        return x < 1e3 ? 2 : 3;
      }

      return 4;
    }

    if (x < 1e7) {
      return x < 1e6 ? 5 : 6;
    }

    if (x < 1e9) {
      return x < 1e8 ? 7 : 8;
    }

    return 9;
  }

  function alphabeticalCompare(a, b) {
    if (a === b) {
      return 0;
    }

    if (~ ~a === a && ~ ~b === b) {
      if (a === 0 || b === 0) {
        return a < b ? -1 : 1;
      }

      if (a < 0 || b < 0) {
        if (b >= 0) {
          return -1;
        }

        if (a >= 0) {
          return 1;
        }

        a = -a;
        b = -b;
      }

      var al = log10(a);
      var bl = log10(b);

      var t = 0;

      if (al < bl) {
        a *= POWERS_OF_TEN[bl - al - 1];
        b /= 10;
        t = -1;
      } else if (al > bl) {
        b *= POWERS_OF_TEN[al - bl - 1];
        a /= 10;
        t = 1;
      }

      if (a === b) {
        return t;
      }

      return a < b ? -1 : 1;
    }

    var aStr = String(a);
    var bStr = String(b);

    if (aStr === bStr) {
      return 0;
    }

    return aStr < bStr ? -1 : 1;
  }

  function minRunLength(n) {
    var r = 0;

    while (n >= DEFAULT_MIN_MERGE) {
      r |= n & 1;
      n >>= 1;
    }

    return n + r;
  }

  function makeAscendingRun(array, lo, hi, compare) {
    var runHi = lo + 1;

    if (runHi === hi) {
      return 1;
    }

    if (compare(array[runHi++], array[lo]) < 0) {
      while (runHi < hi && compare(array[runHi], array[runHi - 1]) < 0) {
        runHi++;
      }

      reverseRun(array, lo, runHi);
    } else {
      while (runHi < hi && compare(array[runHi], array[runHi - 1]) >= 0) {
        runHi++;
      }
    }

    return runHi - lo;
  }

  function reverseRun(array, lo, hi) {
    hi--;

    while (lo < hi) {
      var t = array[lo];
      array[lo++] = array[hi];
      array[hi--] = t;
    }
  }

  function binaryInsertionSort(array, lo, hi, start, compare) {
    if (start === lo) {
      start++;
    }

    for (; start < hi; start++) {
      var pivot = array[start];

      var left = lo;
      var right = start;

      while (left < right) {
        var mid = left + right >>> 1;

        if (compare(pivot, array[mid]) < 0) {
          right = mid;
        } else {
          left = mid + 1;
        }
      }

      var n = start - left;

      switch (n) {
        case 3:
          array[left + 3] = array[left + 2];

        case 2:
          array[left + 2] = array[left + 1];

        case 1:
          array[left + 1] = array[left];
          break;
        default:
          while (n > 0) {
            array[left + n] = array[left + n - 1];
            n--;
          }
      }

      array[left] = pivot;
    }
  }

  function gallopLeft(value, array, start, length, hint, compare) {
    var lastOffset = 0;
    var maxOffset = 0;
    var offset = 1;

    if (compare(value, array[start + hint]) > 0) {
      maxOffset = length - hint;

      while (offset < maxOffset && compare(value, array[start + hint + offset]) > 0) {
        lastOffset = offset;
        offset = (offset << 1) + 1;

        if (offset <= 0) {
          offset = maxOffset;
        }
      }

      if (offset > maxOffset) {
        offset = maxOffset;
      }

      lastOffset += hint;
      offset += hint;
    } else {
      maxOffset = hint + 1;
      while (offset < maxOffset && compare(value, array[start + hint - offset]) <= 0) {
        lastOffset = offset;
        offset = (offset << 1) + 1;

        if (offset <= 0) {
          offset = maxOffset;
        }
      }
      if (offset > maxOffset) {
        offset = maxOffset;
      }

      var tmp = lastOffset;
      lastOffset = hint - offset;
      offset = hint - tmp;
    }

    lastOffset++;
    while (lastOffset < offset) {
      var m = lastOffset + (offset - lastOffset >>> 1);

      if (compare(value, array[start + m]) > 0) {
        lastOffset = m + 1;
      } else {
        offset = m;
      }
    }
    return offset;
  }

  function gallopRight(value, array, start, length, hint, compare) {
    var lastOffset = 0;
    var maxOffset = 0;
    var offset = 1;

    if (compare(value, array[start + hint]) < 0) {
      maxOffset = hint + 1;

      while (offset < maxOffset && compare(value, array[start + hint - offset]) < 0) {
        lastOffset = offset;
        offset = (offset << 1) + 1;

        if (offset <= 0) {
          offset = maxOffset;
        }
      }

      if (offset > maxOffset) {
        offset = maxOffset;
      }

      var tmp = lastOffset;
      lastOffset = hint - offset;
      offset = hint - tmp;
    } else {
      maxOffset = length - hint;

      while (offset < maxOffset && compare(value, array[start + hint + offset]) >= 0) {
        lastOffset = offset;
        offset = (offset << 1) + 1;

        if (offset <= 0) {
          offset = maxOffset;
        }
      }

      if (offset > maxOffset) {
        offset = maxOffset;
      }

      lastOffset += hint;
      offset += hint;
    }

    lastOffset++;

    while (lastOffset < offset) {
      var m = lastOffset + (offset - lastOffset >>> 1);

      if (compare(value, array[start + m]) < 0) {
        offset = m;
      } else {
        lastOffset = m + 1;
      }
    }

    return offset;
  }

  var TimSort = (function () {
    function TimSort(array, compare) {
      _classCallCheck(this, TimSort);

      this.array = null;
      this.compare = null;
      this.minGallop = DEFAULT_MIN_GALLOPING;
      this.length = 0;
      this.tmpStorageLength = DEFAULT_TMP_STORAGE_LENGTH;
      this.stackLength = 0;
      this.runStart = null;
      this.runLength = null;
      this.stackSize = 0;

      this.array = array;
      this.compare = compare;

      this.length = array.length;

      if (this.length < 2 * DEFAULT_TMP_STORAGE_LENGTH) {
        this.tmpStorageLength = this.length >>> 1;
      }

      this.tmp = new Array(this.tmpStorageLength);

      this.stackLength = this.length < 120 ? 5 : this.length < 1542 ? 10 : this.length < 119151 ? 19 : 40;

      this.runStart = new Array(this.stackLength);
      this.runLength = new Array(this.stackLength);
    }

    TimSort.prototype.pushRun = function pushRun(runStart, runLength) {
      this.runStart[this.stackSize] = runStart;
      this.runLength[this.stackSize] = runLength;
      this.stackSize += 1;
    };

    TimSort.prototype.mergeRuns = function mergeRuns() {
      while (this.stackSize > 1) {
        var n = this.stackSize - 2;

        if (n >= 1 && this.runLength[n - 1] <= this.runLength[n] + this.runLength[n + 1] || n >= 2 && this.runLength[n - 2] <= this.runLength[n] + this.runLength[n - 1]) {

          if (this.runLength[n - 1] < this.runLength[n + 1]) {
            n--;
          }
        } else if (this.runLength[n] > this.runLength[n + 1]) {
          break;
        }
        this.mergeAt(n);
      }
    };

    TimSort.prototype.forceMergeRuns = function forceMergeRuns() {
      while (this.stackSize > 1) {
        var n = this.stackSize - 2;

        if (n > 0 && this.runLength[n - 1] < this.runLength[n + 1]) {
          n--;
        }

        this.mergeAt(n);
      }
    };

    TimSort.prototype.mergeAt = function mergeAt(i) {
      var compare = this.compare;
      var array = this.array;

      var start1 = this.runStart[i];
      var length1 = this.runLength[i];
      var start2 = this.runStart[i + 1];
      var length2 = this.runLength[i + 1];

      this.runLength[i] = length1 + length2;

      if (i === this.stackSize - 3) {
        this.runStart[i + 1] = this.runStart[i + 2];
        this.runLength[i + 1] = this.runLength[i + 2];
      }

      this.stackSize--;

      var k = gallopRight(array[start2], array, start1, length1, 0, compare);
      start1 += k;
      length1 -= k;

      if (length1 === 0) {
        return;
      }

      length2 = gallopLeft(array[start1 + length1 - 1], array, start2, length2, length2 - 1, compare);

      if (length2 === 0) {
        return;
      }

      if (length1 <= length2) {
        this.mergeLow(start1, length1, start2, length2);
      } else {
        this.mergeHigh(start1, length1, start2, length2);
      }
    };

    TimSort.prototype.mergeLow = function mergeLow(start1, length1, start2, length2) {

      var compare = this.compare;
      var array = this.array;
      var tmp = this.tmp;
      var i = 0;

      for (i = 0; i < length1; i++) {
        tmp[i] = array[start1 + i];
      }

      var cursor1 = 0;
      var cursor2 = start2;
      var dest = start1;

      array[dest++] = array[cursor2++];

      if (--length2 === 0) {
        for (i = 0; i < length1; i++) {
          array[dest + i] = tmp[cursor1 + i];
        }
        return;
      }

      if (length1 === 1) {
        for (i = 0; i < length2; i++) {
          array[dest + i] = array[cursor2 + i];
        }
        array[dest + length2] = tmp[cursor1];
        return;
      }

      var minGallop = this.minGallop;

      while (true) {
        var count1 = 0;
        var count2 = 0;
        var exit = false;

        do {
          if (compare(array[cursor2], tmp[cursor1]) < 0) {
            array[dest++] = array[cursor2++];
            count2++;
            count1 = 0;

            if (--length2 === 0) {
              exit = true;
              break;
            }
          } else {
            array[dest++] = tmp[cursor1++];
            count1++;
            count2 = 0;
            if (--length1 === 1) {
              exit = true;
              break;
            }
          }
        } while ((count1 | count2) < minGallop);

        if (exit) {
          break;
        }

        do {
          count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare);

          if (count1 !== 0) {
            for (i = 0; i < count1; i++) {
              array[dest + i] = tmp[cursor1 + i];
            }

            dest += count1;
            cursor1 += count1;
            length1 -= count1;
            if (length1 <= 1) {
              exit = true;
              break;
            }
          }

          array[dest++] = array[cursor2++];

          if (--length2 === 0) {
            exit = true;
            break;
          }

          count2 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare);

          if (count2 !== 0) {
            for (i = 0; i < count2; i++) {
              array[dest + i] = array[cursor2 + i];
            }

            dest += count2;
            cursor2 += count2;
            length2 -= count2;

            if (length2 === 0) {
              exit = true;
              break;
            }
          }
          array[dest++] = tmp[cursor1++];

          if (--length1 === 1) {
            exit = true;
            break;
          }

          minGallop--;
        } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);

        if (exit) {
          break;
        }

        if (minGallop < 0) {
          minGallop = 0;
        }

        minGallop += 2;
      }

      this.minGallop = minGallop;

      if (minGallop < 1) {
        this.minGallop = 1;
      }

      if (length1 === 1) {
        for (i = 0; i < length2; i++) {
          array[dest + i] = array[cursor2 + i];
        }
        array[dest + length2] = tmp[cursor1];
      } else if (length1 === 0) {
        throw new Error('mergeLow preconditions were not respected');
      } else {
        for (i = 0; i < length1; i++) {
          array[dest + i] = tmp[cursor1 + i];
        }
      }
    };

    TimSort.prototype.mergeHigh = function mergeHigh(start1, length1, start2, length2) {
      var compare = this.compare;
      var array = this.array;
      var tmp = this.tmp;
      var i = 0;

      for (i = 0; i < length2; i++) {
        tmp[i] = array[start2 + i];
      }

      var cursor1 = start1 + length1 - 1;
      var cursor2 = length2 - 1;
      var dest = start2 + length2 - 1;
      var customCursor = 0;
      var customDest = 0;

      array[dest--] = array[cursor1--];

      if (--length1 === 0) {
        customCursor = dest - (length2 - 1);

        for (i = 0; i < length2; i++) {
          array[customCursor + i] = tmp[i];
        }

        return;
      }

      if (length2 === 1) {
        dest -= length1;
        cursor1 -= length1;
        customDest = dest + 1;
        customCursor = cursor1 + 1;

        for (i = length1 - 1; i >= 0; i--) {
          array[customDest + i] = array[customCursor + i];
        }

        array[dest] = tmp[cursor2];
        return;
      }

      var minGallop = this.minGallop;

      while (true) {
        var count1 = 0;
        var count2 = 0;
        var exit = false;

        do {
          if (compare(tmp[cursor2], array[cursor1]) < 0) {
            array[dest--] = array[cursor1--];
            count1++;
            count2 = 0;
            if (--length1 === 0) {
              exit = true;
              break;
            }
          } else {
            array[dest--] = tmp[cursor2--];
            count2++;
            count1 = 0;
            if (--length2 === 1) {
              exit = true;
              break;
            }
          }
        } while ((count1 | count2) < minGallop);

        if (exit) {
          break;
        }

        do {
          count1 = length1 - gallopRight(tmp[cursor2], array, start1, length1, length1 - 1, compare);

          if (count1 !== 0) {
            dest -= count1;
            cursor1 -= count1;
            length1 -= count1;
            customDest = dest + 1;
            customCursor = cursor1 + 1;

            for (i = count1 - 1; i >= 0; i--) {
              array[customDest + i] = array[customCursor + i];
            }

            if (length1 === 0) {
              exit = true;
              break;
            }
          }

          array[dest--] = tmp[cursor2--];

          if (--length2 === 1) {
            exit = true;
            break;
          }

          count2 = length2 - gallopLeft(array[cursor1], tmp, 0, length2, length2 - 1, compare);

          if (count2 !== 0) {
            dest -= count2;
            cursor2 -= count2;
            length2 -= count2;
            customDest = dest + 1;
            customCursor = cursor2 + 1;

            for (i = 0; i < count2; i++) {
              array[customDest + i] = tmp[customCursor + i];
            }

            if (length2 <= 1) {
              exit = true;
              break;
            }
          }

          array[dest--] = array[cursor1--];

          if (--length1 === 0) {
            exit = true;
            break;
          }

          minGallop--;
        } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);

        if (exit) {
          break;
        }

        if (minGallop < 0) {
          minGallop = 0;
        }

        minGallop += 2;
      }

      this.minGallop = minGallop;

      if (minGallop < 1) {
        this.minGallop = 1;
      }

      if (length2 === 1) {
        dest -= length1;
        cursor1 -= length1;
        customDest = dest + 1;
        customCursor = cursor1 + 1;

        for (i = length1 - 1; i >= 0; i--) {
          array[customDest + i] = array[customCursor + i];
        }

        array[dest] = tmp[cursor2];
      } else if (length2 === 0) {
        throw new Error('mergeHigh preconditions were not respected');
      } else {
        customCursor = dest - (length2 - 1);
        for (i = 0; i < length2; i++) {
          array[customCursor + i] = tmp[i];
        }
      }
    };

    return TimSort;
  })();

  function sort(array, compare, lo, hi) {
    if (!Array.isArray(array)) {
      throw new TypeError('Can only sort arrays');
    }

    if (!compare) {
      compare = alphabeticalCompare;
    } else if (typeof compare !== 'function') {
      hi = lo;
      lo = compare;
      compare = alphabeticalCompare;
    }

    if (!lo) {
      lo = 0;
    }
    if (!hi) {
      hi = array.length;
    }

    var remaining = hi - lo;

    if (remaining < 2) {
      return;
    }

    var runLength = 0;

    if (remaining < DEFAULT_MIN_MERGE) {
      runLength = makeAscendingRun(array, lo, hi, compare);
      binaryInsertionSort(array, lo, hi, lo + runLength, compare);
      return;
    }

    var ts = new TimSort(array, compare);

    var minRun = minRunLength(remaining);

    do {
      runLength = makeAscendingRun(array, lo, hi, compare);
      if (runLength < minRun) {
        var force = remaining;
        if (force > minRun) {
          force = minRun;
        }

        binaryInsertionSort(array, lo, lo + force, lo + runLength, compare);
        runLength = force;
      }

      ts.pushRun(lo, runLength);
      ts.mergeRuns();

      remaining -= runLength;
      lo += runLength;
    } while (remaining !== 0);

    ts.forceMergeRuns();
  }
});

},{}],1197:[function(require,module,exports){
module.exports = require('./build/timsort.js');
},{"./build/timsort.js":1196}],1198:[function(require,module,exports){
"use strict"

function unique_pred(list, compare) {
  var ptr = 1
    , len = list.length
    , a=list[0], b=list[0]
  for(var i=1; i<len; ++i) {
    b = a
    a = list[i]
    if(compare(a, b)) {
      if(i === ptr) {
        ptr++
        continue
      }
      list[ptr++] = a
    }
  }
  list.length = ptr
  return list
}

function unique_eq(list) {
  var ptr = 1
    , len = list.length
    , a=list[0], b = list[0]
  for(var i=1; i<len; ++i, b=a) {
    b = a
    a = list[i]
    if(a !== b) {
      if(i === ptr) {
        ptr++
        continue
      }
      list[ptr++] = a
    }
  }
  list.length = ptr
  return list
}

function unique(list, compare, sorted) {
  if(list.length === 0) {
    return list
  }
  if(compare) {
    if(!sorted) {
      list.sort(compare)
    }
    return unique_pred(list, compare)
  }
  if(!sorted) {
    list.sort()
  }
  return unique_eq(list)
}

module.exports = unique

},{}],1199:[function(require,module,exports){
module.exports = function uniqs() {
  var list = Array.prototype.concat.apply([], arguments);
  return list.filter(function(item, i) {
    return i == list.indexOf(item);
  });
};

},{}],1200:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var punycode = require('punycode');
var util = require('./util');

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // Special case for a simple path URL
    simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = require('querystring');

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && util.isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!util.isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  // Copy chrome, IE, opera backslash-handling behavior.
  // Back slashes before the query string get converted to forward slashes
  // See: https://code.google.com/p/chromium/issues/detail?id=25916
  var queryIndex = url.indexOf('?'),
      splitter =
          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',
      uSplit = url.split(splitter),
      slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, '/');
  url = uSplit.join(splitter);

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
        if (parseQueryString) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString) {
        this.search = '';
        this.query = {};
      }
      return this;
    }
  }

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a punycoded representation of "domain".
      // It only converts parts of the domain name that
      // have non-ASCII characters, i.e. it doesn't matter if
      // you call it with a domain that already is ASCII-only.
      this.hostname = punycode.toASCII(this.hostname);
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      if (rest.indexOf(ae) === -1)
        continue;
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (util.isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &&
      util.isObject(this.query) &&
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (util.isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  var tkeys = Object.keys(this);
  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  }

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    var rkeys = Object.keys(relative);
    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== 'protocol')
        result[rkey] = relative[rkey];
    }

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);
      for (var v = 0; v < keys.length; v++) {
        var k = keys[v];
        result[k] = relative[k];
      }
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!util.isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especially happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host || srcPath.length > 1) &&
      (last === '.' || last === '..') || last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last === '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especially happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};

},{"./util":1201,"punycode":9,"querystring":1101}],1201:[function(require,module,exports){
'use strict';

module.exports = {
  isString: function(arg) {
    return typeof(arg) === 'string';
  },
  isObject: function(arg) {
    return typeof(arg) === 'object' && arg !== null;
  },
  isNull: function(arg) {
    return arg === null;
  },
  isNullOrUndefined: function(arg) {
    return arg == null;
  }
};

},{}],1202:[function(require,module,exports){
(function (global){

/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],1203:[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],1204:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./support/isBuffer":1203,"_process":1098,"inherits":728}],1205:[function(require,module,exports){
module.exports=[
  "ah",
  "apple",
  "atsc",
  "epub",
  "hp",
  "khtml",
  "moz",
  "ms",
  "o",
  "rim",
  "ro",
  "tc",
  "wap",
  "webkit",
  "xv"
]

},{}]},{},[1]);
